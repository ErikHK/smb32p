; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-11 19:37:01.275664050 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; STANDARD HORIZONTAL SCREEN

	
Tile_Mem_Addr:	
	; This breaks up the overall "tile" layout memory into screen-based chunks
	; With a screen width of 256 pixels, that makes 16 blocks across every "screen",
	; NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 28 POTENTIAL rows per screen
	; but the status bar occludes one, so only 27 rows are stored... 
	; Up to 15 screens!
	.word Tile_Mem,       Tile_Mem+$01B0, Tile_Mem+$0360, Tile_Mem+$0510, Tile_Mem+$06C0, Tile_Mem+$0870, Tile_Mem+$0A20, Tile_Mem+$0BD0
	.word Tile_Mem+$0D80, Tile_Mem+$0F30, Tile_Mem+$10E0, Tile_Mem+$1290, Tile_Mem+$1440, Tile_Mem+$15F0, Tile_Mem+$17A0


	; ALTERNATE VERTICAL SCREEN

	; Each "screen" (stacked vertically) is made up of 15 rows of tiles
	; which amounts to $F0 bytes per screen; the following split LUT defines tile memory
	; offsets gapped by $F0... not sure why they had to make the address lookup into two LUTs
	; like they did, but whatever... 16 vertical screens available

	; High bytes are separate from low
Tile_MemH = HIGH(Tile_Mem)

	; Vertical low byte, per screen
Tile_Mem_AddrVL:
	.byte $00, $F0, $E0, $D0, $C0, $B0, $A0, $90, $80, $70, $60, $50, $40, $30, $20, $10

	; Vertical high byte, per screen
Tile_Mem_AddrVH:
	.byte Tile_MemH+$0, Tile_MemH+$0, Tile_MemH+$1, Tile_MemH+$2
	.byte Tile_MemH+$3, Tile_MemH+$4, Tile_MemH+$5, Tile_MemH+$6
	.byte Tile_MemH+$7, Tile_MemH+$8, Tile_MemH+$9, Tile_MemH+$A
	.byte Tile_MemH+$B, Tile_MemH+$C, Tile_MemH+$D, Tile_MemH+$E



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This table contains commands for Video_Misc_Updates which tells
; it how to generate certain graphical elements programatically
;
; Format:
;	[2B TVA][CMD][DATA]
;	TVA: Target Video Address, typ. inside the nametable somewhere
;	CMD: 	- Bit 7 set = Use vertical updates (32B) else use horizontal (1B)
;		- Bit 6 set = Means that there is only one byte of DATA, repeated
;		- Bits 0-5  = Count of bytes to write directly to PPU 
;	DATA: Raw byte(s) to write to the PPU, count specified by CMD
; After a data chunk has been read, a new TVA is expected, or a $00 byte which terminates the stream.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Remember that the left edge is typically clipped, so nothing is visible there...
Video_Upd_Table: ; $803E
	.word Graphics_Buffer	; $00 - Graphics buffer for dynamically generated content
	.word Video_DoStatusBarV; $01 - status bar (vertical level)
	.word Video_DoStatusBar	; $02 - status bar (typical)
	.word $A000		; $03 - ???
	.word $A06F		; $04 - ???
	.word Video_DoStatusBarHM; $05 - status bar appropriate for horizontal mirroring
	.word Video_DoPalUpd	; $06 - Updates palettes per values in the $07BE+ Palette_* vars; used during fade in/out routines
	.word Video_RoulBordAttr; $07 - Roulette sliders border and attribute settings
	.word Bonus_InstBoxTop	; $08 - Top of Bonus Game instruction box
	.word Bonus_InstBoxLine1; $09 - First line of Bonus Game instruction box
	.word Bonus_InstBoxLine2; $0A - Second line of Bonus Game instruction box
	.word Bonus_InstBoxLine3; $0B - Third line of Bonus Game instruction box
	.word Bonus_InstBoxBot	; $0C - Bottom of Bonus Game instruction box
	.word Video_NSpadeBG	; $0D - N-Spade candy striping background
	.word Video_DoWXMario00	; $0E - "World X" Intro, Mario (horizontal scroll at $00)
	.word Video_DoWXLuigi00	; $0F - "World X" Intro, Luigi (horizontal scroll at $00)
	.word Video_DoWXMario80	; $10 - "World X" Intro, Mario (horizontal scroll at $80)
	.word Video_DoWXLuigi80	; $11 - "World X" Intro, Luigi (horizontal scroll at $80)
	.word Video_DoGameOver00; $12 - "GAME OVER" Box (horizontal scroll at $00)
	.word Video_DoGameOver80; $13 - "GAME OVER" Box (horizontal scroll at $80)
	.word Video_Blackout	; $14 - Blacks out 3 colors, used during end-level triple card match; not sure what for?
	.word Video_3CMMushTop	; $15 - End Level Triple Card Match: Mushroom top
	.word Video_3CMFlowTop	; $16 - End Level Triple Card Match: Flower top
	.word Video_3CMStarTop	; $17 - End Level Triple Card Match: Star top
	.word Video_3CMMushLeft	; $18 - End Level Triple Card Match: Mushroom left spot
	.word Video_3CMFlowDiag	; $19 - End Level Triple Card Match: Flower inner diagonal
	.word Video_3CMStarTip	; $1A - End Level Triple Card Match: Star eyes and tips
	.word Video_3CMMushMid	; $1B - End Level Triple Card Match: Mushroom eyes and middle
	.word Video_3CMFlowMid	; $1C - End Level Triple Card Match: Flower middle
	.word Video_3CMStarSide	; $1D - End Level Triple Card Match: Star left/right sides
	.word Video_3CMMushRight; $1E - End Level Triple Card Match: Mushroom right spot
	.word Video_3CMFlowStem	; $1F - End Level Triple Card Match: Flower stem
	.word Video_3CMStarBot1	; $20 - End Level Triple Card Match: Star near bottom
	.word Video_3CMMushBot	; $21 - End Level Triple Card Match: Mushroom bottom
	.word Video_3CMFlowBot	; $22 - End Level Triple Card Match: Flower bottom
	.word Video_3CMStarBot2	; $23 - End Level Triple Card Match: Star bottom
	.word Video_3CMAppear1	; $24 - End Level Triple Card Match: Make big shape appear attribute change 1
	.word Video_3CMAppear2	; $25 - End Level Triple Card Match: Alters palette
	.word Video_3CMAppear3	; $26 - End Level Triple Card Match: Make big shape appear attribute change 2
	.word Video_3CMAppear4	; $27 - End Level Triple Card Match: Make big shape appear attribute change 3
	.word Video_3CMAppear5	; $28 - End Level Triple Card Match: Make big shape appear attribute change 4
	.word Video_3CMAppear6	; $29 - End Level Triple Card Match: Make big shape appear attribute change 5
	.word Video_3CMAppear7	; $2A - End Level Triple Card Match: Make big shape appear attribute change 6
	.word Video_DoW2WZ	; $2B - "WELCOME TO WARP ZONE" banner
	.word Video_YouGotCardH	; $2C - "YOU GOT A CARD" (and the card space) [for the End Level Triple Card Match]
	.word Video_CourseClear	; $2D - "COURSE CLEAR"
	.word Video_YouGotCard	; $2E - "YOU GOT A CARD" (and the card space) [for the End Level otherwise]

	; The status bar comes in three identical versions with different VRAM start addresses
	; Might as well make a macro out of that, eh?

	; NOTE!! If you want to edit the status bar, you should also sync up
	; with the "flip" data in PRG026 as noted below...
StatusBar	.macro

	; Sync next three with PRG026 Flip_TopBarCards
	vaddr \1 + $00
	.byte $02, $FC, $A0		; Upper left corner

	vaddr \1 + $02
	.byte VU_REPEAT | $12, $A1	; Bar across the top

	vaddr \1 + $14
	.byte $0C, $A2, $A0, $A1, $A1, $A3, $A1, $A1, $A3, $A1, $A1, $A2, $FC	; top of card slots

	; Sync this with PRG026 Flip_MidTStatCards
	vaddr \1 + $20
	.byte $20, $FC, $A6, $70, $71, $72, $73, $FE, $FE, $EF, $EF, $EF, $EF, $EF, $EF, $3C	; |WORLD  >>>>>>[P] $  | |  | |  | |  | |
	.byte $3D, $FE, $EC, $F0, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE, $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $FE, $F0 ... in PRG026 status bar graphics)

	; Sync this with PRG026 Flip_MidBStatCards
	vaddr \1 + $40
	; Discrepency --------v  (Pattern is ... $FE, $FE ... in PRG030 status bar)  Unimportant; inserts <M> which is replaced anyway
	.byte $20, $FC, $A6, $FE, $FE, $FB, $FE, $F3, $FE, $F0, $F0, $F0, $F0, $F0, $F0, $F0	; [M/L]x  000000 c000| etc.
	.byte $FE, $ED, $F4, $F0, $F0, $A7, $A6, $FE, $FE, $AA, $FE, $FE, $AA, $FE, $FE, $A7, $FC
	; Discrepency --------^  (Pattern is ... $F4, $F0 ... in PRG030 status bar graphics)

	; Sync next three with PRG026 Flip_BottomBarCards
	vaddr \1 + $60
	.byte $02, $FC, $A8	; Lower corner

	vaddr \1 + $62
	.byte VU_REPEAT | $12, $A4	; Bottom bar

	vaddr \1 + $74
	.byte $0C, $A5, $A8, $A4, $A4, $A9, $A4, $A4, $A9, $A4, $A4, $A5, $FC	; lower corner and card bottoms

	; End PRG026 sync

	vaddr \1 + $80
	.byte VU_REPEAT | $20, $FC	; black space

	vaddr \1 + $A0
	.byte VU_REPEAT | $20, $FC	; black space

	; Terminator
	.byte $00
	.endm

	; Typical status bar (vertical level)
Video_DoStatusBarV:
	StatusBar $2700

	; Typical status bar (non-vertical level)
Video_DoStatusBar:
	StatusBar $2B00

	; Status bar used when Horizontal Mirroring in effect (Roulette game)
Video_DoStatusBarHM:
	StatusBar $2300

Video_3CMStarTop:
	vaddr $208F
	.byte VU_REPEAT | $02, $A9
	vaddr $20AE
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $20B1
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $20ED
	.byte $01, $A9
	vaddr $20F2
	.byte $01, $A9
	vaddr $2108
	.byte VU_REPEAT | $06, $A9
	vaddr $2112
	.byte VU_REPEAT | $06, $A9
	.byte $00	; Terminator

Video_3CMStarTip:
	vaddr $2128
	.byte $01, $A9
	vaddr $2137
	.byte $01, $A9
	vaddr $2149
	.byte $01, $A9
	vaddr $214E
	.byte VU_VERT | VU_REPEAT | $03, $A9
	vaddr $2151
	.byte VU_VERT | VU_REPEAT | $03, $A9
	vaddr $2156
	.byte $01, $A9
	.byte $00	; Terminator

Video_3CMStarSide:
	vaddr $216A
	.byte $01, $A9
	vaddr $2175
	.byte $01, $A9
	vaddr $218B
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $2194
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $21CA
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $21D5
	.byte VU_VERT | VU_REPEAT | $02, $A9
	.byte $00	; Terminator

Video_3CMStarBot1:
	vaddr $2209
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $220F
	.byte VU_REPEAT | $42, $A9
	vaddr $2216
	.byte VU_VERT | VU_REPEAT | $02, $A9
	vaddr $222D
	.byte VU_REPEAT | $02, $A9
	vaddr $2231
	.byte VU_REPEAT | $02, $A9
	.byte $00	; Terminator

Video_3CMStarBot2:
	vaddr $2248
	.byte $05, $A9, $FC, $FC, $A9, $A9
	vaddr $2253
	.byte $05, $A9, $A9, $FC, $FC, $A9
	vaddr $2268
	.byte VU_REPEAT | $03, $A9
	vaddr $2275
	.byte VU_REPEAT | $03, $A9
	.byte $00	; Terminator

Video_3CMAppear1:
	vaddr $23CA
	.byte VU_REPEAT | $04, $FF
	vaddr $23D2
	.byte VU_REPEAT | $04, $FF
	vaddr $23DA
	.byte VU_REPEAT | $04, $FF
	vaddr $23E2
	.byte VU_REPEAT | $04, $FF
	.byte $00	; Terminator

Video_3CMAppear3:
	vaddr $23D3
	.byte $02, $BF, $EF
	vaddr $23DB
	.byte $02, $FB, $FE
	.byte $00	; Terminator
	
Video_3CMAppear4:
	vaddr $23D3
	.byte $02, $6A, $9A
	vaddr $23DB
	.byte $02, $A6, $A9
	.byte $00	; Terminator

Video_3CMAppear5:
	vaddr $23CA
	.byte $04, $BF, $AF, $AF, $EF
	vaddr $23D2
	.byte $04, $BB, $55, $55, $EE
	vaddr $23DA
	.byte $04, $BB, $55, $55, $EE
	vaddr $23E2
	.byte $04, $FB, $FA, $FA, $FE
	.byte $00	; Terminator

Video_3CMAppear6:
	vaddr $23CA
	.byte $04, $7F, $5F, $5F, $DF
	vaddr $23D2
	.byte $04, $77, $55, $55, $DD
	vaddr $23DA
	.byte $04, $77, $55, $55, $DD
	vaddr $23E2
	.byte $04, $F7, $F5, $F5, $FD
	.byte $00	; Terminator

Video_3CMAppear7:
	vaddr $23CA
	.byte VU_REPEAT | $04, $55
	vaddr $23D2
	.byte VU_REPEAT | $04, $55
	vaddr $23DA
	.byte VU_REPEAT | $04, $55
	vaddr $23E2
	.byte VU_REPEAT | $04, $55
	.byte $00	; Terminator

	; Blacks out a little bit of the palette during end level triple-card match sequecnce
Video_Blackout:
	vaddr $3F0D
	.byte VU_REPEAT | $03, $0F, $00


Video_3CMAppear2:
	vaddr $3F05
	.byte $03

EndLevelCard_PalData:
	.byte $0F, $30, $3C
	vaddr $3F09
	.byte $03, $0F, $10, $2C
	vaddr $3F0D
	.byte VU_REPEAT | $03, $0F
	.byte $00	; Terminator

Video_YouGotCardH:
	vaddr $22C7
	.byte $13
	;       Y    O    U         G    O    T         A         C    A    R    D         |              |
	.byte $0D, $0E, $0A, $FC, $06, $0E, $09, $FC, $00, $FC, $05, $00, $02, $07, $FC, $26, $FE, $FE, $27
	vaddr $22B6
	.byte $04 ;  _    _    _   _
	;           |               |
	.byte      $20, $21, $21, $22

	vaddr $22F6
	.byte $04
	;       |              |
	.byte $26, $FE, $FE, $27

	vaddr $2316
	.byte $04
	;      |_    _    _   _|
	.byte $28, $24, $24, $25

	.byte $00	; Terminator

Video_CourseClear:
	vaddr $2889
	.byte $0E
	;       C    O    U    R    S    E         C    L    E    A    R         !
	.byte $85, $8E, $8A, $82, $83, $84, $FC, $85, $8B, $84, $80, $82, $FC, $9B, $00

Video_YouGotCard:
	vaddr $28E7
	.byte $13
	;       Y    O    U         G    O    T         A         C    A    R    D         |              |
	.byte $8D, $8E, $8A, $FC, $86, $8E, $89, $FC, $80, $FC, $85, $80, $82, $87, $FC, $A6, $FE, $FE, $A7

	vaddr $28D6
	.byte $04 ;  _    _    _   _
	;           |               |
	.byte      $A0, $A1, $A1, $A2

	vaddr $2916
	.byte $04
	;       |              |
	.byte $A6, $FE, $FE, $A7

	vaddr $2936
	.byte $04
	;      |_    _    _   _|
	.byte $A8, $A4, $A4, $A5
	.byte $00	; Terminator

	.byte $AF, $11

Map_Y_Starts:
	; Map Y start positions, World 1-8 (X is always $20)
	.byte $40, $A0, $A0, $40, $80, $60, $30, $50

	; A clear pattern set by Level_Tileset (for use with Clear_Nametable_Short)
ClearPattern_ByTileset:
	.byte $FF	; 0 - Map
	.byte $FC	; 1 - Plains
	.byte $FF	; 2 - Mini fortress style
	.byte $FC	; 3 - Hills style
	.byte $FC	; 4 - High-Up style
	.byte $FC	; 5 - pipe world plant infestation
	.byte $FC	; 6 - Water world
	.byte $FF	; 7 - Toad house
	.byte $FF	; 8 - Vertical pipe maze
	.byte $FC	; 9 - desert level
	.byte $FC	; 10 - airship
	.byte $FC	; 11 - Giant World
	.byte $FC	; 12 - ice level
	.byte $FC	; 13 - coin heaven / sky level
	.byte $FC	; 14 - underground
	.byte $FF	; 15 - bonus game intro
	.byte $FF	; 16 - spade game sliders
	.byte $FF	; 17 - N-spade
	.byte $FC	; 18 - 2P Vs


	.byte $AB, $83, $C6, $83, $CD, $83

	; This single byte is used in plant infestation levels to load the animation counter
PlantInfest_ACnt_MaxConst:	.byte (PlantInfest_PTPAC_End - PlantInfest_PatTablePerACnt - 1)
PlantInfest_PatTablePerACnt:
	.byte $60, $60, $60, $60, $60, $60, $60, $60, $60, $60, $62, $64, $66, $3E, $3E, $3E
	.byte $3E, $3E, $3E, $3E, $3E, $3E, $3E, $66, $64, $62, $06
PlantInfest_PTPAC_End

	.byte $34, $36, $38, $3A, $3C
	.byte $3E, $08, $34, $36, $38, $36, $34, $3A, $3E, $3A

	; List of C000 pages to switch to by Level_Tileset
PAGE_C000_ByTileset: ; $83D6
	.byte 10, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 22, 22, 22, 14

	; List of A000 pages to switch to by Level_Tileset
PAGE_A000_ByTileset: ; $83E9
	.byte 11, 15, 21, 16, 17, 19, 18, 18, 18, 20, 23, 19, 17, 19, 13, 26, 26, 26, 9

	; The normal level VROM page cycle set
PT2_Anim:	.byte $60, $62, $64, $66

PAUSE_Sprites:
	.byte $58, $F1, $03, $60	; P
	.byte $58, $F5, $03, $70	; A
	.byte $58, $F9, $03, $80	; U
	.byte $58, $FD, $03, $90	; S
	.byte $58, $FF, $03, $A0	; E
PAUSE_Sprites_End

	; The BGM per world (see also World_BGM_Restore in PRG010)
World_BGM:	
	.byte MUS2A_WORLD1, MUS2A_WORLD2, MUS2A_WORLD3, MUS2A_WORLD4
	.byte MUS2A_WORLD5, MUS2A_WORLD6, MUS2A_WORLD7, MUS2A_WORLD8
	.byte MUS2A_WARPWHISTLE

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; IntReset_Part2
	;
	; Part 2 of the Reset routine...
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IntReset_Part2:
	LDA PPU_STAT	 ;
	BPL IntReset_Part2 ; Wait until VBlank
	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg
	STA PPU_CTL1	 ; Most likely just to disable further Resets

	; Map_Unused7992 = 0 (used only in dead code it seems)
	;LDA #$00
	;STA Map_Unused7992

	; Note: This is setting up the address $7F00 @ $00/$01, the last page of SRAM
	LDY #$00	 ; Y = $00
	STY <Temp_Var1	 ; <Temp_Var1 = $00
	LDA #$7f	 ; A = $7F
	STA <Temp_Var2	 ; <Temp_Var2 = $7F

	; The following loop clears all of $6000 - $7FFF ... a lot of RAM!
PRG030_8437:
	LDA #$00	 	; A = 0
	STA [Temp_Var1],Y	; Clear 
	DEY			; Y--
	BNE PRG030_8437	 	; While Y is not zero, loop (since Y started at 0, this does a full 256 bytes)

	; This decrement then moves to $7E, $7D ... $60
	DEC <Temp_Var2	 ; Next lower page
	LDA <Temp_Var2	 ; Get page -> A
	CMP #$5f	 ; 
	BNE PRG030_8437	 ; If A <> $5F, loop again (clears down to $6000)

	; Clear $07FF - $0000, excluding $01xx
	LDY #$07
	JSR Clear_RAM_thru_ZeroPage

	; Reset_Latch = $5A (magic value that prevents reset vector from being run)
	LDA #$5a
	STA Reset_Latch

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	LDA #HIGH(8000)
	STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	LDA #LOW(8000)
	STA Map_NSpade_NextScore+2

PRG030_845A:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	; Load title screen graphics
	LDA #$78
	STA PatTable_BankSel
	LDA #$7a	
	STA PatTable_BankSel+1
	LDA #$20	
	STA PatTable_BankSel+2
	LDA #$21	
	STA PatTable_BankSel+3
	LDA #$04	
	STA PatTable_BankSel+4
	LDA #$7f	
	STA PatTable_BankSel+5

	; Load page 24 into A000 and page 25 into C000
	LDA #24	 
	STA PAGE_A000
	LDA #25	 
	STA PAGE_C000
	JSR PRGROM_Change_Both2	

	LDA #$20
	STA Update_Select	 ; Update_Select = $20 (Title Screen)
	STA Raster_Effect	 ; Raster_Effect = $20 (Title Screen style)

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	JSR Do_Title_Screen	; Do the title screen!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BEGINNING INITIALIZATION OF WORLD MAP!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG030_84A0:

	; Load page 11 into A000 and page 10 into C000
	LDA #10
	STA PAGE_C000
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_Both2	


	JSR Map_Init	 ; Initialize map variables (page 11)

	LDA #$00
	STA Map_Operation	; Map_Operation = 0 ("World X" intro)
	STA BigQBlock_GotIt	; Clear the opened Big ? Block variable
	STA Map_Airship_Dest	; Map_Airship_Dest = 0
	STA Map_Got13Warp	; Clear the "Got 1-3 Warp Whistle" flag
	STA Map_Anchored	; Map_Anchored = 0 (not anchored yet)

	; Map_UnusedGOFlag = $F8?
	;LDA #$f8
	;STA <Map_UnusedGOFlag

	LDA #$00	 ; 
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; Stop Update_Select activity temporarily while we initialize
	INC UpdSel_Disable

	; The following clears Map_Completions (stores completed levels on the map)
	LDY #$7f	 ; Y = $7F
	LDA #$00	 ; A = $00
PRG030_84D1:
	STA Map_Completions,Y
	DEY		 ; Y--
	BPL PRG030_84D1	 ; While Y >= 0, loop!

PRG030_84D7:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	; Init for lost bonus game??
	;LDA #$2b
	;STA Bonus_UnusedVH
	;LDA #$35
	;STA Bonus_UnusedVL

	LDA #$00
	STA Level_Tileset	; Level_Tileset = 0
	;STA Map_Unused72C 	; Map_Unused72C = 0
	STA Map_March_Count	; Not sure about this
	STA Raster_Effect	; Raster Effects disabled
	STA UpdSel_Disable 	; Stop Update_Select activity
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0

	; Init for lost bonus game??
	LDA #$04
	STA BonusText_CharPause
	STA Bonus_DieCnt

	; Reload the timer tick for the next time it's used
	LDA #$28	
	STA Level_TimerTick

	; Unused699 = 3 (never used)
	;LDA #$03	 
	;STA Unused699

	; Update_Select = $C0
	LDA #$c0	 	
	STA Update_Select

	; Load world map graphics
	LDA #$14
	STA PatTable_BankSel
	LDA #$16
	STA PatTable_BankSel+1
	LDX #$20
	STX PatTable_BankSel+2
	INX
	STX PatTable_BankSel+3
	INX
	STX PatTable_BankSel+4
	INX
	STX PatTable_BankSel+5

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10

	LDX Player_Current	; X = Player_Current
	LDA #(Inventory_Score - Inventory_Items)	; Base offset to score from Inventory_Items
	CPX #$00	 	; 
	BEQ PRG030_853F	 	; If X = 0 (Player is Mario), jump to PRG030_853F
	ADD #(Inventory_Score2 - Inventory_Score)	 ; Otherwise, add $23

PRG030_853F:
	TAY		 ; Y = $1F (Mario) or $42 (Luigi)

	; Copies the 3 byte score of this Player to the status bar
	; loading area to display their score...
	LDX #$00	 ; X = 0
PRG030_8542:
	LDA Inventory_Items,Y	; Starts at $1F or $42, score offset
	STA Player_Score,X	; Store into buffer area..
	INY		 	; Y++
	INX		 	; X++
	CPX #$03	 
	BNE PRG030_8542	 ; While X <> 3, loop


	; Init Player's on map
	LDX Total_Players
	DEX		 ; X = Total_Players-1
PRG030_8552:
	; Set Player's Y position
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X

	; Set Player's X position
	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X
	LDA Map_Entered_X,X
	STA <World_Map_X,X

	LDA Map_Previous_UnusedPVal2,X
	STA <Map_UnusedPlayerVal2,X

	; Map_UnusedPlayerVal = $20 each Player (not used for anything)
	;LDA #$20
	;STA <Map_UnusedPlayerVal,X

	DEX		 ; X--
	BPL PRG030_8552	 ; If more players to initialize, loop!

	LDA #$00	 
	STA Level_Tileset	 ; Map uses Level_Tileset = 0
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)
	STA <Map_EnterLevelFX	 ; Scratch = 0
	STA <Map_Intro_CurStripe ; Start with the first "strip" of erasing the World X intro box
	STA <Map_WarpWind_FX	 ; No warp whistle wind effects
	STA Map_Intro_Tick	 ; Map_Intro_Tick = 0 (forces init in some functions)

PRG030_857E:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = current Player index

	LDA World_Map_Power,X	; X = Player's current world map power
	STA Map_Power_Disp	; Set as powerup currently displayed 

	LDY #$00	 ; "Darkness" flag (only works correctly on World 8 level 2)
	LDA World_Num	 ; A = World_Num
	CMP #$07	 
	BNE PRG030_85A5	 ; If this is NOT World 8, jump to PRG030_85A5

	; We're in World 8...
	LDA <World_Map_XHi,X
	CMP #$02	 
	BNE PRG030_85A5	 ; If NOT on the third level of World 8, jump to PRG030_85A5
	INY		 ; Activate darkness

PRG030_85A5:
	STY World_8_Dark ; Set the darkness flag

	; Not sure what this assignment means here?
	;LDA #$00
	;STA Bonus_UnusedFlag

	; Changes pages at A000 and C000 based on value Level_Tileset (0)
	JSR SetPages_ByTileset	 ;	A000 = Page 11, C000 = Page 10

	JSR Scroll_Map_SpriteBorder	; Draw sprite-based border on map

	; Set A000 page to 12
	LDA #12
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR Map_Reload_with_Completions	 	; Load map and set already completed levels
	JSR Fill_Tile_AttrTable_ByTileset	; Load tile attribute tiles by the tileset

	LDA Inventory_Open	
	BNE PRG012_85CE		; If Inventory is open, jump to PRG012_85CE

	; If Inventory is not open
	LDX Player_Current	; X = Player_Current

	LDA Map_Previous_Dir,X 	; Get Player's previous moment direction
	STA <World_Map_Dir,X	; Restore it

PRG012_85CE:
	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync

	LDY Player_Current	; Y = current Player index

	; This sets up the scroll correctly given wherever the Player last was on the map
	LDA Map_Prev_XOff,Y	 
	STA <Scroll_Temp	 ; Scroll_Temp = X offset
	LDA Map_Prev_XHi,Y	 ; A = hi byte of X offset
	JSR Scroll_Update_Ranges ; Off to Scroll_Update_Ranges...

	LDA #$00	 
	STA <Scroll_LastDir	 ; Scroll_LastDir = 0

	LDA <Scroll_ColumnL	
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #26		
	STA MMC3_PAGE	 

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00	 		; Commit graphics in Graphics_Buffer
	JSR Video_Do_Update		; Do it!

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	; Clear all the map object Y to zero!
	LDY #$0d	 ; Y = $D
	LDA #$00	 ; A = 0
PRG030_8617:
	STA Map_Object_ActY,Y
	DEY		 ; Y--
	BPL PRG030_8617	 ; While Y >= 0, loop!

	LDA World_8_Dark
	BEQ PRG030_8625	 	; If World_8_Dark = 0 (not doing the effect), jump to PRG030_8625

	JSR Map_W8DarknessFill	; Fill in the entire screen with black

PRG030_8625:
	LDA World_Num	 
	CMP #$08
	BNE PRG030_8634	 ; If World_Num <> 8 (World 9 / Warp Zone), jump to PRG030_8634

	LDA #$2b	
	JSR Video_Do_Update	 ; Print the "WELCOME TO WARP ZONE" banner
	JSR PRGROM_Change_A000	 ; Fix bank A000

PRG030_8634:
	LDY Player_Current	 ; Y = Player_Current
	LDA Map_Prev_XOff,Y	 ; Get player's previous X offset (low byte)
	STA <Horz_Scroll	 ; Set the scroll to that
	STA <Scroll_Temp	 
	LDA Map_Prev_XHi,Y	 ; Get player's previous X offset (high byte) 
	STA <Horz_Scroll_Hi	 ; Store as current scroll "high"
	JSR Scroll_Update_Ranges

PRG030_8646:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	; Pushes any buffered graphics thru
	LDA #$00	 	
	JSR Video_Do_Update	

	LDA Map_DrawPanState
	BNE PRG030_8646	 	; If some kind of map drawing/panning activity is occurring, loop around

	LDA Map_Operation
	BNE PRG030_86A2	 	; If map operation is anything besides zero, jump to PRG030_86A2

	; Map_Operation = 0 ... the "World X" intro
	; Used at the beginning of a world, and alternating players
	LDA Inventory_Open
	BNE PRG030_86A2	; If inventory is open, jump to PRG030_86A2

	; Set bank at A000 to page 11
	LDA #11	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$0E 		; X = 14 (standard $00 aligned box)

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG030_8670	 	; If Horz_Scroll = 0, jump to PRG030_8670

	LDX #$10		; Otherwise, X = 16 (map halfway scroll $80 aligned box)
PRG030_8670:
	LDA Player_Current
	BEQ PRG030_8676		; If Player_Current = 0 (Mario), jump to PRG030_8676
	INX		 	; Otherwise, increment X (use Luigi's name!)
PRG030_8676:
	TXA		 	; A = X ($0E/$0F, $10/$11)
	JSR Video_Do_Update	; Do the World X intro box!

	JSR Map_ConfigWorldIntro	; Apply the world number and lives count

	; Push the buffered update
	LDA #$00
	JSR Video_Do_Update	 

	LDX World_Num	 	
	LDY World_BGM,X		; Get BGM index for this world
	CPX #4	 	
	BNE PRG030_8698		; If we're NOT on world 5, jump to PRG030_8698

	; World 5 special handling (Sky part different music)
	LDX Player_Current	; X = Player_Current
	LDA <World_Map_XHi,X	; Get the high byte of this Player's X position
	BEQ PRG030_8698	 	; If it's equal to 0 (the "lower" part of the Sky World), jump to PRG030_8698

	; Otherwise...
	LDY #MUS2A_SKY	 ; Use Sky music!
	JMP PRG030_869F	 

PRG030_8698:
	; Either not world 5, or ground-side of world 5
	LDA Map_MusicBox_Cnt	
	BEQ PRG030_869F		; If Map_MusicBox_Cnt = 0, jump to PRG030_869F
	LDY #MUS2A_MUSICBOX	 	; Otherwise, play the music box song

PRG030_869F:
	STY Sound_QMusic2	; Play BGM!

PRG030_86A2:
	LDA #$00
	STA Inventory_Open	; Inventory_Open = 0

	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 11
	LDA #11	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Switch bank A000 to page 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

WorldMap_Loop:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!

	; Switch bank A000 to page 11 
	LDA #11
	STA PAGE_A000	
	JSR PRGROM_Change_A000
	JSR Map_DoAnimations	; On page 11 -- animate world map

	LDA InvFlip_Counter
	BNE PRG030_86F9	 	; If InvFlip_Counter <> 0, jump to PRG030_86F9

	LDA Inventory_Open	
	BEQ PRG030_8715	 	; If Inventory_Open = 0, jump to PRG030_8715

PRG030_86F9:
	; Inventory_Open <> 0 && InvFlip_Counter = 0 ...

	; Switch bank A000 to page 26
	LDA #26	
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000	

	JSR World5_Sky_AddCloudDeco	 ; World 5 sky area gets an extra cloud sprite (strange?)
	JSR WorldMap_UpdateAndDraw	 ; Update and draw map graphics
	JMP WorldMap_Loop	 	; Loop back around...

PRG030_8715:
	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_DoMap	 		; Do the map!

	LDA Map_Operation
	CMP #$02	 
	BLT PRG030_8732	 		; If Map_Operation < 2, jump to PRG030_8732 

	; Map_Operation >= 2...

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR StatusBar_UpdateValues	; Update status bar

PRG030_8732:
	LDY Map_Operation
	CPY #$0d	 
	BNE PRG030_873F	 		; If Map_Operation <> $D (Normal), jump to PRG030_873F

	LDA <Map_WarpWind_FX
	CMP #$03	 
	BEQ PRG030_874F	 		; If Map_WarpWind_FX = 3 (initialize for warp island), jump to PRG030_874F

PRG030_873F:
	; Map_WarpWind_FX <> 3 or Map_Operation <> $D...

	CPY #$04
	BEQ PRG030_874F	 		; If Map_Operation <> $4, jump to PRG010_874F

	CPY #$0f	 
	BLT WorldMap_Loop	 	; If Map_Operation < $F (edge scroll), jump to WorldMap_Loop

	; Map_Operation >= $F...

	LDX Player_Current	
	LDA Map_Player_SkidBack,X
	BEQ PRG030_87BD			; If Map_Player_SkidBack = 0, jump to PRG030_87BD

PRG030_874F:
	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeOut	 		; Fade out
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Likely just using this for VSync

	; Disable the display
	LDA #$00	 
	STA <PPU_CTL2_Copy
	STA PPU_CTL2	 

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	LDA <Map_WarpWind_FX
	BNE PRG030_8772	 		; If Map_WarpWind_FX <> 0 (warp wind is active), jump to PRG030_8772

	LDA Map_Operation
	CMP #$04	 
	BNE PRG030_8775	 		; If Map_Operation <> 4, jump to PRG030_8775

PRG030_8772:
	JMP PRG030_857E			; Jump to PRG030_857E (partial loop back)

PRG030_8775:
	; Map_Operation <> 4

	LDX Player_Current

	; Store current map scroll positions and Player positions 
	; into the respective backup variables...
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X

	LDA <Horz_Scroll_Hi	
	STA Map_Prev_XHi,X

	LDA <World_Map_Y,X
	STA Map_Entered_Y,X

	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X

	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA <Map_UnusedPlayerVal2,X
	STA Map_Previous_UnusedPVal2,X	

	LDA #$00
	STA Map_Player_SkidBack,X

PRG030_879B:
	; Switch to the other Player (if any!)
	INX
	STX Player_Current
	CPX Total_Players
	BNE PRG030_87A9	 	; If not at the total Player count, jump to PRG030_87A9

	LDA #$00	 
	STA Player_Current	; Otherwise, back to 0 (basically keeps at 0 for 1P or goes 0, 1, 0, 1...)
PRG030_87A9:

	LDA Player_Current
	TAX		 
	LDA Player_Lives,X	
	BMI PRG030_879B	 	; If Player's lives are negative (dead!), jump to PRG030_879B (makes assumption at least ONE Player is alive...)

	LDA #$00
	STA Map_Operation		; Map_Operation = 0
	STA Map_PlayerLost2PVs	; Clear Map_PlayerLost2PVs

	JMP PRG030_84D7	 	; Jump to PRG030_84D7 (partial loop)

PRG030_87BD:
	; Map_Operation >= $F...

	JSR GraphicsBuf_Prep_And_WaitVSync	; Vertical sync

	; Copy the Player's positions into respective backup variables
	LDX Player_Current
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X
	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X	
	STA Map_Entered_X,X	
	LDA <Map_UnusedPlayerVal2,X	
	STA Map_Previous_UnusedPVal2,X	

	LDA #$00
	STA <Map_EnterLevelFX		; Map_EnterLevelFX = 0
	STA Map_EntTran_BorderLoop	; Map_EntTran_BorderLoop = 0
	STA Update_Select		; Update_Select = 0
	STA World_EnterState		; World_EnterState = 0
 
	JSR Map_Clear_EntTranMem	; Clear entrance transition memory

	; Set initial "high" parts of VRAM addresses
	LDA #$28	 
	STA Map_EntTran_BVAddrH	 	; top VRAM high
	STA Map_EntTran_BVAddrH+2	; left VRAM high
	STA Map_EntTran_BVAddrH+3	; right VRAM high

	LDA #$2a	 
	STA Map_EntTran_BVAddrH+1	; bottom VRAM high

	LDA #$00	 
	STA Map_EntTran_BVAddrL	 	; top VRAM low
	STA Map_EntTran_BVAddrL+3	; right VRAM low

	LDA #$1f	 
	STA Map_EntTran_BVAddrL+2	; left VRAM low
	STA Map_EntTran_TBCnt	 	; Map_EntTran_TBCnt also happens to be $1f

	LDA #$e0	 
	STA Map_EntTran_BVAddrL+1	; bottom VRAM low

	LDA #$17	 
	STA Map_EntTran_LRCnt	 	; Map_EntTran_LRCnt = $17


	; Top 0, bottom 1, right 2, left 3
	LDX #$03	 	; X = 3
PRG030_881D:
	LDA <Scroll_ColumnL
	AND #$0f
	ASL A	
	ADD Map_EntTran_BVAddrL,X	; adds 2 per column scrolled
	STA Map_EntTran_BVAddrL,X
	DEX		 	; X--
	BPL PRG030_881D	 	; While X >= 0, loop!

	LDA Map_EntTran_BVAddrL+2
	AND #$1f	 
	STA Map_EntTran_BVAddrL+2

	LDA #$30
	STA Map_EntTran_Cnt	 ; Map_EntTran_Cnt = $30

	LDA #SND_MAPENTERLEVEL
	STA Sound_QMap	 ; Play "enter level" sound effect!

	; Loop until V-Blank is not occurring
PRG030_883E:
	LDA PPU_STAT
	AND #$80	
	BNE PRG030_883E	

	LDA #%10101000		; sprites on PT2, 8x16 sprites, generate V-Blank NMIs
	STA PPU_CTL1	 
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	; The actual border rendering occurs in the interrupt's "Update_Select" routine
	; which calls "Map_EnterLevel_Effect" in PRG026
PRG030_884C:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Just VSyncs

	LDA #$01
	STA <Map_EnterLevelFX	; Map_EnterLevelFX = 1

	LDX Map_EntTran_BorderLoop	; Get current border loop counter (0-3: Top 0, bottom 1, right 2, left 3)
	TXA
	AND #$02
	BEQ PRG030_887F		 	; If Map_EntTran_BorderLoop & 2 = 0, jump to PRG030_887F (means jump if doing top/bottom)

	; Left/right edge sprite removal check...

	; This calculates the border's relative X position -> Temp_Var1
	LDA Map_EntTran_BVAddrL,X
	ASL A
	ASL A
	ASL A
	SUB <Horz_Scroll
	STA <Temp_Var1		; Temp_Var1 = (Map_EntTran_BVAddrL[X] << 3) - Horz_Scroll

	; This goes through all system sprites and removes them as the encroaching black border hits them
	LDX #$00	 	; X = 0
PRG030_8868:
	LDA Sprite_RAM+$03,X	; Get this sprite's X coordinate
	AND #$f8	 	; Only considering its nearest-8 position (aligned to the pattern-based border)
	CMP <Temp_Var1		
	BNE PRG030_8876	 	; If this sprite hasn't been touched yet, jump to PRG030_8876

	LDA #$f8	 
	STA Sprite_RAM+$00,X	; Set this sprite's Y to $F8 (make invisible)

PRG030_8876:
	DEX
	DEX
	DEX
	DEX		 	; X -= 4
	BNE PRG030_8868	 	; While X <> 0, loop!

	JMP PRG030_88A5	 	; Jump to PRG030_88A5

PRG030_887F:
	; Top/bottom edge sprite removal check...

	; This calculates the border's relative Y position -> Temp_Var1
	LDA Map_EntTran_BVAddrL,X
	AND #$c0	
	STA <Temp_Var1
	LDA Map_EntTran_BVAddrH,X
	LSR A		
	ROR <Temp_Var1	
	LSR A		
	ROR <Temp_Var1	

	LDX #$00	 	; X = 0
PRG030_8891:
	LDA Sprite_RAM+$00,X	; Get this sprite's Y position
	AND #$f0	 	; Only check its nearest-16 position (16 because of 16 pixel tall sprites)
	CMP <Temp_Var1
	BNE PRG030_889F	 	; If this sprite hasn't been touched yet, jump to PRG030_889F

	LDA #$f8	 
	STA Sprite_RAM+$00,X	; Set this sprite's Y to $F8 (make invisible)

PRG030_889F:
	DEX
	DEX
	DEX
	DEX		 	; X -= 4
	BNE PRG030_8891	 	; While X <> 0, loop!

PRG030_88A5:
	DEC Map_EntTran_Cnt	; Map_EntTran_Cnt--
	BMI PRG030_88AD	 	; If Map_EntTran_Cnt < 0, jump to PRG030_88AD

	JMP PRG030_884C	 	; Jump to PRG030_884C (loop)

PRG030_88AD:
	; Completed the entrance transition...

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Waiting for vertical sync

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	; Disable display
	LDA #$00
	STA PPU_CTL2

	LDA #$04	
	STA Level_TimerMSD	; Level_TimerMSD = 4

PRG030_88C8:
	; Clearing scroll variables
	LDA #$00
	STA <Horz_Scroll_Hi
	STA <Horz_Scroll
	STA <Vert_Scroll_Hi
	STA <Vert_Scroll
	STA <Scroll_ColumnR
	STA <Scroll_ColumnL
	STA <Scroll_LastDir

	STA Coins_ThisLevel	 ; Clear "coins earned this level" counter
	STA Map_BonusCoinsReqd	 ; Clear the "coins required for bonus"
	STA Map_BonusType	 ; Clear the "bonus type"

	STA <Temp_Var1	; Temp_Var1 = 0

	LDX #$05	
	STX <Temp_Var2	; Temp_Var2 = 5

	; Going to clear memory from $9D to $01
	LDY #$9d	; Y = $9D
PRG030_88E9:
	STA [Temp_Var1],Y	; Clear this byte
	DEY		 	; Y--
	BNE PRG030_88E9	 	; While Y <> 0, loop!

	STA [Temp_Var1],Y	; And address $00 is cleared too (though this is technically unnecessary)

	LDA <Map_Enter2PFlag
	BEQ PRG030_891A	 	; If not entering 2P Vs mode, jump to PRG030_891A

	; 2P Vs mode begin!

	; Level_Tileset = 18 (2P Vs)
	LDA #18
	STA Level_Tileset

	JSR SetPages_ByTileset

	INC Map_2PVsGame	; Map_2PVsGame++ (play next game style)

	LDA Map_2PVsGame
	CMP #12
	BNE PRG030_890B	 ; If Map_2PVsGame <> 12 (overflow), jump to PRG030_890B

	; Otherwise, restart count
	LDA #$00
	STA Map_2PVsGame

PRG030_890B:
	ASL A	; Multiply game style by 2
	TAX	; -> 'X'

	; Load address to battlefield level data
	LDA Vs_Battlefields,X
	STA <Level_LayPtr_AddrL
	LDA Vs_Battlefields+1,X
	STA <Level_LayPtr_AddrH

	JMP PRG030_892A	 ; Jump to PRG030_892A

PRG030_891A:

	; Non-2P Mode begin!

	; Set bank C000 to page 22 and A000 to page 12
	LDA #22
	STA PAGE_C000
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	; The ultimate output is properly configured
	; Level_ObjPtr_AddrL/H and Level_ObjPtrOrig_AddrL/H (object list pointer)
	; Level_LayPtr_AddrL/H and Level_LayPtrH_AddrL/H (tile layout pointer)
	; Level_Tileset
	JSR Map_PrepareLevel	 

PRG030_892A:
	LDA World_Num
	CMP #$08	
	BNE PRG030_893F	 ; If World_Num <> 8 (World 9), jump to PRG030_893F

	; Warp zone special
	LDA #MUS1_STOPMUSIC	 
	STA Sound_QMusic1	; Stop BGM

	; The destination world is fed back out through Map_Warp_PrevWorld
	LDA Map_Warp_PrevWorld
	STA World_Num	 	; World_Num = Map_Warp_PrevWorld
	JMP PRG030_84A0	 	; Jump to PRG030_84A0 (initialize the world map!)

PRG030_893F:
	LDY Level_Tileset	; Y = Level_Tileset
	LDA ClearPattern_ByTileset,Y
	STA ClearPattern	 	; ClearPattern = ClearPattern_ByTileset[Y]

	CPY #$07	 
	BNE PRG030_8964	 	; If Level_Tileset <> 7 (Toad House), jump to PRG030_8964

	; Toad House object pointer override!

	; The object set pointer has different meaning for a Toad House!
	LDA <Level_ObjPtr_AddrL
	STA THouse_ID		; Toad House ID; not used, would have tracked boxes already opened (multiple visits perhaps??)
	LDA <Level_ObjPtr_AddrH
	STA THouse_Treasure	 

	; Force object set at TOADO (Toad and the message object)
	LDA #LOW(TOADO)
	STA <Level_ObjPtr_AddrL
	STA Level_ObjPtrOrig_AddrL	
	LDA #HIGH(TOADO)
	STA <Level_ObjPtr_AddrH
	STA Level_ObjPtrOrig_AddrH	

PRG030_8964:

	; Clears $7F bytes starting at Level_BlockGrabHitMem ($7E02)
	; Clear Level_BlockGrabHitMem (collected coins and 1-ups memory)
	LDY #$7f	; Y = $7f
	LDA #$00	; A = 0
PRG030_8968:
	STA Level_BlockGrabHitMem,Y
	DEY		 ; Y--
	BPL PRG030_8968	 ; While Y >= 0, loop!

	; Clears $80 bytes starting at Player_XHi ($75, gameplay context)
	LDY #$80	 ; Y = $80
	LDA #$00	 ; A = 0
	STA LevelJctBQ_Flag	 ; LevelJctBQ_Flag = 0 
PRG030_8975: 
	STA Player_XHi,Y
	DEY		 ; Y--
	BNE PRG030_8975	 ; While Y >= 0, loop!

PRG030_897B:
	; Level junctions enter here, to continue with preparation to display!

	LDA #$00	
	STA Vert_Scroll_Off	; Vert_Scroll_Off = 0

	; If Level_Tileset = 16 (Spade game sliding cards) or 17 (N-Spade), jump to PRG030_89AB
	LDA Level_Tileset
	CMP #16
	BEQ PRG030_89AB
	CMP #17
	BEQ PRG030_89AB	

	; Inline clone of "SetPages_ByTileset"
	; Change A000 and C000 pages by Level_Tileset
	LDY Level_Tileset
	LDA PAGE_C000_ByTileset,Y
	STA PAGE_C000	 
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000	 
	JSR PRGROM_Change_Both2

	JSR LevelLoad_ByTileset			; Load the level layout data!
	JSR Sprite_RAM_Clear			; Clear the sprites
	JSR Fill_Tile_AttrTable_ByTileset	; Load tile attribute tiles by the tileset

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

PRG030_89AB:
	JSR Reset_PPU_Clear_Nametables2		; Blank display, clear nametables
	JSR Sprite_RAM_Clear	 		; Clear the sprites

	; Select the first bank of BG VROM as specified by Level_BG_Page1_2
	LDY Level_BG_Page1_2
	LDA Level_BG_Pages1,Y
	STA PatTable_BankSel

	LDA Level_BG_Pages2,Y

	LDX Level_PSwitchCnt
	BEQ PRG030_89C4	 	; If P-Switch not active, jump to PRG030_89C4

	LDA #$3e	 	; Otherwise, force override to page $3E

PRG030_89C4:
	STA PatTable_BankSel+1	 ; Select second bank of BG VROM

	LDA Level_Tileset	
	CMP #16
	BEQ PRG030_89D1	 	; If Level_Tileset = 16 (Spade game sliders), jump to PRG030_89D1

	JMP PRG030_8A4E	 	; Otherwise, jump to PRG030_8A4E

PRG030_89D1:
	; Spade game sliders (Roulette Game)

	; Set pattern banks on sprite side... only really need the border sprites??
	LDY #$20
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	STY PatTable_BankSel+4
	INY
	STY PatTable_BankSel+5

	; Horizontal mirroring
	LDA #$00
	STA MMC3_MIRROR

	JSR Roulette_DrawShapes	 	; Draw in the Roulette Shapes
	JSR Roulette_DrawBorderSprites	; Draw the sprite borders

	; Render Roulette borders and set attributes
	LDA #$07
	JSR Video_Do_Update

	; Status bar suitable for the horizontal mirroring mode
	LDA #$05
	JSR Video_Do_Update

	; Switch to page 26 @ A000
	LDA #MMC3_8K_TO_PRG_A000
	STA MMC3_COMMAND
	LDA #26		
	STA MMC3_PAGE	 

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	; Push through what's in graphics buffer
	LDA #$00
	JSR Video_Do_Update

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Set scrolling to absolute top
	LDA #$00
	STA <Vert_Scroll

	; Resume Update_Select activity
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

	; Enable the Roulette slider raster effect
	LDA #UPDATERASTER_SPADEGAME
	STA Update_Request

	; We actually get hung up here until afer the end of the Roulette
	; game when it has completely faded out due to Update_Request = UPDATERASTER_SPADEGAME
	JSR GraphicsBuf_Prep_And_WaitVSync

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Vertical mirroring
	LDA #$01
	STA MMC3_MIRROR

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Returning to map
	JMP PRG030_8FA1	 ; Jump to PRG030_8FA1

PRG030_8A4E:
	; Not spade game sliders

	CMP #17
	BEQ PRG030_8A55	 ; If Level_Tileset = 17 (N-Spade game), jump to PRG030_8A55
	JMP PRG030_8AE0	 ; Otherwise, jump to PRG030_8AE0

PRG030_8A55:
	; N-Spade Game

	; Load graphics for N-Spade
	LDY #$28
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	INY
	STY PatTable_BankSel+5
	LDA #$5a
	STA PatTable_BankSel+4

	; Card_Index = $0E (this assignment isn't really used for anything)
	LDA #$0E
	STA Card_Index

	; Temp_Var1 = $20 (VRAM High Address for Clear_Nametable_Short)
	LDA #$20
	STA <Temp_Var1
	JSR Clear_Nametable_Short

	; Generate the candystripe background of the N-Spade game
	LDA #$0d
	JSR Video_Do_Update

PRG030_8A79:
	JSR Card_InitGame	 ; Do this stage of initialization

	LDA <Graphics_Queue
	JSR Video_Do_Update	 ; Push graphics update

	LDA Card_InitState
	CMP #$03
	BNE PRG030_8A79		; While Card_InitState <> 3, loop!

	; Status bar suitable for the card game
	LDA #$05
	JSR Video_Do_Update

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	; Push through what's in graphics buffer
	LDA #$00
	JSR Video_Do_Update

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Set scrolling to absolute top
	LDA #$00
	STA <Vert_Scroll

	; Resume Update_Select activity
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

PRG030_8AC0:
	JSR GraphicsBuf_Prep_And_WaitVSync	; VSync

	JSR NSpade_DoGame	 ; Run N-Spade game

	JSR StatusBar_UpdateValues	 ; Update status bar

	LDA <Level_ExitToMap
	BEQ PRG030_8AC0	 ; If we're not exiting to map, loop N-Spade game

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

	JMP PRG030_8FA1	 ; Jump to PRG030_8FA1

PRG030_8AE0:
	CMP #18
	BNE PRG030_8AE7	 ; If Level_Tileset <> 18 (2P Vs), jump to PRG030_8AE7

	JMP Do_2PVsChallenge	 ; Jump Do_2PVsChallenge

PRG030_8AE7:
	; Normal gameplay...

	; Clear Update_Request
	LDA #$00
	STA Update_Request

	; Vertical mirroring
	LDA #$01
	STA MMC3_MIRROR

	LDA #$02	 ; A = 2
	LDX #$c0	 ; X = $C0 (Normal style updating)

	LDY Level_7Vertical
	BEQ PRG030_8B03	 	; If level is NOT a vertical one, jump to PRG030_8B03

	; Level is vertical!

	; Horizontal mirroring
	LDA #$00
	STA MMC3_MIRROR

	LDA #$01	 ; A = 1
	LDX #$80	 ; X = $80 (Vertical style updating)

PRG030_8B03:
	STX Update_Select	; Set Update_Select

	JSR Video_Do_Update	; Video update

	; Set bank at A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	JSR Scroll_Dirty_Update	 ; Entering level, do dirty update

	LDA Level_Tileset
	CMP #15
	BEQ PRG030_8B6D	 ; If Level_Tileset = 15 (Bonus game intro), jump to PRG030_8B6D

	; Changes pages at A000 and C000 to 26 and 6, respectively
	LDA #6
	STA PAGE_C000
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	JSR LevelLoad_CopyObjectList	 ; Copy in level objects!

	LDX Player_Current
	LDA Player_FallToKing,X
	BNE PRG030_8B6D	 	; If Player is bound for king, jump to PRG030_8B6D

	LDA Inventory_Open
	BNE PRG030_8B51	 	; If inventory is open (only normally happens at this point in Toad House), jump to PRG030_8B51

	LDA Level_JctCtl
	BNE PRG030_8B51	 	; If we're using a level junction override, jump to PRG030_8B51

	JMP PRG030_8B6D	 	; Otherwise, jump to PRG030_8B6D

PRG030_8B51:
	; Level junction override!  Copy in junction variables as appropriate
	LDA Level_Jct_HS
	STA <Horz_Scroll
	LDA Level_Jct_HSHi
	STA <Horz_Scroll_Hi

	LDA Level_Jct_VS
	STA <Vert_Scroll

	LDA Level_Jct_VSHi
	STA <Vert_Scroll_Hi

	; Junction complete (and inventory is NOT open)
	LDA #$00	 
	STA Inventory_Open
	STA Level_JctCtl

PRG030_8B6D:
	LDX Player_Current

	LDA Player_FallToKing,X
	BEQ PRG030_8B78	 	; If player is NOT bound for king's room, jump to PRG030_8B78

	JMP PRG030_9009	 ; Jump to PRG030_9009

PRG030_8B78:
	LDA #$00	
	STA Raster_Effect ; Raster_Effect = $00 (Normal status bar)
	STA UpdSel_Disable	; Resume Update_Select activity

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; Setup palette data

	LDA Level_Tileset
	CMP #15
	BNE PRG030_8B9A	 ; If Level_Tileset <> 15 (Bonus game intro), jump to PRG030_8B9A

	; Otherwise, set page @ C000 to 22
	LDA #22
	STA PAGE_C000
	JSR PRGROM_Change_Both2

PRG030_8B9A:
	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeIn	 ; Fade in palette

	; Set page @ A000 as appropriate for this tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; This is the init code for the level "boxing out" effect removed in the US release

	; US VERSION DOES THIS:
	JMP PRG030_8CB8	 ; Jump to PRG030_8CB8 (skipping code related to the "Boxing out" effect, removed in US version)

	; Leftover optional code, see below
	LDA #$00
	STA <Map_EnterLevelFX		 ; Map_EnterLevelFX = 0

	; ORIGINAL VERSION DID THIS (addresses relate to original code!):
;	LDA Level_Tileset
;	CMP #15
;	BEQ PRG030_8BC2	 ; If Level_Tileset = 15 (bonus game intro), jump to PRG030_8BC2
;
;	LDA Map_UNK713
;	BEQ PRG030_8BC5	 ; If Map_UNK713 = 0, jump to PRG030_8BC5
;
;PRG030_8BC2:
;	JMP PRG030_8CC9	 ; Jump to PRG030_8CC9
;
;PRG030_8BC5:
;	LDA #$00
;	STA <Map_EnterLevelFX		 ; Map_EnterLevelFX = 0
;PRG030_8CC9:

	JSR Map_Clear_EntTranMem	 ; Clear entrance transition memory

	LDA #$ff
	STA Map_EntTran_Temp	 ; Map_EntTran_Temp = $ff

	LDA Level_7Vertical
	BEQ PRG030_8BD5	 	; If not a vertical level, jump to PRG030_8BD5

	; Set address as appropriate for vertical
	LDY Level_SizeOrig
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	JMP PRG030_8BDF	; Jump to PRG030_8BDF

PRG030_8BD5: 

	; First screen is always where non-vertical maps start
	LDA Tile_Mem_Addr
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1
	STA <Map_Tile_AddrH

PRG030_8BDF:
	LDA #$00	
	STA Map_EntTran_VLHalf	 ; Map_EntTran_VLHalf = 0

	LDA <Vert_Scroll
	BEQ PRG030_8BF4	 	; If Vert_Scroll = 0, jump to PRG030_8BF4

	; Otherwise, offset initial address by $F0 (15 rows) and
	; flag we're performing this on the lower vertical
	LDA <Map_Tile_AddrL
	ADD #$f0	 
	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $F0

	LDA #$01
	STA Map_EntTran_VLHalf	 ; Map_EntTran_VLHalf = 1

PRG030_8BF4:
	LDY #$04	; Y = 4 (search begin)

PRG030_8BF6:
	LDA <Vert_Scroll
	CMP BoxOut_ByVStart,Y
	BEQ PRG030_8C00
	DEY		 ; Y--
	BPL PRG030_8BF6	 ; While Y >= 0, loop

PRG030_8C00:
	STY Map_EntTran_InitValIdx ; Store initial value index

	LDA BoxOut_InitVAddrH,Y	 ; Get initial high part of VRAM address
	STA Map_EntTran_BVAddrH
	STA Map_EntTran_BVAddrH+1
	STA Map_EntTran_BVAddrH+2
	STA Map_EntTran_BVAddrH+3

	; Copy in the four low bytes
	LDA BoxOut_InitVAddrL0,Y
	STA Map_EntTran_BVAddrL	

	LDA BoxOut_InitVAddrL2,Y
	STA Map_EntTran_BVAddrL+2

	LDA BoxOut_InitVAddrL1,Y
	STA Map_EntTran_BVAddrL+1

	LDA BoxOut_InitVAddrL3,Y
	STA Map_EntTran_BVAddrL+3

	LDA #$00
	STA Map_EntTran_BorderLoop	 ; Map_EntTran_BorderLoop = 0

	LDA #$04
	STA Map_EntTran_TBCnt	 ; Map_EntTran_TBCnt = 4

	LDY #$01	
	STY Map_EntTran_LRCnt	 ; Map_EntTran_LRCnt= 1

	LDA #$00	 
	STA Update_Select	; Insist (again!) that Update_Select = 0

PRG030_8C3E:
	JSR GraphicsBuf_Prep_And_WaitVSync	; VSync

	; Set page @ A000 as appropriate by Level_Tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDX Map_EntTran_BorderLoop	 ; X = current border index (0-3: Top 0, bottom 1, right 2, left 3)

	LDA Map_EntTran_BVAddrH,X	 ; Get high byte of VRAM addres
	STA Map_EntTran_VAddrH	 	; Store it

	LDA Map_EntTran_BVAddrL,X	 ; Get low byte of VRAM address
	STA Map_EntTran_VAddrL	 	; Store it

	LDA Map_EntTran_BorderLoop	 ; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
	AND #$02
	BNE PRG030_8C74	 		; If not updating top/bottom, jump to PRG030_8C74

	; top/bottom update...
	LDX Map_EntTran_TBCnt

	LDA #$01
	STA Map_EntTran_VRAMGap	 ; Map_EntTran_VRAMGap = 1

	LDA Map_EntTran_VAddrL
	AND #$01
	BEQ PRG030_8C8C	 ; If on even address, jump to PRG030_8C8C
	BNE PRG030_8C83	 ; If on odd address, jump to PRG030_8C83

PRG030_8C74:

	; left/right update...
	LDX Map_EntTran_LRCnt

	LDA #32
	STA Map_EntTran_VRAMGap	 ; PRG030_8C8C = 32

	LDA Map_EntTran_VAddrL
	AND #$20
	BEQ PRG030_8C8C	 ; If on 32 byte aligned address, jump to PRG030_8C8C

PRG030_8C83:
	JSR BoxOut_PutPatternInStrip	 ; Put an 8x8 pattern into the strip
	JSR BoxOut_SetThisBorderVRAM	 ; Set the VRAM offset for this border
	DEX		 		; X-- (counter decrement)
	BMI PRG030_8CAA	 		; If X < 0, jump to PRG030_8CAA

PRG030_8C8C:
	JSR BoxOut_PutPatternInStrip	 ; Put an 8x8 pattern into the strip
	DEX		 		; X-- (counter decrement)
	BMI PRG030_8CAA	 		; If X < 0, jump to PRG030_8CAA

	INC <Temp_Var14		 ; Temp_Var14++ (tile pattern layout high, jump to next pattern)

	LDA Map_EntTran_VRAMGap
	AND #$01	
	BEQ PRG030_8C9D	 	; If Map_EntTran_VRAMGap & 1 jump to PRG030_8C9D

	INC <Temp_Var14		 ; Temp_Var14++ (tile pattern layout high, jump to next pattern)

PRG030_8C9D:
	LDA [Temp_Var13],Y	 ; Get 8x8 pattern
	STA <Scroll_ColorStrip,X	 ; Store into strip

	JSR BoxOut_SetThisBorderVRAM	; Set border VRAM
	JSR BoxOut_SetThisBorderVRAM	; Called twice??
	DEX		 ; X--
	BPL PRG030_8C8C	 ; While X >= 0, loop!

PRG030_8CAA:
	LDA #$02
	STA <Map_EnterLevelFX	 ; Map_EnterLevelFX = 2 (begin the proper box out effect!)

	LDA Map_EntTran_Cnt
	CMP #$34	 
	BEQ PRG030_8CB8	 ; If Map_EntTran_Cnt = $34, jump to PRG030_8CB8
	JMP PRG030_8C3E	 ; Otherwise, loop!

PRG030_8CB8:
	; End of box-out effect (removed in US version)

	; Set page @ A000 as appropriate for Tileset
	LDY Level_Tileset
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA #$00
	STA <Map_EnterLevelFX	 ; Map_EnterLevelFX = 0

	LDX #$c0	 	; X = $C0 (Normal style updating)
	LDA Level_7Vertical	
	BEQ PRG030_8CD1	 	; If not a vertical level, jump to PRG030_8CD1

	LDX #$80	 ; X = $80 (Vertical style updating)

PRG030_8CD1:
	STX Update_Select	 ; Set Update_Select as appropriate

	LDA Level_Tileset
	CMP #15	 
	BEQ PRG030_8CDE	 ; If Level_Tileset = 15 (bonus game intro), jump to PRG030_8CDE
	JMP PRG030_8DCB	 ; Jump to PRG030_8DCB

PRG030_8CDE:
	; Bonus game intro 

	LDA #$04
	STA BonusText_CharPause	; BonusText_CharPause = $04
	STA Bonus_UnusedFlag	; Bonus_UnusedFlag = $04

	; Set text VRAM pointer to $28C5
	LDA #$28
	STA BonusText_VH
	LDA #$c5
	STA BonusText_VL

	LDA #$2b
	STA ToadTalk_VH
	STA PatTable_BankSel+4	 ; Load host graphics

	LDA #$35
	STA ToadTalk_VL

	; BonusDie_YVel = -$60
	LDA #-$60
	STA <BonusDie_YVel

	; Set the die to Y = $78, X = $78
	LDA #$78
	STA <BonusDie_Y
	STA <BonusDie_X
	
	; Queue the bonus music
	LDA #MUS2A_BONUSGAME
	STA Level_MusicQueue

	
	
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

;8CEC
OrangeCheep_DoGameplay:
	;first check if Player_XHi and Orange_XHi is the same:
	LDA <Player_XHi
	SUB <Orange_XHi
	CMP #2
	BMI continue
	
	LDA #5
	STA <Player_Suit
	
	;LDA #1
	;STA Player_HaltGame
	;;;JSR Player_Die
	;LDA #0
	;STA Event_Countdown
	;JMP Player_GetHurt
	
	
	;;LDA #$01
	;;STA <Player_IsDying	 ; Player_IsDying = 1 (superfluous, Player_Die sets it to 1)
	
	;LDA #$c0
	;STA Event_Countdown ; Event_Countdown = $C0
	;;;LDA #$01
	;;;STA <Player_IsDying	; Player_IsDying = 1
	
	;JSR Player_Die_Dying

	;INC <Level_ExitToMap	; Level_ExitToMap = 1

	;LDA #$01
	;STA Map_ReturnStatus	 ; Map_ReturnStatus = 1 (Player died, level is not clear)

	

continue:
	;check if jumping
	LDA <Pad_Input_2
	AND #PAD_A
	BEQ not_input_a
	
	;is inputting A, is orange in air?
	LDA <Orange_In_Air
	CMP #0
	BEQ not_input_a
	
	;is inputting A, and is not in the air
	LDA Player_RootJumpVel	 	; Get initial jump velocity
	;SUB Player_SpeedJumpInc,X	; Subtract a tiny bit of boost at certain X Velocity speed levels
	ADD #4
	STA <Orange_YVel
	;JMP check_if_holding_right
	JMP realend

	
;8d02
not_input_a:	;not inputting A, but maybe we're holding A? may be both in air and not
	LDY #$05
	LDA <Pad_Holding_2
	AND #PAD_A
	BEQ add_to_y_speed	;not holding A and not inputting A, jump away
	

	;8d0a
not_input_a_in_the_air:		;here we're holding A
	;holding A, 
	LDY #$01
	;holding A, check if we're in the air
	LDA <Orange_In_Air
	CMP #0
	BNE add_to_y_speed
	
	;we're in the air, and holding A, check if yvel is greater than zero, in that case, increase down acc
	LDA <Orange_YVel
	CMP #0
	BMI add_to_y_speed
	LDY #$05
	
add_to_y_speed:
	;LDY #1
	TYA
	ADD <Orange_YVel
	STA <Orange_YVel ; Player_YVel += Y
	
	;check if y speed is more than max
	LDA <Orange_YVel
	CMP #$40
	BMI check_if_holding_right
	
	;sätt högsta farten
	LDA #$40
	STA <Orange_YVel
		
	;BMI check_if_holding_right	 	; If Y velocity is negative, jump
	
	
check_if_holding_right:
	LDA <Pad_Holding_2
	AND #(PAD_LEFT | PAD_RIGHT)
	BEQ not_holding_left_nor_right
	AND #PAD_RIGHT
	BEQ not_holding_right
	

	;holding right, then move right
	LDA #$25
	;STY <Orange_XVel
	CMP <Orange_XVel ;compare 25 to xvel
	BMI realend
	INC <Orange_XVel
	
	JMP realend
	;LDA <Player_X
	;STA <Orange_X
	;LDA <Player_XHi
	;STA <Orange_XHi
;yy:
	;LDA <Player_Y
	;STA <Orange_Y
	;LDA <Player_YHi
	;STA <Orange_YHi
	
not_holding_right:
	LDA <Pad_Holding_2
	AND #PAD_LEFT
	BEQ not_holding_left_nor_right

	;holding left
	LDA #-$25
	;STY <Orange_XVel
	CMP <Orange_XVel ;compare 25 to xvel
	BPL realend
	DEC <Orange_XVel
	
	JMP realend
	
realend:
	;LDA <Orange_In_Air
	;CMP #0
	;BNE reaaalend
	
	;still in the air, make sure we're not falling too fast
	;LDA <Orange_YVel
	;CMP #$0
	;BLT reaaalend	 	; If object is not falling at the max rate, jump to check_if_holding_right
	;CMP #$40
	;BLT reaaalend

	;LDA #$40
	;STA <Orange_YVel	; Cap fall at max rate
	
	;LDA <Pad_Holding_2
	;AND #(PAD_LEFT | PAD_RIGHT)
	;BNE trueend
	
	;LDA <Orange_XVel
	;CMP #$ff
	;BEQ trueend
	;LDA #0
	;STA <Orange_XVel
	
trueend:
	RTS
	
checkzero:
	LDA <Orange_XVel
	CMP #$fe
	BEQ after
	;BPL after
	JMP trueend
after:
	LDY #0
	STY <Orange_XVel
	JMP trueend
	
not_holding_left_nor_right:
	LDA <Orange_XVel
	CMP #$ff
	BEQ afters
	BPL is_moving_right
	BMI is_moving_left
afters:
	LDY #0
	STY <Orange_XVel
	JMP realend

;is moving left, but not holding left, i.e. decelerate to zero please
is_moving_left:


	LDA <Orange_In_Air
	CMP #0
	BEQ checkzero
	;STY <Orange_XVel
	INC <Orange_XVel
	INC <Orange_XVel
	;INC <Orange_XVel
	JMP checkzero
;is moving right, but not holding right, i.e. decelerate to zero speed please
is_moving_right:
	LDA <Orange_In_Air
	CMP #0
	BEQ checkzero
	;STY <Orange_XVel
	DEC <Orange_XVel
	DEC <Orange_XVel
	;DEC <Orange_XVel	
	JMP checkzero

is_moving_left_but_holding_right:

is_moving_right_but_holding_left:

	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	
	
	
	
	
	
	
	
	; The Bonus Game Loop begins here...

BonusGame_Loop:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

	LDA SndCur_Map
	AND #SND_MAPENTERLEVEL
	BNE PRG030_8D23	 ; If the "entering" sound is still playing, jump to PRG030_8D23

	LDA Level_MusicQueue
	BEQ PRG030_8D23	 ; If nothing is in the music queue, jump to PRG030_8D23

	; Start the queued music
	STA Sound_QMusic2

	; Clear the music queue
	LDA #$00
	STA Level_MusicQueue

PRG030_8D23:
	JSR BonusGame_Do	 ; Run the Bonus Game
	JSR StatusBar_Fill_Score ; Update score

	LDA <Level_ExitToMap
	BEQ BonusGame_Loop	 ; If Level_ExitToMap = 0, loop!!

	; Exiting the Bonus Game loop...

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA Bonus_GameType
	CMP #BONUS_UNUSED_DDDD
	BNE PRG030_8D43	 ; If Bonus_GameType <> BONUS_UNUSED_DDDD (??!), jump to PRG030_8D43

	; BONUS_UNUSED_DDDD (??!) only...

	; Set Bonus_DDDD = 1 (??)
	LDA #$01
	STA Bonus_DDDD

	JMP PRG030_8D4A	 ; Jump to PRG030_8D4A

PRG030_8D43:
	CMP #BONUS_UNUSED_2RETURN
	BNE PRG030_8D4A	 ; If Bonus_GameType <> BONUS_UNUSED_2RETURN (??!), jump to PRG030_8D4A

	; BONUS_UNUSED_2RETURN (??!) only...

	JSR Bonus_Return2_SetMapPos	; Change Player's map position and mark them as having died??

PRG030_8D4A:
	; BonusText_CPos = 0
	LDA #$00
	STA BonusText_CPos
	STA Bonus_UnusedFlag	 ; Bonus_UnusedFlag = 0

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for vertical sync

	LDA #$00
	STA PPU_CTL2	 ; Most importantly, hide sprites/bg

	; NOTE: This jumps to PRG030_8DC3, which returns to World Map, if the die is face value 1.
	; Seems like the die face logic for jumping to "Roulette" / "Card" is not implemented.
	LDA Bonus_DieCnt
	BEQ PRG030_8DC3	 ; If Bonus_DieCnt = 0 (Face value 1), jump to PRG030_8DC3

	LDY #$00	 ; Level tileset 0 (World Map)

	LDA Bonus_GameType
	CMP #BONUS_SPADE
	BNE PRG030_8D85	 ; If Bonus_GameType <> BONUS_SPADE, jump to PRG030_8D85

	; Select palettes
	LDA #$01
	STA PalSel_Tile_Colors
	LDA #$09
	STA PalSel_Obj_Colors

	LDY #16		; Level tileset 16 (Spade)

	BNE PRG030_8D95	 ; Jump (technically always) to PRG030_8D95

PRG030_8D85:
	CMP #BONUS_NSPADE
	BNE PRG030_8D95	 ; If Bonus_GameType <> BONUS_NSPADE, jump to PRG030_8D95

	; Select palettes
	LDA #$02
	STA PalSel_Tile_Colors
	LDA #$0a
	STA PalSel_Obj_Colors

	LDY #17		; Level tileset 17 (N-Spade)

PRG030_8D95:
	STY Level_Tileset	; Update Level_Tileset
	STY Level_BG_Page1_2	; Use proper BG patterns

	CPY #$00
	BEQ PRG030_8DC3	 ; If tileset = 0 (exit back to world map :(), jump to PRG030_8DC3


	; About to enter Spade / N-Spade game!

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	; A little cleanup loop...

	; Clears page 0 addresses $00-$FD, excluding $69-$74 (?)

	LDY #$fd	 ; Y = $FD
	LDA #$00	 ; A = 0
PRG030_BDA6:
	STA Temp_Var1,Y	 ; Clear this byte

PRG030_BDA9:
	DEY		 ; Y--

	CPY #World_Map_Y
	BGE PRG030_8DB2	 ; If Y >= World_Map_Y, jump to PRG030_8DB2

	; Range between $69-$74 is not cleared ... mainly protecting sound engine I think

	CPY #Video_Upd_AddrL
	BGE PRG030_BDA9	 ; If Y >= Video_Upd_AddrL, jump to PRG030_BDA9
PRG030_8DB2: 
	CPY #$ff
	BNE PRG030_BDA6	 ; If Y <> $FF (underflow), loop!


	; Clears memory $0400-$04CF (mainly Bonus game cleanup)
	LDY #$cf	 ; Y = $CF
PRG030_8DB8:
	STA Roulette_Pos,Y	; Clear this byte

	DEY		 ; Y--
	CPY #$ff
	BNE PRG030_8DB8	 ; If Y <> $FF (underflow), loop!

	JMP PRG030_897B	 ; Jump to PRG030_897B

PRG030_8DC3:

	; Exiting to world map...

	; Bonus_DieCnt = 0
	LDA #$00
	STA Bonus_DieCnt

	JMP PRG030_8FA8	; Jump to PRG030_8FA8 (proceed back to World Map)

PRG030_8DCB:
	LDY Level_Tileset
	CPY #$05
	BNE Level_MainLoop	 ; If Level_Tileset <> 5 (pipe world plant infestation), jump to Level_MainLoop

	LDA PlantInfest_ACnt_MaxConst	; A = [PlantInfest_ACnt_MaxConst] ($1A) (weird specific read??)
	STA PlantInfest_ACnt_Max	; PlantInfest_ACnt_Max = [PlantInfest_ACnt_MaxConst] ($1A)



	
	

	; LEVEL MAIN LOOP BEGIN!

Level_MainLoop:
	JSR GraphicsBuf_Prep_And_WaitVSync

	LDA SndCur_Map
	AND #$04	
	BNE PRG030_8DF4	; If enter level sound is still playing, jump to PRG030_8DF4

	LDA Level_MusicQueue
	BEQ PRG030_8DF4	 	; If Music Queue is empty, jump to PRG030_8DF4

	CMP SndCur_Music2
	BEQ PRG030_8DEF	 	; If we're queueing the BGM already playing, jump to PRG030_8DEF (don't re-queue)

	STA Sound_QMusic2	 ; Queue the song that's waiting in Level_MusicQueue

PRG030_8DEF:
	LDA #$00
	STA Level_MusicQueue	 ; Queue is emptied

PRG030_8DF4:
	LDA Level_TimerEn
	BMI PRG030_8E2E	 	; If bit 7 is set (animations disabled), jump to PRG030_8E2E

	LDY Level_Tileset
	CPY #$05	 
	BNE PRG030_8E1D	 	; If Level_Tileset <> 5 (pipe world plant infestation), jump to PRG030_8E1D


	; PLANT INFESTATION ALTERNATE ANIMATION

	; Specific animation style for the pirhana plant world thing in World 7
	LDA <Counter_1
	AND #$07
	BNE PRG030_8E2E 	; Only update every 8 ticks (otherwise, nothing)

	INC <PlantInfest_ACnt	; PlantInfest_ACnt++

	LDA <PlantInfest_ACnt
	CMP PlantInfest_ACnt_Max
	BNE PRG030_8E13	 	; If PlantInfest_ACnt <> PlantInfest_ACnt_Max, jump to PRG030_8E13

	LDA #$00	 
	STA <PlantInfest_ACnt	; PlantInfest_ACnt = 0

PRG030_8E13:

	; Set proper VROM for this animation count of the plant infestation animation
	TAY		; Y = PlantInfest_ACnt
	LDA PlantInfest_PatTablePerACnt,Y
	STA PatTable_BankSel+1

	JMP PRG030_8E5D	 ; Jump to PlantInfest_ACnt

PRG030_8E1D:
	CPY #$07
	BNE PRG030_8E24	 ; If Level_Tileset <> 7 (Toad House), jump to PRG030_8E24
	JMP PRG030_8EAD	 ; Toad House's also do not use the standard animations

PRG030_8E24:
	; NOT TOAD HOUSE

	LDA Level_PSwitchCnt
	BEQ PRG030_8E31	 	; If P-Switch is not active, jump to PRG030_8E31

	; Otherwise force pattern override to $3E
	LDA #$3e
	STA PatTable_BankSel+1

PRG030_8E2E:
	JMP PRG030_8E5D	 ; Jump to PRG030_8E5D (skip main anim code)

PRG030_8E31:
	CPY #10
	BNE PRG030_8E4F	 ; If Level_Tileset <> 10 (Airship), jump to PRG030_8E4F

	; AIRSHIP ONLY

	LDY PatTable_BankSel+1
	CPY #$6a	
	BEQ PRG030_8E5D	 ; If the current animation active pattern table is $6A (Airship standard), jump to PRG030_8E5D (do nothing)

	; Otherwise...
	LDA <Counter_1
	AND #$03	
	BNE PRG030_8E5D	 ; Only update every 4 ticks (otherwise nothing, jump to PRG030_8E5D)

	INY
	INY		; +2 pattern tables

	CPY #$76	 
	BNE PRG030_8E4A	 ; If we're at $76, jump to PRG030_8E4A

	LDY #$70	 ; Otherwise, use $70

PRG030_8E4A:
	STY PatTable_BankSel+1 ; Update active pattern table
	BNE PRG030_8E5D	 ; Jump (technically always) to PRG030_8E5D

PRG030_8E4F:
	; REGULAR LEVEL ANIMATIONS

	LDA <Counter_1
	AND #$18
	LSR A	
	LSR A	
	LSR A		
	TAX	        ; 0-3, changing every 8 ticks

	LDA PT2_Anim,X	
	STA PatTable_BankSel+1 ; Set pattern for this tick

PRG030_8E5D:
	; End of animations...

	LDA SndCur_Pause
	BNE PRG030_8E79	 ; Can't unpause game while pause sound is playing

	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG030_8E79	 ; If Player is NOT pressing START, jump to PRG030_8E79

	LDX #PAUSE_STOPMUSIC	 ; for Sound_QPause, pause sound

	LDA Level_PauseFlag
	EOR #$01	 
	STA Level_PauseFlag	 ; Toggle pause flag
 
	BNE PRG030_8E76	 ; If game is now paused, jump to PRG030_8E76

	LDX #PAUSE_RESUMEMUSIC	 ; for Sound_QPause, resume sound

PRG030_8E76:
	STX Sound_QPause ; Set appropriately

PRG030_8E79:
	LDA Level_PauseFlag
	BEQ PRG030_8EAD	 	; If not paused, jump to PRG030_8EAD

	; When game is paused...

	; Wow, what the heck did they remove here??
	NOP
	NOP
	NOP
	NOP

	LDA #$32
	STA PatTable_BankSel+5	; Set patterns needed for P A U S E sprites

	JSR Sprite_RAM_Clear	 ; Clear other sprites

	; Copy in the P A U S E sprites
	LDY #(PAUSE_Sprites_End - PAUSE_Sprites - 1)
PRG030_8E9D:
	LDA PAUSE_Sprites,Y
	STA Sprite_RAM+$00,Y
	DEY		 ; Y--
	BPL PRG030_8E9D	 ; While Y >= 0, loop!

	; Updates palette
	LDA #$06	 
	STA <Graphics_Queue

	; Nothing else to do while paused; loop!
	JMP Level_MainLoop

PRG030_8EAD:
	; Not paused!

	LDA <Player_IsDying
	BNE PRG030_8ECC	 	; If Player is dying, jump to PRG030_8ECC

	LDY <Scroll_LastDir	; Y = Scroll_LastDir

	LDA Level_7Vertical
	BEQ PRG030_8EC3	 	; If level is NOT vertical, jump to PRG030_8EC3

	; Forms a value of current "scroll row" in upper 4 bits
	; and "current screen" in lower 4 bits -> Scroll_Temp
	LDA <Vert_Scroll
	AND #$f0	 
	ORA <Vert_Scroll_Hi
	STA <Scroll_Temp

	JMP PRG030_8EC9	 	; Jump to PRG030_8EC9

PRG030_8EC3:
	LDA <Horz_Scroll
	STA <Scroll_Temp	; Scroll_Temp = Horz_Scroll
	LDA <Horz_Scroll_Hi	; A = Horz_Scroll_Hi

PRG030_8EC9:
	JSR Scroll_Update_Ranges

PRG030_8ECC:
	LDA Level_JctCtl	 
	BEQ PRG030_8EE7	 	; If not junctioning, jump to PRG030_8EE7

	; Level junction!

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JMP HandleLevelJunction	; Handle the junction!

PRG030_8EE7:
	; Not junctioning...

	JSR Scroll_Update

	LDA #$00
	STA PAGE_C000	 ; Load page 0 @ C000

	LDA #$00
	STA Level_ScrollDiffH	 ; Level_ScrollDiffH = 0
	STA Level_ScrollDiffV	 ; Level_ScrollDiffV = 0

	LDA #$08	 
	STA PAGE_A000	 ; Load page 8 @ A000

	; Change both A000/C000 pages!
	JSR PRGROM_Change_Both2

	JSR Player_DoGameplay	 ; Does just about everything that makes the Player in gameplay mode!
	
	;make sure first object is an orange cheep!
	LDX #4
	LDA Level_ObjectID,X
	CMP #OBJ_ORANGECHEEP
	BNE notcheep
	
	
	JSR OrangeCheep_DoGameplay
notcheep:
	LDA <Player_IsDying
	CMP #$03
	BEQ PRG030_8F31	 ; If dead due to TIME UP, jump to PRG030_8F31

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_Both2	 

	JSR Objects_HandleScrollAndUpdate

	; Load page 7 @ A000
	LDY #$07
	STY PAGE_A000
	JSR PRGROM_Change_A000

	JSR Scores_GiveAndDraw	 ; Give point awards and draw score sprites


	; Color rotation effects, lava, donut lifts, arrow platforms,
	; brick busts, water/waterfall visual effects, bubbles, splashes,
	; pop-up coins, Special Objects, Cannon Fires, Player Projectiles,
	; and, last but not least (well, maybe least), "shell kill flashes"!
	JSR Gameplay_UpdateAndDrawMisc

	LDA Level_HAutoScroll
	BEQ PRG030_8F31	 ; If Auto Horizontal Scrolling is NOT active, jump to PRG030_8F31

	; Load page 9 @ A000
	LDA #$09
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR AutoScroll_Do	 ; Perform auto scroll, if any

PRG030_8F31:
	LDA <Level_ExitToMap
	BEQ PRG030_8F42	 ; If Level_ExitToMap flag is not set, jump to PRG030_8F42

	LDX Player_Current	 ; X = Player_Current

	; Transfer Player's current power up to the World Map counterpart
	LDA <Player_Suit
	STA World_Map_Power,X

	; Level_GetWandState = 0
	LDA #$00
	STA Level_GetWandState

PRG030_8F42:

	; Load page 29 @ C000
	LDA #29
	STA PAGE_C000
	JSR PRGROM_Change_C000

	JSR BlockChange_Do	 ; Do Block Change event, if necessary

	; Load page 0 @ C000
	LDA #$00
	STA PAGE_C000
	JSR PRGROM_Change_C000

	; If scroll updates need to be committed, jump to PRG030_8F80 
	LDA Scroll_ToVRAMHi
	BNE PRG030_8F80
	LDA Scroll_ToVRAMHA
	BNE PRG030_8F80

	; No scroll updates need committed...

	LDA Level_SkipStatusBarUpd
	BNE PRG030_8F80	 ; If requesting we skip the status bar updates for this frame, jump to PRG030_8F80

	LDA <Graphics_Queue
	BNE PRG030_8F80	 ; If we have a video update to do, skip the status bar updates for this frame, jump to PRG030_8F80

	; Switch bank A000 to page 26
	LDA #26	
	STA PAGE_A000
	JSR PRGROM_Change_A000

	LDA InvFlip_Counter
	BNE PRG030_8F7D	 ; If InvFlip_Counter <> 0 (flipping open Inventory), jump to PRG030_8F7D

	JSR StatusBar_UpdateValues	; Just update values on the status bar

	LDA Inventory_Open
	BEQ PRG030_8F85	 ; If Inventory is not open, jump to PRG030_8F85

PRG030_8F7D:
	JSR Map_DoInventory_And_PoofFX	; Do everything with that inventory bar (On page 26)

PRG030_8F80:

	; StatusBar_UpdFl = 0 (we just updated it)
	LDA #$00
	STA StatusBar_UpdFl

PRG030_8F85:

	; Level_SkipStatusBarUpd = 0 (only skip updating for one frame)
	LDA #$00
	STA Level_SkipStatusBarUpd

	LDA <Level_ExitToMap
	BEQ PRG030_9006	 ; If not exiting to map, jump to PRG030_9006 (Level_MainLoop)

	LDX Player_Current	 ; X = Player_Current

	; Map_Unused749 = 1 (just set here, never read back)
	LDA #$01
	STA Map_Unused749,X

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	 		; Fade out

PRG030_8FA1:
	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; Wait for VSync

PRG030_8FA8:
	; World_EnterState = 0
	LDA #$00
	STA World_EnterState

	; Disable the display
	STA <PPU_CTL2_Copy
	STA PPU_CTL2	 

PRG030_8FB2:
	LDA #$01	 
	STA MMC3_MIRROR	 ; Set vertical mirroring

	LDX Player_Current	 ; X = LDX Player_Current

	LDA Player_FallToKing,X
	BEQ PRG030_8FCA	 ; If not falling to the King's room, jump to PRG030_8FCA

	; Exiting to King's room...

	LDA Map_ReturnStatus
	BNE PRG030_8FCA	 ; If Player died, jump to PRG030_8FCA

	; Player is alive...

	; Stop Update_Select activity temporarily
	INC UpdSel_Disable

	JMP PRG030_88C8	 ; Jump to PRG030_88C8

PRG030_8FCA:
	; Clear $06FF - $0000, excluding $01xx
	LDY #$06
	JSR Clear_RAM_thru_ZeroPage

	; Vert_Scroll_Off = 0
	LDA #$00
	STA Vert_Scroll_Off

	; Stop the music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	LDA Map_ReturnStatus
	BNE PRG030_8FFC	 ; If Player died, jump to PRG030_8FFC

	LDA Player_RescuePrincess
	BEQ PRG030_8FFC	 ; If not rescuing the Princess, jump to PRG030_8FFC

	; Load page 24 into A000 and page 25 into C000
	LDA #25
	STA PAGE_C000
	LDA #24
	STA PAGE_A000
	JSR PRGROM_Change_Both2

	LDA #%10101000
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA #$20
	STA Update_Select	 ; Update_Select = $20 (Title Screen... or ending in this case)

	JMP Rescue_Princess	 ; Do the Princess Rescue sequence!!

PRG030_8FFC:

	; Player died or not rescuing the princess...

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!
	STA PPU_CTL1	 	

	JMP PRG030_9097	 	; Jump to PRG030_9097

PRG030_9006:
	JMP Level_MainLoop	; Gameplay loop!

PRG030_9009:
	; Player is falling into king's room...

	LDA #$c0
	STA Update_Select	; Update_Select = $C0 (Normal)

	LDA #$00
	STA Raster_Effect	; Raster_Effect = $00 (Normal status bar)

	LDA #$00
	STA World_EnterState	; World_EnterState = 0
	STA <Level_ExitToMap	; Level_ExitToMap = 0 (not going to exit to map)

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR EndWorldLetter_GenerateText	; Generate the text for the end-of-world letter

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; Setup palette data

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in

	; Load font graphics
	LDA #$5e
	STA PatTable_BankSel+1

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

PRG030_904D:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; VSync

	JSR CineKing_DoWandReturn	 ; Do the returned wand scene!

	LDA <Level_ExitToMap
	BEQ PRG030_904D		; While Level_ExitToMap = 0, loop

	; Clear $06FF - $0000, excluding $01xx
	LDY #$06
	JSR Clear_RAM_thru_ZeroPage

	; Clear some relevant Player values
	LDX Total_Players
	DEX		 ; X = Total_Players - 1
	LDA #$00	 ; Clear value
PRG030_9062:
	STA Player_FallToKing,X
	STA Map_ReturnStatus
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X

	DEX		 ; X--
	BPL PRG030_9062	 ; While X >= 0, loop

	LDX Player_Current	 ; X = current Player index

	LDA #(Inventory_Score - Inventory_Items)	; Mario's score

	CPX #$00
	BEQ PRG030_907D	 ; If Player is Mario, jump to PRG030_907D
	ADD #(Inventory_Score2 - Inventory_Score)	; offset to Luigi's score
PRG030_907D:
	TAY		 ; Y = offset to score

	LDX #$00	 ; X = 0
PRG030_9080:
	LDA Player_Score,X
	STA Inventory_Items,Y
	INY		 ; Y++ (next byte of Inventory score)
	INX		 ; X++ (next byte of Player's score)
	CPX #$03
	BNE PRG030_9080	 ; If X <> 3, jump to PRG030_9080

	; Stop any music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	INC World_Num	 ; Go to next world!

	JMP PRG030_84A0	 	; Jump to PRG030_84A0 (initialize the world map!)

PRG030_9097:

	; Exiting to map somehow

	LDA #$c0
	STA Update_Select	; Update_Select = $C0 (Normal)

	LDA #$00
	STA Raster_Effect	; Raster_Effect = $00 (Normal status bar)


	; Need to transfer Player's "gameplay score" to their "inventory" score storage...

	LDX Player_Current	; X = Player_Current

	LDA #(Inventory_Score - Inventory_Items)	; Offset to Mario's Score

	CPX #$00
	BEQ PRG030_90AD	 ; If Player is Mario, jump to PRG030_90AD

	ADD #(Inventory_Items2 - Inventory_Items)	; Offset to Luigi's Score

PRG030_90AD:
	TAY		 ; -> 'Y'

	LDX #$00	 ; X = 0

PRG030_90B0:
	LDA Player_Score,X	 ; Get this byte of score
	STA Inventory_Items,Y	 ; Transfer into Mario/Luigi's specific score storage

	INY		 ; Y++ (next score storage byte)
	INX		 ; X++ (next gameplay score byte)

	CPX #$03
	BNE PRG030_90B0	 ; While X <> 3, loop!

	LDA Map_MusicBox_Cnt
	BEQ PRG030_90C4	 ; If Map_MusicBox_Cnt = 0, jump to PRG030_90C4

	DEC Map_MusicBox_Cnt	 ; Otherwise, one less turn with music box...

PRG030_90C4:
	LDY #$06	 ; Y = 6

	LDA Map_ReturnStatus
	BNE PRG030_910C	 ; If Player died, jump to PRG030_910C

	; Player did not die...

	; Toad House and bonuses jump to PRG030_9128
	LDA Level_Tileset
	CMP #15
	BGE PRG030_9128	 ; If Level_Tileset >= 15 (some kind of Bonus Game), jump to PRG030_9128
	CMP #$07
	BEQ PRG030_9128	 ; If Level_Tileset = 7 (Toad House), jump to PRG030_9128

	; Typical levels go here...

	LDX Player_Current	 ; X = Player_Current

	; Set bonus appearance coordinates at your last valid location!
	LDA Map_Previous_Y,X
	STA Map_BonusAppY
	LDA Map_Previous_XHi,X
	STA Map_BonusAppXHi
	LDA Map_Previous_X,X
	STA Map_BonusAppX

	LDA Map_Entered_Y,X
	STA Map_Previous_Y,X

	LDA Map_Entered_XHi,X
	STA Map_Previous_XHi,X

	LDA Map_Entered_X,X
	STA Map_Previous_X,X

	LDA Map_Prev_XOff,X
	STA Map_Prev_XOff2,X

	LDA Map_Prev_XHi,X
	STA Map_Prev_XHi2,X

	JMP PRG030_9128	 ; Jump to PRG030_9128

PRG030_910C:

	; Player returns to map dead

	LDY #$02	 ; Y = 2 (Will be the Map_Operation value)

	; Map_ReturnStatus = 0
	LDA #$00
	STA Map_ReturnStatus

	; Clear all Big ? Blocks bits
	STA BigQBlock_GotIt

	LDX Player_Current	 ; X = Player_Current

	; Skid backward
	LDA #$01
	STA Map_Player_SkidBack,X

	LDA Map_PlayerLost2PVs
	BNE PRG030_9128	 ; If Map_PlayerLost2PVs is set, jump to PRG030_9128

	DEC Player_Lives,X	; One less life for the Player...
	BMI PRG030_9133	 	; If fell below zero, GAMEOVER!; jump to PRG030_9133

PRG030_9128:

	; Stop any music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	STY Map_Operation	 ; Map_Operation = 2
	JMP PRG030_84D7	 	; Jump to PRG030_84D7

PRG030_9133:

	; GAME OVER!!

	; Set Player as twirling (in case they Continue...)
	LDA #$01	 
	STA World_Map_Twirl,X

	; Init map vars
	LDA #$00
	STA Level_Tileset
	STA <Map_EnterLevelFX
	STA <Map_WarpWind_FX
	STA Map_Intro_Tick

	; Map_GameOver_CursorY = $60
	LDA #$60
	STA Map_GameOver_CursorY

PRG030_9149:
	JSR Sprite_RAM_Clear	 
	JSR Scroll_PPU_Reset	 
	JSR Reset_PPU_Clear_Nametables

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA World_EnterState
	BNE PRG030_9163	 ; If World_EnterState <> 0, jump to PRG030_9163

	; Otherwise, gotta player the game over music!
	LDA #MUS1_GAMEOVER
	STA Sound_QMusic1

PRG030_9163:

	; Load up graphics
	LDA #$14
	STA PatTable_BankSel
	LDA #$16
	STA PatTable_BankSel+1
	LDX #$20
	STX PatTable_BankSel+2
	INX
	STX PatTable_BankSel+3
	INX
	STX PatTable_BankSel+4
	INX
	STX PatTable_BankSel+5
	JSR SetPages_ByTileset


	; Set both Players to their previous map values
	LDX Total_Players
	DEX		 ; X = Total_Players - 1

PRG030_9185:
	LDA Map_Entered_Y,X
	STA <World_Map_Y,X
	LDA Map_Entered_XHi,X
	STA <World_Map_XHi,X
	LDA Map_Entered_X,X
	STA <World_Map_X,X
	LDA Map_Previous_UnusedPVal2,X
	STA <Map_UnusedPlayerVal2,X

	; Set Player's previous travel direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X

	DEX		 ; X--
	BPL PRG030_9185	; While X >= 0, loop!

	JSR Scroll_Map_SpriteBorder	 ; Keep that map border going!

	; Set page @ A000 to 12
	LDA #12
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_Reload_with_Completions	 ; Load map and set already completed levels

	LDX Player_Current	 ; X = Player_Current

	; Set Player's previous movement direction
	LDA Map_Previous_Dir,X
	STA <World_Map_Dir,X

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDY #$00	 ; Y = 0

	LDA World_Num
	CMP #$07
	BNE PRG030_91D1	 ; If World_Num <> 7 (World 8), jump to PRG030_91D1

	; World 8 only...

	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_XHi,X
	CMP #$02
	BNE PRG030_91D1	 ; If Player is not on the "dark" part of World 8, jump to PRG030_91D1

	INY		 ; Y = 1 (enable the World 8 darkness)

PRG030_91D1:
	STY World_8_Dark	 ; Set World_8_Dark appropriately

	LDY Player_Current	 ; Y = Player_Current

	; Scroll updates
	LDA Map_Prev_XOff,Y
	STA <Scroll_Temp
	LDA Map_Prev_XHi,Y
	JSR Scroll_Update_Ranges

	LDA <Scroll_ColumnL
	STA <Scroll_ColumnR

	; Scroll_Cols2Upd = 32 (full dirty scroll update sweep)
	LDA #32
	STA Scroll_Cols2Upd

	; This (re)draws the status bar
	LDA #$02
	JSR Video_Do_Update

	; Set page @ A000 to 26
	LDA #26		
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR StatusBar_Update_Cards	 ; Update status bar cards
	JSR StatusBar_UpdateValues	 ; Update other status bar stuff
	JSR StatusBar_Fill_MorL	 	 ; Patch in correct M or L on status bar
	JSR StatusBar_Fill_World	 ; Fill in correct world number

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	JSR Scroll_Dirty_Update 	; Do a full draw of the map tiles

	LDA World_8_Dark
	BEQ PRG030_9214	 	; If World_8_Dark = 0 (not doing the effect), jump to PRG030_9214

	JSR Map_W8DarknessFill	; Fill in the entire screen with black

PRG030_9214:

	LDY Player_Current	 ; Y =  Player_Current

	LDA Map_Prev_XOff,Y
	STA <Horz_Scroll
	STA <Scroll_Temp
	LDA Map_Prev_XHi,Y
	STA <Horz_Scroll_Hi
	JSR Scroll_Update_Ranges

PRG030_9226:
	JSR Map_DrawAndPan	 ; Draw and pan map as necessary

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

	LDA Map_DrawPanState
	BNE PRG030_9226	 	; If some kind of map drawing/panning activity is occurring, loop around

	LDA World_EnterState
	BNE PRG030_9257	 ; If World_EnterState <> 0, jump to PRG030_9257

	; Set page @ A000 to 11
	LDA #11
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Map_IntroAttrSave	; Pick up the current attribute info under the box

	LDX #$12 		; X = $12 (standard $00 aligned GAME OVER box)

	LDA <Horz_Scroll 	; A = Horz_Scroll
	BEQ PRG030_924B	 	; If Horz_Scroll = 0, jump to PRG030_924B

	LDX #$13		; Otherwise, X = $13 (map halfway scroll $80 aligned GAME OVER box)

PRG030_924B:
	TXA		 ; A = X
	JSR Video_Do_Update	 ; Draw up the Game Over! box

	JSR GameOver_PatchPlayerName	 ; Add MARIO/LUIGI to gameover box

	LDA #$00		 ; A = 0 (Graphics buffer push)
	JSR Video_Do_Update	 ; Push through what's in graphics buffer

PRG030_9257:
	LDA #$ef	 	
	STA <Vert_Scroll	; Vert_Scroll = $EF (map always stays at this height)

	LDA #$c0	 	
	STA Update_Select	; Update_Select = $C0 (Normal)

	; Switch bank A000 to page 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Switch bank A000 to page 11
	LDA #11	 
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

PRG030_927E:
	JSR GraphicsBuf_Prep_And_WaitVSync	; This is probably just using it to VSync
	JSR Sprite_RAM_Clear	 		; Clear sprites!
	JSR GameOver_Loop	 		; Do Gameover stuff
	JSR World5_Sky_AddCloudDeco	 	; World 5 sky area gets an extra cloud sprite (strange?)

	LDA GameOver_State

	CMP #$06
	BEQ PRG030_929C	 ; If GameOver_State = 6 (Player aligning to start panel Y), jump to PRG030_929C

	CMP #$09
	BNE PRG030_927E	 ; If GameOver_State <> 9 (Player did not choose to END), jump to PRG030_927E (loop around)

	; Player chose to END...

	LDA Total_Players
	CMP #$01
	BEQ PRG030_92B6	 ; If Total_Players = 1, jump to PRG030_92B6

	; More than 2 Players

PRG030_929C:
	
	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Switch bank A000 to page 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Palette_FadeOut	; Fade out

	LDA GameOver_State
	CMP #$09
	BEQ PRG030_92B6	 ; If GameOver_State = 9 (Player chose to END), jump to PRG030_92B6

	JMP PRG030_9149	 ; Jump to PRG030_9149

PRG030_92B6:

	LDA #$00
	STA World_EnterState	 ; World_EnterState = 0 (just arriving)

	LDX Player_Current	 ; X = Player_Current

	LDA Map_GameOver_CursorY
	AND #$08
	BNE PRG030_932A	 ; If Player chose to END, jump to PRG030_932A

	; Player's live reset to 4
	LDA #$04
	STA Player_Lives,X

	; Set up position variables
	LDA <Horz_Scroll
	STA Map_Prev_XOff,X
	LDA <Horz_Scroll_Hi
	STA Map_Prev_XHi,X
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X
	LDA <Map_UnusedPlayerVal2,X
	STA Map_Previous_UnusedPVal2,X

	; Reset map variables
	LDA #$00
	STA Map_Player_SkidBack,X
	STA World_EnterState
	STA Map_GameOver_CursorY
	STA BigQBlock_GotIt	; Didn't get any Big ? Blocks

	LDY #(Inventory_Coins - Inventory_Cards)	; Y = offset to Mario's coins

	CPX #$00
	BEQ PRG030_92FE	 ; If Player is Mario, jump to PRG030_92FE

	LDY #(Inventory_Coins2 - Inventory_Cards)	; Y = offset to Luigi's coins

PRG030_92FE:
	LDA #(Inventory_Coins - Inventory_Cards)
	STA <Temp_Var1		 ; Temp_Var1 = total bytes to clear

	LDA #$00	 ; A = 0
PRG030_9304:
	STA Inventory_Cards,Y	 ; Clear cards/coins

	DEY		 ; Y--
	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9304	 ; While Temp_Var1 >= 0, loop

	LDY #$3f	 ; Y = $3F (End of Mario's Map Completions)

	CPX #$00
	BEQ PRG030_9314	 ; If Player is Mario, jump to PRG030_9314

	LDY #$7f	 ; Y = $7F (End of Luigi's Map Completions)

PRG030_9314:
	LDA #$3f
	STA <Temp_Var1	 ; Temp_Var1 = $3F
 
PRG030_9318:
	TYA
	EOR #$40
	TAX

	; Clear this Player's map completions
	LDA Map_Completions,X
	AND Map_Completions,Y
	STA Map_Completions,Y

	DEY		 ; Y--
	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9318	 ; While Temp_Var1 >= 0, loop!

PRG030_932A:
	LDY Total_Players	 ; Y = Total_Players
	DEY		 ; Y = 0 if 1P, or 1 if 2P

PRG030_932E:
	LDA Player_Lives,Y
	BPL PRG030_933E	 ; If this Player isn't dead, jump to PRG030_933E

	DEY		 ; Y--
	BPL PRG030_932E	 ; While Y >= 0, loop

	; All Players are dead and have given up

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	; Reset game
	JMP IntReset_Part2

PRG030_933E:

	; A Player gave up, but there's one left

	JSR GameOver_PlayerQuitCleanup	 ; Performs some cleanup work for the Player who left

	; Map_Operation = 0
	LDY #$00
	STY Map_Operation

	LDX Player_Current	 ; X = Player_Current
	JMP PRG030_879B	 ; Jump to PRG030_879B


Do_2PVsChallenge:

	; 2P Vs Challenge!

	; Load page 14 @ C000
	LDA #14
	STA PAGE_C000
	JSR PRGROM_Change_Both2

	JSR Scroll_Dirty_Update	 ; Render the 2P Vs terrain

	; Update_Select = $C0
	LDA #$c0
	STA Update_Select

	; Raster_Effect = $80
	LDA #$80
	STA Raster_Effect

	; Load graphics for 2P Vs
	LDY #$04
	STY PatTable_BankSel+2
	INY
	STY PatTable_BankSel+3
	INY
	STY PatTable_BankSel+4
	INY
	STY PatTable_BankSel+5

	; Play battle (2P Vs) music
	LDA #MUS2B_BATTLE
	STA Level_MusicQueue

	; Set page @ A000 to 27
	LDA #27
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Setup_PalData	 ; On page 27 -- PalData now holds palette data for world map tiles/objects

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeIn	 ; On page 26 -- Fade in the world map

	; Set page @ A000 to 9
	LDA #$09
	STA PAGE_A000
	JSR PRGROM_Change_A000

PRG030_939A:
	JSR GraphicsBuf_Prep_And_WaitVSync	 ; V Sync

	LDA SndCur_Map
	AND #SND_MAPENTERLEVEL
	BNE PRG030_93B1	 ; If the level entrance sound is still playing, jump to PRG030_93B1

	LDA Level_MusicQueue
	BEQ PRG030_93B1	 ; If no BGM is queued, jump to PRG030_93B1

	; Play the queued music
	STA Sound_QMusic2

	; Clear music queue
	LDA #$00
	STA Level_MusicQueue

PRG030_93B1:
	JSR Sprite_RAM_Clear	 ; Clear Sprite RAM 
	JSR Vs_2PVsPauseHandler	 ; Handle pausing

	LDA Level_ExitToMap
	BEQ PRG030_939A	 ; If not exiting to map, loop 2P Vs!

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000
	JSR Palette_FadeOut	 		; Fade out

	; Stop 2P Vs music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG+Sprites

	JSR GraphicsBuf_Prep_And_WaitVSync	; Vertical sync

	; Disable display
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	LDX Map_PlayerLost2PVs
	DEX
	CPX Player_Current
	BNE PRG030_93E7	 ; If the Player who lost the match was not the Player whose turn it was, jump to PRG030_93E7

	JMP PRG030_946C	 ; Jump to PRG030_946C

PRG030_93E7:
	LDA #(Inventory_Score - Inventory_Items)	; Offset to Mario's score

	LDX Player_Current
	BEQ PRG030_93F1	 ; If current Player is Mario, jump to PRG030_93F1

	ADD #(Inventory_Score2 - Inventory_Score)	; Offset to Luigi's score

PRG030_93F1:
	TAY		 ; Y = offset to Player's score

	LDX #$00	 ; X = 0
PRG030_93F4:
	LDA Inventory_Items,Y
	STA Player_Score,X

	INY		 ; Y++ (next "inventory" score byte)
	INX		 ; X++ (next "active" score byte)

	CPX #$03
	BNE PRG030_93F4	; While X <> 3, loop!

	LDX Map_PlayerLost2PVs
	DEX
	TXA
	EOR #$01
	TAY		 ; Y = the OTHER Player's index

	; Swap all Player map position variables because the challenger lost!
	LDA Map_Previous_Y,Y
	STA <Temp_Var1
	LDA Map_Previous_XHi,Y
	STA <Temp_Var2
	LDA Map_Previous_X,Y
	STA <Temp_Var3
	LDA Map_Prev_XOff2,Y
	STA <Temp_Var4
	LDA Map_Prev_XHi2,Y
	STA <Temp_Var5
	LDA Map_Prev_XOff,Y
	STA <Temp_Var6
	LDA Map_Prev_XHi,Y
	STA <Temp_Var7
	LDA Map_Previous_Y,X
	STA Map_Previous_Y,Y
	LDA Map_Previous_XHi,X
	STA Map_Previous_XHi,Y
	LDA Map_Previous_X,X
	STA Map_Previous_X,Y
	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff2,Y
	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi2,Y
	LDA <Temp_Var1
	STA Map_Previous_Y,X
	LDA <Temp_Var2
	STA Map_Previous_XHi,X
	LDA <Temp_Var3
	STA Map_Previous_X,X
	LDA <Temp_Var4
	STA Map_Prev_XOff2,X
	LDA <Temp_Var5
	STA Map_Prev_XHi2,X
	LDA <Temp_Var6
	STA Map_Prev_XOff,X
	LDA <Temp_Var7
	STA Map_Prev_XHi,X

PRG030_946C:

	; Flag as "death" so challenger flies backward
	LDX Map_PlayerLost2PVs
	STX Map_ReturnStatus

	; Set new current Player
	DEX		 ; X--
	STX Player_Current

	JMP PRG030_8FB2	 ; Jump to PRG030_8FB2

GameOver_WhiteMapObjs:
	.byte MAPOBJ_NSPADE, MAPOBJ_WHITETOADHOUSE, MAPOBJ_UNK0C


GameOver_PlayerQuitCleanup:
	LDY Total_Players	; Y = Total_Players
	CPY #$01
	BEQ PRG030_948F	 	; If only a 1P game, jump to PRG030_948F

	; This is a 2P game

	DEY		 ; Y-- (Y = 1)
PRG030_9484:
	LDA Player_Lives,Y
	BPL PRG030_948E	 ; If this is the living Player, jump to PRG030_948E (RTS)

	DEY		 ; Y--
	BPL PRG030_9484	 ; While Y >= 0, loop!

	BMI PRG030_948F	 ; Jump to PRG030_948F

PRG030_948E:
	RTS		 ; Return

PRG030_948F:
	; BUG!! Apparently the game is SUPPOSED to delete all 
	; bonus objects after a game over, but code starts with
	; the wrong index (see immediately below) and that causes
	; this to not work correctly!  Strange, huh?

	; As my brother put it:
	; "It may have been because of the 2P mode. You can't punish
	; the other player because one of you sucks bad."

	LDX #-$04	; <-- BUG!  BAD INDEX!!  (Should be X = 2??)
PRG030_9491:
	LDY #(MAPOBJ_TOTAL-1)	 ; Y = (MAPOBJ_TOTAL-1) (all Map Objects)

PRG030_9493:
	LDA Map_Objects_IDs,Y
	BEQ PRG030_94A2	 ; If this Map Object is empty, jump to PRG030_94A2

	CMP GameOver_WhiteMapObjs,X
	BNE PRG030_94A2	 ; If this is NOT one of the "white" objects (White Toad House, Coin Ship, and the ??), jump to PRG030_94A2

	; Delete the bonus objects!  You don't deserve them!

	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs,Y

PRG030_94A2:
	DEY		 ; Y--
	BPL PRG030_9493	 ; While Y >= 0, loop

	DEX		 ; X--
	BPL PRG030_9491	 ; While X >= 0, loop	<-- BUG! This will fail on the first pass!

	LDA #$00
	STA Map_NSpade_NextScore	 ; Highest byte in the N-Spade score = 0
	STA Map_Anchored ; Airship is no longer anchored

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	LDA #HIGH(8000)
	STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	LDA #LOW(8000)
	STA Map_NSpade_NextScore+2

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetPages_ByTileset
;
; This routine uses sets both A000 and C000 pages based on the active Level_Tileset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetPages_ByTileset:	; $94BB
	LDY Level_Tileset	 	; Y = Level_Tileset

	; Change A000 and C000 pages based on Page_A/C000_List
	LDA PAGE_C000_ByTileset,Y
	STA PAGE_C000
	LDA PAGE_A000_ByTileset,Y
	STA PAGE_A000	 
	JMP PRGROM_Change_Both2		; JUMP to page routine, do not continue below...


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Video_Do_Update
;
; This very important subroutine takes an index value in 'A'
; and sets up to execute one of the Video_Upd_Table updates
; to the screen, e.g. A = 2 for the status bar.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Video_Do_Update:	; $94CD
	PHA		 ; Push A

	ASL A		 ; A << 1 (multiply by 2, looks up different address)
	TAY		 ; Y = A

	; Set update VRAM address high/low
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Video_Misc_Updates	 

	PLA		 ; Pop A

	BNE PRG030_94EE	 ; If A <> 0, jump to PRG030_94EE
	STA Graphics_BufCnt	; Clear the buffer counter
	STA Graphics_Buffer	; Immediately terminate the buffer

PRG030_94EE:
	; Jump into SetPages_ByTileset to "correct" the tables back
	; (mainly A000)
	JMP SetPages_ByTileset

	; Select the attribute table (which loads 8 bytes into Tile_AttrTable)
TileAttribute_ByTileset:
	.word Tile_Attributes_TS0		; 0 - Map
	.word Tile_Attributes_TS1		; 1 - Plains [15]
	.word Tile_Attributes_TS2		; 2 - Mini fortress style [21]
	.word Tile_Attributes_TS3		; 3 - Hills style [16]
	.word Tile_Attributes_TS4_TS12		; 4 - High-Up style [17]
	.word Tile_Attributes_TS5_TS11_TS13	; 5 - pipe world plant infestation [19]
	.word Tile_Attributes_TS6_TS7_TS8	; 6 - Water world [18]
	.word Tile_Attributes_TS6_TS7_TS8	; 7 - Toad house [18]
	.word Tile_Attributes_TS6_TS7_TS8	; 8 - Vertical pipe maze [18]
	.word Tile_Attributes_TS9		; 9 - desert level [20]
	.word Tile_Attributes_TS10		; 10 - airship [23]
	.word Tile_Attributes_TS5_TS11_TS13	; 11 - Giant World [19]
	.word Tile_Attributes_TS4_TS12		; 12 - ice level [17]
	.word Tile_Attributes_TS5_TS11_TS13	; 13 - coin heaven / sky level [19]
	.word Tile_Attributes_TS14		; 14 - underground [13]
	.word Tile_Attributes_TS15_TS16_TS17	; 15 - bonus game intro [22]
	.word Tile_Attributes_TS15_TS16_TS17	; 16 - spade game sliders [22]
	.word Tile_Attributes_TS15_TS16_TS17	; 17 - N-spade [22]
	.word Tile_Attributes_TS18		; 18 - 2P Vs [14]

	; NOT USED Tile Attribute values (not valid either; incomplete set!)
Tile_Attributes_TS15_TS16_TS17:
	; Unused space
	;.byte $FF, $FF, $FF, $FF


Fill_Tile_AttrTable_ByTileset:
	LDA Level_Tileset
	ASL A		 
	TAY		 	; Y = Level_Tileset << 1

	; Index into TileAttribute_ByTileset and store address to [Temp_Var2][Temp_Var1]
	LDA TileAttribute_ByTileset,Y
	STA <Temp_Var1		
	LDA TileAttribute_ByTileset+1,Y
	STA <Temp_Var2		

	LDY #$07		; Y = 7
PRG030_952C:
	LDA [Temp_Var1],Y	
	STA Tile_AttrTable,Y	
	DEY			; Y--
	BPL PRG030_952C	 	; While Y >= 0, loop!

	RTS			; Return

	; This LUTs are for the unused-in-US-release "Box out" effect when a level starts
	
	; This one selects the appropriate init values for everything
	; else based on what the vertical start position is...
BoxOut_ByVStart:	.byte $00, $30, $70, $B0, $EF	; Needs to sync with GamePlay_VStart

	; The init values, each column links to an above vertical start position
BoxOut_InitVAddrH:	.byte $21, $22, $23, $28, $29
BoxOut_InitVAddrL0:	.byte $6E, $2E, $2E, $6E, $6E
BoxOut_InitVAddrL1:	.byte $8E, $4E, $4E, $8E, $8E
BoxOut_InitVAddrL2:	.byte $73, $33, $33, $73, $73
BoxOut_InitVAddrL3:	.byte $6D, $2D, $2D, $6D, $6D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Clear_EntTranMem
;
; Clears memory used by the entrance transition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Clear_EntTranMem:
	LDY #$1c	 ; Y = $1C
PRG030_9555:
	LDA #$00	 ; A = 0
	STA Map_EntTran_VLHalf,Y
	DEY		 ; Y--
	BPL PRG030_9555	 ; While Y >= 0, loop!
	RTS		 ; Return


BoxOut_SetThisBorderVRAM:
	; Map_EntTran_VAddrL/H += Map_EntTran_VRAMGap
	LDA Map_EntTran_VAddrL
	ADD Map_EntTran_VRAMGap
	STA Map_EntTran_VAddrL
	LDA Map_EntTran_VAddrH
	ADC #$00
	STA Map_EntTran_VAddrH

	LDA Map_EntTran_InitValIdx
	CMP #$04
	BEQ PRG030_95AD	 ; If the initial index was 4, jump to PRG030_95AD (RTS)

	LDA Map_EntTran_Temp
	CMP #$ff	 
	BNE PRG030_95AD	 ; If Map_EntTran_Temp <> $FF, jump to PRG030_95AD (RTS)

	LDY Map_EntTran_BorderLoop	 ; Y = current border index (0-3: Top 0, bottom 1, right 2, left 3)

	; Prevent out of range video writes
	LDA Map_EntTran_BVAddrH,Y
	CMP #$28	 
	BGE PRG030_95AD	 	; If border's VRAM high address >= $28, jump to PRG030_95AD (RTS)
 
	LDA Map_EntTran_VAddrH
	CMP #$23
	BLT PRG030_95AD	 	; If border's VRAM high address < $23, jump to PRG030_95AD (RTS)

	LDA Map_EntTran_VAddrL
	CMP #$c0
	BLT PRG030_95AD	 	; If border's VRAM low address < $C0, jump to PRG030_95AD (RTS)

	; Set VRAM address to [$28][Map_EntTran_BVAddrL & $1f]
	LDA #$28
	STA Map_EntTran_VAddrH

	LDA Map_EntTran_VAddrL
	AND #$1f
	STA Map_EntTran_VAddrL

	LDA Map_EntTran_BorderLoop	 ; A = current border index (0-3: Top 0, bottom 1, right 2, left 3)
	AND #$02	
	BEQ PRG030_95AD	 	; If not doing right side update, jump to PRG030_95AD (RTS)

	STX Map_EntTran_Temp	 ; Store X (LRCnt) into Map_EntTran_Temp

PRG030_95AD:
	RTS		 ; Return


	; As part of the "boxing out" effect, calculate adjusted VRAM 
	; addresses as fit to the arbitrary positioning of the screen
BoxOut_CalcOffsets:
	; I'll let someone else figure this out in particular,
	; I'm not as concerned about a removed effect...

	LDA Map_EntTran_VAddrL
	AND #$c0
	STA Map_EntTran_TileOff

	LDA Map_EntTran_VAddrH
	AND #$0f
	STA Map_EntTran_VAddrHAdj

	CLC
	ROR Map_EntTran_VAddrHAdj
	ROR Map_EntTran_TileOff
	CLC
	ROR Map_EntTran_VAddrHAdj
	ROR Map_EntTran_TileOff
	LDA Map_EntTran_VAddrL
	AND #$1f
	LSR A	
	ADD Map_EntTran_TileOff
	STA Map_EntTran_TileOff

	RTS		 ; Return


	; Determine which 8x8 of the tile layout we're going to need
BoxOut_CalcWhich8x8:
	LDA Map_EntTran_VAddrL
	AND #$01
	STA Map_EntTran_Tile8x8

	LDA Map_EntTran_VAddrL
	AND #$20	 
	BNE PRG030_95EF	

	ASL Map_EntTran_Tile8x8
	JMP PRG030_95F3	 	; Jump to PRG030_95F3

PRG030_95EF: 
	SEC		 
	ROL Map_EntTran_Tile8x8

PRG030_95F3:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Calc_NT2Addr_By_XY
;
; This calculates the Nametable 2 address where a modification
; is about to take place (e.g. when a hammer has broken a rock)
; X = X coordinate on map (e.g. MapPoof_X)
; A = Y coordinate on map (e.g. MapPoof_Y)
;
; High byte of address is in Temp_Var15
; Low byte of address is in Temp_Var16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Calc_NT2Addr_By_XY:

	; This rearranges 'A' such that the two highest bits become
	; the two lowest bits, and the other 6 are shifted up.
	; Basically a ROL without the carry being involved
	ASL A
	ADC #$00
	ASL A	
	ADC #$00
	STA <Temp_Var13	 	; Stored into Temp_Var13

	TXA		 	; A = X coordinate
	LSR A
	LSR A
	LSR A
	STA <Temp_Var14 	; Temp_Var14 = X coord >> 3
 
	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11		; Get just the lower 2 bits (which are the upper 2 bits of Y coordinate)
	ORA #$28		; OR $28 (upper byte of video address for Nametable 2)
	STA <Temp_Var15		; Store into Temp_Var15

	LDA <Temp_Var13		; A = Temp_Var13
	AND #%11000000		; Get just the upper 2 bits of Temp_Var13
	ORA <Temp_Var14	; OR in Temp_Var14
	STA <Temp_Var16	; Store into Temp_Var16

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bonus_Prize1
;
; FOR UNUSED BONUS GAMES
; This is the routine used to give a prize for a roll of "2" on the die
; It's not completely clear what was intended, but that might be because
; the memory it is manipulating used to be something else once...
;
; It uses Inventory_Cards as the base but the only use of "Bonus_Prize1"
; is the lost bonus game die and it uses an input value of X = 3, which
; ultimately means we edit the first byte of Inventory_Score instead.
; But not in a "safe" way with carried arithmetic etc... which makes me
; think that memory space was once home to some other idea...
; And not that it'd make sense to "increment" your card storage either!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bonus_Prize1:

	; ; Backup Y/X
	; TYA
	; PHA
	; TXA
	; PHA

	; ; Temp_Var16 = 0 (offset to Mario's Inventory)
	; LDA #$00
	; STA <Temp_Var16

	; LDY Player_Current
	; CPY #$00
	; BEQ PRG030_962C	; If Player is Mario, jump to PRG030_962C

; PRG030_9622:
	; ; Offset to Luigi's Inventory
	; LDA <Temp_Var16
	; ADD #(Inventory_Items2 - Inventory_Items)
	; STA <Temp_Var16

	; DEY		 ; Y will equal 1 here, so this just makes Y zero
	; BNE PRG030_9622	 ; Jump technically NEVER to PRG030_9622 (?!)

; PRG030_962C:
	; TXA		 ; Input value -> 'A'

	; ADD <Temp_Var16	 ; Add to offset value
	; TAX		 ; -> 'X'

	; INC Inventory_Cards,X	 ; The intention of this is unclear!

	; ; Restore X/Y
	; PLA
	; TAX
	; PLA
	; TAY

	; RTS		 ; Return

BoxOut_PutPatternInStrip:
	JSR BoxOut_CalcOffsets	 ; Calculate offset to tile
	JSR BoxOut_CalcWhich8x8	 ; Calculate which 8x8 pattern of the tile layout we're going to use

	LDA Level_7Vertical
	BEQ PRG030_9654	 	; If level is not vertical, jump to PRG030_9654

	LDY Level_SizeOrig

	; Correct base address for vertical levels
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	JMP PRG030_965E	 	; Jump to PRG030_965E

PRG030_9654:
	; Correct base address for non-vertical levels
	LDA Tile_Mem_Addr
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1
	STA <Map_Tile_AddrH

PRG030_965E:
	LDA Map_EntTran_VAddrH
	AND #$08	 
	BEQ PRG030_966C	 ; If "high" address is not halfway through vertically, jump to PRG030_966C

	; Otherwise, offset halfway through screen
	LDA <Map_Tile_AddrL
	ADD #$f0
	STA <Map_Tile_AddrL	; Map_Tile_AddrL += $F0

PRG030_966C:
	LDA Level_Tileset
	ASL A		
	TAY		 

	; Set Temp_Var13/14 to point to the layout data for this Tileset
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var13	
	LDA TileLayout_ByTileset+1,Y
	STA <Temp_Var14	

	LDY Map_EntTran_TileOff
	LDA [Map_Tile_AddrL],Y	 ; Get the tile we're working on

	TAY		 
	LDA Map_EntTran_Tile8x8
	ADD <Temp_Var14		
	STA <Temp_Var14		
	LDA [Temp_Var13],Y	 ; Get the specific 8x8 tile of the tile we're working on

	STA <Scroll_ColorStrip,X ; Store into the strip
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update_Ranges
;
; This subroutine updates Scroll_ColumnL/R based on
; where the screen has currently scrolled to...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update_Ranges: 
	LDY Level_7Vertical
	BNE PRG030_96A5	 	; If Level_7Vertical, jump to PRG030_96A5

	; Non-vertical map
	; Expected that 'A' is currently set to the "Hi byte" of the X Scroll coordinate

	; This loop puts the lower 4 bits of the "hi byte" X into the 
	; upper 4 bits of Scroll_Temp, and shifts Scroll_Temp 4 bits down... or basically,
	; Scroll_Temp = (Scroll_Temp >> 4) | (A << 4)

	; Most importantly, this has taken a pixel-based scroll X and a "high byte" of X
	; scroll and combined them into a reduced accuracy (column-based) value of where
	; we're at horizontally...
	LDX #$03	 ; X = 3
PRG030_9695:
	LSR A		 ; Pushes the LSb -> Carry
	ROR <Scroll_Temp	 ; Shift everything in Scroll_Temp to the right, and pull in the carry
	DEX		 ; X--
	BPL PRG030_9695	 ; If X >= 0, loop!

	LDA <Scroll_Temp	; A = result from loop...
	STA <Scroll_ColumnL	; Store as the current "left side" column
	ADD #16	
	STA <Scroll_ColumnR	; Scroll_ColumnR = Scroll_ColumnL + 16 (always -- 256/16 = 16 columns spanning the screen)
	RTS			; Return!

PRG030_96A5:
	; Vertical level

	LDA <Scroll_Temp
	BEQ PRG030_96B7	 	; If Scroll_Temp = 0, jump to PRG030_96B7

	SUB #16			
	STA <Scroll_Temp	; Scroll_Temp -= 16

	CMP #$f0	 
	BLT PRG030_96B7	 ; If Scroll_Temp < $F0 (would only happen if it was previously $00-$0F), jump to PRG030_96B7

	SUB #17
	STA <Scroll_Temp	; Scroll_Temp -= 17

PRG030_96B7:
	LDA <Scroll_Temp	
	STA <Scroll_VOffsetT	; Scroll_VOffsetT = Scroll_Temp

	; Calculate bottom tile row offset

	ADD #$e0	 	; A = Scroll_Temp + $E0
	BCC PRG030_96C2	 	; If no carry occurred, jump to PRG030_96C2

	ADC #$10	 	; A = Scroll_Temp + $F0

PRG030_96C2:
	CMP #$f0	 	
	BLT PRG030_96CB	 	; If A < $F0, jump to PRG030_96CB
	AND #$0f	 	; A &= $F
	ADD #$01	 	; A += 1

PRG030_96CB:
	STA <Scroll_VOffsetB	; Update Scroll_VOffsetB
	RTS		 	; Return!

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Clear_RAM_thru_ZeroPage
	; 
	; Starting at the page provided in Y, this will clear everything
	; (except the stack space) $YY00 to $0000
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Clear_RAM_thru_ZeroPage:
	STY <Temp_Var2	 ; Save Y in <Temp_Var2
	LDY #$00	 ; Y = 0
	STY <Temp_Var1	 ; Clear <Temp_Var1
	TYA		 ; A = 0

	; Y is the initial input as the high byte of the address
	; low first then high, so [Temp_Var2][Temp_Var1]
PRG030_96D5:
	LDX <Temp_Var2	 ; X = current high byte of address in this case
	CPX #$01	 ; If we've reached the $01xx bank...
	BEQ PRG030_96DD	 ; ... skip the next line (don't clear the stack space!)
	STA [Temp_Var1],Y	 ; Otherwise, clear this byte
PRG030_96DD:
	DEY		 ; Y--
	BNE PRG030_96D5	 ; While Y <> 0, loop around again (goes $00, $FF, $FE, ... back to $00) again
	DEC <Temp_Var2	 ; Next lower bank
	BPL PRG030_96D5	 ; While we're >= bank $00
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GraphicsBuf_Prep_And_WaitVSync
;
; This subroutine takes Graphics_Queue and loads and address
; from Video_Upd_Table into the Video_Upd_Addr, then waits for
; a VBlank cycle to occur via reading the VBlank_Tick after
; force-setting it to zero.  This gets the system into a state
; where it can actually apply the update!
;
; See also GraphicsBuf_Prep_And_WaitVSyn2 in PRG024
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GraphicsBuf_Prep_And_WaitVSync:	; 96E5
	LDA <Graphics_Queue
	ASL A		 	
	TAY		 	; Y = Graphics_Queue * 2

	; Get the address where the video update data is
	LDA Video_Upd_Table,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table+1,Y
	STA <Video_Upd_AddrH	

	LDA #$01	
	STA <VBlank_TickEn	 ; Enable the VBlank tick
	LDA #$00	 
	STA <VBlank_Tick	 ; Force VBlank_Tick = 0, so we know when a VBlank has occurred

	; Waiting for VBlank...
PRG030_96FB:
	LDA <VBlank_Tick
	BPL PRG030_96FB	

	LDA #$00	 
	STA <VBlank_TickEn	 ; Disable the VBlank

	CLI		 ; Enable further masked interrupts
	RTS		 ; Return


	; Tile_Mem_ClearA/B form a way to rapidly clear all of the tile
	; memory to a specific value (A), used in conjunction with the
	; proper iterative loop...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearA
;
; $1B0 is the size of one screen, so this essentially writes to the
; same place on all screens, offset by 'Y'.  Unfortunately since 
; one screen is $1B0, 'Y' cannot cover the entire space, so we have
; Tile_Mem_ClearB with a different offset...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearA:	; $9705
	STA Tile_Mem,Y	 
	STA Tile_Mem+$1B0,Y
	STA Tile_Mem+$360,Y
	STA Tile_Mem+$510,Y
	STA Tile_Mem+$6C0,Y
	STA Tile_Mem+$870,Y
	STA Tile_Mem+$A20,Y
	STA Tile_Mem+$BD0,Y
	STA Tile_Mem+$D80,Y
	STA Tile_Mem+$F30,Y
	STA Tile_Mem+$10E0,Y
	STA Tile_Mem+$1290,Y
	STA Tile_Mem+$1440,Y
	STA Tile_Mem+$15F0,Y
	STA Tile_Mem+$17A0,Y
	INY		 ; Y++

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tile_Mem_ClearB
;
; Similar to Tile_Mem_ClearA, writes to the same place on all screens,
; only this one begins at the 12th row (making up for the 'Y'
; register coming up short of a full screen)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Tile_Mem_ClearB:	; $9734
	STA Tile_Mem+$0C0,Y
	STA Tile_Mem+$270,Y
	STA Tile_Mem+$420,Y
	STA Tile_Mem+$5D0,Y
	STA Tile_Mem+$780,Y
	STA Tile_Mem+$930,Y
	STA Tile_Mem+$AE0,Y
	STA Tile_Mem+$C90,Y
	STA Tile_Mem+$E40,Y
	STA Tile_Mem+$FF0,Y
	STA Tile_Mem+$11A0,Y
	STA Tile_Mem+$1350,Y
	STA Tile_Mem+$1500,Y
	STA Tile_Mem+$16B0,Y
	STA Tile_Mem+$1860,Y
	RTS		 ; Return


	; Array of bank selections by Level_BG_Page1_2 
	; What LEVEL4_BGBANK_INDEX references
Level_BG_Pages1:
	.byte $00	;  0 Not Used
	.byte $08	;  1 Plains
	.byte $10	;  2 Fortress
	.byte $1C	;  3 Hills / Underground
	.byte $0C	;  4 High-Up
	.byte $58	;  5 Plant Infestation
	.byte $58	;  6 Underwater
	.byte $5C	;  7 Toad House
	.byte $58	;  8 Pipe Maze
	.byte $30	;  9 Desert
	.byte $34	; 10 Airship
	.byte $6E	; 11 Giant world
	.byte $18	; 12 Ice
	.byte $38	; 13 Sky
	.byte $1C	; 14 Not Used (Same as Hills / Underground)
	.byte $24	; 15 Bonus Room
	.byte $2C	; 16 Spade (Roulette)
	.byte $5C	; 17 N-Spade (Card)
	.byte $58	; 18 2P Vs
	.byte $6C	; 19 Hills / Underground alternate
	.byte $68	; 20 3-7 only
	.byte $34	; 21 World 8 War Vehicle
	.byte $28	; 22 Throne Room

Level_BG_Pages2:
	.byte $00	;  0 Not Used
	.byte $60	;  1 Plains
	.byte $60	;  2 Fortress
	.byte $60	;  3 Hills / Underground
	.byte $60	;  4 High-Up
	.byte $3E	;  5 Plant Infestation
	.byte $60	;  6 Underwater
	.byte $5E	;  7 Toad House
	.byte $60	;  8 Pipe Maze
	.byte $60	;  9 Desert
	.byte $6A	; 10 Airship
	.byte $60	; 11 Giant world
	.byte $60	; 12 Ice
	.byte $60	; 13 Sky
	.byte $60	; 14 Not Used (Same as Hills / Underground)
	.byte $5E	; 15 Bonus Room
	.byte $2E	; 16 Spade (Roulette)
	.byte $5E	; 17 N-Spade (Card)
	.byte $60	; 18 2P Vs
	.byte $60	; 19 Hills / Underground alternate
	.byte $60	; 20 3-7 only
	.byte $70	; 21 World 8 War Vehicle
	.byte $60	; 22 Throne Room


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LevelLoad
;
; The master level loader function!  Without this, there's no game!
;
; This function performs all the work necessary to translate 
; "layout" data into functional geometry.  Note that based on
; the value of Level_Tileset, there are different "generators"
; that are employed, so while the overall macro format is consistent,
; the stylization and inner format may not be!
;
; Best to follow through to figure out the format to each "style"...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; There are 8 defined vertical start positions

	; Defines Player's Y "high" start
GamePlay_YHiStart:	.byte $01, $00, $00, $01, $00, $00, $00, $01

	; Defines Player's Y start
GamePlay_YStart:	.byte $70, $40, $00, $40, $70, $B0, $F0, $80

	; Defines screen vertical position starts
	; NOTE: If the "box out" effect were to be used, needs to sync with BoxOut_ByVStart
GamePlay_VStart:	.byte $EF, $00, $00, $EF, $30, $70, $B0, $EF

	; Available MSD time start values
GamePlay_TimeStart:	.byte 3, 4, 2, 0

	; Available BGMs for levels (16 possible with stock code, only 11 defined here)
GamePlay_BGM:
	.byte MUS2B_OVERWORLD	; 0
	.byte MUS2B_UNDERGROUND	; 1
	.byte MUS2B_UNDERWATER	; 2
	.byte MUS2B_FORTRESS	; 3
	.byte MUS2B_BOSS	; 4
	.byte MUS2B_AIRSHIP	; 5
	.byte MUS2B_BATTLE	; 6
	.byte MUS2B_TOADHOUSE	; 7
	.byte MUS2B_ATHLETIC	; 8
	.byte MUS2A_THRONEROOM	; 9
	.byte MUS2A_SKY		; 10


LevelLoad:	; $97B7

	; Clear loading variables
	LDA #$00
	STA TileAddr_Off
	STA LevLoad_Unused4
	STA LevLoad_Unused3
	STA LevLoad_Unused1
	STA LevLoad_Unused2

	LDY #$04	 ; Y = 4 (in case we're skipping first 4 bytes of header)

	; If we're using a "junction" device (door/pipe/etc.), we don't want to (incorrectly) set the "alternates"...
	LDA Level_JctCtl	 
	CMP #$80	 
	BEQ PRG030_980D	 ; If Level_JctCtl = $80, jump to PRG030_980D (use current Level_AltLayout/Level_AltObjects values)

	LDY #$00	 ; Y = 0

	; Get bytes 0-3 of layout data; pointers Level_AltLayout and Level_AltObjects

	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltLayout
	INY
	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltLayout+1
	INY		 

	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltObjects
	INY		
	LDA [Level_LayPtr_AddrL],Y
	STA Level_AltObjects+1
	INY		

	LDA Level_JctCtl	
	BNE PRG030_980D	 ; If Level_JctCtl <> 0, jump to PRG030_980D (skip setting vertical start position)

	LDA [Level_LayPtr_AddrL],Y
	AND #%11100000
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAX		 	; X = upper 3 bits, shifted down, from byte 4 (0-7)

	; Set up the vertical starting position!
	LDA GamePlay_YHiStart,X
	STA <Player_YHi		; Player_YHi = GamePlay_YHiStart[X]

	LDA GamePlay_YStart,X
	STA <Player_Y		; Player_Y = GamePlay_YStart[X]

	LDA #$00	 
	STA <Player_XHi		; Player_XHi = 0

	; Set the starting vertical position
	LDA GamePlay_VStart,X
	STA <Vert_Scroll	; Vert_Scroll = GamePlay_VStart[X]

PRG030_980D:

	; Set the width of the level (in screens) from byte 4
	LDA [Level_LayPtr_AddrL],Y
	AND #%00001111
	STA <Level_Width
	STA Level_SizeOrig	 

	;;;;;;;;;;;;;;;
	INY		 

	; First 3 bits of byte 5 determine the palette select for tiles
	LDA [Level_LayPtr_AddrL],Y
	AND #%00000111
	STA PalSel_Tile_Colors

	; Next 2 bits select an object palette, root value 8
	LDA [Level_LayPtr_AddrL],Y
	AND #%00011000
	LSR A		
	LSR A		
	LSR A		
	ORA #%00001000		; forces minimum value of 8
	STA PalSel_Obj_Colors

	; Next 2 bits sets Level_SelXStart (sets Player_X after level starts)
	LDA [Level_LayPtr_AddrL],Y
	AND #%01100000
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	STA Level_SelXStart	 

	; Finally, bit 7 sets Level_UnusedFlag (unused; only set, never read)
	LDA [Level_LayPtr_AddrL],Y
	AND #$80	
	STA Level_UnusedFlag 

	;;;;;;;;;;;;;;;
	INY		 

	; Bit 7 of byte 6 sets Level_PipeNotExit
	LDA [Level_LayPtr_AddrL],Y
	AND #$80	 
	STA Level_PipeNotExit

	; Bits 5-6 set Level_FreeVertScroll
	LDA [Level_LayPtr_AddrL],Y
	AND #%01100000
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	STA Level_FreeVertScroll

	CMP #$02
	BNE PRG030_9864	 ; If Level_FreeVertScroll <> 2 (arbitrary scroll lock), jump to PRG030_9864

	; Otherwise for a level started with the arbitrary lock, it picks Vert_Scroll = 0 (highest point)
	; if Vert_Scroll is less than $B0, otherwise it picks $EF (lowest point)
	; NOTE however that these two points are not required during normal gameplay; you can arbitrarily
	; lock to ANY Vert_Scroll value and it will work just fine!

	LDX #$00		; X = 0

	LDA <Vert_Scroll
	CMP #$b0
	BLT PRG030_985F	 	; If Vert_Scroll < $B0, jump to PRG030_985F

	LDX #$ef	 	; Otherwise, X = $EF

PRG030_985F:
	STX <Vert_Scroll	; Vert_Scroll = X
	STX Level_Jct_VS	; Level_Jct_VS = Vert_Scroll

PRG030_9864:

	; Bit 4 sets whether this level is a vertical one
	LDA [Level_LayPtr_AddrL],Y
	AND #%00010000
	STA Level_7Vertical
	BEQ PRG030_9893	 	; If not vertical, jump to PRG030_9893

	LDX Level_JctCtl
	BNE PRG030_987C	 	; If Level_JctCtl <> 0, jump to PRG030_987C

	; Start at bottom of vertical level
	LDA Level_SizeOrig
	STA <Vert_Scroll_Hi
	STA <Player_YHi		; Player's Y High is the same!
	JMP PRG030_9893	


PRG030_987C:
	LDA #$00	
	STA Level_SizeOrig	; ?? Why?

	LDA <Player_YHi	
	BEQ PRG030_988E	 	; If the Player Y high is zero, jump to PRG030_988E

	LDA <Level_Width
	STA <Vert_Scroll_Hi
	STA <Player_YHi	
	STA Level_SizeOrig

PRG030_988E:
	LDA <Vert_Scroll_Hi
	STA Level_Jct_VSHi	 ; Level_Jct_VSHi = Vert_Scroll_Hi

	; End of Vertical alternative

PRG030_9893:

	; Bits 0-3 set Level_AltTileset
	LDA [Level_LayPtr_AddrL],Y
	AND #$0f	
	STA Level_AltTileset

	;;;;;;;;;;;;;;;
	INY		; Y++	

	; Bits 5-7 of byte 7 set Level_InitAction (sets an action to begin level, see Level_InitAction_JumpTable)
	LDA [Level_LayPtr_AddrL],Y
	AND #%11100000	 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	STA Level_InitAction

	; Bits 0-4 set Level_BG_Page1_2 (an index to which pages of BG graphics should be loaded)
	LDA [Level_LayPtr_AddrL],Y
	AND #%00011111	 
	STA Level_BG_Page1_2

	;;;;;;;;;;;;;;;
	INY		 ; Y++

	LDA Level_JctCtl
	BNE PRG030_98C8	 ; If using a junction device, don't set the time; jump to PRG030_98C8

	; Bits 6-7 of byte 8 select a time setting (0=300, 1=400, 2=200, 3=000 [unlimited])
	LDA [Level_LayPtr_AddrL],Y
	AND #%11000000	
	CLC		
	ROL A		
	ROL A		
	ROL A		
	TAX		
	LDA GamePlay_TimeStart,X
	STA Level_TimerMSD
	BNE PRG030_98C8	 	; If not using the 000 time, jump to PRG030_98C8

	INC Level_TimerEn	; Otherwise Level_TimerEn = 1 (disable the clock, hence unlimited time)

PRG030_98C8:

	; Bits 0-3 select a BGM
	LDA [Level_LayPtr_AddrL],Y
	AND #%00001111
	TAX
	LDA GamePlay_BGM,X	; A = target music
	LDX SndCur_Music2	; X = currently playing music

	CPX #MUS2B_PSWITCH
	BEQ PRG030_98DE		; If playing the P-Tab music, don't queue this song right now
	CPX #MUS2A_INVINCIBILITY		
	BEQ PRG030_98DE		; If playing the Invincibility music, don't queue this song right now

	; Queue this music to play
	STA Level_MusicQueue

PRG030_98DE:
	; Set this as the music to "restore" to when P-Tab / Invincibility ends
	STA Level_MusicQueueRestore

	; Level_LayPtr_AddrL/H += 9 (i.e. move pointer to after the header)
	LDA <Level_LayPtr_AddrL
	ADD #$09
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00
	STA <Level_LayPtr_AddrH

PRG030_98EE:
	LDY #$00	 		; Y = 0 (beginning of post-header)

	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	CMP #$ff	 		
	BEQ PRG030_9934	 		; If $FF, jump to PRG030_9934 (RTS)

	; Otherwise...
	STA <Temp_Var15			; Store byte into Temp_Var15

	INY		 		; Y++
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA <Temp_Var16		 	; Store into Temp_Var16

	INY				; Y++
	LDA [Level_LayPtr_AddrL],Y	; Get next byte
	STA LL_ShapeDef	 		; Store into LL_ShapeDef

	INY		 		; Y++
	TYA		 		; A = Y

	; Add current offset into Level_LayPtr_AddrL/H, moving it ahead
	ADD <Level_LayPtr_AddrL
	STA <Level_LayPtr_AddrL
	LDA <Level_LayPtr_AddrH
	ADC #$00	 
	STA <Level_LayPtr_AddrH

	LDA <Temp_Var15		 	; Retrieve first byte we read
	AND #$e0	 
	CMP #$e0	 
	BNE PRG030_991E	 		; If its upper 3 bits are not all set, jump to PRG030_991E

	; *****************
	; Upper 3 bits of Temp_Var15 are ALL set... i.e. Temp_Var15 = 111x xxxx
	; *****************

	JSR LoadLevel_StoreJctStart 	; Temp_Var16 and LL_ShapeDef define junction start positions
	JMP PRG030_98EE	 		; Loop around

PRG030_991E:

	; *****************
	; Upper 3 bits of Temp_Var15 are NOT ALL set... i.e. Temp_Var15 DOES *NOT follow* the mask 111x xxxx
	; *****************

	; Temp_Var15 and Temp_Var16 are the input parameters to LoadLevel_Set_TileMemAddr,
	; which set, most importantly, "Map_Tile_Addr" to some root screen address, and
	; set "TileAddr_Off" as an offset value within that screen.

	; "Map_Tile_Addr" is formed Tile_Mem_Addr[ (Temp_Var16 & $F0) >> 3 ]
	;	- The upper 4 bits of Temp_Var16 select the starting screen
	;
	; "TileAddr_Off" is formed (Temp_Var15 << 4) | (Temp_Var16 & $f)
	;	- The lower 4 bits of Temp_Var15, and lower 4 bits of Temp_Var16
	JSR LoadLevel_Set_TileMemAddr

	LDA LL_ShapeDef
	AND #$f0
	BEQ PRG030_992E	 	; If upper 4 bits of LL_ShapeDef are all zero, jump to PRG030_992E

	; *****************
	; Upper 4 bits of LL_ShapeDef are NOT ALL clear... i.e. LL_ShapeDef DOES *NOT follow* the mask 0000 xxxx
	; *****************

	; Otherwise, we handle this as a construction command, and so turn
	; to the "generators" which define what the bytes mean...
	JSR LeveLoad_Generators	

	JMP PRG030_9931	 	; (Essentially) loop around (pointless jump, heh)

PRG030_992E:
	; *****************
	; Upper 4 bits of LL_ShapeDef are ALL NOT set... i.e. LL_ShapeDef = 0000 xxxx
	; *****************

	; This is a fixed-size construction type
	JSR LeveLoad_FixedSizeGens

PRG030_9931:
	JMP PRG030_98EE	 	; Loop around...

PRG030_9934:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LoadLevel_Set_TileMemAddr
;
; Used while loading a level.  Sets the Map_Tile_AddrL/H pointer
; to a specified "screen", and also sets TileAddr_Off to an offset
; within that screen.
;
; Takes input parameters of Temp_Var15 and Temp_Var16 and from 
; there generates:
;
; Guide to help visualize the input:
; Temp_Var15 Temp_Var16
; FEDC BA98  7654 3210	<-- bits
;
;
; * Map_Tile_AddrL/H points to Tile_Mem_Addr(V)[7654 0] <-- '0' is a one-up shift, not bit 0 of Temp_Var16; (V) is the "Vertical" table, used if applicable
;
; * If 'C' (bit 4) of Temp_Var15 is set, then Map_Tile_AddrH is incremented
;
; * Temp_Var5 = Map_Tile_AddrH + 1 -- Pre-'C' increment, ONLY WHEN NOT VERTICAL (otherwise unassigned)
;
; * Temp_Var6 = Map_Tile_AddrH -- Post-'C' increment (i.e. equals whatever Map_Tile_AddrH does at end of function)
;
; * TileAddr_Off = BA98 3210 -OR- (Temp_Var15 << 4) | (Temp_Var16 & $f)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LoadLevel_Set_TileMemAddr:
	; Upper 3 bits of first byte were all set...


	LDA <Temp_Var15	 ; Get that first byte
	ASL A		
	ASL A		
	ASL A		
	ASL A		
	STA <Temp_Var7	 ; Temp_Var7 = Temp_Var15 << 4 (take lower 4 bits and multiply by 16)

	LDA <Temp_Var16	 ; Second byte
	AND #$0f	 ; Lower 4 bits
	ORA <Temp_Var7	 ; Applied to Temp_Var7
	STA TileAddr_Off	 ; Stored into TileAddr_Off

	; TileAddr_Off = BA98 3210 -OR- (first byte << 4) | (second byte & $f)


	LDA <Temp_Var16	 ; Second byte
	AND #$f0	 ; Upper 4 bits
	LSR A		 
	LSR A		 
	LSR A		 
	TAX		 ; X = (Temp_Var16 & $F0) >> 3 (value in upper 4 bits times 2, 2 byte index for Tile_Mem_Addr)

	; X = 7654 0 <-- '0' is a one-up shift, not bit 0 of Temp_Var16

	LDA Level_7Vertical
	BEQ PRG030_9963	 ; If not a vertical level, jump to PRG030_9963

	; Vertical level

	TXA
	LSR A
	TAX		; X >>= 1 (single byte index, since the Tile_Mem_AddrV lookup is split into two tables)

	; Load the target address into Map_Tile_AddrH/L
	LDA Tile_Mem_AddrVL,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,X
	STA <Map_Tile_AddrH

	JMP PRG030_997F	 ; Jump to PRG030_997F

PRG030_9963:

	; Non-vertical level

	CPX #$1e
	BNE PRG030_9969	 ; If X <> $1E (the max value), jump to PRG030_9969

	; Otherwise, X -= 2
	DEX
	DEX

PRG030_9969:

	; Load the target address into Map_Tile_AddrH/L
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	STA <Temp_Var5	
	INC <Temp_Var5		; Temp_Var5 = Map_Tile_AddrH + 1

	LDA <Temp_Var15	
	AND #$10	
	BEQ PRG030_997F		; If bit 4 of the first byte is not set, jump to PRG030_997F

	; Otherwise, Map_Tile_AddrH++
	INC <Map_Tile_AddrH

PRG030_997F:
	LDA <Map_Tile_AddrH
	STA <Temp_Var6		; Temp_Var6 = Map_Tile_AddrH

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Randomize
;
; Shakes up the random number pool a bit!
; Anyone want to detail the algorithm, go right ahead...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Randomize:
	LDX #$00	
	LDY #$09	
	LDA Random_Pool	
	AND #$02	
	STA <Temp_Var1	
	LDA RandomN	
	AND #$02	
	EOR <Temp_Var1	
	CLC		
	BEQ PRG030_999A	
	SEC		
PRG030_999A:
	ROR Random_Pool,X
	INX		 
	DEY		 
	BNE PRG030_999A	 

	RTS		 ; Return



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Level_RecordBlockHit
;
; Called after a coin is collected or a hidden 1-Up is found.
; This records those events so if the level is swapped with its
; alternate, these things do not retun.  Next best thing to
; actually having enough memory to hold both levels together...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RecordBlockHitBits:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

Level_RecordBlockHit:

	; Currently Temp_Var13-16 are defined as follows:
	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo
	; ... of Player detection coordinates

	TYA
	PHA		 ; Save 'Y'

	TXA
	PHA		 ; Save 'X'

	LDA <Temp_Var16
	PHA		 ; Save Temp_Var16

	LDA <Temp_Var13
	PHA		 ; Save Temp_Var13

	; This converts Temp_Var15/Temp_Var16 into a tile row stored in Temp_Var16
	; Essentially a 16-bit right shift 4 bits
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16
	LDA <Temp_Var15
	ASL A
	ASL A
	ASL A
	ASL A
	ORA <Temp_Var16
	STA <Temp_Var16

	; This turns Temp_Var13 into an index into Level_BlockGrabHitMem
	LDA <Temp_Var16
	AND #%11111000
	LSR A
	LSR A
	ORA <Temp_Var13
	STA <Temp_Var13

	LDA Level_JctFlag
	BEQ PRG030_99DC	 ; If we're not junctioning, jump to PRG030_99DC

	; If junctioning, Temp_Var13 += $40
	LDA <Temp_Var13
	ADD #$40
	STA <Temp_Var13

PRG030_99DC:
	LDA <Temp_Var16
	AND #$07
	TAX
	LDY <Temp_Var13
	LDA Level_BlockGrabHitMem,Y
	ORA RecordBlockHitBits,X
	STA Level_BlockGrabHitMem,Y

	; Restore everything we saved
	PLA
	STA <Temp_Var13
	PLA
	STA <Temp_Var16
	PLA
	TAX
	PLA
	TAY

	RTS		 ; Return

TileLayout_ByTileset:
	; Defines the 8x8 blocks to build a particular 16x16 "tile"

	.word Tile_Layout_TS0		; 0 - Map
	.word Tile_Layout_TS1		; 1 - Plains [15]
	.word Tile_Layout_TS2		; 2 - Mini fortress style [21]
	.word Tile_Layout_TS3		; 3 - Hills style [16]
	.word Tile_Layout_TS4_TS12	; 4 - High-Up style [17]
	.word Tile_Layout_TS5_TS11_TS13	; 5 - pipe world plant infestation [19]
	.word Tile_Layout_TS6_TS7_TS8	; 6 - Water world [18]
	.word Tile_Layout_TS6_TS7_TS8	; 7 - Toad house [18]
	.word Tile_Layout_TS6_TS7_TS8	; 8 - Vertical pipe maze [18]
	.word Tile_Layout_TS9		; 9 - desert level [20]
	.word Tile_Layout_TS10		; 10 - airship [23]
	.word Tile_Layout_TS5_TS11_TS13	; 11 - Giant World [19]
	.word Tile_Layout_TS4_TS12	; 12 - ice level [17]
	.word Tile_Layout_TS5_TS11_TS13	; 13 - coin heaven / sky level [19]
	.word Tile_Layout_TS14		; 14 - underground [13]
	.word Tile_Layout_TS15_TS16_TS17; 15 - bonus game intro [22]
	.word Tile_Layout_TS15_TS16_TS17; 16 - spade game sliders [22]
	.word Tile_Layout_TS15_TS16_TS17; 17 - N-spade [22]
	.word Tile_Layout_TS18		; 18 - 2P Vs [14]

LevelLoad_ByTileset:
	LDA Level_Tileset
	JSR DynJump

	; Page numbers are determined by PAGE_A000_ByTileset and PAGE_C000_ByTileset, indexed by Level_Tileset

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0			; 0 - Map [11] (not used, enters in the middle of WWFX_WarpIslandInit, and not in a logical place)
	.word LevelLoad_TS1		; 1 - Plains [15]
	.word LevelLoad_TS2		; 2 - Mini fortress style [21]
	.word LevelLoad_TS3		; 3 - Hills style [16]
	.word LevelLoad_TS4_TS12	; 4 - High-Up style [17]
	.word LevelLoad_TS5		; 5 - pipe world plant infestation [19]
	.word LevelLoad_TS6		; 6 - Water world [18]
	.word LevelLoad_TS7		; 7 - Toad house [18]
	.word LevelLoad_TS8		; 8 - Vertical pipe maze [18]
	.word LevelLoad_TS9		; 9 - desert level [20]
	.word LevelLoad_TS10		; 10 - airship [23]
	.word LevelLoad_TS5		; 11 - Giant World [19]
	.word LevelLoad_TS4_TS12	; 12 - ice level [17]
	.word LevelLoad_TS13		; 13 - coin heaven / sky level [19]
	.word LevelLoad_TS14		; 14 - underground [13]

	.word LevelLoad_TS15_TS16_TS17	; 15 - bonus game intro [22]
	.word LevelLoad_TS15_TS16_TS17	; 16 - spade game sliders [22]
	.word LevelLoad_TS15_TS16_TS17	; 17 - N-spade [22]
	.word LevelLoad_TS18		; 18 - 2P Vs [14]


; RegEx S&R:
; LDA LL_ShapeDef.*\n.*AND #\$0f.*\n.*STA <Temp_Var(.)		 ; .*
; LDA LL_ShapeDef\n\tAND #$0f\n\tSTA <Temp_Var\1		 ; Temp_Var\1 = lower 4 bits of LL_ShapeDef

; LDA LL_ShapeDef.*\n.*AND #\$0f.*\n.*TAX		 ; .*
; LDA LL_ShapeDef\n\tAND #$0f\n\tTAX		 ; X = lower 4 bits of LL_ShapeDef

; LDA <Temp_Var(.).*\n.*STA <Temp_Var(.)		 ; .*
; LDA <Temp_Var\1\n\tSTA <Temp_Var\2		 ; Temp_Var\2 = Temp_Var\1

; DEC <Temp_Var(.)		 ; .*
; DEC <Temp_Var\1		 ; Temp_Var\1--

; LDA <Map_Tile_AddrL.*\n.*STA <Temp_Var1.*\n.*LDA <Map_Tile_AddrH.*\n.*STA <Temp_Var2.*
;; Backup Map_Tile_AddrL/H into Temp_Var1/2\n\tLDA <Map_Tile_AddrL\n\tSTA <Temp_Var1\n\tLDA <Map_Tile_AddrH\n\tSTA <Temp_Var2

; LDA <Temp_Var1.*\n.*STA <Map_Tile_AddrL.*\n.*LDA <Temp_Var2.*\n.*STA <Map_Tile_AddrH.*
;; Restore Map_Tile_Addr from backup\n\tLDA <Temp_Var1\n\tSTA <Map_Tile_AddrL\n\tLDA <Temp_Var2\n\tSTA <Map_Tile_AddrH

LeveLoad_Generators:
	LDA Level_Tileset
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0B				; 0 - Map [11] (not used, enters in the middle of nowhere, in a not logical place)
	.word LoadLevel_Generator_TS1		; 1 - Plains [15]
	.word LoadLevel_Generator_TS2		; 2 - Mini fortress style [21]
	.word LoadLevel_Generator_TS3		; 3 - Hills style [16]
	.word LoadLevel_Generator_TS4_TS12	; 4 - High-Up style [17]
	.word LoadLevel_Generator_TS051113	; 5 - pipe world plant infestation [19]
	.word LoadLevel_Generator_TS678		; 6 - Water world [18]
	.word LoadLevel_Generator_TS678		; 7 - Toad house [18]
	.word LoadLevel_Generator_TS678		; 8 - Vertical pipe maze [18]
	.word LoadLevel_Generator_TS9		; 9 - desert level
	.word LoadLevel_Generator_TS10		; 10 - airship
	.word LoadLevel_Generator_TS051113	; 11 - Giant World
	.word LoadLevel_Generator_TS4_TS12	; 12 - ice level [17]
	.word LoadLevel_Generator_TS051113	; 13 - coin heaven / sky level [19]
	.word LoadLevel_Generator_TS14		; 14 - underground [13]
	.word LoadLevel_Generator_TS151617	; 15 - bonus game intro
	.word LoadLevel_Generator_TS151617	; 16 - spade game sliders
	.word LoadLevel_Generator_TS151617	; 17 - N-spade
	.word LoadLevel_Generator_TS18		; 18 - 2P Vs

LeveLoad_FixedSizeGens:
	LDA Level_Tileset
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word LT0B				; 0 - Map [11] (not used, enters in the middle of nowhere, in a not logical place)
	.word LeveLoad_FixedSizeGen_TS1		; 1 - Plains
	.word LeveLoad_FixedSizeGen_TS2		; 2 - Mini fortress style
	.word LeveLoad_FixedSizeGen_TS3		; 3 - Hills style [16]
	.word LeveLoad_FixedSizeGen_TS4_TS12	; 4 - High-Up style [17]
	.word LeveLoad_FixedSizeGen_TS051113	; 5 - pipe world plant infestation [19]
	.word LeveLoad_FixedSizeGen_TS678	; 6 - Water world
	.word LeveLoad_FixedSizeGen_TS678	; 7 - Toad house
	.word LeveLoad_FixedSizeGen_TS678	; 8 - Vertical pipe maze
	.word LeveLoad_FixedSizeGen_TS9		; 9 - desert level
	.word LeveLoad_FixedSizeGen_TS10	; 10 - airship
	.word LeveLoad_FixedSizeGen_TS051113	; 11 - Giant World [19]
	.word LeveLoad_FixedSizeGen_TS4_TS12	; 12 - ice level [17]
	.word LeveLoad_FixedSizeGen_TS051113	; 13 - coin heaven / sky level [19]
	.word LeveLoad_FixedSizeGen_TS14	; 14 - underground [13]
	.word LeveLoad_FixedSizeGen_TS151617	; 15 - bonus game intro
	.word LeveLoad_FixedSizeGen_TS151617	; 16 - spade game sliders
	.word LeveLoad_FixedSizeGen_TS151617	; 17 - N-spade
	.word LeveLoad_FixedSizeGen_TS18	; 18 - 2P Vs

PRG030_9AA1:
	.byte $01, $FF

PRG030_9AA3:
	.byte $08, $F8

PRG030_9AA5:
	.byte $00, $08


TileLayoutPage_ByTileset:
	; A000 page selected per-Level_Tileset...
	.byte BANK(Tile_Layout_TS0)		; 0 - Map [11]
	.byte BANK(Tile_Layout_TS1)		; 1 - Plains [15]
	.byte BANK(Tile_Layout_TS2)		; 2 - Mini fortress style [21]
	.byte BANK(Tile_Layout_TS3)		; 3 - Hills style [16]
	.byte BANK(Tile_Layout_TS4_TS12)	; 4 - High-Up style [17]
	.byte BANK(Tile_Layout_TS5_TS11_TS13)	; 5 - pipe world plant infestation [19]
	.byte BANK(Tile_Layout_TS6_TS7_TS8)	; 6 - Water world [18]
	.byte BANK(Tile_Layout_TS6_TS7_TS8)	; 7 - Toad house [18]
	.byte BANK(Tile_Layout_TS6_TS7_TS8)	; 8 - Vertical pipe maze [18]
	.byte BANK(Tile_Layout_TS9)		; 9 - desert level [20]
	.byte BANK(Tile_Layout_TS10)		; 10 - airship [23]
	.byte BANK(Tile_Layout_TS5_TS11_TS13)	; 11 - Giant World [19]
	.byte BANK(Tile_Layout_TS4_TS12)	; 12 - ice level [17]
	.byte BANK(Tile_Layout_TS5_TS11_TS13)	; 13 - coin heaven / sky level [19]
	.byte BANK(Tile_Layout_TS14)		; 14 - underground [13]

	; THESE VALUES ARE WRONG!  Appears that they were not maintained?
	; It doesn't matter because these specialized cases go where they need to anyway!
	.byte 23				; 15 - bonus game intro (WRONG: Should be 22)
	.byte 23				; 16 - spade game sliders (WRONG: Should be 22)
	.byte 23				; 17 - N-spade (WRONG: Should be 22)
	.byte 16				; 18 - 2P Vs (WRONG: Should be 14)

	; CORRECT VALUES:
	;.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 15 - bonus game intro [22]
	;.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 16 - spade game sliders [22]
	;.byte BANK(Tile_Layout_TS15_TS16_TS17)	; 17 - N-spade [22]
	;.byte BANK(Tile_Layout_TS18)		; 18 - 2P Vs [14]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Dirty_Update
;
; This function performs a full-screen redraw of all tiles, 
; used when first showing map/level, but not for scrolling!
; (Though it does call the same routine USED for scrolling)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Dirty_Update:
	LDA Level_7Vertical
	BNE PRG030_9B10	 	; If level is vertical, jump to PRG030_9B10

	; Non-vertical level
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	STA <Scroll_RightUpd,X	; Current horizontal scroll stored into appropriate left/right value

PRG030_9AC5:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	; Buffers a single 8x8 column of tiles
	JSR Scroll_DoColumn

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	; Commits the buffer
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	 ; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	 ; A = Get the last 8 pixel location update
	ADD PRG030_9AA3,X	 ; Add an appropriate offset given the direction of travel
	STA <Scroll_RightUpd,X	 ; Update it!

	; Produce the attribute data and commits the buffer
	JSR Scroll_Do_AttrColumn
	JSR Scroll_Commit_Column

	LDX <Scroll_LastDir	; Last direction to index the following
	LDA <Scroll_RightUpd,X	; Get updated column
	AND #$08	 	; Every half screen
	CMP PRG030_9AA5,X
	BNE PRG030_9B02	 	; For updating on half-tiles (??), jump to PRG030_9B02
	LDA <Scroll_ColumnR,X	
	ADD PRG030_9AA1,X
	STA <Scroll_ColumnR,X

PRG030_9B02:
	DEC Scroll_Cols2Upd	 ; Scroll_Cols2Upd--
	BNE PRG030_9AC5	 ; While Scroll_Cols2Upd <> 0, loop!

	LDA #$ff
	STA <Scroll_RightUpd		 ; Scroll_RightUpd = $ff (marker as in "not last updated"; flat for dirty)
	STA <Scroll_LeftUpd		 ; Scroll_LeftUpd = $ff (marker as in "not last updated"; flat for dirty)
	JMP SetPages_ByTileset	 ; JUMP to SetPages_ByTileset to reset pages (will take care of the RTS)

PRG030_9B10:

	; Scroll_LastDir = 0
	LDA #$00
	STA <Scroll_LastDir

	; Vert_Scroll = $E0
	LDA #$e0
	STA <Vert_Scroll

	; Scroll_RightUpd = $E8
	ADD #$08
	STA <Scroll_RightUpd

	; Scroll_ColumnR = (Level_SizeOrig - 1) | $E0
	LDY Level_SizeOrig	 ; Y = Level_SizeOrig
	DEY		 ; Y--
	TYA
	ORA #$e0
	STA <Scroll_ColumnR

PRG030_9B26:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR VScroll_PageAndDoPatAttrRow	 ; Do the row of patterns and attributes for vertical scroll

	; Set page @ A000 to 26
	LDA #26
	STA PAGE_A000
	JSR PRGROM_Change_A000

	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates
	JSR Scroll_ToVRAM_Apply	 ; Applies Scroll_ToVRAMHi and Scroll_ToVRAMHA updates

	LDA <Vert_Scroll
	ADD #$08
	STA <Vert_Scroll

	CMP #$f0
	BNE PRG030_9B59	 ; If not changing to new screen, jump to PRG030_9B59

	INC <Scroll_VOffsetT		 ; Scroll_VOffsetT++

	; Loop vertical offset to new screen
	LDA <Scroll_VOffsetT
	AND #$0f
	STA <Scroll_VOffsetT

	JMP PRG030_9B66	 ; Jump to PRG030_9B66

PRG030_9B59:
	LDA <Vert_Scroll
	AND #$08
	BNE PRG030_9B66	 ; If only halfway vertically through tile row, jump to PRG030_9B66

	; Otherwise, go to next row
	LDA <Scroll_VOffsetT
	ADD #$10
	STA <Scroll_VOffsetT

PRG030_9B66:
	LDA <Vert_Scroll
	CMP #$d0
	BNE PRG030_9B26	 ; While Vert_Scroll <> $D0, loop!

	LDA #$00
	STA <Vert_Scroll	; Vert_Scroll = 0
	STA <Scroll_VertUpd	; Scroll_VertUpd = 0

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Update
;
; This subroutine updates one column of tiles worth
; of scroll (tile and attribute) as needed per
; changes in Horz_Scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Update:
	LDA Level_7Vertical
	BNE PRG030_9BB2	 	; If this is a vertical scroller world, jump to PRG030_9BB2

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$f8		; Only caring about every 8 pixels (for valid comparison to Scroll_RightUpd)
	CMP <Scroll_RightUpd,X	; Compared to whichever update applies to the last scroll
	BEQ PRG030_9BA9	 	; If we are updated completely, jump to PRG030_9BA9

	; Otherwise ...
	TAY		 	; Y = A (Horz_Scroll, 8 pixel aligned)

	LDA Scroll_Cols2Upd
	BNE PRG030_9B9B	 	; If columns remain to be updated, jump to PRG030_9B9B

	LDA <Horz_Scroll
	AND #$07		; How many pixels across a tile boundary of 8 (0 - 7)

	CPX #$00
	BNE PRG030_9B97	 	; If last scroll direction <> 0 (last moved left), jump to PRG030_9B97

	; Last moved right...
	CMP #$02
	BGE PRG030_9B9B	 	; If greater-or-equal to 2 pixels to the right, jump to PRG030_9B9B

	JMP PRG030_9BA9	 	; Otherwise, jump to PRG030_9BA9

PRG030_9B97:
	; Last moved left...

	CMP #$05
	BGE PRG030_9BA9	 ; If greater-or-equal to 5 pixels in (complement to 2 pixels from right case), jump to PRG030_9BA9

	; Otherwise...

PRG030_9B9B:
	STY <Scroll_RightUpd,X	 ; Store our right/left update

	LDA <Scroll_LastDir
	EOR #$01	 
	TAX		 
	LDA #$ff	 
	STA <Scroll_RightUpd,X	 ; Store $FF on the other side

	JSR Scroll_DoColumn	 ; Render a column of tiles...

PRG030_9BA9:
	LDA Scroll_UpdAttrFlag	
	BEQ PRG030_9BB1	 	; If Scroll_UpdAttrFlag is not set (not time to update attributes), jump to PRG030_9BB1 (RTS)

	JSR Scroll_Do_AttrColumn ; Otherwise, Render a column of attributes...

PRG030_9BB1:
	RTS		 ; Return


PRG030_9BB2:
	LDA <Vert_Scroll
	AND #$f8
	CMP <Scroll_VertUpd
	BEQ PRG030_9BD2	 ; If the vertical scroll hasn't changed 8 pixels, jump to PRG030_9BD2 (RTS)

	; Otherwise, change the Scroll_VertUpd value
	LDA <Vert_Scroll
	AND #$f8
	STA <Scroll_VertUpd

VScroll_PageAndDoPatAttrRow:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	JSR VScroll_CalcPatternVRAMAddr	 ; Calculate start of pattern row
	JSR VScroll_DoPatternAndAttrRow	 ; Do the pattern row AND attributes

PRG030_9BD2:
	RTS		 ; Return

PRG030_9BD3:	.byte $00, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_DoColumn	
;
; This subroutine renders a "column" of 8x8 blocks for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_DoColumn:
	; Set proper Page @ A000 for tile layout data
	LDY Level_Tileset
	LDA TileLayoutPage_ByTileset,Y	
	STA PAGE_A000	 
	JSR PRGROM_Change_A000

	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_RightUpd,X	; Related last update value
	AND #$08	 	; Take just whether we've moved onto an 8
	LSR A		 	
	LSR A		 
	LSR A		 
	STA <Scroll_OddEven	; <Scroll_OddEven is 0 for 0, 1 for 8
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Horz_Scroll	; A = Horz_Scroll
	AND #$0f	 	; A is now 0-15
	CPX #$00	 	
	BNE PRG030_9BFD	 	; If Scroll_LastDir = 0 (last scrolled right), jump to PRG030_9BFD

	; Last scrolled left
	CMP #$04	 	
	BGE PRG030_9C01	 ; If the horizontal scroll is 4-15, jump to PRG030_9C01
	JMP PRG030_9C06	 ; Otherwise, jump to PRG030_9C06

PRG030_9BFD:
	; Last scrolled right
	CMP #12	
	BGE PRG030_9C06	 ; If the horizontal scroll is 12-15, jump to PRG030_9C06

PRG030_9C01:	; (Scrolled left and scroll is 4-15) OR (Scrolled right and scroll is 0-11)

	; Scroll_UpdAttrFlag = 1 (time to update attributes!)
	LDA #$01
	STA Scroll_UpdAttrFlag

PRG030_9C06:
	LDA Level_Tileset 
	ASL A		 ; A = Level_Tileset << 1 (index into TileLayout_ByTileset)
	TAY		 ; -> 'Y'

	; A tile is laid out like:
	; 02
	; 13

	; Store the low byte of the address into Temp_Var11/Temp_Var13
	; This defines addresses used to look up the construction of a tile
	; by its index number; note that top and bottom half use a common
	; low byte.
	LDA TileLayout_ByTileset,Y
	STA <Temp_Var11		 
	STA <Temp_Var13		 

	; The following takes the high byte of the "TileLayout_ByTileset"
	; and either adds nothing or a jump of 512, and still adds a jump of
	; 256 to the after address 
	LDX TileLayout_ByTileset+1,Y	; X = High byte of address (block 0 of tile)
	LDA <Scroll_OddEven		; A = Scroll_OddEven
	BEQ PRG030_9C1B			; If Scroll_OddEven = 0, jump to PRG030_9C1B
	INX		 		; +256 (block 1)
	INX		 		; +256 (block 2) beginning of the right half

PRG030_9C1B:
	STX <Temp_Var12		; High byte [?] into Temp_Var12
	INX		 		; block 1 or 3, depending on Scroll_OddEven
	STX <Temp_Var14		; High byte [?] into Temp_Var14

	LDX <Scroll_LastDir		; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	 	; A = appropriate current column (right or left)
	AND #$f0	 	 	; Checking what screen we're on (every 16 columns is a screen's worth)
	LSR A		 
	LSR A		 
	LSR A		 
	TAY		 		; Y = ((Scroll_ColumnR & $F0) >> 3), or basically, 2 for every screen we've moved (for indexing...)

	; Set the address of the tiles we need to modify!
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var15	
	LDA Tile_Mem_Addr+1,Y
	STA <Temp_Var16	

	LDA #26	 		; Number of rows to update (NTSC res of 224, two screens tall, is 448 / 16px-per-tile = 26)
	STA <Temp_Var1		; Temp_Var1 = 26 (see immediately above)
	LDA <Scroll_ColumnR,X	; Get the column we're on
	AND #$0f	 	; Make it relative to THIS screen, 0-15
	STA <Temp_Var2		; Temp_Var2 stores this value

	LDX #$00	 	; X = 0
PRG030_9C40:
	LDY <Temp_Var2		; Y = Temp_Var2 (screen relative column)
	LDA [Temp_Var15],Y	; Get tile to display
	TAY		 	; Tile becomes offset 'Y'

	; Store the top block for this tile
	LDA [Temp_Var11],Y
	STA Scroll_PatStrip,X

	; Store the bottom block for this tile
	LDA [Temp_Var13],Y
	STA Scroll_PatStrip+1,X

	LDA <Temp_Var2
	ADD #16	
	STA <Temp_Var2	 	; Temp_Var2 += 16 (next row in this column is 16 bytes down)
	BCC PRG030_9C5A	 	; If we haven't overflowed, jump to PRG030_9C5A
	INC <Temp_Var16	; Otherwise we need to increment the upper part of the tile address
PRG030_9C5A:
	INX		 
	INX		 ; X += 2 (two tiles added)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG030_9C40	 ; If more tiles to go, loop!


	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDA <Scroll_ColumnR,X	; A = last column value
	AND #$0f	 	; Screen column relative
	ASL A		 	; A << 1 (0, 2, 4, ... E)
	ORA <Scroll_OddEven	; Apply the odd/even (forms an 8x8 current column)
	STA Scroll_LastCol8	; Store this in Scroll_LastCol8

	LDA #$20	 	; 
	STA Scroll_ToVRAMHi	; Scroll_ToVRAMHi = $20
	JMP SetPages_ByTileset	; JUMP to SetPages_ByTileset (restores page A000 most importantly, and will do the RTS)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrColumn
;
; This subroutine renders a "column" of attributes for the
; screen scrolling.  Also used by the "dirty update" routine
; to sweep across and render the blocks...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PRG030_9C74:
	.byte $F1, $01

PRG030_9C76:
	.byte $ff, $0f

Scroll_Do_AttrColumn:
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Y = get column
	TYA		 	; A = Y
	AND #$01	 	; Get odd/even
	BEQ PRG030_9C87	 	; If even, jump to PRG030_9C87

	TYA		 	; A = back to column again
	ADD PRG030_9C76,X	; Add appropriate value, whether going right or left (-1 or +15)
	TAY		 	; Y = A

PRG030_9C87:
	STY <Temp_Var1		; column, possibly offset, into Temp_Var1
	LDA #$00	 	
	STA <Temp_Var2		; Temp_Var2 = 0

PRG030_9C8D:
	LDA <Temp_Var1		; A = Temp_Var1 (column, possibly offset)
	AND #$f0	 	; Figure out which SCREEN we're on
	LSR A		 
	LSR A		 
	LSR A		 	; A >> 3 (2 byte per screen index)
	TAY		 	; Y = A

	; Setup pointer to tile memory we need to be focusing on!
	LDA Tile_Mem_Addr,Y	
	STA <Temp_Var15		
	LDA Tile_Mem_Addr+1,Y	
	STA <Temp_Var16	

	LDX <Temp_Var2	 	; X = Temp_Var2
	LDA <Temp_Var1	 	; A = Temp_Var1
	AND #$0f	 	; Current screen-relative column
	TAY		 	; Y = A (screen relative column)
PRG030_9CA6:
	LDA [Temp_Var15],Y	; Get next tile
	AND #$c0	 	; Set attributes based on the "range" of the tile, like palette 0 for tiles 00-3f, palette 1 for tiles 40-7f, etc.
	STA <Scroll_ColorStrip,X	; Store this into the attribute strip
	TYA		 	; A = Y (the tile offset)
	ADD #16		 	; A += 16 (every tile row is 16 bytes)
	TAY		 	; Y = A
	BCC PRG030_9CB5	 	; If we didn't overflow, jump to PRG030_9CB5
	INC <Temp_Var16	; Increment the high byte
PRG030_9CB5:
	INX			; X++ (next byte in the Scroll_ColorStrip)
	STX <Temp_Var2		; Temp_Var2 = X
	CPX #27	
	BNE PRG030_9CD0	 	; If X <> 27, jump to PRG030_9CD0

	; X is 27, we need to go to the next page
	LDX <Scroll_LastDir	; X = Scroll_LastDir
	LDY <Scroll_ColumnR,X	; Get the column
	TYA		 	; A = Y
	AND #$01	 	; 
	BNE PRG030_9CCB	 	; If odd, jump to PRG030_9CCB
	TYA			; A = Y (back to the column)
	ADD PRG030_9C74,X
	TAY		 	; -> 'Y'
PRG030_9CCB:
	STY <Temp_Var1		; -> Temp_Var1
	JMP PRG030_9C8D	 	; Loop around again...

PRG030_9CD0:
	CPX #54
	BNE PRG030_9CA6	 ; If A <> 54, loop!


	LDY #$00	 ; Y = 0
	LDX #$00	 ; X = 0 

PRG030_9CD8:
	; Attributes store colors for 4 tiles in one byte, this
	; forms the coloring information for all four blocks; this
	; also explains the odd-but-necessary offsets
	LDA <Scroll_ColorStrip,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+27,X
	LSR A		 
	LSR A		 ; A >>= 2 
	ORA <Scroll_ColorStrip+1,X
	LSR A		 
	LSR A		 ; A >>= 2
	ORA <Scroll_ColorStrip+28,X

	STA Scroll_AttrStrip,Y
	INX		 ; X++
	INX		 ; X++
	CPY #$07	 
	BNE PRG030_9CF8	 ; If Y <> 7, jump to PRG030_9CF8

	; Only store half the attribute data on row 7
	LDA Scroll_AttrStrip,Y	
	AND #$0f
	STA Scroll_AttrStrip,Y	
	DEX		 ; X--	; Redo other half later!

PRG030_9CF8:
	INY		 ; Y++
	CPY #14	 	 
	BNE PRG030_9CD8	 ; If Y <> 14, loop!

	LDA #$23	 
	STA Scroll_ToVRAMHA	; Scroll_ToVRAMHA = $23
	LDX <Scroll_LastDir	
	LDA <Scroll_ColumnR,X	; Get column
	AND #$0f	 	; Screen relative
	LSR A		 	; A >> 1 (every two blocks when dealing with attributes)
	ORA #$c0	 	; $C0 is the base offset into Attribute Table 0/2
	STA Scroll_LastAttr	; Store into Scroll_LastAttr

	; Scroll_UpdAttrFlag = 0
	LDA #$00	 
	STA Scroll_UpdAttrFlag

	RTS		 	; Return!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcPatternVRAMAddr
;
; Calculates Scroll_ToVRAMHi/Lo for patterns for the current vertical scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_CalcPatternVRAMAddr:
	LDX <Scroll_LastDir	; X = Scroll_LastDir

	; Calculate VRAM High into nametable for this offset
	LDA <Scroll_VOffsetT,X
	AND #$c0
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	ADD #$20
	STA Scroll_ToVRAMHi

	; Calculate VRAM Low into nametable for this offset
	LDA <Scroll_VOffsetT,X
	AND #$30
	ASL A
	ASL A
	STA Scroll_LastOff8

	LDA <Vert_Scroll
	AND #$08
	BEQ PRG030_9D3E	 ; If not on odd row, jump to PRG030_9D3E (RTS)

	; +32 bytes to offset to reach next tile row in VRAM
	LDA Scroll_LastOff8
	ADD #32
	STA Scroll_LastOff8

PRG030_9D3E:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_DoPatternAndAttrRow
;
; This subroutine renders a "row" of 8x8 blocks for the vertical
; screen scrolling.  Also creates the attributes for the same.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_DoPatternAndAttrRow:
	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$0f
	TAY		 ; Y = offset column

	; Get address of tile at this vertical position
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var9 = offset at leftmost column in current row
	LDA <Scroll_VOffsetT,X
	AND #$f0
	STA <Temp_Var9

	; Temp_Var10 = 0
	LDA #$00
	STA <Temp_Var10

PRG030_9D5A:
	LDY <Temp_Var9		 ; Y = current offset along row
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	STA <Temp_Var11		 ; -> Temp_Var11

	INC <Temp_Var9		 ; Temp_Var9++ (next column)

	JSR TileLayout_GetBaseAddr	 ; Get tile layout address -> Temp_Var13/14

	LDX <Temp_Var10		 ; X = Temp_Var10

	LDA <Vert_Scroll
	AND #$08
	BEQ PRG030_9D6F	 ; If not vertically halfway on the tile, jump to PRG030_9D6F

	INC <Temp_Var14		 ; Otherwise, Temp_Var14++ (next row of layout)

PRG030_9D6F:
	LDA [Temp_Var13],Y	 ; Get pattern of tile
	STA Scroll_PatStrip,X	 ; Store into pattern strip

	INX		 ; X++ (next pattern strip byte)

	; Temp_Var14 += 2 (next adjacent tile pattern)
	INC <Temp_Var14
	INC <Temp_Var14

	LDA [Temp_Var13],Y	 ; Get pattern of tile
	STA Scroll_PatStrip,X	 ; Store into pattern strip

	INX		 ; X++ (next pattern strip byte)

	STX <Temp_Var10		 ; X -> Temp_Var10

	CPX #$20
	BLT PRG030_9D5A	 ; If not at end of strip row, loop

	LDA Scroll_LastOff8
	CMP #$20
	BEQ PRG030_9D92	 ; If Scroll_LastOff8 = $20 (end of top row), jump to PRG030_9D92

	CMP #$a0
	BEQ PRG030_9D92	 ; If Scroll_LastOff8 = $A0 (end of bottom row), jump to PRG030_9D92

	BNE PRG030_9D98	 ; Otherwise, jump to PRG030_9D98 (RTS)

PRG030_9D92:
	JSR VScroll_CalcAttributeVRAMAddr	; Calculate the attribute VRAM addresses
	JSR Scroll_Do_AttrRow	 		; Do row of attributes

PRG030_9D98:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VScroll_CalcAttributeVRAMAddr
;
; Calculates Scroll_ToVRAMHA/Scroll_LastAttr for attributes for the current vertical scroll
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
VScroll_CalcAttributeVRAMAddr:

	; VRAM High address to attributes
	LDA #$23
	STA Scroll_ToVRAMHA

	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	; VRAM Low address to attributes
	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$c0
	LSR A
	LSR A
	ADD #$c0
	STA Scroll_LastAttr

	LDA <Scroll_VOffsetT,X
	AND #$20
	BEQ PRG030_9DBB	

	; Scroll_LastAttr += 8
	LDA Scroll_LastAttr
	ADD #$08
	STA Scroll_LastAttr

PRG030_9DBB:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scroll_Do_AttrRow
;
; This subroutine renders a "row" of attributes for the
; screen scrolling.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Scroll_Do_AttrRow:
	LDX <Scroll_LastDir	 ; X = Scroll_LastDir

	LDA <Scroll_VOffsetT,X	; Get proper offset based on direction of scroll
	AND #$0f
	TAY		 ; Y = offset column

	; Get address of tile at this vertical position
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var9 = offset at leftmost column in current row
	LDA <Scroll_VOffsetT,X
	AND #$f0
	STA <Temp_Var9

	AND #$10
	BNE PRG030_9DDE

	LDA <Temp_Var9
	ADD #$10
	STA <Temp_Var9 

PRG030_9DDE:
	INC <Temp_Var9		 ; Temp_Var9++ (next column)

	; Temp_Var8 = 0
	LDA #$00
	STA <Temp_Var8
PRG030_9DE4:
	LDY <Temp_Var9		 ; Y = current offset along row
	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Y -= 15 (previous row; 15 because VScroll_TileQuads2Attrs already subtracted 1)
	TYA
	SUB #$0f
	TAY

	JSR VScroll_TileQuads2Attrs	 ; Create attribute bits out of tile values

	; Temp_Var9 += 2 (next 2 columns over)
	INC <Temp_Var9
	INC <Temp_Var9

	; Temp_Var8++ (next Scroll_AttrStrip byte)
	INC <Temp_Var8

	LDA <Temp_Var8
	CMP #$08
	BLT PRG030_9DE4	 ; While not at end of row, loop

	LDA Scroll_LastAttr
	CMP #$f8
	BNE PRG030_9E11

	LDY #$07	 ; Y = 7
PRG030_9E06:

	LDA Scroll_AttrStrip,Y
	AND #$0f
	STA Scroll_AttrStrip,Y

	DEY		 ; Y--
	BPL PRG030_9E06	 ; While Y >= 0, loop

PRG030_9E11:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; TileLayout_GetBaseAddr
;
; Set layout pointer for the active tileset -> Temp_Var13/14
; also reloads 'Y' with the tile in Temp_Var11
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TileLayout_GetBaseAddr:
	LDA Level_Tileset 
	ASL A
	TAX		 ; X = Level_Tileset * 2

	; Set Temp_Var13/14 to point to the layout data for this Tileset
	LDA TileLayout_ByTileset,X
	STA <Temp_Var13
	LDA TileLayout_ByTileset+1,X
	STA <Temp_Var14

	LDY <Temp_Var11		 ; Y = tile temp

	RTS		 ; Return


VScroll_TileQuads2Attrs:
	LDX <Temp_Var8		 ; X = Temp_Var8 (Scroll_AttrStrip offset)

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	DEY		 ; Y--

	LDA [Map_Tile_AddrL],Y	 ; Get the tile

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits
	ASL A
	ROL Scroll_AttrStrip,X
	ASL A
	ROL Scroll_AttrStrip,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileV
;
; Gets tile in vertical level
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileV:	; $9E3C 

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	LDA <Temp_Var13	 ; A = Temp_Var13 (Y Hi)
	PHA		 ; Save it
	TAY		 ; Y = Y Hi

	LDA <Temp_Var14	 ; A = Temp_Var14 (Y Lo)
	PHA		 ; Save it

	JSR LevelJct_GetVScreenH

	STA <Temp_Var14	 ; Adjusted Y for vertical -> Temp_Var14

	; Select root offset into tile memory
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Combine positions into Temp_Var15 to form tile mem offset
	LDA <Temp_Var14
	AND #$f0
	STA <Temp_Var15

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var15

	TAY		 ; Offset -> 'Y'

	PLA		 ; Restore original value for Temp_Var14
	STA <Temp_Var14	 ; Store it

	PLA		 ; Restore original value for Temp_Var13
	STA <Temp_Var13	 ; Store it

	LDA [Map_Tile_AddrL],Y	 ; Get tile
	STA <Level_Tile	 ; Store into Level_Tile

	RTS		 ; Return


	; This is basically a lookup for any given "Player Y Hi" shifted up 4 bits
PRG030_9E6C:
	.byte $00, $10, $20, $30, $40, $50, $60, $70, $80, $90, $A0, $B0, $C0, $D0, $E0, $F0

	; Translates the Player position into appropriate "high" value
	; as Vertical describes it ($0(00), $0(F0), $1(E0), ...)
LevelJct_GetVScreenH:
	; Y = Player_YHi
	; A = Player_Y

	CPY #$00
	BLS PRG030_9E8E	 ; If Y < 0 (i.e. if the Player Y High is less than zero, which shouldn't happen!), jump to PRG030_9E8E (RTS)

	ADD PRG030_9E6C,Y	; Player_Y += Player_YHi[Y]
	BCS PRG030_9E8A	 	; If carry set (overflow occurred), jump to PRG030_9E8A

	CMP #$f0	
	BLT PRG030_9E8E	 	; If result is < $F0, jump to PRG030_9E8E

PRG030_9E8A:
	; Add $10 and roll over 'Y' (Considered in the lower vertical half)
	ADD #$10
	INY	

PRG030_9E8E:
	RTS		 ; Return


	; Something similar to LevelJct_GetVScreenH, but I'm 
	; not quite following the purpose
LevelJct_GetVScreenH2:
	; A = Player_Y
	; Y = Player_YHi
	CPY #$00
	BLS PRG030_9E9A	 ; If YHi < 0 (shouldn't happen?), jump to PRG030_9E9A

	SUB PRG030_9E6C,Y
	BCS PRG030_9E9A	 ; If carry set, jump to PRG030_9E9A

	DEY		 ; Y--

PRG030_9E9A:
	RTS		 ; Return


; FIXME: Anybody want to claim this??
; $9E9B
	.byte $F0, $20

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_GetTileAndSlope_Normal
;
; Get tile and slope for given position and offset
; for non-vertical ("normal") levels
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_GetTileAndSlope_Normal:	; $9E9D

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo

	; Clear slope array
	LDA #$00	
	STA <Player_Slopes
	STA <Player_Slopes+1	; Not used; see below with Temp_Var1 assignment
	STA <Player_Slopes+2	; Not used; see below with Temp_Var1 assignment

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Level_TileOff	 ; Level_TileOff = Temp_Var16 >> 4 (current column Player is in)

	LDA <Temp_Var15
	AND #$0f	
	ASL A		
	TAX		 ; X = (Temp_Var15 & $0F) << 1 (current "high" part of Player X shifted up by 1, indexing Tile Mem)

	; Set Map_Tile_AddrL/H to appropriate screen based on Player's position
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	LDA <Temp_Var13
	BEQ PRG030_9EC3	 ; If Temp_Var13 (Y Hi) = 0, jump to PRG030_9EC3

	INC <Map_Tile_AddrH ; Otherwise, go to second half of screen

PRG030_9EC3:
	LDA <Temp_Var14
	AND #$f0
	ORA <Level_TileOff	 ; Level_TileOff gets the Player's current row in the upper 4 bits

	; Level_TileOff is now Player's current offset in Tile Mem from the selected pointer

	STA <Temp_Var12		 ; ... and copied into Temp_Var12

	TAY		 	; Y = current offset
	LDA [Map_Tile_AddrL],Y	; Get tile here
	STA <Level_Tile	; Store into Level_Tile

	LDY Level_Tileset
	CPY #3
	BEQ PRG030_9EDB	 ; If Level_Tileset = 3 (Hills style), jump to PRG030_9EDB

	CPY #14
	BNE PRG030_9F0D	 ; If Level_Tileset <> 14 (Underground), jump to PRG030_9F0D

PRG030_9EDB:
	; NOTE: Temp_Var1 = 0 and is used directly; at one time there was probably some kind
	; of loop here that would have implicated Player_Slopes+1 and Player_Slopes+2
	LDA #$00
	STA <Temp_Var1		 ; Temp_Var1 = 0

	LDY <Temp_Var12		 ; Y = current offset in Tile Mem
	LDA [Map_Tile_AddrL],Y	 ; Get tile here
	STA <Temp_Var2		 ; Store into Temp_Var2

	AND #$c0
	CLC
	ROL A
	ROL A
	ROL A
	TAY		; Y = tile quadrant (0 to 3)

	LDA <Temp_Var2		 ; Re-get tile
	CMP Tile_AttrTable,Y
	BLT PRG030_9F0D	 	; If it's less than the tile specified in Tile_AttrTable[Y], jump to PRG030_9F0D

	TYA
	ASL A
	TAX		 ; X = Y (tile quadrant) << 1 (two byte index)

	; Temp_Var3/4 are loaded with address inside PRG000_C000
	LDA Level_SlopeSetByQuad,X
	STA <Temp_Var3
	LDA Level_SlopeSetByQuad+1,X
	STA <Temp_Var4

	LDX <Temp_Var1	 	; X = Temp_Var1 (always 0)
	LDA <Temp_Var2	 	; A = Temp_Var2 (the retrieved tile)
	SUB Tile_AttrTable,Y	; Subtract the root tile value
	TAY		 	; Y = result

	LDA [Temp_Var3],Y		; Get value 
	STA <Player_Slopes,X	; Store into Player_Slopes

PRG030_9F0D:
	LDA <Level_Tile	; A = Level_Tile (the tile retrieved)
	RTS		 ; Return

	; Probably unused space
	;.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	;.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	;.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff


PRG030_SUB_9F40:
	LDA #$00
	STA Raster_State 	; Reset Raster_State

	LDA Update_Request
	JMP PRG031_F499

	; Filler space
	.byte $ff, $ff, $ff, $ff, $ff

	; Sub part of A0 mode of IRQ
PRG030_SUB_9F50:
	; Some kind of delay loop?
	LDX #$17	 ; X = $17
PRG030_9F52:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG030_9F52 ; While X > 0, loop

	; Latch this value, and force it into the counter!
	STA MMC3_IRQLATCH
	STA MMC3_IRQDISABLE
	STA MMC3_IRQENABLE
	RTS		 ; Return

	; Probably unused space
	;.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
	;.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF

IntIRQ_32PixelPartition_Part5:

	; Some kind of delay loop?
	LDX #$13	 ; X = $13
PRG030_9F80:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG030_9F80 ; While X > 0, loop

	; More NOPs
	NOP
	NOP
	NOP

	STA MMC3_IRQLATCH ; Latch A (last set to 27!)
	STA MMC3_IRQENABLE ; Enable IRQ again
	JMP PRG031_FA3C	 ; Jump to PRG031_FA3C

	; Unused space
	;.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF

IntIRQ_32PixelPartition_Part2:	; $9FA0
	LDA Update_Request	 
	AND #UPDATERASTER_32PIXSHOWSPR
	BNE PRG030_9FAA	 ; If UPDATERASTER_32PIXSHOWSPR is set, go to PRG030_9FAA

	; Otherwise, change loaded pattern tables to hide sprites that fall beneath the 32 pixel partition
	JMP IntIRQ_32PixPart_HideSprites

PRG030_9FAA:

	; I think the following NOPs and loop are to help synchronize the IRQ
	; routine if it didn't perform the IntIRQ_32PixPart_HideSprites step
	NOP
	NOP
	NOP

	LDX #$03	 ; X = 3
PRG030_9FAF:
	NOP		 ; ?
	DEX		 ; X--
	BPL PRG030_9FAF	 ; While X > 0, loop

	JMP IntIRQ_32PixelPartition_Part3

; NOTE: The remaining ROM space was all blank ($FF)

