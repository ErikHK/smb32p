; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-28 13:51:54.652889989 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

; Some constants specific to title screen; they don't really match up with the gameplay
FALL_NORMAL		= 5	; Normal fall rate added to 'Y'
FALL_TAILWAG		= 1	; Adjusted fall rate for when wagging raccoon tail
FALL_OBJECT		= 4	; Fall rate for objects

FALLRATE_TAILWAGMAX	= 8	; Maximum Y velocity falling rate when wagging raccoon tail
FALLRATE_MAX		= $40	; Maximum Y velocity falling rate
FALLRATE_OBJECTMAX	= $60	; Maximum Y velocity falling rate of an object

Cinematic_ToadAndKing:
	LDA Cine_ToadKing
	LSR A
	BNE PRG024_A03A	 ; If Cine_ToadKing > 1, jump to PRG024_A03A

	LDX #$00	 ; X = 0

	JSR Level_PrepareNewObject

	; Disable timer and animations
	LDA #$81	 
	STA Level_TimerEn

	; CineKing_Timer = $20
	LDA #$20
	STA CineKing_Timer

	; Initialize VRAM address for Toad and King Cinematic Dialog Box
	LDA #$28
	STA ToadTalk_VH
	LDA #$86
	STA ToadTalk_VL

	; Initialize character counter
	LDA #$00
	STA ToadTalk_CPos

	LDA #168
	STA <Objects_X

	LDA #$60	 ; A = $60

	LDY World_Num	 ; Y = World_Num

	CPY #$01
	BNE PRG024_A033	 ; If World_Num <> 1 (World 2), jump to PRG024_A033

	LDA #$20	 ; A = $20

PRG024_A033:
	STA King_Y

	INC Cine_ToadKing ; Cine_ToadKing = 2
	RTS		 ; Return

PRG024_A03A:

	; Keep the Player halted
	LDA #$02
	STA Player_HaltTick

	LDA Player_HaltGame
	BNE PRG024_A04A	 ; If gameplay is halted, jump to PRG024_A04A

	JSR King_Animate  ; Do King's animation logic
	JSR King_DoDialog ; Do King's dialog

PRG024_A04A:
	JMP PRG024_A39D	 ; Jump to PRG024_A39D


King_DoDialog:
	; Load font patterns
	LDA #$5E
	STA PatTable_BankSel+1

	LDA <CineKing_DialogState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TAndK_DrawDiagBox		; 0: Draw the dialog box
	.word TAndK_DoToadText		; 1: Do the text
	.word TAndK_WaitPlayerButtonA	; 2: Wait for Player to push 'A'

	; Patterns that make up the rows of the dialog box
DiagBox_R1:	.byte $94, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $96
DiagBox_R2:	.byte $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $93
DiagBox_R3:	.byte $95, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $97

DiagBox_RowOffs:
	.byte (DiagBox_R1 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1)
	.byte (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R2 - DiagBox_R1), (DiagBox_R3 - DiagBox_R1)
DiagBox_RowOffs_End

TAndK_DrawDiagBox:
	LDA CineKing_Timer 
	BNE PRG024_A119	 ; If CineKing_Timer has not expired, jump to PRG024_A119 (RTS)

	LDA King_Y
	CMP #90
	BLT PRG024_A119	 ; If King is higher than pixel line 90, jump to PRG024_A119 (RTS)

	LDX Graphics_BufCnt	 ; X = buffer count

	; Set current VRAM address 
	LDA ToadTalk_VH
	STA Graphics_Buffer,X
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,X

	; Jump to next video row
	ADD #$20	; 32 bytes to next row
	STA ToadTalk_VL
	BCC PRG024_A0CD
	INC ToadTalk_VH	 ; Apply carry
PRG024_A0CD:

	LDA #(DiagBox_R2 - DiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY ToadTalk_CPos	 ; Y = current dialog box row
	LDA DiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG024_A0DB:
	; Store next pattern in dialog box
	LDA DiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG024_A0DB	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	INC ToadTalk_CPos	 ; Next row

	LDA ToadTalk_CPos
	CMP #(DiagBox_RowOffs_End - DiagBox_RowOffs)
	BLT PRG024_A119	 ; If row count < 8, jump to PRG024_A119

	; Dialog box is complete

	LDA #$00	 ; A = 0 ("The King has been transformed!")

	LDY Map_Objects_IDs
	BNE PRG024_A105	 ; If the "HELP!" bubble is still present (haven't been on airship yet), jump to PRG024_A105

	LDA #(KingHelpMsg2 - KingHelpMsg1)	 ; ("Get the magic wand back from little koopa!")

PRG024_A105:
	STA ToadTalk_CPos	 ; Set proper character position

	; Initialize VRAM address for Toad and King Cinematic Dialog Box Text
	LDA #$28
	STA ToadTalk_VH
	LDA #$a7
	STA ToadTalk_VL

	; CineKing_Timer = $10
	LDA #$10
	STA CineKing_Timer

	INC <CineKing_DialogState	; CineKing_DialogState = 1

PRG024_A119:
	RTS		 ; Return

	; English: "Oh,it's terrible!" / "The King has been" / "transformed!" / "Please find the" / "Magic Wand so we can" / "change him back"
KingHelpMsg1:
	;       O    h    ,    i    t    '    s         t    e    r    r    i    b    l    e    !
	.byte $BE, $D7, $9A, $D8, $CD, $AB, $CC, $FE, $CD, $D4, $CB, $CB, $D8, $D1, $DB, $D4, $EA, $FE, $FE, $FE

	;       T    h    e         K    i    n    g         h    a    s         b    e    e    n
	.byte $C3, $D7, $D4, $FE, $BA, $D8, $DD, $D6, $FE, $D7, $D0, $CC, $FE, $D1, $D4, $D4, $DD, $FE, $FE, $FE

	;       t    r    a    n    s    f    o    r    m    e    d    !
	.byte $CD, $CB, $D0, $DD, $CC, $D5, $DE, $CB, $DC, $D4, $D3, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       P    l    e    a    s    e         f    i    n    d         t    h    e
	.byte $BF, $DB, $D4, $D0, $CC, $D4, $FE, $D5, $D8, $DD, $D3, $FE, $CD, $D7, $D4, $FE, $FE, $FE, $FE, $FE

	;       M    a    g    i    c         W    a    n    d         s    o         w    e         c    a    n
	.byte $BC, $D0, $D6, $D8, $D2, $FE, $C6, $D0, $DD, $D3, $FE, $CC, $DE, $FE, $81, $D4, $FE, $D2, $D0, $DD

	;       c    h    a    n    g    e         h    i    m         b    a    c    k    .
	.byte $D2, $D7, $D0, $DD, $D6, $D4, $FE, $D7, $D8, $DC, $FE, $D1, $D0, $D2, $DA, $E9, $FE, $FE, $FE, $FE

	; English: "Hurry! Hurry!" / "Get the Magic Wand" / "back from Little" / "Koopa."
KingHelpMsg2:
	;       H    u    r    r    y    !         H    u    r    r    y    !
	.byte $B7, $CE, $CB, $CB, $8C, $EA, $FE, $B7, $CE, $CB, $CB, $8C, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;       G    e    t         t    h    e         M    a    g    i    c         W    a    n    d
	.byte $B6, $D4, $CD, $FE, $CD, $D7, $D4, $FE, $BC, $D0, $D6, $D8, $D2, $FE, $C6, $D0, $DD, $D3, $FE, $FE

	;       b    a    c    k         f    r    o    m         L    i    t    t    l    e
	.byte $D1, $D0, $D2, $DA, $FE, $D5, $CB, $DE, $DC, $FE, $BB, $D8, $CD, $CD, $DB, $D4, $FE, $FE, $FE, $FE

	;       K    o    o    p    a    .
	.byte $BA, $DE, $DE, $DF, $D0, $E9, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

TAndK_DoToadText:
	LDA CineKing_Timer
	BNE PRG024_A260	 ; If the timer is not expired, jump to PRG024_A260

	LDY ToadTalk_CPos	 ; Y = dialog message character position

	LDA KingHelpMsg1,Y	 ; Get next character of message

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	STA Graphics_Buffer+3,Y	 ; Store into buffer

	; Insert one character into graphics buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,Y	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,Y	; run length
	LSR A
	STA Graphics_Buffer+4,Y	; terminator
	TYA
	ADD #$04
	STA Graphics_BufCnt	; count
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,Y	; address low

	INC ToadTalk_CPos	 ; Next character in message
	INC ToadTalk_VL	 ; Next VRAM byte
	AND #$1f	 	; Get current column
	CMP #$1a	 
	BNE PRG024_A25B	 	; If we're not in column 26, jump to PRG024_A25B

	; Line break!

	LDA ToadTalk_VL
	ADC #$0b		; Add enough bytes to get to next row
	STA ToadTalk_VL
	BCC PRG024_A250
	INC ToadTalk_VH	; Apply carry
PRG024_A250:

	CMP #$67	
	BNE PRG024_A25B	 ; If we haven't reached the last character, jump to PRG024_A25B

	INC <CineKing_DialogState		 ; CineKing_DialogState = 2

	LDA #$00
	STA ToadTalk_CPos

PRG024_A25B:
	; Reset tick counter for next character
	LDA #$04
	STA CineKing_Timer

PRG024_A260:
	RTS		 ; Return


TAndK_WaitPlayerButtonA:
	LDA <Pad_Input
	BPL PRG024_A282	 ; If Player is not pushing 'A', jump to PRG024_A282 (RTS)

	LDA Map_Objects_IDs
	BEQ PRG024_A27A	 ; If the "HELP!" bubble is gone, jump to PRG024_A27A

	; Level_JctCtl = 3 (switch to airship)
	LDA #$03
	STA Level_JctCtl

	; No more "HELP!" bubble...
	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs

	; Airship is in town now!
	LDA #MAPOBJ_AIRSHIP
	STA Map_Objects_IDs+1

	RTS		 ; Return


PRG024_A27A:
	; Standard exit to map
	LDA #$00
	STA Map_ReturnStatus
	INC Level_ExitToMap

PRG024_A282:
	RTS		 ; Return

	; Sets PatTable_BankSel+5 by world 1-7
King_PatTableByWorld:
	.byte $27, $27, $27, $26, $26, $26, $27

	; Sets King's sprite palette select by world 1-7
King_PalByWorld:
	.byte SPR_PAL2, SPR_PAL2, SPR_PAL3, SPR_PAL2, SPR_PAL2, SPR_PAL2, SPR_PAL2

	; Number of King's patterns (sprites) by world 1-7
King_NumPatsByWorld:
	.byte (King_W1Pat0 - King_W1Pat1), (King_W2Pat1 - King_W2Pat0), (King_W3Pat0 - King_W3Pat1), (King_W4Pat0 - King_W4Pat1)
	.byte (King_W5Pat1 - King_W5Pat0), (King_W6Pat1 - King_W6Pat0), (King_W7Pat0 - King_W7Pat1)

	; King sprite data offset by world and frame (Left = 0, Right = 1)
King_SprDataOffByWorldAndFrame:
	.byte (King_W1YOff - King_SprDataYOff), (King_W1YOff - King_SprDataYOff)	; World 1
	.byte (King_W2YOff - King_SprDataYOff), (King_W2YOff - King_SprDataYOff)	; World 2
	.byte (King_W3YOff0 - King_SprDataYOff), (King_W3YOff1 - King_SprDataYOff)	; World 3
	.byte (King_W4YOff - King_SprDataYOff), (King_W4YOff - King_SprDataYOff)	; World 4
	.byte (King_W5YOff - King_SprDataYOff), (King_W5YOff - King_SprDataYOff)	; World 5
	.byte (King_W6YOff - King_SprDataYOff), (King_W6YOff - King_SprDataYOff)	; World 6
	.byte (King_W7YOff0 - King_SprDataYOff), (King_W7YOff1 - King_SprDataYOff)	; World 7

	; Y offset (from King_Y) per King sprite (must be parallel with King_SprDataX)
King_SprDataYOff:
King_W1YOff:	.byte $09, $10, $10, $10, $20, $20, $20
King_W7YOff1:	.byte $02, $10, $10, $20, $20
King_W7YOff0:	.byte $03, $10, $10, $20, $20
King_W6YOff:	.byte $00, $16, $16
King_W5YOff:	.byte $EA, $F0, $F0, $F0, $00, $00, $00
King_W4YOff:	.byte $0B, $10, $10, $10, $20, $20, $20
King_W2YOff:	.byte $00, $00, $00
King_W3YOff1:	.byte $0D, $10, $10, $20, $20, $20
King_W3YOff0:	.byte $0E, $10, $10, $20, $20, $20

	; X per King sprite (must be parallel with King_SprDataYOff)
King_SprDataX:
King_W1X:	.byte $D7, $CC, $D4, $DC, $CC, $D4, $DC
King_W7X1:	.byte $CC, $C8, $D0, $C8, $D0
King_W7X2:	.byte $CC, $C8, $D0, $C8, $D0
King_W6X:	.byte $C8, $C8, $D0
King_W5X:	.byte $D4, $D0, $D8, $E0, $D0, $D8, $E0
King_W4X:	.byte $D2, $D0, $D8, $E0, $D0, $D8, $E0
King_W2X:	.byte $CC, $C8, $D0
King_W3X1:	.byte $D3, $D0, $D8, $D0, $D8, $E0
King_W3X0:	.byte $D1, $D0, $D8, $D0, $D8, $E0

King_SprPatOffByWorldAndFrame:
	.byte (King_W1Pat0 - King_SprPats), (King_W1Pat1 - King_SprPats)	; World 1
	.byte (King_W2Pat0 - King_SprPats), (King_W2Pat1 - King_SprPats)	; World 2
	.byte (King_W3Pat0 - King_SprPats), (King_W3Pat1 - King_SprPats)	; World 3
	.byte (King_W4Pat0 - King_SprPats), (King_W4Pat1 - King_SprPats)	; World 4
	.byte (King_W5Pat0 - King_SprPats), (King_W5Pat1 - King_SprPats)	; World 5
	.byte (King_W6Pat0 - King_SprPats), (King_W6Pat1 - King_SprPats)	; World 6
	.byte (King_W7Pat0 - King_SprPats), (King_W7Pat1 - King_SprPats)	; World 7

King_SprPats:
King_W1Pat1:	.byte $E1, $E3, $E5, $E7, $E9, $EB
King_W1Pat0:	.byte $E1, $ED, $E5, $E7, $EF, $EB
King_W7Pat1:	.byte $F1, $F3, $F5, $F7
King_W7Pat0:	.byte $F9, $D5, $FD, $FF
King_W6Pat0:	.byte $C1, $C3
King_W6Pat1:	.byte $C5, $C7
King_W5Pat0:	.byte $DB, $DD, $DF, $E1, $E3, $E5
King_W5Pat1:	.byte $DB, $E7, $E9, $E1, $EB, $ED
King_W4Pat1:	.byte $D5, $CB, $CD, $D7, $D9, $D3
King_W4Pat0:	.byte $C9, $CB, $CD, $CF, $D1, $D3
King_W2Pat0:	.byte $D9, $DB
King_W2Pat1:	.byte $DD, $DF
King_W3Pat1:	.byte $CB, $CD, $CF, $D1, $D3
King_W3Pat0:	.byte $C1, $C3, $C5, $C7, $C9

	; World 6 King is a seal juggling a crown (indexed by CineKing_Frame2)
King_W6Crown_YOff:	.byte $06, $04, $0A, $09, $09, $02, $04, $06
King_W6Crown_Pattern:	.byte -5, -3, -3, -5, -3, -3, -5, -5
King_W6Crown_Attr:	
	.byte SPR_PAL3, SPR_PAL3, SPR_PAL3 | SPR_VFLIP, SPR_PAL3 | SPR_VFLIP, SPR_PAL3 | SPR_HFLIP | SPR_VFLIP
	.byte SPR_PAL3 | SPR_HFLIP, SPR_PAL3, SPR_PAL3

PRG024_A36C:
	.byte $30, $40, $50, $60

	; Sprites that make up the yelling Toad
KingToad_Sprites:
	.byte $80, $00, $01, $B8
	.byte $80, $00, $01, $B0
	.byte $80, $00, $01, $A8
	.byte $70, $00, $01, $B8
	.byte $70, $00, $01, $B0
	.byte $70, $00, $01, $A8
KingToad_Sprites_End

KingToad_Patterns:
ToadFrame0:	.byte $A1, $A3, $A5, $A7, $A9, $AB
ToadFrame1:	.byte $B9, $BB, $71, $BD, $BF, $71
ToadFrame2:	.byte $AD, $AF, $B1, $B3, $B5, $B7

KingToad_PatOffset:
	.byte (ToadFrame0 - KingToad_Patterns), (ToadFrame1 - KingToad_Patterns), (ToadFrame2 - KingToad_Patterns)

PRG024_A39D:
	; Load yelling Toad's graphics
	LDA #$2a
	STA PatTable_BankSel+4

	; Copy in the sprites for yelling Toad
	LDY #(KingToad_Sprites_End - KingToad_Sprites - 1)
PRG024_A3A4:
	LDA KingToad_Sprites,Y
	STA Sprite_RAM+$40,Y

	DEY		 ; Y--
	BPL PRG024_A3A4	 ; While Y >= 0, loop

	LDY Objects_Frame	; Y = yelling Toad's frame
	LDX KingToad_PatOffset,Y ; X = base offset into patterns for this frame

	; Patch the patterns on the yelling Toad for the current frame
	LDY #((KingToad_Sprites_End - KingToad_Sprites - 1) & ~3)
PRG024_A3B5:
	LDA KingToad_Patterns,X
	STA Sprite_RAM+$41,Y

	INX		 ; X++ (index to next patch pattern)

	; Y -= 4 (previous sprite)
	DEY
	DEY
	DEY
	DEY

	BPL PRG024_A3B5	; While Y >= 0, loop

	LDY World_Num	 ; Y = World_Num

	; Set King's pattern table
	LDA King_PatTableByWorld,Y
	STA PatTable_BankSel+5	

	; King's Y -> Temp_Var1
	LDA King_Y
	STA <Temp_Var1

	; King's palette select -> Temp_Var2
	LDA King_PalByWorld,Y
	STA <Temp_Var2

	; King's number of patterns (sprites) -> Temp_Var4 and 5
	LDA King_NumPatsByWorld,Y
	STA <Temp_Var4
	STA <Temp_Var5

	TYA		; A = Y (World_Num)
	ASL A		; A = World_Num * 2
	ORA CineKing_Frame	; OR'd King's frame (0 or 1)
	PHA		; Save value
	TAY		; -> 'Y'

	LDX King_SprDataOffByWorldAndFrame,Y	; X = root index of King Sprite data
	LDY #$60	; Y = $60
PRG024_A3E8:
	; Set King Sprite Y
	LDA <Temp_Var1
	ADD King_SprDataYOff,X
	STA Sprite_RAM,Y

	; Set King Sprite Attributes
	LDA <Temp_Var2
	STA Sprite_RAM+$02,Y

	; Set King Sprite X
	LDA King_SprDataX,X
	STA Sprite_RAM+$03,Y

	INX		 ; X++ (next King sprite data)

	; Y += 4 (Next King sprite)
	INY
	INY
	INY
	INY

	DEC <Temp_Var4	 ; Temp_Var4--
	BPL PRG024_A3E8	 ; While Temp_Var4 >= 0, loop

	PLA		 ; Restore A = (World_Num * 2) | CineKing_Frame
	TAY		 ; -> 'Y'

	; Copy in all the King sprite patterns
	LDX King_SprPatOffByWorldAndFrame,Y	; X = root index of King Sprite patterns
	LDY #$64	 ; Y = $64
PRG024_A40C:
	LDA King_SprPats,X
	STA Sprite_RAM+$01,Y

	INX		 ; X++ (next King Sprite pattern index)

	; Y += 4 (next King Sprite)
	INY
	INY
	INY
	INY

	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG024_A40C	 ; While Temp_Var5 <> 0, loop

	LDY World_Num
	CPY #$05
	BEQ PRG024_A48A	 ; If World_Num = 5 (World 6), jump to PRG024_A48A

	; Not World 6...

	; Just put a stationary crown there
	LDA #$fb
	STA Sprite_RAM+$61
	LDA #$02
	STA Sprite_RAM+$62

	CPY #$06
	BNE PRG024_A439	 ; If World_Num <> 6 (World 7), jump to PRG024_A439

	; World 7 only...

	; Set piranha's body palette to 3
	LDA #SPR_PAL3
	STA Sprite_RAM+$6E
	STA Sprite_RAM+$72

	RTS		 ; Return

PRG024_A439:
	CPY #$01
	BNE PRG024_A4A1	 ; If World_Num <> 1 (World 2), jump to PRG024_A4A1 (RTS)

	; World 2 only...

	; Crown on the floor 
	LDA #$80
	STA Sprite_RAM+$60

	; Temp_Var4 = CineKing_DialogState
	LDA <CineKing_DialogState
	STA <Temp_Var4

	; Temp_Var3 = $10
	LDA #$10
	STA <Temp_Var3

	LDY #$80	 ; Y = $80
PRG024_A44C:
	LDA <Temp_Var4
	BEQ PRG024_A466	 ; If Temp_Var4 (CineKing_DialogState) = 0, jump to PRG024_A466

	LDX #$03	 ; X = 3

	CMP #$00
	BNE PRG024_A45B	 ; Jump (technically always) to PRG024_A45B

	LDA ToadTalk_CPos
	LSR A
	TAX		 ; X = ToadTalk_CPos / 2

PRG024_A45B:
	LDA <Temp_Var3
	CMP #$20
	BLT PRG024_A466	 ; If Temp_Var3 < $20, jump to PRG024_A466

	CMP PRG024_A36C,X
	BLT PRG024_A47E	 ; If Temp_Var3 < PRG024_A36C[X], jump to PRG024_A47E

PRG024_A466:

	; Set web sprite Y
	LDA <Temp_Var3
	STA Sprite_RAM,Y

	; Set web sprite pattern
	LDA #$d7
	STA Sprite_RAM+$01,Y

	; Set web sprite attribute
	LDA <Temp_Var2
	STA Sprite_RAM+$02,Y

	; Set web sprite X
	LDA #$d0
	STA Sprite_RAM+$03,Y

	; Y += 4 (next sprite)
	INY
	INY
	INY
	INY

PRG024_A47E:

	; Temp_Var3 += $10
	LDA <Temp_Var3
	ADD #$10
	STA <Temp_Var3

	CMP <Temp_Var1	
	BLT PRG024_A44C	 ; While Temp_Var3 < Temp_Var1, loop!

	RTS		 ; Return

PRG024_A48A:
	LDY <CineKing_Frame2

	; Set crown sprite Y
	LDA <Temp_Var1	; King Sprite Y
	ADD King_W6Crown_YOff,Y
	STA Sprite_RAM+$60

	; Set crown sprite pattern
	LDA King_W6Crown_Pattern,Y
	STA Sprite_RAM+$61

	; Set crown sprite attributes
	LDA King_W6Crown_Attr,Y
	STA Sprite_RAM+$62

PRG024_A4A1:
	RTS		 ; Return

	; Performs animation logic for the king
King_Animate:
	LDA <Counter_1
	AND #$07
	BNE PRG024_A4B2	 ; 6:7 ticks, jump to PRG024_A4B2

	; Loop the panicking Toad's frame 2 to 0
	DEC Objects_Frame
	BPL PRG024_A4B2
	LDA #$02
	STA Objects_Frame

PRG024_A4B2:
	LDA World_Num
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word King_W1347	; World 1 King (Dog scratching ear)
	.word King_W2		; World 2 King (Spider with crown on floor)
	.word King_W1347	; World 3 King (Hunched green creature)
	.word King_W1347	; World 4 King (Dinosaur)
	.word King_W5		; World 5 King (Albatross)
	.word King_W6		; World 6 King (Seal juggling crown)
	.word King_W1347	; World 7 King (Fire Piranha)

W6Seal_Frames:	.byte $01, $01, $01, $00, $00, $00, $00, $01
W6Crown_Frames:	.byte $00, $01, $02, $03, $04, $05, $00, $01

King_W6:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7 by counter

	; Set seal's frame
	LDA W6Seal_Frames,Y
	STA CineKing_Frame

	; Set seal juggled crown frame
	LDA W6Crown_Frames,Y
	STA <CineKing_Frame2

	RTS		 ; Return

King_YDelta:	.byte $01, -$01, $01
King_W2_YLimit:	.byte $70, $68

King_W2:
	JSR King_W1347	 ; Do animation like other kings

	LDA King_Y
	CMP #$68
	BGE PRG024_A4FD	 ; If King_Y >= $68, jump to PRG024_A4FD 

	INC King_Y 	 ; King_Y++

	RTS		 ; Return

PRG024_A4FD:
	LDA <Counter_1
	AND #$03	
	BNE PRG024_A519	 ; 3:4 ticks, jump to PRG024_A519

	LDY <CineKing_Var	 ; Y = CineKing_Var (0/1 as spider walks up and down)

	; King spider moves up or down
	LDA King_Y
	ADD King_YDelta,Y
	STA King_Y

	CMP King_W2_YLimit,Y
	BNE PRG024_A519	 ; If King has not hit Y limit in this direction, jump to PRG024_A519

	; Reverse direction
	TYA
	EOR #$01
	STA <CineKing_Var

PRG024_A519:
	RTS		 ; Return

PRG024_A51A:
	.byte %00100100	; World 1
	.byte %00001000	; World 2
	.byte %00101000	; World 3
	.byte %00101000	; World 4
	.byte %00010000	; World 5
	.byte %00000000	; World 6
	.byte %00010000	; World 7
	
King_W1347:
	LDY World_Num	; Y = World_Num

	LDA <Counter_1
	AND PRG024_A51A,Y ; Mask counter by value from PRG024_A51A
	BEQ PRG024_A52D	 ; If this is the tick to fire on, jump to PRG024_A52D

	LDA #$01	 ; A = 1 (frame)

PRG024_A52D:
	STA CineKing_Frame	 ; Set king frame

	RTS		 ; Return

King_W5:
	JSR King_W1347	 ; Do animation like other kings

	TAY		 ; Y = King frame

	LDA <Counter_1
	AND #$03	
	BNE PRG024_A545	 ; 3:4 ticks, jump to PRG024_A545

	LDA King_Y
	ADD King_YDelta+1,Y
	STA King_Y

PRG024_A545:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;; BEGIN UNUSED COPY/PASTED CODE ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The following are copied fragments from PRG022 ... THEY DO NOT BELONG HERE
; They also are in the wrong address space (PRG024 is $Axxx, PRG022 is $Cxxx)
; My guess... massive copy/paste error? :D

; $A546
	STA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A548:		; <-- originally PRG022_C548		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA Background_Tiles,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next tile, DANGEROUS)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEC <Temp_Var11	; Temp_Var11-- (repeat)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A548	 ; While Temp_Var11 >= 0, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INC <Temp_Var12	 ; Temp_Var12++		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	JMP PRG022_C51E	 ; Jump to PRG022_C51E (is what this should be)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


; Player_BonusTiles_Big:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_BRICKBG, 		TILE15_PLAYERBIG_TOPM,	TILE15_PLAYERBIG_TOPR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_PLAYERBIG_HEADL,	TILE15_PLAYERBIG_HEADM,	TILE15_PLAYERBIG_HEADR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_PLAYERBIG_TORL,	TILE15_PLAYERBIG_TORM,	TILE15_PLAYERBIG_TORR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_PLAYERBIG_BOTL,	TILE15_PLAYERBIG_BOTM,	TILE15_PLAYERBIG_BOTR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; Player_BonusTiles_Raccoon:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_BRICKBG, 		TILE15_PLAYERRAC_TOPM,	TILE15_PLAYERRAC_TOPR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_PLAYERBIG_HEADL,	TILE15_PLAYERBIG_HEADM,	TILE15_PLAYERBIG_HEADR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_PLAYERBIG_TORL,	TILE15_PLAYERBIG_TORM,	TILE15_PLAYERBIG_TORR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_PLAYERBIG_RACL,	TILE15_PLAYERBIG_RACM,	TILE15_PLAYERBIG_BOTR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; Player_BonusTiles_Small:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_BRICKBG,	TILE15_BRICKBG,		TILE15_BRICKBG		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_BRICKBG,	TILE15_BRICKBG,		TILE15_BRICKBG		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_BRICKBG,	TILE15_PLAYERSM_TOP,	TILE15_BRICKBG		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_BRICKBG,	TILE15_PLAYERSM_BOTTOM,	TILE15_BRICKBG		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; PlayerSuit_ToIndex:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte PLAYERSUIT_BIG		; 0 (Default when all else fails)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte PLAYERSUIT_RACCOON	; 1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte PLAYERSUIT_SMALL		; 2		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; PlayerSuit_TileBaseIndex:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte (Player_BonusTiles_Big - Player_BonusTiles_Big)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte (Player_BonusTiles_Raccoon - Player_BonusTiles_Big)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte (Player_BonusTiles_Small - Player_BonusTiles_Big)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; LoadLevel_BonusPlayer:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; This loop tries to match the Player's power up with an index		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	; If nothing else, X = 0, which uses "Big"		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDX #(PlayerSuit_ToIndex_End - PlayerSuit_ToIndex - 1)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDY Player_Current	; Y = Player_Current		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA World_Map_Power,Y	; Get current Player's power		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A589:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	CMP PlayerSuit_ToIndex,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BEQ PRG024_A591	 ; If this is the Player's current power up, jump to PRG024_A591		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEX		 ; X--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A589	 ; While X > 0, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A591:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Get starting tile for Player		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA PlayerSuit_TileBaseIndex,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAX		 ; -> 'X'		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var3 = 0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$00		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var3		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDY TileAddr_Off	; Y = TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A59C:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	; Temp_Var1 = 2		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$02		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A5A0:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	; Get tile for Player -> grid		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA Player_BonusTiles_Big,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next grid tile, DANGEROUS!)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INX		 ; X++ (next Player tile)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INC <Temp_Var3	 ; Temp_Var3++		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var1	 ; Temp_Var1--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	BPL PRG024_A5A0	 ; While Temp_Var1 >= 0, loop		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Go to next row of tiles		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADD #16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		 ; -> 'Y'		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA <Temp_Var3		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	CMP #(Player_BonusTiles_Raccoon - Player_BonusTiles_Big)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A59C	 ; If we have more tiles to go, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; BonusUNKTALL_Tiles:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_UNKTALL_UL,	TILE15_UNKTALL_UR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_UNKTALL_R1L,	TILE15_UNKTALL_R1R		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_UNKTALL_R2L,	TILE15_UNKTALL_R2R 		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte TILE15_UNKTALL_LL,	TILE15_UNKTALL_LR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; LoadLevel_UNKTALL:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDX #$00		; X = 0 		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDY TileAddr_Off	; Y = TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A5CB:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	; Temp_Var1 = 1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$01		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A5CF:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA BonusUNKTALL_Tiles,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y			; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next grid tile, DANGEROUS!)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INX		 ; X++		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEC <Temp_Var1	 ; Temp_Var1--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A5CF	 ; While Temp_Var1 >= 0, loop		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Next tile row		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADD #16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		 ; -> 'Y'		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	CPX #(BonusUNKTALL_Tiles_End - BonusUNKTALL_Tiles)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A5CB	 ; While X < number of tiles, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


; LoadLevel_Border:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDY TileAddr_Off	; Y = TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Border upper left		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #TILE15_BORDER_UL		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Run of 14 middle tiles		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A5F0:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INY		 ; Y++		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA #TILE15_BORDER_UM		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	CPY #$0f		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A5F0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Border upper right		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #TILE15_BORDER_UR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A5FD:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INY		 ; Y++		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TYA		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	AND #$0f		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A607	 ; If not time to place left border, jump to PRG024_A607		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA #TILE15_BORDER_ML		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A60D	 ; Jump (technically always) to PRG024_A60D		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A607:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	CMP #$0f		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A5FD	 ; If not time to place right border, jump to PRG024_A5FD		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA #TILE15_BORDER_MR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A60D:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y	 ; Store appropriate middle border		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	CPY #$9f		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A5FD	 ; If Y <> $9F, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Lower left border		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #TILE15_BORDER_LL		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Run of 14 middle tiles		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A618:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INY		 ; Y++		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA #TILE15_BORDER_LM		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	CPY #$af		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A618		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Lower right border		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #TILE15_BORDER_LR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; QBoxOrange_Tiles:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $C9, $CA, $CB, $CC		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; LoadLevel_QBoxOrange:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDX #$00	 ; X = 0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDY TileAddr_Off ; Y = TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A62F:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var1 = 1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$01		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A633:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Add prize box tile		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA QBoxOrange_Tiles,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next tile, DANGEROUS)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INX		 ; X++ (next prize box tile)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEC <Temp_Var1	; Temp_Var1--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A633 ; While Temp_Var1 >= 0, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Next row		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADD #16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		 ; -> 'Y'		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	CPX #(QBoxOrange_Tiles_End - QBoxOrange_Tiles)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A62F	; While tiles to go, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; QBoxBlue_Tiles:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $87, $88, $89, $8A		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


; LoadLevel_QBoxBlue:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDX #$00	 ; X = 0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDY TileAddr_Off ; Y = TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A656:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var1 = 1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$01		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A65A:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Add prize box tile		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA QBoxBlue_Tiles,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [BonusText_BaseL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next tile, DANGEROUS)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INX		 ; X++ (next prize box tile)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEC <Temp_Var1	; Temp_Var1--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A65A ; While Temp_Var1 >= 0, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Next row		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADD #16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		 ; -> 'Y'		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	CPX #(QBoxBlue_Tiles_End - QBoxBlue_Tiles)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A656	; While tiles to go, loop!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


;LoadLevel_BonusFloor:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var1 = 1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$01		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var1		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDY TileAddr_Off	 ; Y = TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A67B:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA LL_ShapeDef		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	AND #$0f		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAX		 ; X = lower 4 bits of LL_ShapeDef		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A681:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #TILE15_BRICKFLOOR		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA [Map_Tile_AddrL],Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++  (NOT SAFE!)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEX		 ; X--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A681	 ; While X >= 0, loop		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Next row		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADD #16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		 ; -> 'Y'		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEC <Temp_Var1	 ; Temp_Var1--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A67B	 ; While Temp_Var1 >= 0, loop		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; FIXME: Anyone want to claim this?		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
; $C698		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Y += 16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TYA		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADD #16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA <BonusText_BaseH		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADC #$00		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <BonusText_BaseH		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; FIXME: Anyone want to claim this?		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
; $C6A4		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA <Temp_Var6		 		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <BonusText_BaseH		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDY TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INY		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TYA		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	AND #$0f		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BNE PRG024_A6E2		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDY #$00		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA <Temp_Var15		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	AND #$10		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BEQ PRG024_A6BA		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY			; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A6BA:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STY <Temp_Var10		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA <BonusText_BaseL		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADD #$b0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <BonusText_BaseL		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA <BonusText_BaseH		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	ADC <Temp_Var10			; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <BonusText_BaseH		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var6		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA <Temp_Var16		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	AND #$f0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	INY		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA Tile_Mem_Addr+1,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var5		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INC <Temp_Var5		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	AND #$f0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	TAY		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

PRG024_A6E2:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STY TileAddr_Off		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


; BonusGame_HostDraw:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA Bonus_GameHost		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	JSR DynJump		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.word HostToad_Draw			; 0: Standard Toad Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.word HostTroopa_DrawWithGameBits	; 1: (Unused, glitched) Koopa Troopa Host w/ (unused, glitched) large [?] and card		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.word HostTroopa_Draw			; 2: (Unused, glitched) Koopa Troopa Host w/o the other thing		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.word HostHammerBro_Draw		; 3: (Unused, glitched) Hammer Bro Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostToad_Draw:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	JSR HostToad_DrawSprites		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostTroopa_DrawWithGameBits:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	JSR HostTroopa_DrawSprites		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDA #$3f	; <-- denotes starting tile, for other prize boxes??		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	JSR Draw_KTPrizeGameBox	 ; Draw the Koopa Troopa "Prize" Game box and the prize		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostTroopa_Draw:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	JSR HostTroopa_DrawSprites		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostHammerBro_Draw:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	JSR HostHammerBro_DrawSprites		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostToad_SpriteYs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $60, $60, $60, $60, $70, $70, $70, $70, $80, $80, $80		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostToad_SpriteXs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $C0, $C8, $D0, $D8, $C0, $C8, $D0, $D8, $C0, $C8, $D0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostToad_DrawSprites:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var11 = $95 (starting pattern of Toad Host sprites)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$95	 		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDY #$00	 ; Y = 0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDX #(HostToad_SpriteYs_End - HostToad_SpriteYs - 1)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A727:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set Sprite Y of this sprite of the Toad Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA HostToad_SpriteYs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set pattern of this sprite of the Toad Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set palette of this sprite of the Toad Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #SPR_PAL0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set Sprite X of this sprite of the Toad Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA HostToad_SpriteXs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var11 -= 2 (two patterns backward)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEX		 ; X--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A727	 ; While X >= 0, loop		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostTroopa_SpriteYs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $60, $60, $60, $70, $70, $70, $70, $80, $80, $80		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
; HostTroopa_SpriteYs_End		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostTroopa_SpriteXs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $C0, $C8, $D0, $C0, $C8, $D0, $D8, $C8, $D0, $D8		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostTroopa_DrawSprites:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	; Temp_Var11 = $99 (starting pattern of Koopa Troopa Host sprites)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$99	; WRONG!  Should be $A9, then he'll display correctly :D		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDY #$00	 ; Y = 0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDX #(HostTroopa_SpriteYs_End - HostTroopa_SpriteYs - 1)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A765:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set Sprite Y of this sprite of the Koopa Troopa Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA HostTroopa_SpriteYs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set pattern of this sprite of the Koopa Troopa Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set palette of this sprite of the Koopa Troopa Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #SPR_PAL0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set Sprite X of this sprite of the Koopa Troopa Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA HostTroopa_SpriteXs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var11 -= 2 (two patterns backward)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEX		 ; X--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A765	 ; While X >= 0, loop		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


; HostHammerBro_SpriteYs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $60, $60, $60, $70, $70, $70, $70, $80, $80, $80, $80		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; HostHammerBro_SpriteXs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $C0, $C8, $D0, $C0, $C8, $D0, $D8, $C0, $C8, $D0, $D8		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


; HostHammerBro_DrawSprites:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	; Temp_Var11 = $AF (starting pattern of Koopa Troopa Host sprites)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #$AF	; WRONG!  Should be $BF, then he'll display correctly :D		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDY #$00	 ; Y = 0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDX #(HostHammerBro_SpriteYs_End - HostHammerBro_SpriteYs - 1)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A7A5:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	; Set Sprite Y of this sprite of the Hammer Bro Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA HostHammerBro_SpriteYs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set pattern of this sprite of the Hammer Bro Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set palette of this sprite of the Hammer Bro Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #SPR_PAL0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set Sprite X of this sprite of the Hammer Bro Host		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA HostHammerBro_SpriteXs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var11 -= 2 (two patterns backward)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEX		 ; X--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	BPL PRG024_A7A5	 ; While X >= 0, loop		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; BonusGameBox_SpriteYs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $70, $70, $70, $70, $80, $80, $80, $80		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; BonusGameBox_SpriteXs:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $70, $78, $80, $88, $70, $78, $80, $88		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; Bonus_KTPrizeFlipBits:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte SPR_HFLIP, $00		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

; Bonus_KTPrizePattern:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	.byte $21, $25, $23, $27		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Draws the box and the "prize" for Koopa Troopa's "Prize" Game		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
; Draw_KTPrizeGameBox:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA <Temp_Var11	 		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY


	; Draw the game box first		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	LDX #(BonusGameBox_SpriteYs_End - BonusGameBox_SpriteYs - 1)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
PRG024_A7E1:		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set Sprite Y of this sprite		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA BonusGameBox_SpriteYs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set pattern of this sprite		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set palette of this sprite 		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA #SPR_PAL0		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Set Sprite X of this sprite		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	LDA BonusGameBox_SpriteXs,X		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	STA Sprite_RAM+$10,Y		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	INY		 ; Y++ (next sprite RAM byte)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	; Temp_Var11 -= 2 (two patterns backward)		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY
	DEC <Temp_Var11		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

	DEX		 ; X--		; UNUSED COPY FROM PRG022, DELETE DON'T MODIFY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;  END UNUSED COPY/PASTED CODE  ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


Debug_DownUp:	.byte 1, -1	; Add 1 or subtract 1 from current world on debug menu

; $A802
	.byte $02, $FF, $00, $01

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GraphicsBuf_Prep_And_WaitVSyn2
;
; This subroutine takes Graphics_Queue and loads and address
; from Video_Upd_Table2 into the Video_Upd_Addr, then waits for
; a VBlank cycle to occur via reading the VBlank_Tick after
; force-setting it to zero.  This gets the system into a state
; where it can actually apply the update!
;
; See also GraphicsBuf_Prep_And_WaitVSync in PRG030
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GraphicsBuf_Prep_And_WaitVSyn2:
	LDA <Graphics_Queue
	ASL A		 	
	TAY		 	; Y = Graphics_Queue << 1

	; Get the address where the video update data is
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	LDA #$01	
	STA <VBlank_TickEn	 ; Enable the VBlank tick
	LDA #$00	 
	STA <VBlank_Tick	 ; Force VBlank_Tick = 0, so we know when a VBlank has occurred

	; Waiting for VBlank...
PRG024_A81C:
	LDA <VBlank_Tick
	BPL PRG024_A81C

	LDA #$00	 
	STA <VBlank_TickEn	 ; Disable the VBlank

	CLI		 ; Enable further masked interrupts
	RTS		 ; Return


IntIRQ_TitleEnding:
	STA MMC3_IRQENABLE

	; Some kind of delay loop?
	LDX #$04	 ; X = 4
PRG024_A82B:
	NOP		 ; ?
	DEX		 ; X--
	BNE PRG024_A82B	 ; While X > 0, loop

	LDA PPU_STAT

	LDY #$0b
	LDA #$00
	STY PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR

	LDA PPU_VRAM_DATA

	LDA <PPU_CTL1_Copy	
	ORA <PPU_CTL1_Mod	; Combine bits from PPU_CTL1_Copy into PPU_CTL1_Mod
	STA PPU_CTL1	 ; Stored to the register!

	LDA PPU_STAT

	; H-Scroll locked at 0
	LDA #$00
	STA PPU_SCROLL

	; V-Scroll locked at $EF
	LDA #$ef
	STA PPU_SCROLL

	STA MMC3_IRQDISABLE

	JMP IntIRQ_Finish_NoDis	 ; Jump to IntIRQ_Finish_NoDis

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; Video_Misc_Updates2
;
; This routine is responsible for arbitrary video updates
;
; Loads data as specified from table Video_Upd_Table2 in PRG024 (see Video_Upd_Table in PRG030 for format!)
; Cloned in its entirety in PRG026 (i.e. Video_Misc_Updates)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Video_Misc_Updates2:
	LDY #$00	 	; Start at offset 0
	LDA [Video_Upd_AddrL],Y	; Get next byte from data
	BNE PRG024_A860	 	; If not $00 (terminator), process it @ PRG024_A860
	RTS		 ; Return

PRG024_A860:
	LDX PPU_STAT	 	; Flush video

	STA PPU_VRAM_ADDR	; Store byte into video address high
	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_ADDR	; Store byte into video address low

	INY		 	; Y++
	LDA [Video_Upd_AddrL],Y	; Get next byte...

	ASL A		 	; Its uppermost bit dictates whether to use horizontal (1B) or vertical (32B) advancement
	PHA		 	; Save A

	LDA <PPU_CTL1_Copy	; Get PPU_CTL1 settings
	ORA #$04	 	; Set PPU update vertical (each write advances by 32)
	BCS PRG024_A879		; If bit 7 was set, jump to PRG026_B2B2
	AND #$fb		; Otherwise, use horizontal updates! (clears vertical bit)

PRG024_A879:
	STA PPU_CTL1		; Update PPU_CTL1
	STA <PPU_CTL1_Copy	; Update PPU_CTL1_Copy

	PLA		; Restore A

	ASL A		 ; Check next bit...
	BCC PRG024_A885	 ; If not set, jump to PRG026_B2BE
	ORA #$02	 ; Otherwise, remaining value gets bit 1 set (forces skip of first increment)
	INY		 ; Y++ 

PRG024_A885:
	; Restore remainder of byte read (6-bits for value)
	LSR A
	LSR A
	TAX		 ; Keep it in X

	; The following will continuously write bytes from the stream
	; directly into the PPU 'X+1' times
PRG024_A888:
	BCS PRG024_A88B	 ; If carry set, jump to PRG026_B2C4
	INY		 ; Y++

PRG024_A88B:
	LDA [Video_Upd_AddrL],Y	; Get next byte
	STA PPU_VRAM_DATA	; Store into PPU
	DEX		 	; X--
	BNE PRG024_A888	 	; While X <> 0, loop! 

	; This advances the current position of the pointer so 'Y' can go
	; back to zero and we begin again...
	INY		 ; Y++
	TYA		 ; A = Y
	ADD <Video_Upd_AddrL
	STA <Video_Upd_AddrL
	LDA <Video_Upd_AddrH
	ADC #$00	 
	STA <Video_Upd_AddrH	; Entire video address value has 'Y' added to it
	JMP Video_Misc_Updates2	; Jump back to start to process next command or terminate!

Title_Obj_InitIdx:	.byte $02, $00, $01, $03, $04, $05	; Indexes into Title_ObjStates, inits to state 1 in this order
Title_ObjInitIdx_Time:	.byte $03, $03, $06, $12, $11, $00	; Timing values to delay the next Title_ObjInitIdx

Do_Title_Screen:	; $A8AF
	JSR Sprite_RAM_Clear		; Clear Sprite RAM Copy
	JSR Reset_PPU_Clear_Nametables

	; Basically just hiding everything
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; Clear the first 245 bytes of RAM
	LDX #$f5	 ; X = 245
PRG024_A8BF:
	LDA #$00	 	; A = $00
	STA <Temp_Var1,X	; Clear this byte
	DEX		 	; X--
	BNE PRG024_A8BF	 	; Loop...


	; Clearing memory used by various title screen objects
	LDX #(Title_ObjFrame - Title_MLAccelCnt + 6)
PRG024_A8C8:
	LDA #$00	 ; A = 0
	STA Title_MLAccelCnt,X	 ; Clear this byte
	DEX		 ; X--
	BPL PRG024_A8C8	 ; Loop while X >= 0...

	; Set Mario and Luigi's lives to 4
	LDA #$04
	STA Player_Lives
	STA Player_Lives+1

	LDA #$ff
	STA <Title_ObjInitIdx	; Title_ObjInitIdx = $FF (Should be 0 - 5, does this have an early increment or something?)

	; Set Mario and Luigi's Y position to 160
	LDA #160
	STA <Title_ObjY
	STA <Title_ObjY+1

	LDA #240
	STA <Title_ObjX		; Set Mario's X coordinate to 240

	LDA #$00
	STA <Title_ObjX+1	; Set Luigi's X coordinate to 0

	; Set Mario and Luigi to "Big" power level
	LDA #$01
	STA <Title_ObjMLPower	
	STA <Title_ObjMLPower+1	

	LDA #$88
	STA Random_Pool		; Seed the randomizer

	LDA #%00101000
	STA PPU_CTL1		; use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Sync with PPU_CTL1_Copy

	JSR Title_Display_Curtain	; Put up the curtain!

	; Load the palette and checkerboard floor pattern
	LDA #$01	 ; A = 1
	ASL A		 ; A = 2
	TAY		 ; Y = 2 (Palette + Checkerboard floor)
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH
	JSR Video_Misc_Updates2

	; Some kind of hardware thing perhaps
	LDA #$00
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10	
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$00	
	STA PPU_VRAM_ADDR
	STA PPU_VRAM_ADDR
	LDA #$10	 
	STA PPU_VRAM_ADDR	
	STA PPU_VRAM_ADDR	

	; Wait for V-Blank to end
PRG024_A930:
	LDA PPU_STAT
	AND #$80	
	BNE PRG024_A930	

	LDA #%10101000
	STA PPU_CTL1	 	; Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	LDA #%00011110
	STA <PPU_CTL2_Copy	; Setup for: No BG or sprite clipping, show BG and sprites

	LDA #53
	STA <Title_Ticker	; Set Title_Ticker = 53 (initial delay prior to curtain raise)

PRG024_A946:
	; Used for VSync
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	LDA <Pad_Input
	AND #PAD_START
	BEQ PRG024_A955	 ; If Player is NOT pressing Start, jump to PRG024_A955

	; Player pressed START -- skips rest of intro, if any
	LDA #$06	 	
	STA <Title_State	; Title_State = 6 
	BEQ PRG024_A959	 	; Jump technically never?? to skip title ticker

PRG024_A955: 
	DEC <Title_Ticker	; Decrement title tick counter
	BPL PRG024_A946	 	; If >= 0, loop...

PRG024_A959:
	; Title_Ticker = 0...

	; Used for VSync
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	; There are 6 objects on the title screen that need their states set; if this value hits 6, we're done with that
	LDY <Title_ObjInitIdx	; Y = Title_ObjInitIdx
	CPY #$06	 	
	BGE PRG024_A976	 	; If Title_ObjInitIdx >= 6, jump to PRG024_A976

	; Title_ObjInitIdx < 6... (more objects to go yet)

	; Waiting for event timer to run out
	DEC <Title_ObjInitDly	; Title_ObjInitDly--
	BNE PRG024_A976	 	; If Title_ObjInitDly > 0, jump to PRG024_A976

	; Load next delay for object init
	; Title_ObjInitIdx is 0 to 5
	LDA Title_ObjInitIdx_Time,Y
	STA <Title_ObjInitDly	; Title_ObjInitDly = Title_ObjInitIdx_Time[Title_ObjInitIdx]

	LDA Title_Obj_InitIdx,Y
	TAY		 	; Y = Title_Obj_InitIdx[Title_ObjInitIdx]

	LDA #$01	 	
	STA Title_ObjStates,Y 	; Title_ObjStates[Y] = 1  Set title screen object to state 1

	; Doing next object...
	INC <Title_ObjInitIdx	; Title_ObjInitIdx++

PRG024_A976:
	JSR Title_DoState	; Do whatever this state of the title screen does

	; Title_ResetTrig is the trigger to reset the title screen
	LDA <Title_ResetTrig
	BEQ PRG024_A980	 	; If Title_ResetTrig = 0, jump to PRG024_A980

	JMP Do_Title_Screen	; Reset title screen...

PRG024_A980:
	; Reset trigger is not set...

	LDA <Title_State
	CMP #$05	 
	BNE PRG024_A959	 ; If Title_State <> 5, jump to PRG024_A959

	; When Title_State = 5, we're about to finish and go off to the map!

	; Performs a clearing loop starting from World_Map_Y + $80 ($F5) down and through
	LDX #$80	 ; Clearing $80 bytes
	LDA #$00	 ; Clear value
PRG024_A98A:
	STA <World_Map_Y,X	; Clear this byte
	DEX		 	; X--
	BPL PRG024_A98A	 	; X >= 0, loop!

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_Display_Curtain
;
; You know that nifty "bowser" curtain 
; on the title screen?  Here it is...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_Display_Curtain:
	LDA PPU_STAT 	; read PPU status to reset the high/low latch

	; Set VRAM_ADDR to $2000 (Nametable 0)
	LDA #$20
	STA PPU_VRAM_ADDR
	LDA #$00
	STA PPU_VRAM_ADDR

	LDX #$02	 ; X = 2 (performs loop twice)
	LDA #$08	 ; A = 8 (the Bowser curtain tile)
PRG024_A9A1:
	LDY #$ff	 ; Y = $FF (fill count)
PRG024_A9A3:
	STA PPU_VRAM_DATA	; Write $08/$09 to this byte in the VRAM
	EOR #$01	 	; Toggle between $08/$09
	DEY		 	; Y--
	BNE PRG024_A9A3	 	; Loop while Y not zero
	STA PPU_VRAM_DATA	; One more write since we come up one short
	EOR #$01	 	; And its cooresponding flip
	DEX		 	; X--
 	BPL PRG024_A9A1		; Loop while X >= 0...

	RTS		 	; Return!


Title_DoState:

	; Clear the queues for Mario/Luigi
	LDA #$00
	STA <Title_ObjMLQueue
	STA <Title_ObjMLQueue+1

	LDA <Title_State	
	JSR DynJump	 	; Dynamically jump based on Title_State...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TitleState_CurtainRaise		; 00 - Curtain raise
	.word TitleState_OpeningSequence	; 01 - Opening sequence (updates Mario/Luigi's action scripts, the title screen objects, makes the big '3' glow...)
	.word Title_PrepForMenu			; 02 - Prepares some variables before going into 1P/2P menu mode
	.word Title_Do1P2PMenu			; 03 - Runs the 1P/2P menu with the koopas
	.word Title_PrepForWorldMap		; 04 - Final data initialization before going to world map
	.word Title_DoNothing			; 05 - just RTS, bootstraps world map
	.word Title_IntroSkip			; 06 - Skip intro sequence (cleanly jump to 1P/2P menu)
	.word Title_DebugMenu			; 07 - Debug menu

TitleState_CurtainRaise:
	LDY #$01	 	; Y = 1

PRG024_A9D1:
	; Moving curtain up...
	INC <Vert_Scroll	; Vert_Scroll++
	LDA <Vert_Scroll	
	CMP #208
	BEQ Title_LoadGraphics	 	; If Vert_Scroll = 208, jump to Title_LoadGraphics

	; Still haven't risen all the way...

	CMP #78	 		
	BNE PRG024_A9E4	 	; If Vert_Scroll <> 78, jump to PRG024_A9E4

	; Special stuff when curtain (Vert_Scroll) hits 78
	LDA #$40
	STA <Title_ObjMLStop	; Title_ObjMLStop = $40 (holds Mario/Luigi in place at first so they get a "running start")
	STA Title_MLHoldTick 	; Title_MLHoldTick = $40 (ticks until they are released)

PRG024_A9E4:
	DEY		 ; Y--
	BPL PRG024_A9D1	 ; If Y >= 0, jump to PRG024_A9D1

	LDA <Title_ObjMLStop
	BEQ PRG024_A9EE	 	; If Title_ObjMLStop = 0, jump to PRG024_A9EE (i.e. don't call Title_UpdateAllObjs)
	JSR Title_UpdateAllObjs	; Update all objects!

PRG024_A9EE:
	LDA <Pad_Input
	AND #PAD_START
	BEQ PRG024_A9F8	 ; If Player is NOT pressing start, jump to PRG024_A9F8 (RTS)

	LDA #$06	 
	STA <Title_State ; Title_State = 6 (skip intro)

PRG024_A9F8:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_LoadGraphics
;
; Loads several items from Video_Upd_Table2 in PRG025
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_LoadGraphics:
	LDA #$02
	STA <Title_EventIndex ; Title_EventIndex = $02 (first action taken [load the logo] and continue doing stuff!)

	LDA #$08
	STA <Title_EventGrafX ; Title_EventGrafX = $08 (first item to load from Video_Upd_Table2 in PRG025, up to item $23; see Title_LoadSMB3)

	INC <Title_State ; Next title state...

	LDA #$00	
	STA <Title_ObjMLStop ; Title_ObjMLStop = 0 (releases Mario and Luigi)

	RTS		 ; Return


; This is Mario and Luigi's "action script", which is a simple script to
; dictate their actions on the title screen...
; NOTE: The other objects are mostly autonomous, not scripted.  They respond to
; hardcoded values, timers, or flags from this, but that's it...
;
; Format:
; [DELAY][QUEUE]
;
; Where:
; [DELAY] is normally a tick count until the next event, EXCEPT:
;
;	Mario's script:
;	- $FE to increment Title_State and reset Title_MActScriptPos
;	- $FF to set Title_EventIndex to the value that follows it
;
;	Luigi's script:
;	- $FF is like Mario's $FE, i.e. Title_LActScriptPos = 0, but does not change Title_State
; [QUEUE] is normally a value pumped into Title_MActScriptDirSet (buffer) and Title_ObjMLQueue (acted upon),
; 	except for the prior $FE and $FF values as follows:
;	- For [CMD] $FE (Mario) or $FF (Luigi), it is not used (since Title_MActScriptPos is set to zero)
;	- For [CMD] $FF (Mario), it is the Title_EventIndex value to set

; Mario's action script
Title_MActionScript:
	.byte $4C, $02, $14, $00, $20, $04, $03, $00, $FF, $03, $BD, $00, $30, $08, $17, $80
	.byte $05, $00, $23, $82, $02, $00, $25, $80, $20, $00, $35, $01, $05, $10, $04, $01
	.byte $05, $00, $04, $01, $05, $00, $04, $01, $05, $00, $04, $01, $05, $00, $04, $01
	.byte $50, $00, $42, $02, $01, $80, $12, $02, $05, $01, $20, $00, $10, $01, $05, $20
	.byte $20, $01, $05, $40, $C0, $00, $02, $02, $10, $00, $36, $41, $38, $42, $60, $00
	.byte $60, $51, $FF, $08, $10, $00, $FE, $00

; Luigi's action script
Title_LActionScript:
	.byte $2C, $01, $50, $80, $F0, $01, $90, $00, $70, $00, $10, $02, $10, $22, $09, $00
	.byte $15, $02, $34, $00, $02, $42, $90, $00, $65, $01, $F0, $00, $FF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Title_3Glow
;
; Constantly pushes a palette adjustment into the
; graphics buffer to enable the big '3' on the title
; screen to glow...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Title_3Glow:
	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_AAA9	 	; If Title_Ticker >= 0, jump to PRG024_AAA9 (RTS)

	LDA #$04	 	
	STA <Title_Ticker	; Title_Ticker = 4

	LDY <Title_3GlowIndex	; Y = current 3glow index
	LDA Title_3GlowColors,Y	; Get the cooresponding color

	STA Graphics_Buffer+3	; Put that into the graphics buffer

	; Address the palette
	LDA #$3f	 
	STA Graphics_Buffer
	LDA #$0e	 
	STA Graphics_Buffer+1

	; 1 byte and terminator
	LDA #$01	 	
	STA Graphics_Buffer+2	
	LDA #$00	 	
	STA Graphics_Buffer+4	

	; Title_3GlowIndex goes from 0 - 7, round and round
	INC <Title_3GlowIndex
	LDA <Title_3GlowIndex
	AND #$07	
	STA <Title_3GlowIndex

PRG024_AAA9:
	RTS		 ; Return

	; These are the color values used by Title_3Glow for the big '3'
Title_3GlowColors:
	.byte $27, $17, $07, $17, $27, $37, $37, $27


TitleState_OpeningSequence:

	; Update Mario's action script
	DEC <Title_MActScriptDelay	; Title_MActScriptDelay--
	LDA <Title_MActScriptDelay
	CMP #$ff
	BNE PRG024_AABD			; If ticks remain, jump to PRG024_AABD

	JSR Title_MAS_DoNextEvent	; Performs an event or sets the Mario action queue

PRG024_AABD:

	; Update Luigi's action script
	DEC <Title_LActScriptDelay	; Title_LActScriptDelay--
	LDA <Title_LActScriptDelay		
	CMP #$ff	 
	BNE PRG024_AAC8	 		; If ticks remain, jump to PRG024_AAC8

	JSR Title_LAS_DoNextEvent	; Performs an event or sets the Luigi action queue

PRG024_AAC8:

	; Copy MLDir settings in...
	LDA <Title_MActScriptDirSet
	STA <Title_ObjMLDir	
	LDA <Title_LActScriptDirSet
	STA <Title_ObjMLDir+1	

	JSR Title_DoEvent		; Perform current title screen events
	JSR Title_UpdateAllObjs	 	; Update all title screen objects

	LDA <Title_3GlowFlag
	BEQ PRG024_AADD	 		; If not glowing, jump to PRG024_AADD

	JSR Title_3Glow	 		; Make the big '3' glow!

PRG024_AADD:
	LDA <Pad_Input	
	AND #PAD_START
	
	BEQ PRG024_AAF3			; If Player is not pressing START, jump to PRG024_AAF3

	; Player pressed start...
	LDA <Title_UnusedFlag
	BNE PRG024_AAED	 		; If Title_UnusedFlag is set, jump to PRG024_AAED

	LDA #$06
	STA <Title_State
	BNE PRG024_AAF3	 		; Title_State = 6 (skip)

PRG024_AAED:
	INC <Title_State		; Next title state...

	LDA #$07
	STA <Graphics_Queue		; Graphics_Queue = 7 (load the 1P/2P select menu)

PRG024_AAF3:
	RTS		 ; Return


Title_IntroSkip:
	LDA #$00	 
	STA <Vert_Scroll ; Vert_Scroll = 0

	; Disable display a second
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; This will load the title graphics in reverse, $22 to $6
	LDA #$22	
	STA <Title_EventGrafX	; Title_EventGrafX = $22 (TitleScreen_Part27)

PRG024_AB04:
	LDA <Title_EventGrafX
	ASL A		 
	TAY		 	; Y = Title_EventGrafX << 1 (2 byte index)

	; Get address, store into [Video_Upd_AddrH][Video_Upd_AddrL]
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL	
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	JSR Video_Misc_Updates2	; Load those graphics!

	DEC <Title_EventGrafX	; Title_EventGrafX--

	LDA <Title_EventGrafX
	CMP #$06	
	BGE PRG024_AB04	 	; If Title_EventGrafX >= 6, loop!

	LDA #%00011000
	STA <PPU_CTL2_Copy	; Show BG + sprites

	LDA #$02	 
	STA <Title_State	; Title_State = 2 (prep for 1P/2P menu)
	RTS		 ; Return


Title_MAS_DoNextEvent:
	LDA #$00	 
	STA <Title_MActScriptDirSet		; Clear Title_MActScriptDirSet 
	STA <Title_ObjMLQueue		; Clear Mario's action queue

	LDY <Title_MActScriptPos	; Get current position in action script
	LDA Title_MActionScript,Y	; Get byte from action script

	CMP #$ff	 
	BEQ Title_MAS_CmdFF	 	; If equal to $FF (set Title_EventIndex), jump to Title_MAS_CmdFF

	CMP #$fe	 
	BEQ Title_MAS_CmdFE	 	; If equal to $FE, jump to Title_MAS_CmdFE

	; Not $FF or $FE...

	; Otherwise, just a tick delay
	STA <Title_MActScriptDelay	; Store into Title_MActScriptDelay
	INY		 	; Y++

	LDA Title_MActionScript,Y	; Get next byte
	STA <Title_MActScriptDirSet		; Store into Title_MActScriptDirSet
	STA <Title_ObjMLQueue		; ... and into the Queue

	; Two bytes read, so Title_MActScriptPos += 2
	INC <Title_MActScriptPos
	INC <Title_MActScriptPos
	RTS		 		; Return...!

Title_MAS_CmdFF:
	; Action script command $FF (set Title_EventIndex)...

	INY		 
	LDA Title_MActionScript,Y	 ; Get next byte
	STA <Title_EventIndex		 ; Store this into Title_EventIndex

	; Title_MActScriptPos += 2
	INC <Title_MActScriptPos
	INC <Title_MActScriptPos

	LDA #$00
	STA <Title_MActScriptDelay	; Title_MActScriptPos = 0

	RTS		 ; Return

Title_MAS_CmdFE:
	; Action script command $FE (increment Title_State, reset Title_MActScriptPos)...

	INC <Title_State		; Next title state...

	LDA #$00
	STA <Title_MActScriptPos	; Set Title_MActScriptPos = 0

	RTS		 ; Return


Title_LAS_DoNextEvent:
	LDA #$00
	STA <Title_LActScriptDirSet		; Clear Title_LActScriptDirSet 
	STA <Title_ObjMLQueue+1		; Clear Luigi's action queue

	LDY <Title_LActScriptPos	; Get current position in action script
	LDA Title_LActionScript,Y	; Get byte from action script

	CMP #$ff
	BEQ Title_LAS_CmdFF		; If equal to $FF (set Title_EventIndex), jump to Title_LAS_CmdFF

	
	; Otherwise, just a tick delay
	STA <Title_LActScriptDelay	; Store into Title_LActScriptDelay
	INY		 		; Y++

	LDA Title_LActionScript,Y	; Get next byte
	STA <Title_LActScriptDirSet		; Store into Title_LActScriptDirSet
	STA <Title_ObjMLQueue+1		; ... and into the Queue

	; Two bytes read, so Title_LActScriptPos += 2
	INC <Title_LActScriptPos
	INC <Title_LActScriptPos
	RTS		 		; Return...!


Title_LAS_CmdFF:

	; Title_LActScriptPos = 0
	LDA #$00
	STA <Title_LActScriptPos

	RTS		 ; Return

	
Title_DoEvent:
	LDA <Title_EventIndex	; Get Title_EventIndex
	JSR DynJump	 	; Dynamically jump based on the value of Title_EventIndex...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Title_DoNothing		; 00 - Do nothing
	.word Title_DoNothing		; 01 - Do nothing (never used I don't think!)
	.word Title_LoadSMB3		; 02 - Load title screen into the nametable
	.word Title_Drop		; 03 - "Drops" the logo onto the screen
	.word Title_LogoShakeUp		; 04 - Logo shake up
	.word Title_LogoShakeDown	; 05 - Logo shake down, and check if we're done doing that
	.word Title_InitObjects		; 06 - Prepare all title screen objects
	.word Title_PalFadeIn		; 07 - Palette fade in
	.word Title_DrawMenu		; 08 - Adds the 1P/2P select menu to the title screen
	.word Title_DoNothing		; 09 - Do nothing, we're done!
	
Title_DoNothing:
	RTS		 

; Title_LoadSMB3
;
; This loads the title screen, specifically items $08 thru $23 of Video_Upd_Table2
; The title screen is too complex to be loaded in one shot, so it's done over
; several frames, in pieces
Title_LoadSMB3:

	; Queue next item to load
	LDA <Title_EventGrafX
	STA Graphics_Queue	

	; Increment Title_EventGrafX
	INC <Title_EventGrafX	

	
	LDA <Title_EventGrafX	
	CMP #$23
	BNE PRG024_ABAC	 ; If not at item $23 yet, keep going...

	; We're done, stop doing background event!
	LDA #$00	 
	STA <Title_EventIndex

PRG024_ABAC:
	RTS		 ; Return


; Title_Drop
;
; The logo comes falling down...
Title_Drop:
	LDY #$04

	; Basically drops logo 4 pixels at a time, with a precise safety catch!
PRG024_ABAF:
	DEC <Vert_Scroll
	LDA <Vert_Scroll
	BEQ PRG024_ABB9	 ; If Vert_Scroll = 0, jump to PRG024_ABB9
	DEY		 ; Y--
	BPL PRG024_ABAF	 ; If Y >= 0, loop!

	RTS		 ; Return

PRG024_ABB9:
	; The logo has landed!

	LDA #$10	 
	STA <Title_Ticker	; Title_Ticker = $10

	INC <Title_EventIndex	; Perform next event...
	RTS		 	; Return...

; Title_LogoShakeUp
;
; Shake the logo up, go to the next state
Title_LogoShakeUp:

	; Subtract 2 from Vert_Scroll
	LDA <Vert_Scroll
	SUB #$02	
	STA <Vert_Scroll

	INC <Title_EventIndex	; Shake down next
	RTS			; Return!

; Title_LogoShakeDown
;
; Shake the logo down, go to the previous state, 
; or see if we're done yet...
Title_LogoShakeDown:

	; Add 2 to Vert_Scroll
	LDA <Vert_Scroll
	ADD #$02	
	STA <Vert_Scroll

	DEC <Title_EventIndex	; Shake up next

	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_ABE3	 	; If we're not done yet, jump to PRG024_ABE3 (no change, shake away)

	; Shaking is complete!
	INC <Title_EventIndex
	INC <Title_EventIndex	; Title_EventIndex += 2 (to make up for the decrement above), moving on to object init...

	LDA #$03	 	
	STA <Title_EventGrafX	; Title_EventGrafX = 3 (to fade in the palette, starting with Video_Upd_Table2 item $03)

	LDA #$02	 
	STA <Title_Ticker	; Title_Ticker = 2

PRG024_ABE3:
	RTS		 ; Return


; Title_InitObjects
;
; Queues the title screen objects to prepare themselves for appearing
Title_InitObjects:
	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_ABF6	 	; If Title_Ticker >= 0, do nothing yet...

	; Preparing to initialize objects that fall in the beginning...
	LDA #$00
	STA <Title_ObjInitIdx	; Title_ObjInitIdx = 0

	LDA #$01
	STA <Title_ObjInitDly	; Title_ObjInitDly = 1

	INC <Title_EventIndex	; On to the next event (the palette fade-in)

	LDA #$16
	STA <Title_Ticker	; Title_Ticker = 16

PRG024_ABF6:
	RTS		 	; Return


; Title_PalFadeIn
;
; Loads palette colors to produce a "fade in" effect, 
; specifically items $03 thru $06 of Video_Upd_Table2
Title_PalFadeIn:
	DEC <Title_Ticker	; Title_Ticker--
	BPL PRG024_AC0F	 	; If Title_Ticker >= 0, do nothing yet...

	LDA #$04
	STA <Title_Ticker	; Title_Ticker = 4

	LDA <Title_EventGrafX	
	STA <Graphics_Queue	; Graphics_Queue = Title_EventGrafX
	CMP #$06	 
	BNE PRG024_AC10	 	; If not at item $06 yet, keep going...

	; Done with the fade in!
	LDA #$00	
	STA <Title_EventIndex	; Stop doing anything

	LDA #$01	 	
	STA <Title_3GlowFlag	; Title_3GlowFlag = 1

PRG024_AC0F:
	RTS			; Return

PRG024_AC10:
	INC <Title_EventGrafX	; Next palette fade
	RTS			; Return 


; Title_DrawMenu
;
; Loads in the tiles for the 1/2 PLAYER GAME and Nintendo copyright
Title_DrawMenu:
	LDA #$07
	STA <Graphics_Queue
	INC <Title_EventIndex	; Do next thing (which is actually nothing; on purpose??)
	RTS		 	; Return...

Title_PrepForMenu:

	; Clear objects 1-4 states
	LDA #$00
	STA <Title_ObjStates+1
	STA <Title_ObjStates+2	
	STA <Title_ObjStates+3	
	STA <Title_ObjStates+4	

	; Set object 0's state to 1 (this is the leader koopa, he starts first, brings in the next)
	LDA #$01
	STA <Title_ObjStates

	; This is the counter for when to reset the title sequence
	LDA #20
	STA <Title_ResetCnt ; Title_ResetCnt = 20

	; This is the "fine" part of the reset count; when it goes to zero, it decrements Title_ResetCnt
	LDA #60
	STA <Title_ResetCnt2 ; Title_ResetCnt2 = 60

	INC <Title_State ; Next title state...
	RTS		 ; Return

Title_Menu_1P2PCursorY:
	.byte 151, 167	 ; Y position for the 1P/2P select cursor

Title_Do1P2PMenu:
	LDA <Controller2
	AND #(PAD_A | PAD_B)
	CMP #(PAD_A | PAD_B)	
	BNE PRG024_AC42	 ; If Player 2 is not holding A+B, jump to PRG024_AC42

	; NOTE: This probably WAS the debug menu activation...
	NOP
	NOP
	NOP
	NOP
	NOP

PRG024_AC42:
	; Title_ResetCnt and Title_ResetCnt2 gang together to form a large countdown timer

	DEC <Title_ResetCnt2	; Title_ResetCnt2--
	BNE PRG024_AC52	 	; If <> 0, jump to PRG024_AC52

	LDA #96
	STA <Title_ResetCnt2 	; Title_ResetCnt2 = 96

	DEC <Title_ResetCnt	; Title_ResetCnt--
	BNE PRG024_AC52	 	; If <> 0, jump to PRG024_AC52

	; Title_ResetCnt and Title_ResetCnt2 have reached zero!
	; Trigger the reset!
	LDA #$ff
	STA <Title_ResetTrig	; Title_ResetTrig = $ff

PRG024_AC52:
	JSR Title_Menu_UpdateKoopas	 ; Update and draw koopas

	LDA <Pad_Input		 
	AND #PAD_SELECT
	BEQ PRG024_AC6B	 	; If Player is not pressing SELECT, jump to PRG024_AC6B

	LDA #SND_MAPPATHMOVE	 
	STA Sound_QMap	 	; "Path move" sound (in this case, the "bleep" for the menu)

	; Basically makes sure that the value of Total_Players is 0 or 1 
	INC Total_Players
	LDA Total_Players
	AND #$01	 
	STA Total_Players

PRG024_AC6B:
	LDY Total_Players	 ; Y = Total_Players (0 or 1)
	LDA Title_Menu_1P2PCursorY,Y	 ; Get proper Y value for where cursor is at
	STA Sprite_RAM+$F0	 ; Store into sprite

	LDA #$df	 
	STA Sprite_RAM+$F1	 ; Store pattern value into sprite

	LDA #$00	 
	STA Sprite_RAM+$F2	 ; Store attribute value into sprite

	LDA #72
	STA Sprite_RAM+$F3	 ; Store X value into sprite

	JSR Title_3Glow	 	; Keep the big '3' glowing!

	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG024_ACBA	 	; If Player is not pressing START, jump to PRG024_ACBA (RTS)

	LDA #SND_LEVELCOIN	 
	STA Sound_QLevel1	; Play coin sound (in this case, selected and begin!)

	LDA Sprite_RAM+$F0	; Get Y value of title screen cursor sprite
	STA <Title_EventGrafX	; Reuse as a temp...

PRG024_AC96:
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	INC <Title_ResetCnt	; Title_ResetCnt++

	LDY #$f8	 	; Y = $f8 (hide title screen cursor)

	LDA <Title_ResetCnt
	AND #$18	 
	BEQ PRG024_ACA5	 ; Periodically jump to PRG024_ACA5

	LDY <Title_EventGrafX	; Y = reappear title screen cursor

PRG024_ACA5:
	STY Sprite_RAM+$F0	 ; Set it!

	JSR Title_3Glow	 		; Make the big '3' glow!

	LDA SndCur_Level1
	BNE PRG024_AC96	 ; If the "gling" sound has not ended, loop!

	INC <Title_State ; Title_State++

	; World_Num = 0 (World 1)
	LDA #$00
	STA World_Num

	; Debug_Flag = 0 (no debug mode)
	STA Debug_Flag

PRG024_ACBA:
	RTS		 ; Return

Title_PrepForWorldMap:
	LDA #$00
	STA World_Map_Power	 ; Mario starts as small on world map
	STA World_Map_Power+1	 ; Luigi starts as small on world map
	INC Total_Players	 ; Total_Players should be 1/2, not 0/1
	INC <Title_State	 ; Next title state...
	RTS		 ; Return

Title_DebugMenu:
	JSR Title_Menu_UpdateKoopas	 ; Update the koopas

	LDA <Controller2
	AND #$c1	 
	CMP #$c1	
	BNE PRG024_ACD7	 ; If Player 2 is NOT hitting A+B+Right (credits jump), jump to PRG024_ACD7

	JMP Ending_Credits	 ; Jump to credits

PRG024_ACD7:
	LDA <Controller2
	AND #$c4	
	CMP #$c4	
	BNE PRG024_ACE2	 ; If Player 2 is NOT hitting A+B+Down (jump to Princess rescue), jump to PRG024_ACE2

	JMP Rescue_Princess	 ; Jump to princess rescue

PRG024_ACE2:
	LDA <Pad_Input
	AND #(PAD_UP | PAD_DOWN)
	BEQ PRG024_ACFB	 ; If Player is not pressing Up or Down, jump to PRG024_ACFB

	LSR A
	LSR A
	LSR A
	TAX		 ; X = 0 (Down) or 1 (Up)

	; Properly add or subtract from world depending on direction pressed,
	; and loop around so it never leaves World 1 - 8 (0-7)
	LDA World_Num_Debug
	ADD Debug_DownUp,X
	AND #$07	 
	STA World_Num_Debug

	JMP PRG024_AD9C	 ; Jump to PRG024_AD9C

PRG024_ACFB:
	LDA <Pad_Input	
	AND #PAD_SELECT
	BEQ PRG024_AD0C		; If Player is not pressing SELECT, jump to PRG024_AD0C

	; Basically makes sure that the value of Total_Players is 0 or 1 
	INC Total_Players
	LDA Total_Players
	AND #$01	 
	STA Total_Players

PRG024_AD0C:
	LDY Total_Players	 ; Y = Total_Players (0 or 1)
	LDA Title_Menu_1P2PCursorY,Y	 ; Get proper Y value for where cursor is at
	STA Sprite_RAM+$F0	 ; Store into sprite

	LDA #$df	 
	STA Sprite_RAM+$F1	 ; Store pattern value into sprite

	LDA #$00	 
	STA Sprite_RAM+$F2	 ; Store attribute value into sprite

	LDA #72
	STA Sprite_RAM+$F3	 ; Store X value into sprite

	LDA <Pad_Input
	AND #PAD_A
	BEQ PRG024_AD54	 	; If Player is not pressing A, jump to PRG024_AD54

	LDA Player_Lives
	CMP #99
	BEQ PRG024_AD3A	 	; If Player_Lives = 99, jump to PRG024_AD3A

	; Otherwise, 5 more lives
	LDA Player_Lives
	ADD #$05	
	STA Player_Lives

PRG024_AD3A:

	; Updates number of lives
	LDA #$21	 
	STA Graphics_Buffer
	LDA #$14	 
	STA Graphics_Buffer+1	; VRAM Address $2114

	LDA #$01	 
	STA Graphics_Buffer+2	; 1 byte

	LDA Player_Lives	
	STA Graphics_Buffer+3	; Number of lives direct

	LDA #$00	 
	STA Graphics_Buffer+4	; Terminator

PRG024_AD54:
	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG024_AD9C	 ; If Player is NOT pressing START, jump to PRG024_AD9C

	LDA #$80	
	STA Debug_Flag	 ; Activate debug functions

	LDA #$04
	STA <Title_State 	; Title_State = 4 (prep for world map)

	; Quick loop to set up Mario and Luigi with the lives start and world map power
	LDX Total_Players	; X = Total_Players
	LDY Player_Lives	; Y = Player_Lives
PRG024_AD69:
	TYA		 	; A = Player_Lives
	STA Player_Lives,X	; Store to this player
	LDA #$00	 
	STA World_Map_Power,X	; This player starts small on world map
	DEX		 	; X--
	BPL PRG024_AD69	 	; While X >= 0, loop...

	LDA World_Num_Debug
	STA World_Num	 	; Transfer the selected world to the game's world variable

	; Fills entire inventory of Mario and Luigi with P-Wings first
	LDX #$1b
	LDA #$08	 
PRG024_AD7F:
	STA Inventory_Items,X	
	STA Inventory_Items2,X	
	DEX		 ; X--
	BPL PRG024_AD7F	 ; While X >= 0, loop...

	; Fill beginning of inventory with one of everything
	LDX #$0d 

	; Give second warp whistle
	LDA #$0c
	STA Inventory_Items,X
	STA Inventory_Items2,X
PRG024_AD92:
	TXA
	STA Inventory_Items-1,X
	STA Inventory_Items2-1,X
	DEX		 ; X--
	BNE PRG024_AD92	 ; While X <> 0, loop!  (Don't want 0 because of the "-1" indexing)

PRG024_AD9C:

	; Draw the world select cursor
	LDA World_Num_Debug
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		 
	ADD #$30	 
	STA Sprite_RAM+$50
	LDA #$6f	 
	STA Sprite_RAM+$51
	LDA #$00	 
	STA Sprite_RAM+$52
	LDA #$20	 
	STA Sprite_RAM+$53

	RTS		 ; Return


T_SP_Off .func \1-Title_SpritePattern	; "Title SpritePattern Offset"

	; Index into Title_SpritePattern for all of Mario/Luigi's complex frames
Title_SpritePatternIndex:
	.byte T_SP_Off(T_SP_00), T_SP_Off(T_SP_01), T_SP_Off(T_SP_02), T_SP_Off(T_SP_03)
	.byte T_SP_Off(T_SP_04), T_SP_Off(T_SP_05), T_SP_Off(T_SP_06), T_SP_Off(T_SP_07)
	.byte T_SP_Off(T_SP_08), T_SP_Off(T_SP_09), T_SP_Off(T_SP_0A), T_SP_Off(T_SP_0B)
	.byte T_SP_Off(T_SP_0C), T_SP_Off(T_SP_0D), T_SP_Off(T_SP_0E), T_SP_Off(T_SP_0F)
	.byte T_SP_Off(T_SP_10), T_SP_Off(T_SP_11), T_SP_Off(T_SP_12), T_SP_Off(T_SP_13)
	.byte T_SP_Off(T_SP_14), T_SP_Off(T_SP_15), T_SP_Off(T_SP_16), T_SP_Off(T_SP_17)
	.byte T_SP_Off(T_SP_18), T_SP_Off(T_SP_19), T_SP_Off(T_SP_1A), T_SP_Off(T_SP_1B)

	; Block of patterns, based on offsets from Title_SpritePatternIndex
	; For use with Mario/Luigi's sprites
Title_SpritePattern:
T_SP_00:	.byte $01, $03, $F1, $05, $07, $F1
T_SP_01:	.byte $0B, $0D, $F1, $0F, $29, $F1
T_SP_02:	.byte $2D, $2F, $F1, $19, $1B, $F1
T_SP_03:	.byte $01, $03, $F1, $05, $07, $09
T_SP_04:	.byte $0B, $0D, $F1, $0F, $29, $2B
T_SP_05:	.byte $2D, $2F, $F1, $19, $1B, $1D
T_SP_06:	.byte $31, $33, $F1, $35, $37, $F1
T_SP_07:	.byte $31, $33, $F1, $35, $37, $39
T_SP_08:	.byte $01, $03, $F1, $05, $07, $39
T_SP_09:	.byte $01, $03, $F1, $05, $07, $3B
T_SP_0A:	.byte $25, $25, $F1, $27, $27, $F1
T_SP_0B:	.byte $31, $33, $F1, $35, $37, $F1
T_SP_0C:	.byte $29, $2B, $F1, $2D, $2F, $F1
T_SP_0D:	.byte $27, $19, $F1, $1D, $1F, $F1
T_SP_0E:	.byte $01, $03, $F1, $05, $07, $09
T_SP_0F:	.byte $01, $03, $F1, $0B, $0D, $0F
T_SP_10:	.byte $01, $03, $F1, $21, $23, $25
T_SP_11:	.byte $F1, $F1, $F1, $05, $07, $F1
T_SP_12:	.byte $F1, $F1, $F1, $01, $03, $F1
T_SP_13:	.byte $F1, $F1, $F1, $21, $23, $F1
T_SP_14:	.byte $19, $1B, $F1, $1D, $21, $F1
T_SP_15:	.byte $19, $1B, $F1, $1D, $21, $23
T_SP_16:	.byte $01, $03, $05, $07, $09, $0B
T_SP_17:	.byte $0D, $0F, $F1, $11, $13, $F1
T_SP_18:	.byte $F1, $F1, $F1, $F1, $F1, $F1
T_SP_19:	.byte $25, $27, $F1, $29, $2B, $F1
T_SP_1A:	.byte $2D, $2F, $F1, $19, $1B, $F1
T_SP_1B:	.byte $31, $33, $F1, $35, $37, $F1

	; Specify proper VROM page for Title_ObjMLSprite sprite index
Title_SpriteVROMPage:
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $45
	.byte $02, $02, $02, $02, $02, $03, $03, $03, $03, $03, $7F, $7F, $00, $13, $13, $13


	; Walking animation sprite frames
	; Values per frame (0 - 3, +4 for each power level they are)
Title_ObjMLWalkSprite:
	.byte $11, $12, $11, $12	; Small 
	.byte $00, $01, $02, $01 	; Big
	.byte $03, $04, $05, $04	; Leaf Raccoon
	.byte $1A, $1B, $1A, $1B	; The Princess

	; Duck sprite frames
Title_ObjMLDuckSprite:
	.byte $12	; Small (no duck sprite)
	.byte $06	; Big
	.byte $07	; Leaf Raccoon

	; Skid sprite frames
Title_ObjMLSkidSprite:
	.byte $13	; Small
	.byte $0C	; Big / Leaf Raccoon

	; Leaf raccoon tail wag animation sprite frames
Title_ObjMLTailWagSprite:
	.byte $09, $03, $08

	; Carrying item while walking
Title_ObjMLCarrySprite:
	.byte $0E, $0F, $10, $0E

	; Powering down (shrinking) animation
Title_ObjMarioPowerDown:
	.byte $11, $0B, $11, $0B, $11, $0B, $02, $0B, $02, $0B, $02, $0B

	; Initial X positions of Mario and Luigi
Title_ObjInitX:
	.byte $F0, $00

	; Initial sprite flags of Mario and Luigi
Title_ObjInitFlags:
	.byte $00, SPR_HFLIP


; Title_UpdateAllObjs
; 
; This routine updates ALL of the objects on the title screen; Mario and Luigi
; and the assorted other things that appear on there.  Handles all of the
; related logic as well.  Pretty much the driving force of all the action!
;
; ... except for the final koopa troopas who march across, they're a
; different bit of code...
Title_UpdateAllObjs:
	JSR PRG024_SpriteClear	 ; Clear all sprites

	; The first byte of Title_MLAccelCnt constantly subtracts $90, discarding any of the low 4 bits
	; This provides a slow, semi-natural acceleration for the Bros on the title screen
	LDA Title_MLAccelCnt
	AND #$f0	 
	SUB #$90	 
	STA Title_MLAccelCnt

	LDA #$10	
	STA <Title_ObjMLSprRAMOff	; Mario's sprite RAM starts at Sprite_RAM + $10

	LDA #$28	
	STA <Title_ObjMLSprRAMOff+1	; Luigi's sprite RAM starts at Sprite_RAM + $28

	LDX #$01

PRG024_AEDD:
	STX <Title_CurMLIndex	; Store current index

	LDA <Title_ObjMLStop
	BEQ PRG024_AF0C	 	; If Title_ObjMLStop = 0, jump to PRG024_AF0C

	LDA #$08	 

	LDY Title_MLHoldTick
	BEQ PRG024_AEEF	 	; If Title_MLHoldTick = 0, jump to PRG024_AEEF

	DEC Title_MLHoldTick	; Otherwise, decrement Title_MLHoldTick

	; Initialize Mario and Luigi title screen objects!

	LDA #$00
PRG024_AEEF:
	; Set the initial X velocity (zero)
	STA <Title_ObjXVel,X	

	; Set the initial X coordinates
	LDA Title_ObjInitX,X	
	STA <Title_ObjX,X	

	; Set the initial Y coordinate (160)
	LDA #160
	STA <Title_ObjY,X

	; Set the initial flags
	LDA Title_ObjInitFlags,X
	STA <Title_ObjMLFlags,X	

	JSR Title_AnimateMarioLuigi	; Animate Mario/Luigi
	JSR Title_DrawMarioLuigi	; Draw Mario/Luigi
 
	LDA #$00	 
	STA <Title_ObjXVel,X	 	; Zero Mario/Luigi's X velocity
	JMP PRG024_AF3D	 		; Jump to PRG024_AF3D

PRG024_AF0C:
	; When Title_ObjMLStop = 0...

	JSR Title_MLXAccel		; Update and apply X velocities of Mario/Luigi
	JSR Title_ML_DoGravity		; Update and apply Y velocities of Mario/Luigi
	JSR Title_AnimateMarioLuigi	; Animate Mario/Luigi
	JSR Title_MLDetermineSpriteVis	; Determine what "slivers" of Mario/Luigi sprites are visible
	JSR Title_MarioDoPoof	 	; Update and draw the "poof"

	LDA Title_MarioPoof
	BNE PRG024_AF23	 		; If Mario is doing the "powerup poof", jump to PRG024_AF23

	; Otherwise, draw Mario and Luigi in the standard way!
	JSR Title_DrawMarioLuigi

PRG024_AF23:
	LDA <Title_XPosHi,X	
	BEQ PRG024_AF3D	 		; If the "high" component of the X position is zero, jump to PRG024_AF3D
	BPL PRG024_AF33			; If it is greater than zero, jump to PRG024_AF33

	; The XHi is less than zero...

	LDA <Title_ObjX,X	 	; Get the X coordinate
	CMP #-64
	BGE PRG024_AF3D	 		; If the X coordinate is >= -64, jump to PRG024_AF3D

	; Don't let the X coordinate go below -64
	LDA #$c0
	BNE PRG024_AF3B	 		; Jump (technically always) to PRG024_AF3B

PRG024_AF33:

	; The XHi is greater than zero...

	LDA <Title_ObjX,X
	CMP #64
	BLT PRG024_AF3D	 		; If the X coordinate is less than 64, jump to PRG024_AF3D

	; Don't let the X coordinate go above 64 off the right side of the screen
	LDA #63

PRG024_AF3B:
	STA <Title_ObjX,X	 	; Update the X coordinate

PRG024_AF3D:
	DEX		 ; X-- (Process Mario after Luigi)
	BPL PRG024_AEDD	 ; If X >= 0, loop!


	; Done processing Mario and Luigi

	JSR Title_UpdateOtherObjs	 ; Update the "other", minor objects!

	RTS		 ; Return


	; Quick and dirty sprite RAM "clear" function (pushes the Y component out of visible range)
PRG024_SpriteClear:
	LDY #$1c
	LDA #$f8

PRG024_AF48:
	STA Sprite_RAM,Y
	STA Sprite_RAM+$20,Y
	STA Sprite_RAM+$40,Y
	STA Sprite_RAM+$60,Y
	STA Sprite_RAM+$80,Y
	STA Sprite_RAM+$A0,Y
	STA Sprite_RAM+$C0,Y
	STA Sprite_RAM+$E0,Y
	DEY	
	DEY	
	DEY	
	DEY	
	BPL PRG024_AF48

	RTS		 ; Return
	
PRG024_AF67:
	.byte -1, 0, 1

	; Values added to Title_MLAccelCnt
Title_MLAccelFactors:
	.byte $60, $E0, $70	; $E0 is most common, directly affects their ability to accelerate

; Title_MLXAccel
;
; Figures out Mario/Luigi's X acceleration and applies it
Title_MLXAccel:
	; X is 0/1, Mario/Luigi

	LDY #$02	 	; Y = 2
	LDA <Title_ObjXVel,X	; Get Mario/Luigi's X velocity
	BPL PRG024_AF7A	 	; If velocity is >= 0, jump to PRG024_AF7A

	; Otherwise, negate it (get the absolute value)
	NEG

	LDY #$01	 	; Also, Y = 1

PRG024_AF7A:
	BNE PRG024_AF7D	 	; If velocity is non-zero, jump to PRG024_AF7D

	; X velocity is zero
	TAY		 	; Y = A (which is zero)

PRG024_AF7D:
	; At this point, Y is a standard direction value -- 0 = Not moving, 1 = Leftward, 2 = Rightward

	STA <Temp_Var15			; Store velocity into Temp_Var15
	STY <Title_ObjMLMoveDir,X	; Store movement direction into Title_ObjMLMoveDir

	LDY #$18	 		; Y = $18
	LDA <Title_ObjMLDir,X	 	; Get the direction vector value
	AND #$40	 		; Check bit 6 (FIXME??)
	BEQ PRG024_AF8B	 		; If not set, jump to PRG024_AF8B

	LDY #$28	 		; Y = $28

PRG024_AF8B:
	STY <Temp_Var14		; Store Y -> Temp_Var14

	LDY #$00	 		; Y = 0
	LDA <Title_ObjMLDir,X	 	; Get direction vector
	AND #$03	 		; Check for bit 0 or 1 (left/right)
	BNE PRG024_AFA1	 		; If either is set, jump to PRG024_AFA1

	; Neither left nor right bits are set in vector
	LDA <Title_ObjYVelChng,X	; Get Y velocity change
	BNE PRG024_AFE9	 		; If there's been a Y change, jump to PRG024_AFE9

	LDA <Title_ObjXVel,X	 	; Get the X velocity
	BEQ PRG024_AFE9			; If zero, jump to PRG024_AFE9
	BMI PRG024_AFBB	 		; If < 0, jump to PRG024_AFBB
	BPL PRG024_AFD3	 		; If > 0, jump to PRG024_AFD3

PRG024_AFA1:
	INY
	INY				; Y += 2  (Y = 2)

	AND <Title_ObjMLMoveDir,X	; Check if movement direction's corresponding bit is set in the Title_ObjMLDir direction vector
	BNE PRG024_AFB5	 		; If it is, jump to PRG024_AFB5

	DEY		 		; Y-- (Y = 1)

	LDA <Temp_Var15		 	; Get velocity
	CMP <Temp_Var14		
	BEQ PRG024_AFE9			; If velocity equals key value ($18 or $28), jump to PRG024_AFE9
	BLS PRG024_AFB5	 		; If less, jump to PRG024_AFB5

	LDA <Title_ObjYVelChng,X
	BNE PRG024_AFE9	 		; If there's a Y velocity change, jump to PRG024_AFE9

	DEY		 		; Otherwise, Y-- (Y = 0)

PRG024_AFB5:
	LDA <Title_ObjMLDir,X
	AND #$01	 
	BNE PRG024_AFD3	 		; If bit 1 (left) is set in the direction vector, jump to PRG024_AFD3

PRG024_AFBB:
	LDA #$00	 	
	SUB Title_MLAccelFactors,Y	; A = -Title_MLAccelFactors[Y] (negates values compared to the routine at PRG024_AFD3)
	STA <Temp_Var1		; Store into Temp_Var1

	LDA PRG024_AF67,Y	; 
	EOR #$ff	 	; A = PRG024_AF67[Y] ^ $FF 
	STA <Temp_Var2		; Store into Temp_Var2

	LDA <Temp_Var1	
	BNE PRG024_AFDD	 	; If Temp_Var1 is non-zero, jump to PRG024_AFDD (never false??)

	; NOTE: I don't think the following two lines of code can ever be reached
	INC <Temp_Var2		; Temp_Var2++
	JMP PRG024_AFDD	 	; Jump to PRG024_AFDD

PRG024_AFD3:
	LDA Title_MLAccelFactors,Y	; A = Title_MLAccelFactors[Y]
	STA <Temp_Var1		; Store into Temp_Var1

	LDA PRG024_AF67,Y	; A = PRG024_AF67[Y]
	STA <Temp_Var2		; Store into Temp_Var2

PRG024_AFDD:

	; High-precision adding here...
	LDA <Temp_Var1		 
	ADD Title_MLAccelCnt	; Title_MLAccelCnt += Temp_Var1

	LDA <Title_ObjXVel,X	; Get X velocity
	ADC <Temp_Var2		; Add Temp_Var2, including carry from above operation
	STA <Title_ObjXVel,X	; Store result back...

PRG024_AFE9:
	JSR Title_AddVel_toPos	; Apply the X velocity
	RTS		 	; Return...

	.byte $D0, $CE, $CC, $CA, $CA, $CA

PRG024_AFF3:	.byte $C8			; Just a constant (base Y velocity for the queue function)
PRG024_AFF4:	.byte $00, $02, $04, $08	; Loaded by X velocity "whole" part (reduction in that Y velocity based on X speed)



; Title_ML_DoGravity
;
; Handles applying appropriate "fall" rates and the Y velocity of Mario/Luigi
; Also processes queue event $80
Title_ML_DoGravity:

	LDA <Title_ObjMLQueue,X	
	AND #$80	 
	STA <Temp_Var1	 	; Temp_Var1 = Title_ObjMLQueue & $80
	BEQ PRG024_B023	 	; If bit 7 not set, jump to PRG024_B023

	; Begin queue event $80

	LDA <Title_ObjYVelChng,X
	BNE PRG024_B023	 	; If there's a Y velocity change, jump to PRG024_B023

	LDA <Title_ObjXVel,X	; Get X velocity -> A
	BPL PRG024_B00D	 	; If >= 0, jump to PRG024_B00D

	; Otherwise, negate it!  (Get absolute value)
	NEG

PRG024_B00D:
	LSR A
	LSR A
	LSR A
	LSR A		 
	TAY		 	; Y = X velocity >> 4 (the upper "whole" part of this 4.4FP number)
	LDA PRG024_AFF3	 	; A = $C8 (unnecessary constant memory load?)
	SUB PRG024_AFF4,Y	; Variable subtracted value (faster the X velocity is, the less of a Y velocity we end up with)
	STA <Title_ObjYVel,X	; Store result as Y velocity

	LDA #$01	 
	STA <Title_ObjYVelChng,X 	; Indicate a Y velocity change
	LDA #$00
	STA <Title_ObjMLTailTick,X	; Zero out the tail wagging

	; End of queue event $80


PRG024_B023:
	LDA <Title_ObjYVelChng,X
	BEQ PRG024_B053	 	; If no Y velocity change, jump to PRG024_B053

	LDY #FALL_NORMAL 	; Y = FALL_NORMAL (normal falling rate)

	LDA <Title_ObjYVel,X	; Get the Y velocity
	CMP #-32	 	
	BGS PRG024_B037	 	; If Y velocity >= -32, jump to PRG024_B037

	LDA <Title_ObjMLDir,X	; Get the direction vector
	AND #$80	 	
	BEQ PRG024_B037	 	; If bit 7 (tail wagging) is not set, jump to PRG024_B037

	LDY #FALL_TAILWAG 	; Y = FALL_TAILWAG (slower falling rate when wagging raccoon tail)

PRG024_B037:
	TYA		 	; A = Y (1 or 5)
	ADD <Title_ObjYVel,X	 
	STA <Title_ObjYVel,X	; Title_ObjYVel += Y (1 or 5)

	LDA <Title_ObjMLPower,X	
	CMP #$02	 
	BNE PRG024_B053	 	; If Mario/Luigi's power level is not 2 (leaf raccoon), jump to PRG024_B053

	; Leaf raccoon only...
	LDA <Title_ObjMLDir,X
	AND #$80	 
	BEQ PRG024_B053	 	; If direction vector bit 7 is not set, jump to PRG024_B053

	LDA <Title_ObjYVel,X	 
	CMP #FALLRATE_TAILWAGMAX	 
	BLS PRG024_B053	 	; If Y velocity < FALLRATE_TAILWAGMAX, jump to PRG024_B053

	; Prevent Y velocity from being any greater than FALLRATE_TAILWAGMAX
	; Allows tail wagging to not affect when moving upward
	LDA #FALLRATE_TAILWAGMAX
	STA <Title_ObjYVel,X

PRG024_B053:
	JSR Title_MLYAccel	 ; Apply Y velocity

	LDA <Title_YPosHi,X	; Get the most significant byte of the Y position
	BEQ PRG024_B060	 	; If = 0, jump to PRG024_B060

	; Otherwise, forces Y velocity to $20 (?)
	LDA #$20	 
	STA <Title_ObjYVel,X
	BNE PRG024_B070		; Jump (technically always) to PRG024_B070 (RTS)

PRG024_B060:
	LDA <Title_ObjY,X
	CMP #160
	BLT PRG024_B070	 	; If Object Y is less than 160, jump to PRG024_B070 (RTS)

	; This prevents the objects from falling beneath the 160 line on the title screen (pseudo-detection of "solid" floor)
	LDA #160
	STA <Title_ObjY,X	; Prevent object Y from being >= 160

	; Zero out the Y velocity and change
	LDA #$00	 	
	STA <Title_ObjYVelChng,X
	STA <Title_ObjYVel,X	

PRG024_B070:
	RTS		 ; Return


; Title_AddVel_toPos
;
; This adds the X or Y velocity to an extended precision X or Y position storage
; to enable the velocity to operate as a 4.4 fixed point value, with
; a 20.4 bit X position coordinate...
Title_AddVel_toPos:
	; X is 0-7,  objects X velocity
	; X is 8-15, objects Y velocity

	; Going to perform a faux 16-bit shift 4 bits to the left on the X velocity

	LDA <Title_ObjXVel,X	; Get velocity of Mario/Luigi
	PHA		 	; Save it

	; Produce the lower half
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var12	; Temp_Var12 = velocity << 4 (multiplied by 16)

	LDY #$00	 	; Y = 0
	PLA		 	; Restore A (as velocity)

	; Produce the upper half
	LSR A
	LSR A
	LSR A
	LSR A
	CMP #$08	 	
	BLT PRG024_B088	 	; If (velocity >> 4) < 8, jump to PRG024_B088 (detects a negative source value, because there's on ASR type instruction)

	; (velocity >> 4) >= 8 ... (velocity is negative)
	DEY		 	; Y-- (Y = -1)
	ORA #$f0	 	; Simulates carrying the negative sign bit across the value, like an ASR instruction would

PRG024_B088: 
	STA <Temp_Var11		; Store resultant value into Temp_Var11

	; Register 'Y' also contains an additional level of high bits 
	; (i.e. is zero if this is positive, $FF if negative, carrying the sign across)
	STY <Temp_Var13		; Y -> Temp_Var13

	; So essentially what happened at this point is that the X velocity
	; has become a 24-bit value, shifted up 4 bits from its original
	; [Temp_Var13][Temp_Var11][Temp_Var12] = XVel << 4

	; Title_XPosFrac works as an fractional accumulator
	LDA <Title_XPosFrac,X
	ADD <Temp_Var12
	STA <Title_XPosFrac,X	; Title_XPosFrac += Temp_Var12

	; ... which, as it overflows, provides a carry into the "whole" part
	LDA <Title_ObjX,X
	ADC <Temp_Var11	
	STA <Title_ObjX,X	; Title_ObjX += Temp_Var11 + Carry

	; ... and if that overflows, the carry goes into the "high" part...
	LDA <Title_XPosHi,X	
	ADC <Temp_Var13	
	STA <Title_XPosHi,X	; Further precision of the X position stored here

	RTS		 	; Return...


; Title_MLYAccel
;
; Figures out Mario/Luigi's Y acceleration and applies it (including "gravity", and max fall rate)
Title_MLYAccel:
	LDA <Title_ObjYVel,X
	BMI Title_ApplyYVel	 	; If Y velocity is negative, jump to Title_ApplyYVel

	CMP #FALLRATE_MAX
	BLS Title_ApplyYVel		; If Y velocity is less than FALLRATE_MAX, jump to Title_ApplyYVel

	; Prevent Y velocity from being greater than FALLRATE_MAX
	; This defines the maximum fall speed!
	LDA #FALLRATE_MAX	 
	STA <Title_ObjYVel,X

Title_ApplyYVel:

	; NOTE: The "minor" objects also use code starting HERE (they have different fall/max rates)

	TXA		 ; X (object index) -> A
	PHA		 ; Save A

	; The index gets an offset added to it; this allows reuse of the velocity
	; precision adding function as X or Y velocity... relies on all pertinent values
	; to be exactly the same bytes apart...
	ADD #(Title_ObjYVel - Title_ObjXVel)
	TAX		 ; X = (object index) + 8

	JSR Title_AddVel_toPos	 ; Apply Y velocity

	PLA		 ; Restore A
	TAX		 ; Restore X back to the index value

	RTS		 ; Return

PRG024_B0B8:
	.byte $07, $06, $05, $04, $03, $02, $01, $01, $01

; Title_AnimateMarioLuigi
;
; This lengthy routine is what translates movement hints and velocities
; into animations for our favorite little plumbers...
Title_AnimateMarioLuigi:
	; Input object is assumed to be 0 (Mario) or 1 (Luigi)

	; Absolute value of this object's X velocity
	LDA <Title_ObjXVel,X
	BPL PRG024_B0CA	 	; If X velocity is positive, jump to PRG024_B0CA

	; Otherwise, negate it
	NEG
PRG024_B0CA:

	; Shift velocity down 3 times (divide by 8)
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = X vel absolute magnitude / 8

	; Animation speed will change based on the velocity
	INC <Title_ObjMLDirTicks,X	; Increment animation ticks
	LDA <Title_ObjMLDirTicks,X	; Get it -> A
	CMP PRG024_B0B8,Y	 	; Compare it against the value in Y
	BMI PRG024_B0E7	 		; If it hasn't overflowed yet, jump down to PRG024_B0E7

	; Animation ticks meet or exceed the value in Y!

	LDA #$00
	STA <Title_ObjMLDirTicks,X	 ; Reset the ticks

	INC <Title_ObjMLAnimFrame,X	 ; Increment the frame

	; Cap the frame 0-3
	LDA <Title_ObjMLAnimFrame,X
	CMP #$04	 
	BMI PRG024_B0E7	 
	LDA #$00	 
	STA <Title_ObjMLAnimFrame,X

PRG024_B0E7:
	LDA <Title_ObjMLDir,X
	AND #$03	
	BNE PRG024_B0F5	 ; If Mario/Luigi is moving left or right, jump to PRG024_B0F5

	LDA <Title_ObjXVel,X
	BNE PRG024_B0F5	 ; If X velocity <> 0, jump to PRG024_B0F5

	; If Title_ObjMLDir & 3 = 0 and x velocity = 0, force frame to 2 (standing)
	LDA #$02
	STA <Title_ObjMLAnimFrame,X	 

PRG024_B0F5:

	; Store flags value into Temp_Var1
	LDA <Title_ObjMLFlags,X
	STA <Temp_Var1

	LDA <Title_ObjMLDir,X
	AND #$03
	BEQ PRG024_B109

	; If animation is 1, 2, or 3...
	LDY #$00	 
	AND #$02	 
	BNE PRG024_B107	 ; If it's specifically 2, jump to PRG024_B107

	LDY #SPR_HFLIP	 ; Otherwise, Y = SPR_HFLIP

PRG024_B107:
	STY <Title_ObjMLFlags,X	 ; Update flags value

PRG024_B109:
	LDA <Title_ObjMLFlags,X	
	EOR <Temp_Var1		
	STA <Temp_Var1		 ; Store only the difference in flags -> Temp_Var1

	; Mario/Luigi's current power offsets their default frame value (+4 for each power level)
	LDA <Title_ObjMLPower,X
	ASL A		 
	ASL A		 
	ORA <Title_ObjMLAnimFrame,X

	TAY		 		; frame -> Y
	LDA Title_ObjMLWalkSprite,Y	; Get the proper sprite frame (actual system sprite drawer)
	STA <Title_ObjMLSprite,X	; Make this the next sprite to display

	LDA <Title_ObjXVel,X	 
	ADD #$01	 
	CMP #$03	
	BLT PRG024_B135	 		; If X Vel + 1 < 3, jump to PRG024_B135

	; If the directions conflict, do skid
	LDA <Title_ObjMLMoveDir,X
	AND <Title_ObjMLDir,X	
	BEQ PRG024_B135	 		; If Title_ObjMLMoveDir & Title_ObjMLDir = 0 (moving one way, facing the other), jump to PRG024_B135 (no skid)

	; Use the skid frame!
	LDY <Title_ObjMLPower,X		; Y = power level
	BEQ PRG024_B130	 		; If Title_ObjMLPower = 0 (small), jump to PRG024_B130
	LDY #$01	 		; Otherwise, Y = 1 (same skid for Big or Leaf Raccoon)
PRG024_B130:
	LDA Title_ObjMLSkidSprite,Y	; Get the skid sprite
	STA <Title_ObjMLSprite,X	; Make this the next sprite to display

PRG024_B135:

	LDA <Title_ObjMLDir,X
	AND #$04	 	
	BEQ PRG024_B156	 		; If the direction is not downward, jump to PRG024_B156

	; Direction downward, i.e. need to duck!Title_DrawMarioLuigi
	LDY <Title_ObjMLPower,X		
	LDA Title_ObjMLDuckSprite,Y	; Get appropriate sprite by power level
	STA <Title_ObjMLSprite,X 	; Make this the next sprite to display

	LDA <Title_ObjMLQueue,X
	AND #$04	 	
	BEQ PRG024_B156	 		; If not time for Luigi's rebound off Mario, jump to PRG024_B156

	; This does Luigi's rebound off Mario

	; In short, Y is 0 if Luigi, 1 if Mario (opposite the usual order)
	LDY #$00	 		; Y = 0
	TXA		 		; A = X (player index, 0/1)
	BNE PRG024_B14E	 		; If player index is not zero, jump to PRG024_B14E
	INY		 		; Otherwise increment Y
PRG024_B14E:

	LDA #-96	 		; Luigi's bounce velocity
	STA Title_ObjYVelChng,Y	 	; Store the change in velocity
	STA Title_ObjYVel,Y	 	; And set the velocity

PRG024_B156:
	LDA <Title_ObjMLDir,X	 	
	AND #$08	 		
	BEQ PRG024_B160	 		; If the direction is not upward, jump to PRG024_B160

	; Direction upward, look upward
	LDA #$17	 		; The "looking upward" sprite
	STA <Title_ObjMLSprite,X	; Make this the next sprite to display

PRG024_B160:
	LDA <Title_ObjYVelChng,X
	BEQ PRG024_B19A	 		; If no change in Y velocity, jump to PRG024_B19A
	LDA <Title_ObjMLPower,X	 	
	BEQ PRG024_B19A	 		; If power level = 0 (small), jump to PRG024_B19A

	CMP #$02
	BNE PRG024_B190	 		; If not leaf raccoon, jump to PRG024_B190

	; Leaf raccoon with change in Y velocity...

	LDA #$15			; Sprite to display (fist pump upward, leaf raccoon version)

	LDY <Title_ObjYVel,X
	BMI PRG024_B198	 		; If Y velocity is negative, jump to PRG024_B198

	LDA <Title_ObjMLTailTick,X
	BEQ PRG024_B17B	 		; If tail tick = 0, jump to PRG024_B17B

	DEC <Title_ObjMLTailTick,X	; Decrement tail tick
	JMP PRG024_B185	 		; Jump to PRG024_B185...

PRG024_B17B:
	; Tail ticker has hit zero!

	LDA <Title_ObjMLDir,X
	AND #$80	 
	BEQ PRG024_B185	 		; If not wagging tail, jump to PRG024_B185

	LDA #10
	STA <Title_ObjMLTailTick,X	; Title_ObjMLTailTick = 10

PRG024_B185:
	; Y = Title_ObjMLTailTick / 4
	LDA <Title_ObjMLTailTick,X
	LSR A		 
	LSR A		 
	TAY

	LDA Title_ObjMLTailWagSprite,Y	; Get proper tail wag frame as the next frame to display
	JMP PRG024_B198	 		; Jump to PRG024_B198

PRG024_B190:
	; Change in Y velocity, NOT leaf raccoon

	LDA #$14			; Sprite to display (fist pump upward, non-leaf raccoon version)

	LDY <Title_ObjYVel,X	 
	BMI PRG024_B198			; If Y velocity < 0, jump to PRG024_B198 (i.e. do the fist pump)

	LDA #$00	 		; Otherwise, do the first walk frame (fall frame)

PRG024_B198:
	STA <Title_ObjMLSprite,X	; Make whatever 'A' turned out to be the next frame to display!

PRG024_B19A:
	; No change in Y velocity, or power level is 0 (small)

	LDA <Title_ObjMLKickTick,X
	BEQ PRG024_B1A4	 		; If not currently "kicking", jump to PRG024_B1A4

	DEC <Title_ObjMLKickTick,X	; Decrement the kick tick

	LDA #$0d	 		; Kick sprite
	STA <Title_ObjMLSprite,X	; Make this the next sprite to display

PRG024_B1A4:
	LDA <Title_ObjMLBonkTick,X	 
	BEQ PRG024_B1AE	 		; If not being "bonked", jump to PRG024_B1AE

	DEC <Title_ObjMLBonkTick,X	; Decrement bonk ticks

	LDA #$16	 		; Bonk sprite
	STA <Title_ObjMLSprite,X	; Make this the next sprite to display

PRG024_B1AE:
	TXA		 
	BNE PRG024_B1C9	 		; If Luigi, jump to PRG024_B1C9

	; Only Mario gets to do the "power down" animation...
	LDA <Title_ObjMPowerDown
	BEQ PRG024_B1C9	 		; If not doing the animation, jump to PRG024_B1C9

	; Use Title_ObjMPowerDown / 4 to determine the appropriate sprite
	LSR A
	LSR A
	TAY
	LDA Title_ObjMarioPowerDown,Y
	STA <Title_ObjMLSprite		; Make this the next sprite to display

	; Mario's power level winds up at 0 (small) if the shrinkage sprite is at $11
	; Probably just so the right patterns are loaded is all...
	LDY #$00	 		; Power level 0 (small)
	CMP #$11	 
	BEQ PRG024_B1C5	 
	LDY #$01	 		; Power level 1 (Big) 

PRG024_B1C5:
	STY <Title_ObjMLPower		; Change power level
	DEC <Title_ObjMPowerDown	; Decrement the power down counter

PRG024_B1C9:
	LDA <Title_ObjMLHold,X	 
	BNE PRG024_B1D5	 		; If holding something, jump to PRG024_B1D5

	; Activates the "hold"
	LDA <Title_ObjMLQueue,X
	AND #$20	 	
	BEQ PRG024_B204	 		; If not time to begin carrying, jump to PRGO24_B204

	STA <Title_ObjMLHold,X		; Start carrying!

PRG024_B1D5:

	; Gets frame -> Y, unless no Y velocity change, in which case Y = 0
	LDY <Title_ObjMLAnimFrame,X	
	LDA <Title_ObjYVelChng,X
	BEQ PRG024_B1DD	
	LDY #$00	
PRG024_B1DD:
	LDA Title_ObjMLCarrySprite,Y	; Holding something, change frame to appropriate "carry" frame alternate
	STA <Title_ObjMLSprite,X	; Make this the next sprite to display

	LDA <Temp_Var1		 	; Get sprite flags (stored LONG ago...)
	BEQ PRG024_B1EA	 		; If zero, jump to PRG024_B1EA

	LDA #$08	 
	STA <Title_ObjMLBonkTick,X	; Title_ObjMLBonkTick = 8

PRG024_B1EA:
	LDA <Title_ObjMLBonkTick,X
	BEQ PRG024_B1F4
	DEC <Title_ObjMLBonkTick,X	; Decrement bonk ticks

	LDA #$0a	 		; Face-forward sprite frame
	STA <Title_ObjMLSprite,X	; Make this the next sprite frame to display

PRG024_B1F4:
	LDA <Title_ObjMLQueue,X	 
	AND #$40	 
	BEQ PRG024_B204	 		; If not doing clear carrying/bonk, do kick, jump to PRG024_B204

	; Clear carrying/bonk, do kick

	LDA #$00	 
	STA <Title_ObjMLHold,X	 	; Clear the carrying flag
	STA <Title_ObjMLBonkTick,X	; Clear the bonk tick

	LDA #10
	STA <Title_ObjMLKickTick,X	; Title_ObjMLKickTick = 10

PRG024_B204:
	RTS		 ; Return


	; Defines offsets of 16, 8, or 0 for sprite while building
Title_SpriteOffX:
	.byte 16, 8, 0

	; Per-power level offset to the VROM page
Title_SpriteVROMPwrOff:
	.byte $50	; 0 Small
	.byte $54	; 1 Big
	.byte $00	; 2 Leaf Raccoon

; Title_DrawMarioLuigi
;
; Not literally "draw", of course, but set up their hardware
; sprites in Sprite_RAM to be "drawn"...
Title_DrawMarioLuigi:
	; Input object is assumed to be 0 (Mario) or 1 (Luigi)

	LDY <Title_ObjMLSprite,X	; Get the sprite to display
	LDA Title_SpriteVROMPage,Y	; Get appropriate VROM page for this sprite index

	; VROM pages 0 - 3 are power-up based and an offset is added depending on the bro's power levels
	CMP #$04
	BGE PRG024_B21E	 		; If VROM page >= 4, jump to PRG024_B21E

	STA <Temp_Var1		 	; Store VROM Page in Temp_Var1
	LDY <Title_ObjMLPower,X	 	; Power level -> Y
	LDA Title_SpriteVROMPwrOff,Y	; Get VROM page offset for this power level
	ADD <Temp_Var1		 	; Add Temp_Var1

PRG024_B21E:
	STA PatTable_BankSel+2,X 	; Set this VROM page (first quarter of sprite VROM)

	LDA #$00	 
	STA <Temp_Var12		; Clear Temp_Var12

	LDA <Title_ObjMLPower,X	 	
	BNE PRG024_B232	 		; If power level > 0 (small), jump to PRG024_B232

	LDA <Title_ObjMLDir,X	 
	AND #$10	 	
	BEQ PRG024_B232	 		; If Title_ObjMLDir does not want to set sprite priority bit, jump to PRG024_B232

	; This will set BG priority over the sprite
	ASL A		 		; AND $10 means we're $10 before, and $20 after
	STA <Temp_Var12		; Temp_Var12 = $20 (sprite priority bit)

PRG024_B232: 
	; Store Y coordinate -> <Temp_Var15
	LDA <Title_ObjY,X
	STA <Temp_Var15	

	; Store X coordinate -> <Temp_Var16
	LDA <Title_ObjX,X
	STA <Temp_Var16

	; Store flags -> Temp_Var14 
	LDA <Title_ObjMLFlags,X	 
	STA <Temp_Var14		

	; Store Title_ObjMLSprVis -> Temp_Var13
	LDA <Title_ObjMLSprVis,X
	STA <Temp_Var13		
 
	LDY <Title_ObjMLSprite,X	; Get the sprite index again
	LDA Title_SpritePatternIndex,Y	; Get the appropriate sprite tile index (CHECKME?) 
	STA <Temp_Var1		 	; Store into Temp_Var1

	LDA <Title_ObjMLSprRAMOff,X 	; Get Mario/Luigi's sprite RAM offset
	PHA		 		; Save 'A' (Title_ObjMLSprRAMOff)

	TAX		 		; X = Title_ObjMLSprRAMOff
	LDY #$02	 		; Y = 2

	; Loop begin...
PRG024_B24F:
	TYA		 		; A = 2 (loop counter, Mario/Luigi are 2-3 sprites across [top vs bottom])
	PHA		 		; Save 'A' 

	LDY <Temp_Var1		 	; Y = sprite tile index

	LDA Title_SpritePattern,Y	 	; Get tile for this sprite index
	STA Sprite_RAM+$0D,X	 	; Set pattern number of sprite

	LDA Title_SpritePattern + 3,Y	; Get next tile for this sprite index
	STA Sprite_RAM+$01,X	 	; Set pattern number of adjacent sprite

	PLA		 		; Restore 'A'
	TAY		 		; Y = A (amounts to sprite offset of 0 @ 2, 8 @ 1, 16 @ 0)

	LDA <Temp_Var14		; Get flags value
	AND #%11000000	 		; Only caring about the horizontal / vertical flip
	ORA <Title_CurMLIndex		; Set appropriate palette by using the index value, which works out
	ORA <Temp_Var12		; 0 or $20 (choosing priority)

	; Apply same "byte 2" to both sprites
	STA Sprite_RAM+$02,X	
	STA Sprite_RAM+$0E,X	

	; Only set the Y coordinates if this part of the sprite is visible (as determined by Title_MLDetermineSpriteVis)
	; If the carry is set by the shift, we know NOT to draw this "sliver" of the sprite
	ASL <Temp_Var13		; Shift Title_ObjMLSprVis value left (updates Temp_Var13)
	BCS PRG024_B27E	 	; If bit 7 was set, jump to PRG024_B27E

	; Optionally skipped part...

	LDA <Temp_Var15		; Get Y coordinate
	STA Sprite_RAM+$0C,X	; Set Y coordinate of sprite
	ADD #16
	STA Sprite_RAM,X	; Set Y coordinate of adjacent sprite, 16 pixels beneath the one above

PRG024_B27E:

	LDA <Temp_Var16	; Get X coordinate
	ADD Title_SpriteOffX,Y	; Add offset of 16, 8, or 0 as appropriate by 'Y'
	STA Sprite_RAM+$03,X	; Store X coordinate
	STA Sprite_RAM+$0F,X	; Store X coordinate

	INX
	INX
	INX
	INX			; X += 4

	INC <Temp_Var1		; Increment the sprite tile index
	DEY		 	; Decrement Y
	BPL PRG024_B24F	 	; As long as Y >= 0, loop

	PLA		 	; Restore 'A' (Title_ObjMLSprRAMOff)
	TAX		 	; X = A

	LDA <Temp_Var14	; Get flags
	AND #%01000000	 	
	BEQ PRG024_B2C3	 	; If not horizontally flipped, jump to PRG024_B2C3

	; This mirrors the sprite layout horizontally

	; Reverse pattern index
	LDA Sprite_RAM+$01,X
	PHA		 
	LDA Sprite_RAM+$05,X
	STA Sprite_RAM+$01,X
	PLA		 
	STA Sprite_RAM+$05,X

	; Reverse X coordinates
	LDA Sprite_RAM+$0B,X
	ADD #-24
	STA Sprite_RAM+$0B,X
	STA Sprite_RAM+$17,X

	LDA Sprite_RAM+$D,X
	PHA		 
	LDA Sprite_RAM+$11,X
	STA Sprite_RAM+$D,X
	PLA		 
	STA Sprite_RAM+$11,X

PRG024_B2C3:
	LDA Sprite_RAM+$01,X
	CMP Sprite_RAM+$05,X
	BNE PRG024_B2DE	 	; If the first and second patterns are NOT the same, jump to PRG024_B2DE

	; When the first and second patterns are the same, this is assumed to be a "mirrored" sprite
	; (Think the "going down pipe" or "tail swing" face-forward frames)

	LDA Sprite_RAM+$0E,X	; Take attributes of this sprite
	AND #%10111111	 	; Keep everything EXCEPT the horizontal flip bit
	STA Sprite_RAM+$02,X	; Update both top  
	STA Sprite_RAM+$0E,X	; ... and bottom

	ORA #%01000000	 	; Set the horizontal flip
	STA Sprite_RAM+$06,X	; Update the other side
	STA Sprite_RAM+$12,X	; Ditto

PRG024_B2DE:
	LDY <Title_CurMLIndex	; Y = Mario [0] or Luigi [1]
	LDA Title_ObjMLSprite,Y	; Get their current sprite index
	CMP #$0d	 	
	BNE PRG024_B307	 	; If current sprite is not $0D (kicking outward), jump to PRG024_B307

	; The kicking sprite needs one of the sprites in front for the outward foot!
	LDA Sprite_RAM,X	 
	STA Sprite_RAM+$14,X	 ; Match the Y coordinate

	; Facing left, foot is to the left
	LDA #-8			; A = -8

	; This refers to whether Mario / Luigi is horizontally flipped, but seems wrong?
	; Should only check if NOT h-flipped?

	LDY <Temp_Var14	; Y = Flags
	BEQ PRG024_B2F6		; If flags = 0 (?? this is unlikely?), jump to PRG024_B2F6

	; Facing right, foot is to the right
	LDA #16			; A = 16

PRG024_B2F6:
	ADD Sprite_RAM+$0F,X	; Apply X offset
	STA Sprite_RAM+$17,X	; Duplicate result

	LDA #$1b	 	; Foot pattern
	STA Sprite_RAM+$15,X	; Set it

	; Duplicate attribute settings
	LDA Sprite_RAM+$0E,X
	STA Sprite_RAM+$16,X

PRG024_B307:
	LDY #$05	 	; Y = 5 (loop through all five sprites for Mario/Luigi)

PRG024_B309:
	LDA Sprite_RAM+$01,X	; Get pattern
	CMP #$f1	 
	BNE PRG024_B317	 	; If pattern is not $F1, jump to PRG024_B317

	; Pattern $F1 is used as a disable:
	LDA #$f8	 	
	STA Sprite_RAM,X	; Forces this sprite's Y into oblivion, making it invisible
	BNE PRG024_B324	 	; Jump (technically always) to PRG024_B324

PRG024_B317:
	LDA <Title_CurMLIndex	
	BEQ PRG024_B324	 	; If Mario, jump to PRG024_B324

	; Otherwise, add $40 (Luigi is using second VROM bank)
	LDA Sprite_RAM+$01,X
	ADD #$40
	STA Sprite_RAM+$01,X

PRG024_B324:
	INX
	INX
	INX
	INX		 ; X += 4 (next sprite)
	DEY		 ; Y--
	BPL PRG024_B309	 ; Loop while Y >= 0

	
	LDX <Title_CurMLIndex	; Leaving with 'X' set to what it entered with!
	RTS		 ; Return


	; XOff and XHiOff are basically 16-bit values when put together

Title_MLSpriteVis_XHiOff:
	.byte 0, 0, 0		; Not H-Flipped
	.byte 0, 0, $FF		; H-Flipped ($FF represents a full set of sign bits, for the corresponding '-8' in XOff)

Title_MLSpriteVis_XOff:
	.byte 0, 8, 16		; Not H-Flipped
	.byte 0, 8, -8		; H-Flipped

Title_MLSpriteVis_BitVal:
	; Bit vals to mark which slivers NOT to display
	.byte $80, $40, $20	; Not H-Flipped
	.byte $80, $40, $20	; H-Flipped

; Title_MLDetermineSpriteVis
;
; This function determines which "slivers" of the Player sprite are invisible, by checking if they
; cross screen boundaries (which will make them invisible), to prevent sprites "wrapping" around
; the screen, due to the limit of the 'X' part of the sprite coordinate...
Title_MLDetermineSpriteVis:
	LDA #$00	 	; A = 0
	STA <Title_ObjMLSprVis,X	; Clear Title_ObjMLSprVis

	LDY #$02	 	; Y = 2 (not H-flipped)

	LDA <Title_ObjMLFlags,X	; Get flags -> 'A'
	AND #SPR_HFLIP
	BEQ PRG024_B34E	 	; If not flipped horizontally, jump to PRG024_B34E

	LDY #$05	 	; Y = 5 (H-flipped)

	; This will loop 5, 4, 3 (H-flipped) OR 2, 1, 0 (not H-flipped)
PRG024_B34E:

	; 16-bit + 16-bit add here [Title_XPosHi][Title_ObjX] += [XHiOff][XOff]
	LDA <Title_ObjX,X		; Get object's X position
	ADD Title_MLSpriteVis_XOff,Y	; A += Title_MLSpriteVis_XOff[Y]
	LDA <Title_XPosHi,X		; Get object's "high" part of the X value
	ADC Title_MLSpriteVis_XHiOff,Y	; A += Title_MLSpriteVis_XHiOff[Y], with carry from previous op

	BEQ PRG024_B362	 		; If the X pos high value added with the Title_MLSpriteVis_XHiOff[Y] value is zero, jump to PRG024_B362

	; Otherwise, set a bit
	LDA <Title_ObjMLSprVis,X
	ORA Title_MLSpriteVis_BitVal,Y	
	STA <Title_ObjMLSprVis,X	 	; Title_ObjMLSprVis |= Title_MLSpriteVis_BitVal[Y]

PRG024_B362:
	DEY		 	; Y--
	BMI PRG024_B369	 	; If Y < 0, jump to PRG024_B369 (RTS)

	CPY #$02	
	BNE PRG024_B34E	 	; If Y <> 2, jump to PRG024_B34E

PRG024_B369:
	RTS		 ; Return


	; Patterns of the "poof" sprites, per frame of poofing
Title_Poof_Patterns:	.byte $87, $85, $83, $81

; Title_MarioDoPoof
; 
; Handles doing Mario's (only) "poof" effect after catching the leaf
Title_MarioDoPoof:
	; X is index of Mario/Luigi

	TXA		; X -> A
	BNE PRG024_B3C2	; If index is not zero (i.e. Luigi), jump to PRG024_B3C2 (RTS)

	; Mario only!

	LDA Title_MarioPoof
	BEQ PRG024_B3C2	 	; If the power-up "poof" effect is not occurring, jump to PRG024_B3C2 (RTS)

	DEC Title_MarioPoof	; Title_MarioPoof--

	AND #%1100
	LSR A	
	LSR A	
	TAY		 	; Y is now only bits 2 and 3 from Title_MarioPoof (provides 4 frames)

	; Get pattern -> Temp_Var2
	LDA Title_Poof_Patterns,Y
	STA <Temp_Var2

	LDY <Title_ObjMLSprRAMOff	; Get the offset into Sprite_RAM for Mario

	LDA #%11000000
	STA <Temp_Var1		 	; Sprite attributes in Temp_Var1 (H and V flip right now)

PRG024_B389:
	LDA <Title_ObjY		 	; Get Mario's Y
	ADD #$08	 		; +8
	STA Sprite_RAM,Y	 	; Store as sprite's Y

	LDA <Temp_Var2		 	
	STA Sprite_RAM+$01,Y	 	; Store poof pattern into sprite

	LDA <Temp_Var1
	STA Sprite_RAM+$02,Y	 	; Store current attributes

	LDA <Title_ObjX		 
	STA Sprite_RAM+$03,Y	 	; Store sprite X coordinate

	LDA <Temp_Var1
	AND #$f0	 
	BEQ PRG024_B3AF	 		; If the upper 4 bits of the attribute are zero, jump to PRG024_B3AF

	; Otherwise, add 8 to the sprite's X
	LDA Sprite_RAM+$03,Y
	ADD #$08	 
	STA Sprite_RAM+$03,Y

PRG024_B3AF:
	INY
	INY
	INY
	INY		; Y += 4 (go to next sprite)

	LDA <Temp_Var1	
	SUB #$c0	
	STA <Temp_Var1	; Temp_Var1 -= $C0
	BCS PRG024_B389	; Loop once...

	; Ensure that there's no active velocity being applied!
	LDA #$00
	STA <Title_ObjYVel
	STA <Title_ObjXVel

PRG024_B3C2:
	RTS		 ; Return


Title_UpdateOtherObjs:
	LDX #$05	 	; X = 5 (for the 6 title screen objects)

PRG024_B3C5:
	LDA <Title_ObjStates,X
	BEQ PRG024_B3D6	 	; If object state = 0 (inactive), jump to PRG024_B3D6

	CMP #$01
	BNE PRG024_B3D3	 ; If object state <> 1, jump to PRG024_B3D3

	JSR Title_UpdateObjState1	; Perform state 1 duty of this object
	JMP PRG024_B3D6	 		; Jump to PRG024_B3D6

PRG024_B3D3:
	; Object state > 1
	JSR Title_UpdateObj 	 	; Perform post-state 1 duty of this object

PRG024_B3D6:
	LDA Title_ObjVar,X
	BEQ PRG024_B3DE	 	; If this object's ObjVar = 0, jump to PRG024_B3DE
	DEC Title_ObjVar,X	; Otherwise, decrement it

PRG024_B3DE:
	DEX		 	; X-- (next object)
	BPL PRG024_B3C5	 	; If X >= 0, jump to PRG024_B3C5

	RTS		 	; Return...

	; Starting X coordinates for the different map objects
Title_ObjStartX:
	.byte $D0	; 0 = Starman
	.byte $20	; 1 = Mushroom
	.byte $60	; 2 = Super Leaf
	.byte $43	; 3 = Goomba
	.byte $B0	; 4 = Buzzy Beatle
	.byte $78	; 5 = Koopa shell
	
Title_UpdateObjState1:
	; X is the title screen object index, 0-5

	; Store object's starting X coordinate
	LDA Title_ObjStartX,X
	STA <Title_ObjX+2,X

	; All object's start at Y pos = 0
	LDA #$00	
	STA <Title_ObjY+2,X

	; Clear the object's velocities and state values
	LDA #$00
	STA <Title_ObjXVel+2,X
	STA <Title_ObjYVel+2,X
	INC <Title_ObjStates,X

	TXA		 ; A = X (object index)
	JSR DynJump	 ; Jump dynamically based on object's index

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Title_ObjS1_None		; 0 - Starman
	.word Title_ObjS1_None		; 1 - Mushroom
	.word Title_ObjS1_Leaf		; 2 - Super leaf
	.word Title_ObjS1_Goomba	; 3 - Goomba 
	.word Title_ObjS1_None		; 4 - Buzzy Beatle
	.word Title_ObjS1_None		; 5 - Koopa shell

Title_ObjS1_None:
	RTS

Title_ObjS1_Leaf:

	; Clear velocity (again?) and Title_ObjVar2 (used as swing determination)
	LDA #$00	 
	STA <Title_ObjXVel+2,X
	STA Title_ObjVar2,X	 

	LDA #$10
	STA Title_ObjVar,X	 ; Title_ObjVar = $10

	LDA #$04	 	
	STA <Title_ObjYVel+2,X	; Leaf's Y velocity = 4

	RTS		 ; Return

Title_ObjS1_Goomba:

	; Title_ObjVar2 is used as a tick counter delaying the start to the goomba's move
	LDA #185	 
	STA Title_ObjVar2,X	 ; Title_ObjVar2 = 185

	RTS		 ; Return

Title_UpdateObj:
	TXA		 ; 'X' is the object index, but DynJump uses 'A'
	JSR DynJump	 ; Dynamically jump...

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Title_DoStarman
	.word Title_DoMushroom
	.word Title_DoLeaf 
	.word Title_DoGoomba
	.word Title_DoBuzzyBeatle
	.word Title_DoKoopaShell 

Title_DoStarman:
	JSR Title_ObjCommonXYVel	; Handle velocity standard
	BNE PRG024_B43E	 		; If object did not fall below line 176, jump to PRG024_B43E

	; Otherwise...
	LDA #$20
	STA <Title_ObjXVel+2,X	 ; X velocity set to $20 (initial bounce, bounces away)
	LDA #-80
	STA <Title_ObjYVel+2,X	 ; Y velocity set to -80 (bounce)

PRG024_B43E:
	JSR Title_ObjDraw		; Draw the starman!
	JMP Title_ObjCommonFinale	; Do common finale code

Title_DoMushroom:
	JSR Title_ObjCommonXYVel	; Handle velocity standard
	BNE PRG024_B44D			; If didn't hit ground, jump to PRG024_B44D

	; Otherwise begin moving after hitting ground
	LDA #$f0	
	STA <Title_ObjXVel+2,X

PRG024_B44D:
	JSR Title_ObjDraw		; Draw the mushroom!
	JMP Title_ObjCommonFinale	; Do common finale code

Title_Leaf_XVelAdj:	.byte 2, -2		; X velocity applied to leaf
Title_Leaf_XVelLimit:	.byte 32, -32		; X velocity limits for leaf to swing the other way
Title_Leaf_YVel:	.byte 10, -10, 8	; Y velocities assigned for leaf swinging

Title_DoLeaf:
	LDA Title_ObjVar,X
	BEQ PRG024_B472	 	; If = 0, jump to PRG024_B472

	JSR Title_ApplyYVelFall	; Apply Y velocities

	INC <Title_ObjYVel+2,X	; YVel++

	LDA <Title_ObjYVel+2,X
	CMP #$00	
	BEQ PRG024_B46D	 	; If YVel = 0, jump to PRG024_B46D
	JMP PRG024_B49B	 	; Otherwise, jump to PRG024_B49B

PRG024_B46D:
	; YVel = 0

	; Title_ObjVar is never actually used, just cleared??
	LDA #$00
	STA Title_ObjVar,X	; Clear Title_ObjVar

PRG024_B472:

	; Bit 0 of Title_ObjVar2 determines the current "swing" direction of the leaf
	LDA Title_ObjVar2,X
	AND #$01	 	; Only using 0/1
	TAY		 	; Y = A

	; XVel += Title_Leaf_XVelAdj[Y]
	LDA <Title_ObjXVel+2,X
	ADD Title_Leaf_XVelAdj,Y
	STA <Title_ObjXVel+2,X

	CMP Title_Leaf_XVelLimit,Y
	BNE PRG024_B488	 	; If not equal to Title_Leaf_XVelLimit[Y], jump to PRG024_B488

	INC Title_ObjVar2,X	; Title_ObjVar2++ (just perpetually adds and loops, but only bit 0 is used)

PRG024_B488:
	LDA <Title_ObjXVel+2,X
	BPL PRG024_B48D	 	; If XVel >= 0, jump to PRG024_B48D

	INY		 	; Y++ (1 or 2)

PRG024_B48D:
	LDA Title_Leaf_YVel,Y
	ADD #$06	 
	STA <Title_ObjYVel+2,X	; YVel = Title_Leaf_YVel[Y] + 6

	JSR Title_ObjXVelApply	; Apply X Velocity
	JSR Title_ApplyYVelFall	; Apply Y Velocity

PRG024_B49B:
	LDA #SPR_HFLIP	 	; A = SPR_HFLIP
	LDY <Title_ObjXVel+2,X	; Y = XVel
	BEQ PRG024_B4A7	 	; If XVel = 0, jump to PRG024_B4A7

	BPL PRG024_B4A5	 ; If X velocity > 0, jump to PRG024_B4A5
	LDA #$00	 ; A = 0

PRG024_B4A5:
	STA <Title_ObjFlags,X

PRG024_B4A7:
	JSR Title_ObjDraw	; Draw the leaf!

	LDA <Title_ObjY+2,X
	AND #$f0	; Only considering the most significant bits
	CMP #$50
	BNE PRG024_B4BF	; If the Y position is not in the vicinity of $50, jump to PRG024_B4BF

	; When the leaf hits a certain Y level, the title screen assumes they've connected
	; and gives it to him; no actual object detection is performed...

	LDA #$00	 
	STA <Title_ObjStates,X	 ; Object state = 0 (clear)

	LDA #$13	 
	STA Title_MarioPoof	 ; Title_MarioPoof = $13 

	LDA #$02
	STA <Title_ObjMLPower	 ; Mario is now leaf raccoon!

PRG024_B4BF:
	RTS		 ; Return


Title_DoGoomba:
	JSR Title_ObjCommonXYVel	; Handle velocity standard
	BNE PRG024_B500	 		; If Goomba hasn't hit the floor yet, jump to PRG024_B500

	; Title_ObjVar2 is used as a tick counter
	LDA Title_ObjVar2,X
	BEQ PRG024_B4D0	 		; If Title_ObjVar2 = 0, jump to PRG024_B4D0

	; Otherwise, still waiting for the ticks to run out so the goomba can move...
	DEC Title_ObjVar2,X	 	; Title_ObjVar2--
	JMP Title_ObjDraw	 	; Just draw...

PRG024_B4D0:
	LDA <Title_ObjX+2,X
	CMP #$30	 
	BGE PRG024_B4FC	 	; If goomba is still to the right of X = $30, jump to PRG024_B4FC


	; Goomba has hit its "death" position!
	LDA Title_ObjVar,X	
	BNE PRG024_B4E0	 	; If Title_ObjVar <> 0, jump to PRG024_B4E0


	; Title_ObjVar is used as a counter for the goomba's death...
	; Otherwise, load Title_ObjVar with $10
	LDA #$10	 
	STA Title_ObjVar,X	; Title_ObjVar = $10

PRG024_B4E0: 
	CMP #$01	 
	BNE PRG024_B4E8	 	; If Title_ObjVar <> 1, jump to PRG024_B4E8

	; Title_ObjVar = 1...
	LDA #$00	 
	STA <Title_ObjStates,X	; Set state = 0 (remove)

PRG024_B4E8:

	; Basically if goomba has crossed his death point and hasn't 
	; stopped moving yet, it's about to die...
	LDA <Title_ObjXVel+2,X
	BEQ PRG024_B4F4	 	; If X Velocity = 0, jump to PRG024_B4F4

	; Mario's "stomping" on the goomba
	LDA #$00	 
	STA <Title_ObjXVel+2,X	; GOOMBA'S X velocity = 0
	LDA #-48
	STA <Title_ObjYVel	; MARIO's Y velocity = -48

PRG024_B4F4:
	LDA #$01	 
	STA Title_ObjFrame,X	; ObjFrame = 1 (use "squished" frame)

	JMP Title_ObjDraw	; Draw goomba...

PRG024_B4FC:
	LDA #-8
	STA <Title_ObjXVel+2,X	; Goomba X Velocity = -8 (march left)

PRG024_B500:
	LDA <Counter_1		
	AND #$08	 	; Only interested in a tic counter firing every 8th tick
	ASL A		 
	ASL A		 
	ASL A		 	; Shift the value up 3 (makes $00, $40)
	STA <Title_ObjFlags,X	; Set the object flags (Goomba's "walk" is horizontal flipping of his sprite)
	JMP Title_ObjDraw	; Draw goomba...


Title_DoBuzzyBeatle:

	; Title_ObjVar2 is used as a flag to indicate the buzzy was hit whe non-zero
	LDA Title_ObjVar2,X	
	BNE PRG024_B51D	 	; If <> 0, jump to PRG024_B51D

	LDA <Title_ObjX+2,X	; Buzzy beatle
	SUB <Title_ObjX+7	; Koopa shell
	CMP #16	 	
	BGE PRG024_B543	 	; If the distance between the buzzy beatle and koopa shell is >= 16, jump to PRG024_B543

	INC Title_ObjVar2,X	; Otherwise, Title_ObjVar2 = 1

PRG024_B51D:
	; Buzzy beatle shell was hit

	LDA <Title_ObjXVel+2,X
	BNE PRG024_B52D	 	; If X velocity is non-zero, jump to PRG024_B52D

	LDA #16	 
	STA <Title_ObjXVel+2,X	; X velocity = 16

	LDA #-64
	STA <Title_ObjYVel+2,X	; Y velocity = -64

	LDA #$80	 
	STA <Title_ObjFlags,X	; Vertically flipped

PRG024_B52D:
	; Buzzy beatle shell is flying away...

	; Y velocity += FALL_OBJECT ("gravity")
	LDA <Title_ObjYVel+2,X
	ADD #FALL_OBJECT
	STA <Title_ObjYVel+2,X

	; X/Y velocities
	JSR Title_ObjXVelApply	
	JSR Title_ApplyYVelFall	

	LDA <Title_YPosHi+2,X
	BEQ PRG024_B553	 	; If "high" part of Y position is zero, jump to PRG024_B553

	; Otherwise, set state = 0 (remove)
	LDA #$00
	STA <Title_ObjStates,X
	RTS		 ; Return


PRG024_B543:
	JSR Title_ObjCommonXYVel	; Handle velocity standard
	BNE PRG024_B553	 		; If buzzy beatle shell hasn't hit the floor yet, jump to PRG024_B553

	LDA #$20	
	SUB <Title_ObjYVel+2,X	
	BLT PRG024_B551		; As long as y velocity is less than $20, jump to PRG024_B551

	LDA #$00	 	; Set Y velocity to zero

PRG024_B551:
	STA <Title_ObjYVel+2,X	; Update Y Vel

PRG024_B553:
	JMP Title_ObjDraw	; Draw buzzy beatle shell...


Title_DoKoopaShell:
	LDA <Title_ObjStates,X
	SUB #$02	
	JSR DynJump	 	; Jump based on state - 2 (because state 0 is "removed", state 1 is init, so we're at least in state 2)

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word KS_BonkMario_HitFloor		; 0 - Bonks Mario in the head, hits the floor
	.word KS_Kick_LuigiCatch		; 1 - Mario kicks the shell, and Luigi catches it
	.word KS_LuigiKick_MarioCatch		; 2 - Luigi kicks the shell, Mario catches it
	.word KS_MarioCarry_KickWrapAround	; 3 - Mario holds the shell, kicks it out, shell wraps around screen
	.word KS_HitMario			; 4 - Hit Mario, causing him to power down

KS_BonkMario_HitFloor:
	JSR Title_ObjCommonXYVel
	BNE PRG024_B575	 	; If koopa shell hasn't hit the floor yet, jump to PRG024_B575

	INC <Title_ObjStates,X	; Go to next state

	LDA #$00	 
	STA <Title_ObjXVel+2,X	; X velocity = 0
	BEQ PRG024_B589	 	; Jump (technically always) to PRG024_B589

PRG024_B575:
	LDA <Title_ObjY+2,X
	CMP #144
	BLT PRG024_B589		; If koopa shell Y position is less than $90, jump to PRG024_B589

	; Shell Y pos >= 144... (shell bonks Mario on the head)

	LDA <Title_ObjXVel+2,X
	BNE PRG024_B589	 	; If the X velocity is not zero, jump to PRG024_B589

	LDA #$e8	 
	STA <Title_ObjXVel+2,X	; XVel = $E8
	STA <Title_ObjYVel+2,X	; YVel = $E8

	LDA #$10
	STA <Title_ObjMLBonkTick ; Title_ObjMLBonkTick = $10 (Mario got bonked on the head)

PRG024_B589:
	JMP KS_SpinAnimAndDraw	 ; Shell common end code..


KS_Kick_LuigiCatch:
	JSR Title_ObjCommonXYVel	; Handle velocity standard

	LDA <Title_ObjMLQueue
	AND #$10	 
	BEQ PRG024_B59D	 	; If Title_ObjMLQueue bit 4 was not set (kick shell), jump to PRG024_B59D

	LDA #10	 
	STA <Title_ObjMLKickTick	; Title_ObjMLKickTick = 10 (puts his foot out!)
	LDA #$30	 
	STA <Title_ObjXVel+2,X	 	; X velocity = $30

PRG024_B59D:
	LDA <Title_XPosHi+2,X	 
	BEQ PRG024_B5A5	 		; If the "high" part of the X position is zero, jump to PRG024_B5A5

	; Otherwise, X Velocity = 0 (stop shell)
	LDA #$00	 
	STA <Title_ObjXVel+2,X

PRG024_B5A5:
	LDA <Title_ObjMLHold+1
	BEQ PRG024_B5AB	 		; If Luigi is not holding the shell, jump to PRG024_B5AB

	; Otherwise...
	INC <Title_ObjStates,X	 	; Next state...

PRG024_B5AB:
	JMP KS_SpinAnimAndDraw	 ; Shell common end code..


KS_LuigiKick_MarioCatch:
	LDA <Title_ObjMLHold+1
	BEQ PRG024_B5BB	 	; If Luigi is NOT holding the shell, jump to PRG024_B5BB

	LDA #-48
	STA <Title_ObjXVel+2,X	; X Velocity = -48
	LDY #$01		; Luigi carries the shell
	JMP KS_ShellCarry	; Do KS_ShellCarry

PRG024_B5BB:
	; Luigi is not holding the shell...

	JSR Title_ObjCommonXYVel	; Handle velocity standard

	LDA <Title_ObjX+2,X
	CMP #56
	BGE PRG024_B5D0	 	; If the shell's X position is >= 56, jump to PRG024_B5D0

	LDA <Title_ObjXVel+2,X
	BEQ PRG024_B5D0	 	; If the shell's X velocity is zero, jump to PRG024_B5D0

	LDA #$00	 
	STA <Title_ObjXVel+2,X	; Shell's X velocity = 0
	LDA #-48
	STA <Title_ObjYVel	; MARIO's Y velocity = -48

PRG024_B5D0:
	LDA <Title_ObjMLHold
	BEQ PRG024_B5D6	 	; If Mario is not holding it, jump to PRG024_B5D6

	INC <Title_ObjStates,X	; Next state..

PRG024_B5D6:
	JMP KS_SpinAnimAndDraw	 	; Shell common end code...


KS_MarioCarry_KickWrapAround:
	LDA <Title_ObjMLHold
	BEQ PRG024_B5E2	 	; If Mario is NOT holding the shell, jump to PRG024_B5E2

	LDY #$00		; Mario carries the shell
	JMP KS_ShellCarry	; Do KS_ShellCarry

PRG024_B5E2:
	JSR Title_ObjCommonXYVel	; Handle velocity standard

	LDA #48
	STA <Title_ObjXVel+2,X	 ; X velocity = 48

	LDA <Title_XPosHi+2,X	 
	BEQ PRG024_B5FD	 	; If "high" part of X position is zero, jump to PRG024_B5FD

	; Otherwise, shell's X position (including "high") amount to -16 (wrap around the screen!)
	LDA #$ff	 
	STA <Title_XPosHi+2,X	
	LDA #-16
	STA <Title_ObjX+2,X

	LDA #48
	STA Title_ObjVar,X	 ; Title_ObjVar = 48 (just puts in a delay until actually checking if Mario was hit)

	INC <Title_ObjStates,X	 ; Next state...
	RTS		 	; Return!


PRG024_B5FD:
	JMP KS_SpinAnimAndDraw	 	; Shell common end code...

KS_HitMario:
	LDA Title_ObjVar,X
	BNE PRG024_B627	 	; If ObjVar <> 0, jump to PRG024_B627

	LDA <Title_ObjMPowerDown
	BNE PRG024_B621		; If Mario is powering down, jump to 

	JSR Title_ObjCommonXYVel	; Handle velocity standard

	LDA <Title_XPosHi+2,X	 
	BNE PRG024_B621	 		; If shell's X "high" part is non-zero, jump to PRG024_B621

	LDA <Title_ObjMLPower		 
	BEQ PRG024_B621	 		; If Mario's power level is 0 (small), jump to PRG024_B621

	LDA <Title_ObjX
	SUB <Title_ObjX+2,X
	CMP #16
	BGE PRG024_B621	 		; If the shell greater than 16 pixels away from Mario, jump to PRG024_B621

	LDA #44
	STA <Title_ObjMPowerDown	; Title_ObjMPowerDown = 44 (power down Mario!)

PRG024_B621:
	JSR Title_ObjCommonFinale	; Do common finale code
	JSR KS_SpinAnimAndDraw	 	; Shell common end code...

PRG024_B627:
	RTS		 ; Return

KS_SpinAnimAndDraw:
	LDA <Title_ObjXVel+2,X
	BEQ PRG024_B642	 	; If shell's X velocity = 0, jump to PRG024_B642

	LDA <Title_ObjMPowerDown
	BNE PRG024_B642		; If Mario is currently powering down, jump to PRG024_B642

	; Otherwise, shell is moving, do spin!
	LDA <Counter_1
	AND #$06	 ; A = Counter_1 & 6
	PHA		 ; Save 'A'

	LSR A		 	; Shift right 1 (0 - 3)
	STA Title_ObjFrame,X	; Store as frame
	PLA	 	; Retore 'A'

	AND #$04	; Just bit 2...
	ASL A		 
	ASL A		 
	ASL A		 
	ASL A		; Becomes 0 or $40 (horizontal flip)
	STA <Title_ObjFlags,X	 ; Store as flag

PRG024_B642:
	JMP Title_ObjDraw	 ; Draw objects and don't come back 

KS_Carry_Xoff:
	.byte -12, -10, -6, -2, 2, 6, 10, 12	; When carrier not horizontally flipped
	.byte 12, 10, 6, 2, -2, -6, -10, -12	; When carrier is horizontally flipped

KS_ShellCarry:
	; 'Y' specifies the "carrier" (0 = Mario, 1 = Luigi)

	; Koopa shell's X and XHi coordinate is same as carrier's 
	LDA Title_ObjX,Y
	STA <Title_ObjX+2,X	 
	LDA Title_XPosHi,Y
	STA <Title_XPosHi+2,X
	
	; Koopa shell's Y position = carrier's Y + 13
	LDA Title_ObjY,Y
	ADD #13
	STA <Title_ObjY+2,X

	LDA Title_ObjMLFlags,Y		; Get carrier's flags (specifically, we're only checking "zero" or "non-zero", even more specifically, "(not) horizontally flipped")

	PHP		 		; Save processor status (so it's not effected by the "bonk" load)
	LDA Title_ObjMLBonkTick,Y	; Get bonk ticks
	PLP		 		; Restore processor status

	PHA		 		; Save 'A' (bonk ticks)
	BEQ PRG024_B675	 		; If flags = 0, jump to PRG024_B675

	ADD #$08	 		; Otherwise, add 8 to the "bonk ticks" (use reversed values from KS_Carry_Xoff)

PRG024_B675:
	TAY		 		; Y = bonk ticks (+8)
	LDA KS_Carry_Xoff,Y	 	; Get KS_Carry_Xoff[Y]
	BPL PRG024_B67D	 		; If not negative, jump to PRG024_B67D

	DEC <Title_XPosHi+2,X	 	; Otherwise, shell's "high" X position-- (put to the left of Mario)

PRG024_B67D:
	ADD <Title_ObjX+2,X	 	
	STA <Title_ObjX+2,X	 	; Add X offset to shell's X
	BCC PRG024_B686	 		; If it hasn't overflowed, jump to PRG024_B686

	; Otherwise, "high" X position increments
	INC <Title_XPosHi+2,X	 	

PRG024_B686:
	PLA		 	; Restore 'A' (bonk ticks)
	BNE PRG024_B68C	 	; If bonk ticks are non-zero, jump to PRG024_B68C
	JMP Title_ObjDraw	; Draw shell...

PRG024_B68C:
	LDA #$00	 
	JMP PRG024_B6F1	 	; Hijacks Title_ObjDraw, using sprite zero instead! (for display priority)

; Title_ObjCommonXYVel
;
; A common, reusable function for objects which applies their gravity
; and X/Y velocities, and prevents them from going below YPos 176
Title_ObjCommonXYVel:

	; Add FALL_OBJECT to this object's Y velocity
	LDA <Title_ObjYVel+2,X
	ADD #FALL_OBJECT
	STA <Title_ObjYVel+2,X

	JSR Title_ApplyYVelFall	 ; Update and apply Y velocity
	JSR Title_ObjXVelApply	 ; Apply X velocity

	; Prevents Y position from falling beneath 176
	LDA <Title_ObjY+2,X
	AND #$f0	 
	CMP #176
	BNE PRG024_B6A8	 

	STA <Title_ObjY+2,X

PRG024_B6A8:
	RTS		 ; Return

	; For both of these, the first value is used if the object is off to the right,
	; otherwise the second value for when they are off to the left
Title_ObjXLimit:	.byte -16, 48	; Limits for how far off the side of the screen they can go
Title_ObjXLimitHi:	.byte $FF, $00	; Respective 16-bit sign extensions


	; Common finale for minor objects
Title_ObjCommonFinale:

	LDY #$00		; Y = 0
	LDA <Title_XPosHi+2,X	; A = "high" part of the X position of this object
	BEQ PRG024_B6C7	 	; If its zero, jump to PRG024_B6C7
	BPL PRG024_B6B6	 	; If it is > 0 (off the right side), jump to PRG024_B6B6

	INY		 	; If it is < 0 (off the left side), Y = 1

PRG024_B6B6:
	; There is a "high" part of the X coordinate in use...

	LDA <Title_ObjX+2,X	; Get the X coordinate
	ADD Title_ObjXLimit,Y	; Add an appropriate extreme value

	; 16-bit propogation
	LDA <Title_XPosHi+2,X	
	ADC Title_ObjXLimitHi,Y

	BEQ PRG024_B6C7	 	; If there hasn't been an overflow, jump to PRG024_B6C7

	; Otherwise, set this object's state to zero (removing it) 
	LDA #$00	 
	STA <Title_ObjStates,X

PRG024_B6C7:
	RTS		 ; Return

	; Showing "default" usage per object, but Title_ObjFrane can alter which one is used
Title_ObjPatterns:
	.byte $F9, $F9	; 0 = Starman
	.byte $F5, $F5	; 1 = Mushroom
	.byte $F1, $F3	; 2 = Super Leaf
	.byte $FB, $FD	; 3 = Goomba
	.byte $FF, $FF	
	.byte $DD, $DD	; 4 = Buzzy Beatle
	.byte $D5, $D5	; 5 = Koopa shell

	; Auxillary patterns (accessed by "Title_ObjFrame" values)
	.byte $D7, $D9
	.byte $DB, $DB
	.byte $D7, $D9

	; Each of these tables contains one value per object index (0-5)
Title_ObjPatOff:	.byte $00, $02, $04, $06, $0A, $0C	; Root offset per object for Title_ObjPatterns
Title_ObjSprRAMOff:	.byte $40, $48, $50, $68, $60, $58	; Offset into Sprite_RAM per object
Title_ObjPal:		.byte $03, $00, $00, $02, $02, $03	; Paletter per object

; Title_ObjDraw
;
; Not literally "draw", of course, but set up their hardware
; sprites in Sprite_RAM to be "drawn"...
Title_ObjDraw:
	LDA Title_ObjSprRAMOff,X	; Get the offset into Sprite_RAM

PRG024_B6F1:
	PHA		 		; Save this value

	LDA Title_ObjPal,X	
	STA <Temp_Var3		; Temp_Var3 = this object's palette index

	LDA Title_ObjFrame,X
	ASL A		 
	ADD Title_ObjPatOff,X	; Use the pattern specified in Title_ObjPatOff + 2 * Title_ObjFrame
	TAY		 	; Y = A (the pattern value)

	; Temp_Var1 and Temp_Var2 hold the first and second pattern value for this object
	LDA Title_ObjPatterns,Y	
	STA <Temp_Var1		
	LDA Title_ObjPatterns+1,Y
	STA <Temp_Var2		 

	PLA		 	; Restore 'A' (Sprite_RAM offset)
	TAY		 	; Y = A

	; Set the Y position of the object to its first/second sprites
	LDA <Title_ObjY+2,X
	STA Sprite_RAM,Y
	STA Sprite_RAM+$04,Y

	; Set the X position of object to its first/second sprites (8 pixels apart)
	LDA <Title_ObjX+2,X
	STA Sprite_RAM+$03,Y
	ADD #$08	 
	STA Sprite_RAM+$07,Y

	; Store the attributes for both sprites
	LDA <Temp_Var3		 ; Get the selected palette value
	ORA <Title_ObjFlags,X	 ; Apply the other flags
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	LDA <Temp_Var1		; Get first pattern value of this object
	PHA		 	; Save 'A'
	STA Sprite_RAM+$01,Y	; Store pattern for first sprite

	LDA <Temp_Var2		; Get second pattern value of this object
	STA Sprite_RAM+$05,Y	; Store pattern for second sprite
 
	LDA <Title_ObjFlags,X
	BEQ PRG024_B742	 	; If this object's flags value = 0, jump to PRG024_B742

	; Otherwise, reverse the patterns
	; NOTE: This is making the assumption that the only value stored in ObjFlags
	; is one to horizontally flip the sprite!!
	LDA <Temp_Var2 
	STA Sprite_RAM+$01,Y
	LDA <Temp_Var1 
	STA Sprite_RAM+$05,Y

PRG024_B742:
	PLA		 	; Restore 'A' (first pattern)
	CMP <Temp_Var2
	BNE PRG024_B754	 	; If it's not the same as the second pattern, jump to PRG024_B754

	; Otherwise, flip the sprites
	LDA Sprite_RAM+$02,Y
	AND #$bf		; Keep everything but the horizontal flip flag	 
	STA Sprite_RAM+$02,Y

	ORA #SPR_HFLIP	 	; Apply the horizontal flip flag
	STA Sprite_RAM+$06,Y

PRG024_B754:
	; NOTE: The 1P/2P menu koopas hijack code here to take advantage of disabling their sprites!

	LDA <Title_XPosHi+2,X
	BEQ PRG024_B75D	 	; If the "high" part of the X coordinate is zero, jump to PRG024_B75D

	; Otherwise, disable the first sprite sprite by setting its Y value out of range
	LDA #$f8	 
	STA Sprite_RAM,Y

PRG024_B75D:

	; Take the object's X coordinate, add 8, and if there's been a carry OR the "high" part 
	; of the X coordinate is otherwise non-zero, disable the second half of the sprite
	LDA <Title_ObjX+2,X
	ADD #$08	 
	LDA #$00	 
	ADC <Title_XPosHi+2,X
	BEQ PRG024_B76D	 

	; Disable the second sprite
	LDA #$f8	 
	STA Sprite_RAM+$04,Y

PRG024_B76D:
	RTS		 ; Return


Title_ObjXVelApply: 
	INX		 
	INX		 ; X += 2 (going to use A Mario/Luigi included function, which uses a larger index span... objects start at index 2)

	JSR Title_AddVel_toPos	 ; Apply X velocity as is

	DEX		 
	DEX		 ; X -= 2 (restoring objects to their local index)
	RTS		 ; Return


Title_ApplyYVelFall:
	; X is 0-5, an index to one of the "minor" objects

	LDA <Title_ObjYVel+2,X
	BMI PRG024_B782	 	; If object's Y velocity < 0, jump to PRG024_B782

	CMP #FALLRATE_OBJECTMAX
	BLS PRG024_B782	 	; If object's Y velocity < FALLRATE_OBJECTMAX, jump to PRG024_B782

	; Prevent objects from falling faster than FALLRATE_OBJECTMAX	
	LDA #$60
	STA <Title_ObjYVel+2,X

PRG024_B782:
	INX		 
	INX		 ; X += 2 (going to use A Mario/Luigi included function, which uses a larger index span... objects start at index 2)

	JSR Title_ApplyYVel	 ; Apply Y velocity

	DEX		 
	DEX		 ; X -= 2 (restoring objects to their local index)
	RTS		 ; Return

Title_Menu_Koopa_SpriteRAMOff:	.byte $00, $20, $40, $60	; Offsets into Sprite_RAM per menu koopa

Title_Menu_UpdateKoopas:
	JSR PRG024_SpriteClear	 ; Clear all sprites

	LDX #$03

PRG024_B793:
	LDA <Title_ObjStates,X
	BEQ PRG024_B7A4	 	; If this object's state = 0, jump to PRG024_B7A4

	CMP #$01	 
	BNE PRG024_B7A1	 	; If this object's state <> 1, jump to PRG024_B7A1

	; State 1: Initialize this koopa
	JSR Title_Menu_InitKoopa
	JMP PRG024_B7A4	 		; Jump down to PRG024_B7A4

PRG024_B7A1:
	; Other states: Just update!
	JSR Title_Menu_UpdateKoopa

PRG024_B7A4:
	DEX		 ; X--
	BPL PRG024_B793	 ; If X >= 0, loop!

	RTS		 ; Return


; Title_Menu_InitKoopa
;
; Initializes the data for one of the 1P/2P koopas
; that march along (with the one fast straggler)
Title_Menu_InitKoopa:
	INC <Title_ObjStates,X	 ; Increment this object's state

	; Set this object's XHi / X position to -16
	LDA #$ff
	STA <Title_XPosHi+2,X
	LDA #-16
	STA <Title_ObjX+2,X

	LDA #8	 		; Most of the menu koopas run at X Velocity 8
	CPX #$03
	BNE PRG024_B7BA	 	; If X <> 3 (the straggler koopa), jump to PRG024_B7BA

	LDA #18	 		; The straggler koopa runs at X velocity 18

PRG024_B7BA:
	STA <Title_ObjXVel+2,X	; Set this koopa's velocity
	RTS		 	; Return


	; Y offsets per sprite of the koopa
Title_Menu_Koopa_SprYOff:
	.byte -32, -16, 0

	; This defines an X coordinate per-menu koopa of when to signal the
	; next koopa (unless zero, which means "never", used for the straggler)
	; Hence, $90 is "late" for the straggler
Title_Menu_Koopa_SignalX:
	.byte $20, $20, $90, $00

	; Attributes set per frame of koopa
Title_Menu_Koopa_Attr:
	.byte $42, $43, $42	; First sprite of koopas
	.byte $42, $42, $42	; Second sprite of koopas

	; Patterns set first sprite per frame of koopa
Title_Menu_Koopa_Patterns1:
	.byte $B1, $E5, $E9	; First frame of koopas
	.byte $B1, $E5, $EF	; Second frame of koopas

	; Patterns set second sprite per frame of koopa
Title_Menu_Koopa_Patterns2:
	.byte $E1, $E3, $E7	; First frame of koopas
	.byte $E1, $EB, $ED	; Second frame of koopas


; Title_Menu_UpdateKoopa
;
; Updates and "draws" the menu koopas
Title_Menu_UpdateKoopa:
	JSR Title_ObjXVelApply	 	; Koopas only need X velocity!
	JSR Title_ObjCommonFinale	; Do common finale code

	LDA <Title_XPosHi+2,X
	BNE PRG024_B7F1	 	; If the "high" part of the koopa's X position is zero, jump to PRG024_B7F1

	; This signals the next menu koopa to come marching in when the current leader
	; hits a particular coordinate to do so...
	LDA Title_Menu_Koopa_SignalX,X
	BEQ PRG024_B7F1	 	; If Title_Menu_Koopa_SignalX[X] = 0, jump to PRG024_B7F1 (do nothing)

	CMP <Title_ObjX+2,X
	BGE PRG024_B7F1	 	; If Title_Menu_Koopa_SignalX[X] >= the koopa's X position, jump to PRG024_B7F1

	INX		 	; Next koopa

	LDA <Title_ObjStates,X	
	BNE PRG024_B7F0	 	; If this koopa's state <> 0, jump to PRG024_B7F0 (only signal once!)

	INC <Title_ObjStates,X	; Move next koopa to next state

PRG024_B7F0:
	DEX		 	; Back to this koopa

PRG024_B7F1:
	LDA <Counter_1
	LSR A		 
	LSR A		 ; A = Counter_1 >> 2

	CPX #$03	 
	BEQ PRG024_B7FA	 ; If we're on the straggler koopa, jump to PRG024_B7FA

	LSR A		 ; Otherwise, shift one more time... (slightly slower than the straggler) 

PRG024_B7FA:
	AND #$01	 ; Only looking for 0/1 pattern
	BEQ PRG024_B800	 ; If 0, jump to PRG024_B800
	LDA #$03	 ; Otherwise, change to 3 (thus 0 or 3)

PRG024_B800:
	STA Title_ObjFrame,X	 ; Set frame as 0 or 3

	STX <Temp_Var3		 ; Store koopa index into Temp_Var3

	LDA <Title_ObjX+2,X	 
	STA <Temp_Var1		 ; Store koopa X pos into Temp_Var1

	LDA Title_ObjFrame,X
	STA <Temp_Var2		 ; Store koopa frame into Temp_Var2

	LDY Title_Menu_Koopa_SpriteRAMOff,X	 ; Get Sprite_RAM offset for this koopa -> 'Y'

	LDX #$02	 	; X = 2 (sprites to build)

PRG024_B813:
	LDA #186	 	; A = 186
	ADD Title_Menu_Koopa_SprYOff,X	; A += Title_Menu_Koopa_SprYOff[X]
	STA Sprite_RAM,Y	; Store Y coordinate into first sprite
	STA Sprite_RAM+$04,Y	; Store Y coordinate into second sprite

	TXA		 	; A = X (sprite to build loop counter)
	PHA		 	; Save 'A'

	ADD <Temp_Var2		; Add the frame (0 or 3) to 'A'
	TAX		 	; X = A

	; Setup the patterns
	LDA Title_Menu_Koopa_Patterns1,X	; Get first pattern for this koopa
	STA Sprite_RAM+$01,Y	 		; Store pattern value
	LDA Title_Menu_Koopa_Patterns2,X	; Get second pattern for this koopa
	STA Sprite_RAM+$05,Y	 		; Store pattern value

	LDX <Temp_Var3		; X = koopa index
	JSR PRG024_B754	 	; Disable first and/or second sprite if off-screen

	PLA		 	; Restore 'A' (sprite to build loop counter)
	TAX		 	; X = A

	; Attributes set per sprite of koopa
	LDA Title_Menu_Koopa_Attr,X
	STA Sprite_RAM+$02,Y	 
	LDA Title_Menu_Koopa_Attr+3,X
	STA Sprite_RAM+$06,Y	 

	LDA <Temp_Var1
	STA Sprite_RAM+$03,Y	; Store X position for first sprite of the koopa

	ADD #$08	 	; Sprite X += 8
	STA Sprite_RAM+$07,Y	; Store X position for second sprite of the koopa

	TYA		 
	ADD #$08	 
	TAY		 	; Y += 8 (next two sprites over)

	DEX		 	; X--
	BPL PRG024_B813	 	; If X >= 0, loop!

	LDX <Temp_Var3		; Restore koopa index to 'X'
	RTS		 	; Return..!


Rescue_Princess:
	; NOTE: Debug menu jump to princess rescue jumps here

	; Princess housing block graphics
	LDA #$5c
	STA PatTable_BankSel

	; Princess housing background graphics
	LDA #$5e
	STA PatTable_BankSel+1

	JSR Reset_PPU_Clear_Nametables

	; Disable display
	LDA #$00
	STA PPU_CTL1
	STA PPU_CTL2

	; Disable raster effects
	LDA #$80
	STA Raster_Effect

	; Clears RAM $00-$F5
	LDX #$f5	 ; X = $F5
PRG024_B876:
	LDA #$00
	STA <Temp_Var1,X

	DEX		 ; X--
	BNE PRG024_B876	 ; While X <> 0, loop!

	; Scroll at lowest point
	LDA #$ef
	STA <Vert_Scroll

	LDA #%00101000	 	; use 8x16 sprites, sprites use PT2 (NOTE: No VBlank trigger!)
	STA PPU_CTL1	 	
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

	; Entry $55 of Video_Upd_Table2
	LDA #$55
	ASL A
	TAY

	; Load base address of graphics
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL	
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH	

	JSR Video_Misc_Updates2	; Load those graphics!

	LDA #%10101000	; In addition to anything else specified by PPU_CTL1_Mod, Generate VBlank Resets, use 8x16 sprites, sprites use PT2
	STA PPU_CTL1	; Set above settings
	STA <PPU_CTL1_Copy	; Keep PPU_CTL1_Copy in sync!

PRG024_B8A0:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; VSync

	JSR Ending_ChamberScene	 ; Do the Princess Chamber scene, up through the Fade Out

	LDA <Ending_State
	CMP #$07
	BNE PRG024_B8A0	 ; If Princess Chamber scene is still going on, loop!

	JMP Ending_Credits	 ; Jump to credits


Ending_ChamberScene:
	JSR PRG024_SpriteClear	; Clear sprites

	LDA #$10	
	STA <Title_ObjMLSprRAMOff	; Mario's sprite RAM starts at Sprite_RAM + $10

	LDA #$28	
	STA <Title_ObjMLSprRAMOff+1	; Princess's sprite RAM starts at Sprite_RAM + $28

	LDX #$02	 ; X = 2
PRG024_B8BC:
	LDA <Ending_Timer,X
	BEQ PRG024_B8C2		; If this ending timer = 0, jump to PRG024_B8C2

	DEC <Ending_Timer,X	; Otherwise, decrement it

PRG024_B8C2:
	DEX		 ; X--
	BPL PRG024_B8BC	 ; While X >= 0, loop

	JSR Ending_DoChamberScene	 ; Perform actions for the Princess's Chamber

	; Title_CurMLIndex = 0
	LDX #$00
	STX <Title_CurMLIndex

	JSR Title_DrawMarioLuigi	 ; Draws Mario officially, but may be modified after this to Luigi

	LDA Player_Current
	BEQ PRG024_B8E6	 ; If Player is Mario, jump to PRG024_B8E6

	; Luigi only...

	; This is meant to colorize the Player as Luigi, but I think the loop condition is wrong
	; Seems to work anyway.  Sort of a Schroedinbug without the fact that it will stop working
	; just because I pointed it out...
	LDY #$24	 ; Y = $24
PRG024_B8D6:
	; Use the Luigi palette
	LDA Sprite_RAM+$02,Y
	ORA #SPR_PAL2
	STA Sprite_RAM+$02,Y

	; Y -= 4 (previous sprite)
	DEY
	DEY
	DEY
	DEY

	CMP <Title_ObjMLSprRAMOff ; I think this is a mistake!  Will compare to the attribute value!
	BPL PRG024_B8D6	 ; While ??, loop

PRG024_B8E6:

	; Title_CurMLIndex = 1
	INX		 ; X = 1
	STX <Title_CurMLIndex

	JSR Title_DrawMarioLuigi	 ; Actually draws the Princess

	RTS		 ; Return

Ending_DoChamberScene:
	LDA <Ending_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Ending_Init		; 0: Prepare the Princess chamber scene
	.word Ending_FadeIn		; 1: Fade in
	.word Ending_MarioAppears	; 2: Mario appears, music starts
	.word Ending_LightsOn		; 3: Lights come on, Princess stands up
	.word Ending_WalkToCenter	; 4: Mario and Princess walk to the center
	.word Ending_PrincessSpeech	; 5: Princess's departing message
	.word Ending_FadeOut		; 6: Fade out

Ending_Init:
	; Set Mario's X
	LDA #32
	STA <Title_ObjX

	; Set Princess's X
	LDA #200
	STA <Title_ObjX+1

	; Set both Y = 160
	LDA #160
	STA <Title_ObjY
	STA <Title_ObjY+1

	; Mario standing
	LDA #$18
	STA <Title_ObjMLSprite

	; Princess sobbing
	LDA #$19
	STA <Title_ObjMLSprite+1

	; Mario turned to face, Princess turned away
	LDA #SPR_HFLIP
	STA <Title_ObjMLFlags
	STA <Title_ObjMLFlags+1

	; Super Mario
	LDA #$01
	STA <Title_ObjMLPower

	; Set first ending timer to $0F
	LDA #$0f
	STA <Ending_Timer

	INC <Ending_State	; Ending_State = 1

	; Initialize the princess speech dialog box

	; EndText_CPos = 0
	LDA #$00
	STA <EndText_CPos

	; EndText_VH = $29
	LDA #$29
	STA <EndText_VH

	; EndText_VL = $48
	LDA #$48
	STA <EndText_VL

	RTS		 ; Return

Ending_FadeIn:
	LDA <Ending_Timer
	BNE PRG024_B93D	 ; If the first ending timer has not expired, jump to PRG024_B93D

	INC <Ending_State	 ; Ending_State = 2

	; Set first ending timer to $30
	LDY #$30
	STY <Ending_Timer

PRG024_B93D:


	; Ending timer was init'ed to $F (15) so ...
	LSR A
	LSR A		; Ending timer / 4
	ADD #$56	; ... run command scripts $59, $58, $57, $56 (the "fade in" effect)

	STA Graphics_Queue	 ; Execute appropriate scripe

	RTS		 ; Return

Ending_MarioAppears:
	LDA <Ending_Timer
	CMP #$01
	BNE PRG024_B959	 ; If ending timer does not have one tick left, jump to PRG024_B959

	; Mario standing there
	LDA #$02
	STA <Title_ObjMLSprite

	; Set ending timer 2 = $80
	LDA #$80
	STA <Ending_Timer+1

	; Play finale music
	LDA #MUS2A_ENDING
	STA Sound_QMusic2

PRG024_B959:
	LDA <Ending_Timer+1
	CMP #$01
	BNE PRG024_B965	 ; If second ending timer does not have one tick left, jump to PRG024_B965

	; Set first ending timer = $13
	LDA #$13
	STA <Ending_Timer

	INC <Ending_State ; Ending_State = 3

PRG024_B965:
	RTS		 ; Return

	; The "lights on" effect palette levels
Ending_LightsOnPalSet:
	.byte $0F, $35, $30, $3B
	.byte $0F, $23, $35, $3B
	.byte $0F, $11, $3C, $3B
	.byte $0F, $1C, $2C, $3B
	.byte $0F, $0C, $1C, $3B

Ending_LightsOn:
	LDA <Ending_Timer
	BEQ PRG024_B9BB	 ; If ending timer has expired, jump to PRG024_B9BB

	; Second ending timer = $30
	LDY #$30
	STY <Ending_Timer+1

	AND #%00001100
	TAY		 ; Y = 0, 4, 8, 12 (Ending_LightsOnPalSet level offset)

	LDX Graphics_BufCnt	 ; X = current graphics buffer count
	TXA
	ADD #$07
	STA Graphics_BufCnt	; Make room for 7 bytes

	; VRAM High/Low (for palette)
	LDA #$3f
	STA Graphics_Buffer,X
	LDA #$04
	STA Graphics_Buffer+1,X

	; Run length of 4
	LDA #$04
	STA Graphics_Buffer+2,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+7,X

	; The four palette colors for the "lights on" effect
	LDA Ending_LightsOnPalSet,Y
	STA Graphics_Buffer+3,X
	LDA Ending_LightsOnPalSet+1,Y
	STA Graphics_Buffer+4,X
	LDA Ending_LightsOnPalSet+2,Y
	STA Graphics_Buffer+5,X
	LDA Ending_LightsOnPalSet+3,Y
	STA Graphics_Buffer+6,X

PRG024_B9BB:
	LDA <Ending_Timer+1
	BNE PRG024_B9C9	 ; If second ending timer has not expired, jump to PRG024_B9C9 (RTS)

	INC <Ending_State	 ; Ending_State = 4

	; First ending timer = $80
	LDA #$80
	STA <Ending_Timer

	; Princess stands up
	LDA #$1a
	STA <Title_ObjMLSprite+1

PRG024_B9C9:
	RTS		 ; Return


Ending_WalkToCenter:
	LDA <Ending_Timer
	BEQ PRG024_B9D7	 ; If first ending timer has not expired, jump to PRG024_B9D7

	CMP #$60
	BGE PRG024_B9D6	 ; If ending timer >= $60, jump to PRG024_B9D6 (RTS)

	; Princess turns around
	LDA #$00
	STA <Title_ObjMLFlags+1

PRG024_B9D6:
	RTS		 ; Return

PRG024_B9D7:
	LDA <Title_ObjX
	CMP #104
	BLT PRG024_B9EC	 ; If Mario's X < 104, jump to PRG024_B9EC

	; Mario stands
	LDA #$02
	STA <Title_ObjMLSprite

	; Princess stands
	LDA #$1a
	STA <Title_ObjMLSprite+1

	INC <Ending_State	; Ending_State = 5

	; First Ending Timer = $B0
	LDA #$b0
	STA <Ending_Timer

	RTS		 ; Return

PRG024_B9EC:

	; Second ending timer = $50
	LDA #$50
	STA <Ending_Timer+1

	; Mario steps to the right
	INC <Title_ObjX

	; Princess steps to the left
	DEC <Title_ObjX+1

	LDA <Counter_1
	AND #%00001100
	LSR A
	LSR A
	TAY	; Y = 0 to 3

	; Set Mario's walk frame
	LDA Title_ObjMLWalkSprite+4,Y
	STA <Title_ObjMLSprite	

	; Set Princess's walk frame
	LDA Title_ObjMLWalkSprite+12,Y
	STA <Title_ObjMLSprite+1

	RTS		 ; Return


Ending_PrincessSpeech:
	LDA <Ending_Timer
	BNE PRG024_BA0D	 ; If timer not expired, jump to PRG024_BA0D (RTS)

	JMP PRG024_BA2B	 ; Otherwise, jump to PRG024_BA2B

PRG024_BA0D:
	RTS		 ; Return


Ending_FadeOut:
	LDA <Ending_Timer
	BNE PRG024_BA19	 ; If first ending timer has not expired, jump to PRG024_BA19

	LDA <Ending_Timer+1
	BNE PRG024_BA18	 ; If second ending timer has not expired, jump to PRG024_BA18 (RTS)

	INC <Ending_State ; Ending_State = 7

PRG024_BA18:
	RTS		 ; Return

PRG024_BA19:

	; Ending timer was init'ed to $F (15) so ...
	LSR A
	LSR A		; Ending timer / 4
	STA <Temp_Var1	 ; Temp_Var1 = 0 to 3

	; Execute $5A, $59, $58, $57 (fade out)
	LDA #$5a
	SUB <Temp_Var1
	STA Graphics_Queue

	; Second ending timer = $10
	LDA #$10
	STA Ending_Timer+1

	RTS		 ; Return

PRG024_BA2B:
	LDA <EndText_State
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word EndText_DrawDiagBox	; 0: Draw the dialog box
	.word EndText_DoPrincessText	; 1: Do the text
	.word EndText_Wait		; 2: Waits for timer to expire, then advances Ending_State


PDiagBox_R1:	.byte $94, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $96
PDiagBox_R2:	.byte $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $93
PDiagBox_R3:	.byte $95, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $97

PDiagBox_RowOffs:
	.byte (PDiagBox_R1 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1)
	.byte (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R2 - PDiagBox_R1), (PDiagBox_R3 - PDiagBox_R1)
PDiagBox_RowOffs_End


EndText_DrawDiagBox:

	LDX Graphics_BufCnt	 ; X = buffer count

	; Set current VRAM address 
	LDA <EndText_VH
	STA Graphics_Buffer,X
	LDA <EndText_VL	
	STA Graphics_Buffer+1,X

	ADD #$20	; 32 bytes to next row
	STA <EndText_VL
	BCC PRG024_BA87
	INC <EndText_VH	 ; Apply carry
PRG024_BA87:
	LDA #(PDiagBox_R2 - PDiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY <EndText_CPos	 ; Y = current dialog box row
	LDA PDiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG024_BA94:
	; Store next pattern in dialog box
	LDA PDiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG024_BA94	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	INC <EndText_CPos	 ; Next row

	LDA <EndText_CPos
	CMP #(PDiagBox_RowOffs_End - PDiagBox_RowOffs)
	BLT PRG024_BAC8	 ; If rows to go, jump to PRG024_BAC8 (RTS)

	LDY #$00	 ; Y = 0

	; This basically just amounts to a zero; kind of strange?
	LDA PRG024_BB23,Y
	STA <EndText_CPos

	; EndText_VH = $92
	LDA #$29
	STA <EndText_VH

	; EndText_VL = $69
	LDA #$69
	STA <EndText_VL

	; EndText_Timer = $10
	LDA #$10
	STA <EndText_Timer

	INC <EndText_State	 ; EndText_State = 1

PRG024_BAC8:
	RTS		 ; Return

	; English: "Thank you. But" / "our Princess is" / "in another" / "castle!...Just" / "kidding! Ha ha" / "ha! Bye bye."
EndText:

	;       T    h    a    n    k         y    o    u    .         B    u    t
	.byte $C3, $D7, $D0, $DD, $DA, $FE, $8C, $DE, $CE, $E9, $FE, $B1, $CE, $CD, $FE

	;       o    u    r         P    r    i    n    c    e    s    s         i    s    
	.byte $DE, $CE, $CB, $FE, $BF, $CB, $D8, $DD, $D2, $D4, $CC, $CC, $FE, $D8, $CC

	;       i    n         a    n    o    t    h    e    r    
	.byte $D8, $DD, $FE, $D0, $DD, $DE, $CD, $D7, $D4, $CB, $FE, $FE, $FE, $FE, $FE

	;       c    a    s    t    l    e    !    .    .    .    J    u    s    t
	.byte $D2, $D0, $CC, $CD, $DB, $D4, $EA, $E9, $E9, $E9, $B9, $CE, $CC, $CD, $FE

	;       k    i    d    d    i    n    g    !         H    a         h    a    
	.byte $DA, $D8, $D3, $D3, $D8, $DD, $D6, $EA, $FE, $B7, $D0, $FE, $D7, $D0, $FE

	;       h    a    !         B    y    e         b    y    e    .
	.byte $D7, $D0, $EA, $FE, $B1, $8C, $D4, $FE, $D1, $8C, $D4, $E9, $FE, $FE, $FE

PRG024_BB23:
	; Terminator
	.byte $00

EndText_DoPrincessText:
	LDA <EndText_Timer
	BNE PRG024_BB70	 ; If the timer is not expired, jump to PRG024_BB70 (RTS)

	LDX Graphics_BufCnt	 ; X = current graphics buffer count

	LDY <EndText_CPos	 ; Y = dialog message character position

	; Insert one character into graphics buffer
	LDA <EndText_VH
	STA Graphics_Buffer,X	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,X	; run length
	LDA EndText,Y
	STA Graphics_Buffer+3,X	 ; Next character from Princess speech
	LDA #$00
	STA Graphics_Buffer+4,X	; terminator

	; Update Graphics_BufCnt
	TXA
	ADD #$04
	STA Graphics_BufCnt

	; VRAM low address
	LDA <EndText_VL
	STA Graphics_Buffer+1,X

	INC <EndText_CPos	; Next character in message
	INC <EndText_VL	 	; Next VRAM byte

	AND #$1f	 	; Get current column
	CMP #$17
	BNE PRG024_BB6C	 	; If we're not in column 23, jump to PRG024_BB6C

	; Line break!

	LDA <EndText_VL	
	ADC #$10		; Add enough bytes to get to next row
	STA <EndText_VL	
	BCC PRG024_BB62
	INC <EndText_VH		; Apply carry
PRG024_BB62:

	CMP #$29
	BNE PRG024_BB6C	 ; If we haven't reached the last character, jump to PRG024_BB6C

	INC <EndText_State	 ; EndText_State = 2

	; Second ending timer = $4A
	LDA #$4a
	STA <Ending_Timer+1

PRG024_BB6C:

	; First ending timer = $0B
	LDA #$0b
	STA <Ending_Timer

PRG024_BB70:
	RTS		 ; Return


EndText_Wait:
	LDA <Ending_Timer+1
	BNE PRG024_BB7B	 ; If second ending timer has not expired, jump to PRG024_BB7B (RTS)

	; First ending timer = $0F
	LDA #$0f
	STA <Ending_Timer

	INC <Ending_State	 ; Ending_State = 6

PRG024_BB7B:
	RTS		 ; Return

Ending_Credits:
	; Debug menu credits jump here

	; Curtain and floor top
	LDA #$7c
	STA PatTable_BankSel

	; Rest of floor
	LDA #$76
	STA PatTable_BankSel+1

	; Disable display
	LDA #$00
	STA PPU_CTL2

	; Clear everything
	JSR Sprite_RAM_Clear
	JSR Reset_PPU_Clear_Nametables

	; Stop Update_Select activity temporarily
	LDA #$01
	STA UpdSel_Disable

	; Raster_Effect = $20 (Title/Ending style)
	LDA #$20
	STA Raster_Effect

	; Clears a lot of page 0 RAM
	LDX #$f4	 ; X = $F4
PRG024_BB9D:
	LDA #$00
	STA <Temp_Var1,X

PRG024_BBA1:
	DEX		 ; X--

	; Range between $6B-$75 is not cleared ... mainly protecting sound engine I think

	CPX #Music_Base_L
	BLT PRG024_BBAA	 ; If X < Music_Base_L, jump to PRG024_BBAA

	CPX #World_Map_Y
	BLT PRG024_BBA1	 ; If X < World_Map_Y, jump to PRG024_BBA1

PRG024_BBAA:
	CPX #-1
	BNE PRG024_BB9D	 ; While X >= 0, loop!

	; This clears some of the title screen area memory
	LDX #$15	 ; X = $15
PRG024_BBB0:
	LDA #$00
	STA Title_MLAccelCnt,X

	DEX		 ; X--
	BPL PRG024_BBB0	 ; While X >= 0, loop

	JSR Title_Display_Curtain	; Put up the curtain!

	; Push in the Checkerboard floor
	LDA #$23
	ASL A
	TAY
	LDA Video_Upd_Table2,Y
	STA <Video_Upd_AddrL
	LDA Video_Upd_Table2+1,Y
	STA <Video_Upd_AddrH
	JSR Video_Misc_Updates2

	; Set scroll at lowest point (technically, curtain fully raised)
	LDA #$ef
	STA <Vert_Scroll

	; Clip sprites/BG, show sprites/BG, and enable intensity
	LDA #%00011110
	STA <PPU_CTL2_Copy

	; Resume Update_Select activity
	LDA #$00
	STA UpdSel_Disable

	; Curtain extension
	LDA #$24
	STA Graphics_Queue

	JSR GraphicsBuf_Prep_And_WaitVSyn2


	; This will push graphics command sets $5C, $5D, and $5E

	; Title_EventGrafX = $5C
	LDA #$5c
	STA <Title_EventGrafX 

	; Title_Ticker = 5
	LDA #$05
	STA <Title_Ticker
PRG024_BBE9:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	; Push out graphics or just VSync

	DEC <Title_Ticker
	BPL PRG024_BBE9	; If Title_Ticker >= 0, loop!

	; Title_Ticker = 3
	LDA #$03
	STA <Title_Ticker

	; Queue next event
	LDA <Title_EventGrafX
	STA Graphics_Queue

	INC <Title_EventGrafX	 ; Title_EventGrafX++

	LDA <Title_EventGrafX
	CMP #$5f
	BNE PRG024_BBE9	 ; While Title_EventGrafX <> $5F, loop!

	; Ending2_TimerH = $F
	LDA #$0f
	STA <Ending2_TimerH

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	; Commit the dynamic graphics buffer
	LDA #$00
	STA <Title_EventGrafX

PRG024_BC0D:
	JSR GraphicsBuf_Prep_And_WaitVSyn2

	LDA <Title_EventGrafX
	BNE PRG024_BC21	 ; If Title_EventGrafX <> 0 (curtain at the bottom), jump to PRG024_BC21

	; Lowering curtain
	LDA <Vert_Scroll
	SUB #$01
	STA <Vert_Scroll

	CMP #$3f
	BNE PRG024_BC21	 ; If Vert_Scroll <> $3F (curtain all the way down), jump to PRG024_BC21

	INC <Title_EventGrafX		 ; Title_EventGrafX = 1 (flags curtain at the bottom)

PRG024_BC21:

	; Ending2_TimerL--
	LDA <Ending2_TimerL
	SUB #$01
	STA <Ending2_TimerL
	BCS PRG024_BC0D	 ; If Ending2_TimerL didn't underflow, loop

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	DEC <Ending2_TimerH	 ; Ending2_TimerH--
	BPL PRG024_BC0D	 ; While Ending2_TimerH >= 0, loop

PRG024_BC32:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; Probably mainly for VSync

	JSR Ending2_DoEndPic	 ; Update and draw end picture per world

	LDA <Ending2_CurWorld
	CMP #$08
	BNE PRG024_BC32	 ; While Ending2_CurWorld <> 8, loop!

	; Ending2_CurWorld = 0
	LDA #$00
	STA <Ending2_CurWorld

	LDY #$44	 ; Y = $44 (all sprites used in ending)
PRG024_BC44:

	; Clear this sprite
	LDA #$f8
	STA Sprite_RAM,Y

	; Y -= 4 (previous sprite)
	DEY
	DEY
	DEY
	DEY

	BPL PRG024_BC44	 ; While Y >= 0, loop

PRG024_BC4F:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync 

	DEC <Vert_Scroll ; Vert_Scroll-- (lowering curtain for finale)

	LDA <Vert_Scroll
	CMP #$3f
	BNE PRG024_BC4F	 ; While curtain not completely lowered, loop!

	; Title_Ticker = $55
	LDA #$55
	STA <Title_Ticker

PRG024_BC5E:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; Vsync

	DEC <Title_Ticker	 ; Title_Ticker--
	BPL PRG024_BC5E		; While Title_Ticker >= 0, loop

	; Load graphics for "THE END"
	LDA #$1b
	STA PatTable_BankSel+5

	; Copy in sprite bytes to form THE END
	LDY #(Ending2_THEEND_End - Ending2_THEEND - 1)
PRG024_BC6C:
	LDA Ending2_THEEND,Y
	STA Sprite_RAM,Y

	DEY		 ; Y--
	BPL PRG024_BC6C	 ; While Y >= 0, loop

	; Title_Ticker = 3
	LDA #$03
	STA <Title_Ticker

	; Title_EventGrafX = 3 (going to cycle through all palettes for THE END to fade in)
	LDA #$03
	STA <Title_EventGrafX

	; Graphics_Queue = $5B
	LDA #$5b
	STA Graphics_Queue

PRG024_BC82:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync

	DEC <Title_Ticker ; Title_Ticker--
	BNE PRG024_BC82	 ; While Title_Ticker <> 0, loop

	DEC <Title_EventGrafX	 ; Title_EventGrafX--
	BMI PRG024_BCAE		; If Title_EventGrafX < 0, jump to PRG024_BCAE

	; Title_Ticker = 3
	LDA #$03
	STA <Title_Ticker

	; Set attribute on all THE END sprites
	LDA <Title_EventGrafX
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06
	STA Sprite_RAM+$0A
	STA Sprite_RAM+$0E
	STA Sprite_RAM+$12
	STA Sprite_RAM+$16
	STA Sprite_RAM+$1A
	STA Sprite_RAM+$1E

	JMP PRG024_BC82	 ; Jump to PRG024_BC82 (loop)

PRG024_BCAE:
	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync

	LDA <Pad_Input	
	AND #PAD_START
	BEQ PRG024_BCAE	 ; While Player has not pressed START, loop

	; Stop music
	LDA #MUS1_STOPMUSIC
	STA Sound_QMusic1

	JSR GraphicsBuf_Prep_And_WaitVSyn2	 ; V Sync

	; Disable display
	LDA #$00
	STA PPU_CTL2
	STA PPU_CTL1

	; Map_Unused7992 = 0 (used only in dead code it seems)
	LDA #$00
	STA Map_Unused7992

	; Temp_Var1 = 0
	LDY #$00
	STY <Temp_Var1

	; Temp_Var2 = $7F
	LDA #$7f
	STA <Temp_Var2

	; Clearing RAM $7FFF through $6000
PRG024_BCD4:
	LDA #$00
	STA [Temp_Var1],Y

	DEY		 ; Y--
	BNE PRG024_BCD4	 ; While Y <> 0 (come full circle), loop

	DEC <Temp_Var2	 ; Temp_Var2-- (previous page of RAM)

	LDA <Temp_Var2
	CMP #$5f
	BNE PRG024_BCD4	 ; While Temp_Var2 <> $5F, loop


	; P-Wings for everybody!
	LDX #$01	 ; X = 1
	LDY #(Inventory_Cards - Inventory_Items - 1)
PRG024_BCE7:

	LDA #(Inventory_Cards - Inventory_Items - 1)
	STA <Temp_Var1

	LDA #$08	 ; A = 8 (P-Wing)
PRG024_BCED:
	STA Inventory_Items,Y	 ; Here's another P-Wing

	DEY		 ; Y--

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG024_BCED	 ; While Temp_Var1 >= 0, loop

	DEX		 ; X--
	BMI PRG024_BD01	 ; If X < 0, jump to PRG024_BD01

	LDA #(Inventory_Cards - Inventory_Items - 1)
	ADD #(Inventory_Items2 - Inventory_Items)

	TAY		 ; Reset 'Y'
	JMP PRG024_BCE7	 ; Loop

PRG024_BD01:


	; Clear $07FF - $0000, excluding $01xx
	LDY #$07
	JSR Clear_RAM_thru_ZeroPage

	; Reset_Latch = $5A (magic value that prevents reset vector from being run)
	LDA #$5a
	STA Reset_Latch

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; Middle byte of the N-Spade score
	LDA #HIGH(8000)
	STA Map_NSpade_NextScore+1

	; Lowest byte of the N-Spade score
	LDA #LOW(8000)
	STA Map_NSpade_NextScore+2

	; If they jumped a little earlier, they could've included the N-Spade score init, strangely
	JMP PRG030_845A		; Jump to PRG030_845A

	; THE END sprites
Ending2_THEEND:
	.byte $60, $F1, $03, $60
	.byte $60, $F3, $03, $68
	.byte $60, $F5, $03, $70
	.byte $60, $F7, $03, $78
	.byte $60, $F9, $03, $80
	.byte $60, $FB, $03, $88
	.byte $60, $FD, $03, $90
	.byte $60, $FF, $03, $98
Ending2_THEEND_End

Do_Ending2_IntCmd:
	DEC <Ending2_IntCmd	; Ending2_IntCmd-- (because it is zero based, and zero is "Do nothing")
	LDA <Ending2_IntCmd
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Ending2_ClearScreen
	.word Ending2_CommitPicture
 
Ending2_DoEndPic:
	; Ending2_IntCmd = 0 (disable interrupt routine command)
	LDA #$00
	STA <Ending2_IntCmd

	LDA <Ending2_PicState
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Ending2_CurtainRaise	; 0: Raise the curtain back up
	.word Ending2_PrepClear		; 1: Prepare for screen clear
	.word Ending2_SetFlag1		; 2: Sets Ending2_IntCmd = 1 and waits for interrupt context (which will call Do_Ending2_IntCmd)
	.word Ending2_PrepEndPic	; 3: Load up the Ending_CmdBuffer, set starting VRAM address for world end picture
	.word Ending2_SetFlag2		; 4: Sets Ending2_IntCmd = 2 and waits for interrupt context (which will call Do_Ending2_IntCmd)
	.word Ending2_SeriesQueue	; 5: Queue a series of Graphics_Command (Ending2_QueueCmd++ until Ending2_QCmdEnd)
	.word Ending2_AddSprites	; 6: Add sprites that are part of the end picture
	.word Ending2_FadeIn		; 7: Fade in the palette
	.word Ending2_Wait		; 8: Wait on current world picture
	.word Ending2_FadeOut		; 9: Fade out the palette

Ending2_CurtainRaise:
	LDY #$01	; Y = 1 (two stabs at curtain being fully raised)
PRG024_BD62:
	INC <Vert_Scroll ; Vert_Scroll++ (raising the curtain)

	LDA <Vert_Scroll
	CMP #$ef
	BEQ PRG024_BD6E	 ; If curtain is fully raised, jump to PRG024_BD6E

	DEY		 ; Y--
	BPL PRG024_BD62	 ; While Y >= 0, loop

	RTS		 ; Return

PRG024_BD6E:
	INC <Ending2_PicState		 ; Ending2_PicState = 1
	RTS		 ; Return

Ending2_PrepClear:
	; Set Ending2_PicVRAMH/L
	LDA #$28
	STA <Ending2_PicVRAMH
	LDA #$60
	STA <Ending2_PicVRAML

	; Ending2_ClearLen = $14
	LDA #$14
	STA <Ending2_ClearLen

	; Ending2_ClearPat = $5C
	LDA #$5c
	STA <Ending2_ClearPat

	INC <Ending2_PicState	; Ending2_PicState = 2

	RTS		 ; Return

Ending2_SetFlag1:
	; Ending2_IntCmd = 1
	LDA #$01
	STA <Ending2_IntCmd

	RTS		 ; Return


Ending2_ClearScreen:
	LDA <Ending2_PicVRAMH
	CMP #$2b
	BEQ PRG024_BDBB	 ; If Ending2_PicVRAMH = $2b, jump to Ending2_PicVRAMH

	LDA PPU_STAT

	; Set VRAM Address to Ending2_PicVRAMH/L
	LDA <Ending2_PicVRAMH
	STA PPU_VRAM_ADDR
	LDA <Ending2_PicVRAML
	STA PPU_VRAM_ADDR

	LDY #$1f	 ; Y = $1F
	LDA <Ending2_ClearPat	; Get the clearing pattern
PRG024_BDA0:
	STA PPU_VRAM_DATA	; Store pattern

	DEY		 ; Y--
	BPL PRG024_BDA0	 ; While Y >= 0, loop

	DEC <Ending2_ClearLen	; Ending2_ClearLen--
	BPL PRG024_BDB7		; If Ending2_ClearLen >= 0, jump to PRG024_BDB7

	; Set Ending2_PicVRAMH 
	LDA #$2b
	STA <Ending2_PicVRAMH
	LDA #$c8
	STA <Ending2_PicVRAML

	; Ending2_ClearLen = 4
	LDA #$04
	STA <Ending2_ClearLen

	RTS		 ; Return

PRG024_BDB7:
	JSR Ending2_PicVRAM_NextLineWrap

	RTS		 ; Return

PRG024_BDBB:
	LDA PPU_STAT

	; Set VRAM Address to Ending2_PicVRAMH/L
	LDA <Ending2_PicVRAMH
	STA PPU_VRAM_ADDR
	LDA <Ending2_PicVRAML
	STA PPU_VRAM_ADDR

	LDY #$07	 ; Y = $07
	LDA #$aa	 ; Pattern $AA
PRG024_BDCC:
	STA PPU_VRAM_DATA	; Store pattern

	DEY		 ; Y--
	BPL PRG024_BDCC	 ; While Y >= 0, loop

	DEC <Ending2_ClearLen	; Ending2_ClearLen----
	BPL PRG024_BDD8	 	; If Ending2_ClearLen >= 0, jump to PRG024_BDD8

	INC <Ending2_PicState	; Ending2_PicState++

PRG024_BDD8:

	; Ending2_PicVRAML += 8
	LDA <Ending2_PicVRAML
	ADD #$08
	STA <Ending2_PicVRAML

	RTS		 ; Return

Ending2_PrepEndPic:
	LDY <Ending2_CurWorld	; Y = current world we're depicting

	; Temp_Var2/1 hold the address to the end world picture
	LDA EndPicByWorld_H,Y
	STA <Temp_Var2
	LDA EndPicByWorld_L,Y
	STA <Temp_Var1

	LDY #$00	 ; Y = 0 (EndPic command index)
	LDX #$00	 ; X = 0 (Ending_CmdBuffer index)
PRG024_BDF0:
	; Next command byte -> Temp_Var16
	LDA [Temp_Var1],Y
	STA <Temp_Var16	

	AND #$80
	BEQ PRG024_BE02	 ; If bit 7 is NOT set, jump to PRG024_BE02

	; Bit 7 set...

	; Clear bit 7
	LDA <Temp_Var16
	AND #$7f
	STA <Temp_Var16

	; Store byte into buffer
	STA Ending_CmdBuffer,X
	INX		 ; X++ (next buffer byte)

PRG024_BE02:

	; Bit 7 not set (or just continued)

	; Store byte into buffer
	LDA <Temp_Var16	
	STA Ending_CmdBuffer,X
	INX		 ; X++ (next buffer byte)

	INY		 ; Y++ (next EndPic command byte)

	CPX #$c1
	BLT PRG024_BDF0	 ; While buffer index < $C1, loop!

	; Buffer filled...

	LDY <Ending2_CurWorld	; Y = current world we're depicting

	; Set starting VRAM address
	LDA EndPic_VRAMStart_H,Y
	STA <Ending2_PicVRAMH
	LDA EndPic_VRAMStart_L,Y
	STA <Ending2_PicVRAML

	INC <Ending2_PicState		 ; Ending2_PicState = 4

	; Ending2_ClearLen = $B
	LDA #$0b
	STA <Ending2_ClearLen

	; Ending2_QCmdEnd = 0
	LDA #$00
	STA <Ending2_QCmdEnd

	RTS		 ; Return

Ending2_SetFlag2:
	; Ending2_IntCmd = 2
	LDA #$02
	STA <Ending2_IntCmd

	RTS		 ; Return


PRG024_BE29:
	.byte $2A, $2E, $32, $36, $3A, $3E, $44, $49
PRG024_BE31:
	.byte $2D, $31, $35, $39, $3D, $43, $48, $4C

Ending2_CommitPicture:
	LDA PPU_STAT	

	; Set VRAM Address to Ending2_PicVRAMH/L
	LDA <Ending2_PicVRAMH
	STA PPU_VRAM_ADDR
	LDA <Ending2_PicVRAML
	STA PPU_VRAM_ADDR

	LDX #$0f	 	; X = 4
	LDY <Ending2_QCmdEnd	; Y = Ending2_QCmdEnd
PRG024_BE4A:

	; Buffer -> PPU_VRAM_DATA
	LDA Ending_CmdBuffer,Y
	STA PPU_VRAM_DATA

	INY		 ; Y++
	DEX		 ; X--
	BPL PRG024_BE4A	 ; While X >= 0, loop

	STY <Ending2_QCmdEnd	; Update Ending2_QCmdEnd

	JSR Ending2_PicVRAM_NextLineWrap	; Next line

	DEC <Ending2_ClearLen	; Ending2_ClearLen--
	BPL PRG024_BE6B	 	; If Ending2_ClearLen >= 0, jump to PRG024_BE6B (RTS)

	INC <Ending2_PicState	; Ending2_PicState++

	LDX <Ending2_CurWorld	; X = current world we're depicting

	LDA PRG024_BE29,X
	STA <Ending2_QueueCmd

	LDA PRG024_BE31,X
	STA <Ending2_QCmdEnd

PRG024_BE6B:
	RTS		 ; Return

Ending2_SeriesQueue:
	; Execute next command
	LDA <Ending2_QueueCmd
	STA <Graphics_Queue

	CMP <Ending2_QCmdEnd
	BNE PRG024_BE76	 ; If this is not the last series command to execute, jump to PRG024_BE76

	; Last command executed!
	INC <Ending2_PicState		 ; Ending2_PicState = 6

PRG024_BE76:
	INC <Ending2_QueueCmd		 ; Ending2_QueueCmd++

	RTS		 ; Return

Ending2_AddSprites:

	; Clear ending sprites
	LDA #$f8
	STA Sprite_RAM+$24
	STA Sprite_RAM+$28
	STA Sprite_RAM+$2C
	STA Sprite_RAM+$30
	STA Sprite_RAM+$34
	STA Sprite_RAM+$38
	STA Sprite_RAM+$3C
	STA Sprite_RAM+$40
	STA Sprite_RAM+$44

	LDY <Ending2_CurWorld	; Y = current world we're depicting

	; Load pattern tables required for this world picture sprites
	LDA Ending2_EndPicPatTable2,Y
	STA PatTable_BankSel+2
	LDA Ending2_EndPicPatTable3,Y
	STA PatTable_BankSel+3
	LDA Ending2_EndPicPatTable4,Y
	STA PatTable_BankSel+4
	LDA Ending2_EndPicPatTable5,Y
	STA PatTable_BankSel+5

	; Load starting address for sprite list
	LDA Ending2_EndPicSpriteListH,Y
	STA <Temp_Var2
	LDA Ending2_EndPicSpriteListL,Y
	STA <Temp_Var1

	; Load length of sprite list
	LDA Ending2_EndPicSpriteListLen,Y
	TAY

	; Copy sprite data in
PRG024_BEBE:
	LDA [Temp_Var1],Y
	STA Sprite_RAM,Y

	DEY		 ; Y--
	BPL PRG024_BEBE	 ; While Y >= 0, loop

	INC <Ending2_PicState	 ; Ending2_PicState = 7

	; Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

	; Ending2_QueueCmd = $26
	LDA #$26
	STA <Ending2_QueueCmd

	RTS		 ; Return


Ending2_FadeIn:
	DEC <Ending2_FadeTimer	; Ending2_FadeTimer--
	BPL PRG024_BEFB	 	; If Ending2_FadeTimer >= 0, jump to PRG024_BEFB (RTS)

	; Reload Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

	; Queue graphics command
	LDA <Ending2_QueueCmd
	STA Graphics_Queue

	CMP #$2a
	BNE PRG024_BEF9	 ; If Ending2_QueueCmd <> $2A, jump to PRG024_BEF9

	INC <Ending2_PicState	 ; Ending2_PicState = 8

	; Queue the full palette (fade in is common)
	LDA <Ending2_CurWorld	; A = current world we're depicting
	ADD #$4d
	STA Graphics_Queue

	; Ending2_TimerH = $F
	LDA #$0f
	STA <Ending2_TimerH

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	; Ending2_QueueCmd = $06
	LDA #(Ending2_FadeOutQs_End - Ending2_FadeOutQs - 1)
	STA <Ending2_QueueCmd

	RTS		 ; Return

PRG024_BEF9:
	INC <Ending2_QueueCmd		 ; Ending2_QueueCmd++

PRG024_BEFB:
	RTS		 ; Return

Ending2_Wait:
	; Ending2_TimerL--
	LDA <Ending2_TimerL
	SUB #$01
	STA <Ending2_TimerL
	BCS PRG024_BF13	 ; If Ending2_TimerL >= 0, jump to PRG024_BF13 (RTS)

	; Ending2_TimerL = $16
	LDA #$16
	STA <Ending2_TimerL

	DEC <Ending2_TimerH	 ; Ending2_TimerH--
	BPL PRG024_BF13	 	; If Ending2_TimerH >= 0, jump to PRG024_BF13 (RTS)

	INC <Ending2_PicState		 ; Ending2_PicState = 9

	; Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

PRG024_BF13:
	RTS		 ; Return

	; Fade out command queues
Ending2_FadeOutQs:
	.byte $25, $26, $27, $28, $28, $28, $28
Ending2_FadeOutQs_End
	
Ending2_FadeOut:
	DEC <Ending2_FadeTimer
	BPL PRG024_BF37	 ; If Ending2_FadeTimer >= 0, jump to PRG024_BF37 (RTS)

	; Ending2_FadeTimer = 3
	LDA #$03
	STA <Ending2_FadeTimer

	LDX <Ending2_QueueCmd	 ; X = Ending2_QueueCmd (current index)

	; Queue next fade command
	LDA Ending2_FadeOutQs,X
	STA Graphics_Queue

	CMP #$25
	BNE PRG024_BF35	 ; If current queue command <> $25, jump to PRG024_BF35

	; Restart ending picture generation
	LDA #$01
	STA <Ending2_PicState	; Ending2_PicState = 1

	INC <Ending2_CurWorld		 ; Ending2_CurWorld++ (display next world in series)

PRG024_BF35:
	DEC <Ending2_QueueCmd		 ; Ending2_QueueCmd--

PRG024_BF37:
	RTS		 ; Return


; FIXME: Anybody want to claim this??
; Seems to be called by dead code, would advance to next row or wrap around; maybe a clearing routine?
Ending2_PicVRAM_NextLineWrap:

	; Add 32 to VRAM address for next row
	LDA <Ending2_PicVRAML
	ADD #32
	STA <Ending2_PicVRAML
	LDA <Ending2_PicVRAMH
	ADC #$00
	STA <Ending2_PicVRAMH

	CMP #$28
	BGE PRG024_BF5D	; If VRAM High address >= $28, jump to PRG024_BF5D (RTS)

	CMP #$23
	BLT PRG024_BF5D	; If VRAM High address < $23, jump to PRG024_BF5D (RTS)

	LDA <Ending2_PicVRAML
	CMP #$c0
	BLT PRG024_BF5D	; If VRAM Low address < $C0, jump to PRG024_BF5D (RTS)

	; This will wrap the VRAM address to the top (???)

	; Ending2_PicVRAMH = $28
	LDA #$28
	STA <Ending2_PicVRAMH

	; Column on top row
	LDA <Ending2_PicVRAML
	AND #$1f
	STA <Ending2_PicVRAML

PRG024_BF5D:
	RTS		 ; Return

	; PatTable_BankSel+X values (sprite pattern tables) loaded per "world" of ending picture
Ending2_EndPicPatTable2:	.byte $57, $53, $51, $00, $43, $02, $44, $54
Ending2_EndPicPatTable3:	.byte $00, $04, $00, $76, $76, $76, $04, $76
Ending2_EndPicPatTable4:	.byte $57, $4E, $1A, $1A, $00, $0B, $00, $00
Ending2_EndPicPatTable5:	.byte $4F, $4F, $00, $00, $4F, $4F, $4F, $00

	; Split address, parallel tables for the starting address of the end picture sprite lists for each world
Ending2_EndPicSpriteListH:	
	.byte HIGH(Ending2_EndPicSprites1)
	.byte HIGH(Ending2_EndPicSprites2)
	.byte HIGH(Ending2_EndPicSprites3)
	.byte HIGH(Ending2_EndPicSprites4)
	.byte HIGH(Ending2_EndPicSprites5)
	.byte HIGH(Ending2_EndPicSprites6)
	.byte HIGH(Ending2_EndPicSprites7)
	.byte HIGH(Ending2_EndPicSprites8)

Ending2_EndPicSpriteListL:
	.byte LOW(Ending2_EndPicSprites1)
	.byte LOW(Ending2_EndPicSprites2)
	.byte LOW(Ending2_EndPicSprites3)
	.byte LOW(Ending2_EndPicSprites4)
	.byte LOW(Ending2_EndPicSprites5)
	.byte LOW(Ending2_EndPicSprites6)
	.byte LOW(Ending2_EndPicSprites7)
	.byte LOW(Ending2_EndPicSprites8)

	; Length of the sprite list per world - 1 (or last index, if you prefer)
Ending2_EndPicSpriteListLen:	
	.byte (Ending2_EndPicSprites1_End - Ending2_EndPicSprites1 - 1)
	.byte (Ending2_EndPicSprites2_End - Ending2_EndPicSprites2 - 1)
	.byte (Ending2_EndPicSprites3_End - Ending2_EndPicSprites3 - 1)
	.byte (Ending2_EndPicSprites4_End - Ending2_EndPicSprites4 - 1)
	.byte (Ending2_EndPicSprites5_End - Ending2_EndPicSprites5 - 1)
	.byte (Ending2_EndPicSprites6_End - Ending2_EndPicSprites6 - 1)
	.byte (Ending2_EndPicSprites7_End - Ending2_EndPicSprites7 - 1)
	.byte (Ending2_EndPicSprites8_End - Ending2_EndPicSprites8 - 1)

Ending2_EndPicSprites1:
	.byte $81, $19, $00, $B0
	.byte $81, $1B, $00, $B8
	.byte $91, $1D, $00, $B0
	.byte $91, $21, $00, $B8
	.byte $B1, $EB, $01, $B8
	.byte $B1, $EB, $41, $C0
	.byte $B1, $D9, $01, $80
	.byte $B1, $DB, $41, $88
	.byte $B1, $D9, $01, $90
	.byte $B1, $DB, $41, $98
Ending2_EndPicSprites1_End

Ending2_EndPicSprites2:
	.byte $79, $1B, $40, $38
	.byte $79, $19, $40, $40
	.byte $99, $67, $01, $50
	.byte $B1, $65, $01, $70
	.byte $A9, $85, $01, $88
	.byte $A9, $87, $01, $90
	.byte $B9, $A5, $01, $88
	.byte $B9, $A7, $01, $90
	.byte $91, $8D, $02, $A8
	.byte $91, $8F, $02, $B0
	.byte $99, $B1, $02, $D0
	.byte $99, $B3, $02, $D8
	.byte $A9, $B5, $02, $D0
	.byte $A9, $B7, $02, $D8
Ending2_EndPicSprites2_End

Ending2_EndPicSprites3:
	.byte $3F, $B1, $01, $30
	.byte $3F, $B1, $41, $38
	.byte $47, $B5

	; List continued in PRG025



