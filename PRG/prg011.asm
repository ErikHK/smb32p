; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:36.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
PRG011_A000:
	.byte $00, $01, $02, $03, $04, $05, $06, $07

Map_Unused7EEA_Vals:
	; LUT indexed by world number with no apparent use?
	.byte $02, $04, $03, $FF, $03, $04, $03, $05

	; This sets up the world map objects
Map_List_Object_Ys:
	; List of Y values for objects on this world
	.word W1_Obj_Ys, W2_Obj_Ys, W3_Obj_Ys, W4_Obj_Ys, W5_Obj_Ys, W6_Obj_Ys, W7_Obj_Ys, W8_Obj_Ys

Map_List_Object_XHis:
	.word W1_Obj_XHis, W2_Obj_XHis, W3_Obj_XHis, W4_Obj_XHis, W5_Obj_XHis, W6_Obj_XHis, W7_Obj_XHis, W8_Obj_XHis

Map_List_Object_XLos:
	; List of X values for objects on this world
	.word W1_Obj_XLos, W2_Obj_XLos, W3_Obj_XLos, W4_Obj_XLos, W5_Obj_XLos, W6_Obj_XLos, W7_Obj_XLos, W8_Obj_XLos

Map_List_Object_IDs:
	; Object ID list for objects on this world
	.word W1_Obj_IDs, W2_Obj_IDs, W3_Obj_IDs, W4_Obj_IDs, W5_Obj_IDs, W6_Obj_IDs, W7_Obj_IDs, W8_Obj_IDs

Map_List_Object_Items:
	.word W1_Obj_Items, W2_Obj_Items, W3_Obj_Items, W4_Obj_Items, W5_Obj_Items, W6_Obj_Items, W7_Obj_Items, W8_Obj_Items

; The 'Y' position of each map object
W1_Obj_Ys:	.include "PRG/maps/World1OY"
W2_Obj_Ys:	.include "PRG/maps/World2OY"
W3_Obj_Ys:	.include "PRG/maps/World3OY"
W4_Obj_Ys:	.include "PRG/maps/World4OY"
W5_Obj_Ys:	.include "PRG/maps/World5OY"
W6_Obj_Ys:	.include "PRG/maps/World6OY"
W7_Obj_Ys:	.include "PRG/maps/World7OY"
W8_Obj_Ys:	.include "PRG/maps/World8OY"

; The hi and low (respective) X coordinates of the map objects
W1_Obj_XHis:	.include "PRG/maps/World1OH"
W2_Obj_XHis:	.include "PRG/maps/World2OH"
W3_Obj_XHis:	.include "PRG/maps/World3OH"
W4_Obj_XHis:	.include "PRG/maps/World4OH"
W5_Obj_XHis:	.include "PRG/maps/World5OH"
W6_Obj_XHis:	.include "PRG/maps/World6OH"
W7_Obj_XHis:	.include "PRG/maps/World7OH"
W8_Obj_XHis:	.include "PRG/maps/World8OH"
W1_Obj_XLos:	.include "PRG/maps/World1OX"
W2_Obj_XLos:	.include "PRG/maps/World2OX"
W3_Obj_XLos:	.include "PRG/maps/World3OX"
W4_Obj_XLos:	.include "PRG/maps/World4OX"
W5_Obj_XLos:	.include "PRG/maps/World5OX"
W6_Obj_XLos:	.include "PRG/maps/World6OX"
W7_Obj_XLos:	.include "PRG/maps/World7OX"
W8_Obj_XLos:	.include "PRG/maps/World8OX"

; The IDs of the map objects
; NOTE: The second index is considered reserved for the Airship, which will
; always and only occupy that slot; do not use it for regular maps!
; (World 8 would probably be okay though?)
W1_Obj_IDs:	.include "PRG/maps/World1O"
W2_Obj_IDs:	.include "PRG/maps/World2O"
W3_Obj_IDs:	.include "PRG/maps/World3O"
W4_Obj_IDs:	.include "PRG/maps/World4O"
W5_Obj_IDs:	.include "PRG/maps/World5O"
W6_Obj_IDs:	.include "PRG/maps/World6O"
W7_Obj_IDs:	.include "PRG/maps/World7O"
W8_Obj_IDs:	.include "PRG/maps/World8O"

; The item that this "event" gives you (for hammer brothers only I think)
; 1 - Super, 2 - Fire, 3 - Leaf, 4 - Frog, 5 - Tanooki, 6 - Hammer, 7 - Judgems, 8 - Pwing, 9 - Star
; A - Anchor, B - Hammer, C - Warp Whistle, D - Music Box
W1_Obj_Items:	.include "PRG/maps/World1OI"
W2_Obj_Items:	.include "PRG/maps/World2OI"
W3_Obj_Items:	.include "PRG/maps/World3OI"
W4_Obj_Items:	.include "PRG/maps/World4OI"
W5_Obj_Items:	.include "PRG/maps/World5OI"
W6_Obj_Items:	.include "PRG/maps/World6OI"
W7_Obj_Items:	.include "PRG/maps/World7OI"
W8_Obj_Items:	.include "PRG/maps/World8OI"


PRG011_A1C8:
	.byte $03, $04, $05, $01, $03, $05, $01, $01
	.byte $00, $00, $00, $00, $00, $00, $00, $00

Map_Init:
	JSR Map_Airship_Pick_Travel	; Based on world number and a bit of random, selects which set of destinations the airship will use (referred to as A, B, or C)
	LDX World_Num	 		; X = World_Num

	; Unknown lookup val stored to an unused variable
	LDA Map_Unused7EEA_Vals,X	; LUT based on world number for?
	STA Map_Unused7EEA		; Stored into Map_Unused7EEA

	; X = World_Num << 1
	TXA
	ASL A
	TAX

	; Set address of object Y list for this world
	LDA Map_List_Object_Ys,X
	STA <Temp_Var11	
	LDA Map_List_Object_Ys+1,X
	STA <Temp_Var12	

	; Set address of object X (hi byte) list for this world
	LDA Map_List_Object_XHis,X
	STA <Temp_Var13	
	LDA Map_List_Object_XHis+1,X
	STA <Temp_Var14	

	; Set address of object X (lo byte) list for this world
	LDA Map_List_Object_XLos,X
	STA <Temp_Var15	
	LDA Map_List_Object_XLos+1,X
	STA <Temp_Var16	

	; Set address of object ID list for this world
	LDA Map_List_Object_IDs,X
	STA <Temp_Var9
	LDA Map_List_Object_IDs+1,X
	STA <Temp_Var10

	; Set address of object item list for this world
	LDA Map_List_Object_Items,X
	STA <Temp_Var7
	LDA Map_List_Object_Items+1,X
	STA <Temp_Var8

	; Loop MAPOBJ_TOTALINIT times for all defined map objects
	LDY #MAPOBJ_TOTALINIT
PRG011_A21B:

	; Copy in the data relevant to this map object
	LDA [Temp_Var11],Y
	STA Map_Objects_Y,Y	; Y
	LDA [Temp_Var13],Y
	STA Map_Objects_XHi,Y	; XHi
	LDA [Temp_Var15],Y	
	STA Map_Objects_XLo,Y	; XLo
	LDA [Temp_Var9],Y	
	STA Map_Objects_IDs,Y	; ID
	LDA [Temp_Var7],Y	
	STA Map_Objects_Itm,Y	; Item

	DEY		 ; Y--
	BPL PRG011_A21B	 ; While Y >= 0, go around again...

	LDY World_Num	 	; Y = World_Num
	LDX Total_Players	; X = Total players (1 for 1P, 2 for 2P)
	DEX		 	; X--

	; Initialization for players...
PRG011_A23E:
	; X is the player index, 1 = Luigi, 0 = Mario
	; Y is World_Num

	; Set starting Y position
	LDA Map_Y_Starts,Y
	STA Map_Entered_Y,X
	STA Map_Previous_Y,X

	; Set starting X position (forced to $20!)
	LDA #$20	 
	STA Map_Entered_X,X
	STA Map_Previous_X,X

	; Set Player's previous movement direction
	LDA #$01
	STA Map_Previous_Dir,X

	LDA #$00
	STA Map_Previous_UnusedPVal2,X
	STA Map_Entered_XHi,X
	STA Map_Previous_XHi,X
	STA Map_Unused7984,X	; Cleared here, but never used
	STA Map_Prev_XOff2,X
	STA Map_Prev_XHi2,X
	STA Map_Unused798A,X	; Cleared here, but never used
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X

	DEX		 ; X--
	BPL PRG011_A23E	 ; As long as we have another player to init, loop!

	STX Map_2PVsGame ; Map_2PVsGame = $FF (since game increments at start, this will play game style 0)

	; Clear the following
	STA Map_Unused7995	; Cleared here, but never used
	STA Map_WhiteHouse
	STA Map_CoinShip

	RTS		 ; Return

Map_Airship_Travel_BaseIdx:
	; Base index value, per-world
	;      W1   W2   W3   W4   W5   W6   W7   W8
	.byte $00, $03, $06, $09, $0C, $0F, $12, $15

Map_Airship_Travel_Random:
	; Randomly selected offsets
	.byte $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00


	; At the beginning of the world, this randomly selects a set of travel destinations the airship will take, six defined per set.
Map_Airship_Pick_Travel:
	LDY World_Num		; Y = World_Num
	LDA RandomN		; A = random
	AND #$0f		; Capped 0-15
	TAX			; X = random number 0-15
	LDA Map_Airship_Travel_Random,X		; Get initial random offset value (essentially amounts to a random value of 0 to 2)
	ADD Map_Airship_Travel_BaseIdx,Y	; Apply base index (Adds 3x World_Num)
	STA Map_Airship_Trav	; Store as the Map_Airship_Trav value
	RTS		 	; Return


	; Offset to Player-specific inventory items
Inventory_OffsetByPlayer:	.byte (Inventory_Items - Inventory_Items), (Inventory_Items2 - Inventory_Items)


	; FIXME: Anyone want to claim this?
	; What it appears to do is examine the inventory item of the current Player in the slot
	; determined by unused variable Map_Unused738.  If that inventory slot contains a mushroom, 
	; it jumps to a state table (otherwise does nothing but regular map stuff.)  What state gets
	; called depends on what inventory slot was checked; in this case it roughly split calls the
	; regular map update or part of the world starry entrance (?), and in only once case calls 
	; the warp whistle effect.  Given these strange properties, it was probably just some kind
	; of debug routine to test map features.
; $A2AF
	LDX Player_Current	 ; X = Player_Current

	; Temp_Var1 = offset to Player's inventory
	LDA Inventory_OffsetByPlayer,X
	STA <Temp_Var1

	LDA Map_Unused738	; Get Map_Unused738
	ADD <Temp_Var1	; Add offset to inventory ?
	TAX		; -> 'X'

	LDA Inventory_Items,X
	CMP #$01
	BEQ PRG011_A2C8	 ; If inventory item = 1 (Mushroom??), jump to PRG011_A2C8

	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

PRG011_A2C8:
	LDX Map_Unused738	 ; X = Map_Unused738

	; Seems Map_Unused7DC6 was pretty interesting once?
	LDA Map_Unused7DC6,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_B74A		; 0
	.word WorldMap_UpdateAndDrawInd	; 1
	.word WorldMap_UpdateAndDrawInd	; 2
	.word WorldMap_UpdateAndDrawInd	; 3
	.word WorldMap_UpdateAndDrawInd	; 4
	.word PRG011_B74A		; 5
	.word WorldMap_UpdateAndDrawInd	; 6
	.word Map_DoMap_WarpWind_FX	; 7
	.word WorldMap_UpdateAndDrawInd	; 8
	.word WorldMap_UpdateAndDrawInd	; 9
	.word PRG011_B74A		; 10
	.word PRG011_B74A		; 11
	.word PRG011_B74A		; 12
	.word PRG011_B74A		; 13
	.word PRG011_B74A		; 14
	.word PRG011_B74A		; 15

WorldMap_UpdateAndDrawInd:
	JMP WorldMap_UpdateAndDraw

Map_WW_StartX:	.byte 0, 240	; Map warp wind starting X position, depending which direction it comes from
Map_WW_DeltaX:	.byte 2, -2	; Position change depending on the direction of travel
Map_WW_TargetX:	.byte 240, 0	; The ending position, depending on direction of travel

	; Starting Y position depending on what world you came from
Map_WW_IslandY:
	.byte $50, $70, $70	; World 1 - 3
	.byte $70, $70, $70	; World 4 - 6
	.byte $90, $90, $90	; World 7 - 9

	; Unused?  Guessing this was possible X Hi init values,
	; though always zero (maybe there would've been multiple
	; islands?  Per group of worlds?)
	.byte $00, $00, $00	; World 1 - 3
	.byte $00, $00, $00	; World 4 - 6
	.byte $00, $00, $00	; World 7 - 9

	; Starting X position depending on what world you came from
Map_WW_IslandX:
	.byte $40, $40, $40	; World 1 - 3
	.byte $40, $40, $40	; World 4 - 6
	.byte $80, $80, $80  	; World 7 - 9


Map_DoMap_WarpWind_FX:

	; Note: In original Japanese version, you could warp from a canoe and then
	; sail yourself off the warp island (but never get back on!)  This fixes 
	; that bug with a vengeance, since it will be called several times :)
	LDA #$00	 	
	STA Map_InCanoe_Flag	; Map_InCanoe_Flag = 0 (not in canoe)

	; NOTE: If Map_WarpWind_FX = 0,  Map_DoMap_WarpWind_FX is never called,
	; so state 0 is technically never used... that's okay, it actually
	; contains a "bug", which might just be unmaintained legacy code..

	; Dynamic jump based on current map special effect occurring..
	LDA <Map_WarpWind_FX	
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word WWFX_WarpWhistleInit	; 0 - Initializes the warp whistle (NEVER USED, Inv_UseItem_WarpWhistle does this instead)
	.word WWFX_WarpWhistleFlash	; 1 - Does the "flash" effect of the whistle
	.word WWFX_WarpDoWind		; 2 - Does the wind effect, catches the Player, sets World_Num = 8 (World 9), and clears map objects
	.word WWFX_WarpIslandInit	; 3 - Initialize stuff for the warp island, including setting proper Player X/Y position
	.word WWFX_WarpLanding		; 4 - Does the wind effect, drops Player off
	.word WWFX_WarpWhistleFlash	; 5 - UNUSED; same as State 1, except it will crash by trying to go to undefined "State 6"!

WarpWhistle_Flash:
	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A333	 	; If Map_WWOrHT_Cnt <> 0, jump to PRG011_A333

	LDA #$20	 
	STA <Map_WWOrHT_Cnt	; Otherwise, Map_WWOrHT_Cnt = $20


PRG011_A333:

	; Basically here's what does the white flashing effect
	LDY #%00011000		; Show BG + Sprites
	DEC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt--
	AND #$04	 
	BEQ PRG011_A33D	 	; Every 4 ticks, toggle mono effect
	LDY #%00011001		; Show BG + Sprites + Mono

PRG011_A33D:
	STY <PPU_CTL2_Copy	; Update
	RTS		 	; Return...

WWFX_WarpWhistleInit:

	; *** WWFX_WarpWhistleInit is NEVER USED, Inv_UseItem_WarpWhistle does this instead!

	LDY Player_Current	; Y = Player_Current
	LDX #$00	 	; X = 0 (come from left)
	LDA World_Map_X,Y	; Get Player's world map X coordinate
	SUB <Horz_Scroll
	CMP #$80	 	
	BGE PRG011_A351	 	; If map is scrolled halfway across, jump to PRG011_A351
	LDX #$01	 	; Otherwise X = 1 (come from right)

PRG011_A351:
	STX <Map_WWOrHT_Dir	; Store 'X' as direction of warp wind travel

	LDA Map_WW_StartX,X
	STA <Map_WWOrHT_X	; Set appropriate starting X position

	LDA World_Map_Y,Y	
	STA <Map_WWOrHT_Y	; Set Y position equal to Player
	STA Map_PlyrSprOvrY	; Set Map_PlyrSprOvrY 

	LDX #$05	 	; X = 5 NOTE: This is broken (and seems unused anyway); see NOTE @ PRG011_A381

	LDA Map_WW_Backup_Y	; Load the backed up Y position
	BNE PRG011_A381	 	; If its non-zero, jump to PRG011_A381

	; Otherwise, we need to back up everything!  (Y is the only one that absolutely could not be zero)
	; But I don't know why?
	LDA World_Map_Y,Y
	STA Map_WW_Backup_Y	; Store Player's map Y position

	LDA World_Map_X,Y	
	STA Map_WW_Backup_X	; Store Player's map X position

	LDA World_Map_XHi,Y	
	STA Map_WW_Backup_XH	; Store Player's map X Hi position

	LDA Map_UnusedPlayerVal2,Y	
	STA Map_WW_Backup_UPV2	; Store Player's Map_WW_Backup_UPV2

	LDX #$01	 	; X = 1

PRG011_A381:
	; NOTE: There's an alternate state 5 here that by the jump table is the same
	; as state 1, in theory if it flashes after the backup has already been performed.
	; Couple of problems: Why the backup already be performed?  And the other
	; problem is there's nothing after state 5, yet the state code will blindly
	; increment the state when it finishes, resulting in a crash!
	; I'm thinking that's some kind of lost state for something else?

	; But that's okay, because technically this routine isn't used anyway! :X

	STX <Map_WarpWind_FX		; Map_WarpWind_FX = ... 5 if backup already performed, 1 if not 
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


WWFX_WarpWhistleFlash:
	LDA Sound_QMusic2
	CMP #MUS2A_WARPWHISTLE	 
	BEQ PRG011_A396	 		; If Sound_QMusic2 <> MUS2A_WARPWHISTLE, jump to PRG011_A396

	JSR WarpWhistle_Flash		; Do the "flash" effect of the warp whistle

	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A396	 		; If the counter isn't zero yet, jump to PRG011_A396

	INC <Map_WarpWind_FX		; Otherwise, next state!

PRG011_A396:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


WWFX_WarpDoWind:
	INC <Map_WWOrHT_Cnt		; Map_WWOrHT_Cnt++

	LDY Player_Current	 	; Y = Player_Current
	LDX <Map_WWOrHT_Dir		; X = Map_WWOrHT_Dir

	LDA <Map_WWOrHT_X
	ADD Map_WW_DeltaX,X
	STA <Map_WWOrHT_X		; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

	LDA World_Map_X,Y
	SUB <Horz_Scroll
	CMP <Map_WWOrHT_X
	BNE PRG011_A3BA	 		; If warp wind hasn't hit the Player yet, jump to PRG011_A3BA

	LDA #$f8
	STA Map_PlyrSprOvrY	 	; Map_PlyrSprOvrY = $F8 (will erase Player's map sprite)
	JMP PRG011_A3D9	 		; Jump to PRG011_A3D9...

PRG011_A3BA:
	; Haven't hit the Player yet...
	LDA <Map_WWOrHT_X		
	CMP Map_WW_TargetX,X
	BNE PRG011_A3D9	 		; If Warp Wind hasn't reached its target edge yet, jump to PRG011_A3D9

	LDA World_Num	 	
	STA Map_Warp_PrevWorld	 	; Map_Warp_PrevWorld = World_Num (where you're coming FROM)

	LDA #$08	 
	STA World_Num	 		; World_Num = 8 (World 9)

	; Clears out map objects 
	LDY #(MAPOBJ_TOTAL-1) ; Y = (MAPOBJ_TOTAL-1)
	LDA #MAPOBJ_EMPTY ; A = MAPOBJ_EMPTY
PRG011_A3D0:
	STA Map_Objects_IDs,Y
	DEY		 ; Y--
	BPL PRG011_A3D0	 ; If Y >= 0, loop..

	INC <Map_WarpWind_FX		; Next state...
	RTS		 ; Return

PRG011_A3D9:
	JSR WorldMap_UpdateAndDraw	; Update and draw map

	LDA <Map_WWOrHT_X
	STA <Temp_Var2			; Temp_Var2 = Map_WWOrHT_X

	LDA #$01
	STA <Temp_Var3		 	; Temp_Var3 = 1 (uses palette 1, the white color; otherwise would use hand trap stuff)

	JMP WarpWindHandTrap_Draw	 		; Jump to WarpWindHandTrap_Draw...


WWFX_WarpIslandInit:
	LDA #$00
	STA <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt = 0

	LDA #248
	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248 (overwritten further down... oops?)
	INC <Map_WarpWind_FX	; Next state...

	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld
	LDX Player_Current	; X = Map_Warp_PrevWorld

	; Clears all map X related variables
	LDA #$00
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X
	STA <World_Map_XHi,X

	LDA Map_WW_IslandX,Y
	STA <World_Map_X,X	; Store appropriate X coordinate based on world you came from

	LDA #240
LT0:	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 240 (oops, reassigned?)

	LDA Map_WW_IslandY,Y
	STA <Map_WWOrHT_Y	; Store appropriate Y coordinate based on world you came from

	LDA #$80	 
	STA Map_Intro_Tick	; Map_Intro_Tick = $80

	LDA #$03	
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 3 (??)

	LDA #$00	 
	STA Map_Unused72C	 ; Map_Unused72C = 0

	RTS		 ; Return

WWFX_WarpLanding:
	LDA #$00	 
	STA Map_ReturnStatus 	; Map_ReturnStatus = 0 (was just set to 3?)

	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (reassigned not two instructions later!)
	LDX Player_Current	; X = Player_Current

	INC <Map_WWOrHT_Cnt	; Map_WWOrHT_Cnt++

	LDY Map_Warp_PrevWorld	; Y = Map_Warp_PrevWorld (assigned again??)
	LDX <Map_WWOrHT_Dir	; X = Map_WWOrHT_Dir

	LDA <Map_WWOrHT_X
	ADD Map_WW_DeltaX,X	; Map_WWOrHT_X += Map_WW_DeltaX[X] (travels based on direction)

	STA <Map_WWOrHT_X
	CMP Map_WW_IslandX,Y
	BNE PRG011_A44C	 	; If wind hasn't reached your landing point, jump to PRG011_A44C

	LDX Player_Current	; X = Player_Current

	LDA Map_WW_IslandY,Y
	STA Map_PlyrSprOvrY	; Map_PlyrSprOvrY = Map_WW_IslandY[Y] (target Y) (restore map sprite)
	STA <World_Map_Y,X	; World_Map_Y = Map_WW_IslandY[Y] (target Y)

	JMP PRG011_A45B	 	; Jump to PRG011_A45B

PRG011_A44C:
	; Wind hasn't reached landing point... (or is passed it already, as the case may be)

	CMP Map_WW_TargetX,X
	BNE PRG011_A45B	 	; If warp wind hasn't hit the appropriate edge, jump to PRG011_A45B

	; Otherwise, shut it down!
	LDA #$00	 
	STA <Map_WWOrHT_Cnt
	STA <Map_WarpWind_FX

	LDA #248
	STA <Map_WWOrHT_X	; Map_WWOrHT_X = 248

PRG011_A45B:
	JMP PRG011_A3D9	 ; Jump to PRG011_A3D9


MO_HandTrap:
	LDA Map_HandState
	JSR DynJump	 

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word HT_Init
	.word HT_Flash
	.word HT_GrabPlayer

HT_Init:
	LDX Player_Current
	LDA <World_Map_Y,X
	STA Map_PlyrSprOvrY	; Reset Map_PlyrSprOvrY to the Player's current Y

	ADD #16
	STA <Map_WWOrHT_Y	; Start 16 pixels beneath Player

	; Match Player's X
	LDA <World_Map_XHi,X	 
	STA <Map_HandTrap_XHi	
	LDA <World_Map_X,X
	STA <Map_WWOrHT_X

	INC Map_HandState		; Next state...
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back

HT_Flash:
	JSR WarpWhistle_Flash	 	; Reused flashing effect

	LDA <Map_WWOrHT_Cnt
	BNE PRG011_A494	 		; If Map_WWOrHT_Cnt <> 0, the effect is not over, jump to PRG011_A494

	INC Map_HandState	 	; Next state...

	LDA #SND_LEVELRISE	 
	STA Sound_QLevel1		; "Rising" sound

PRG011_A494:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


HT_GrabPlayer:
	LDA #$01
	STA <Temp_Var1			; Temp_Var1 = 1

	JSR HT_DoRaiseAndFall	 	; Raise hand, take Player down with it

	LDA <Map_WWOrHT_Cnt
	CMP #32 
	BNE PRG011_A4B8	 		; If Map_WWOrHT_Cnt <> 32, jump to PRG011_A4B8

	LDA #$10
	STA Map_Operation	 	; Map_Operation = $10 (enter level)

	LDX Player_Current
	LDA #$00	 
	STA Map_Player_SkidBack,X	; Map_Player_SkidBack = 0
	STA World_EnterState		; World_EnterState = 0
	STA Map_HandState	 	; The multipurpose state variable is reset
	RTS		 		; Return...


PRG011_A4B8:
	JSR WorldMap_UpdateAndDraw	; Do WorldMap_UpdateAndDraw

	LDX Player_Current
	LDA <World_Map_Y,X
	ADD #16
	STA <Temp_Var1		 	; Temp_Var1 = Player's map Y + 16

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	STA <Temp_Var2		 	; Temp_Var2 = Player's map X - Horz_Scroll

	LDA #$00
	STA <Temp_Var3		 	; Temp_Var3 = 0
	JMP PRG011_A503	 		; Jump to PRG011_A503

	; Hand Trap raises for 16 ticks (-1), then falls (1)
HT_RaiseFall:	.byte -1, 1

HT_DoRaiseAndFall:
	LDA <Counter_1
	AND #$01	
	BNE PRG011_A4FC	 	; Every other tic, jump to PRG011_A4FC

	; More specifically, 16 tics for the hand to come up, 16
	; tics for the hand to go down...
	LDA <Map_WWOrHT_Cnt
	AND #$10	 	; Every 16 counter tics...
	LSR A	
	LSR A	
	LSR A	
	LSR A		 	; Amounts to 0/1 every 16 tics
	TAY		 	; Y = 0 or 1
	LDX Player_Current	; X = Player_Current

	LDA <Map_WWOrHT_Y
	ADD HT_RaiseFall,Y
	STA <Map_WWOrHT_Y	; Hand trap's Y += HT_RaiseFall[Y]

	INC <Map_WWOrHT_Cnt
	LDA <Map_WWOrHT_Cnt
	AND #$10
	BEQ PRG011_A4FC	 	; If hand is still raising (pre 16 ticks), jump to PRG011_A4FC

	; As hand falls, it takes Player down with it!
	LDA <Map_WWOrHT_Y	
	STA Map_PlyrSprOvrY	

PRG011_A4FC:
	RTS		 	; Return...

	; NOTE: These values are shared with the HAND TRAP of World 8
Map_WW_Pal:	.byte $01, $03	; The former is a BROWN color (hand trap), the latter is its white color
Map_WW_Pattern:
	.byte $59, $51	; Frame 0 (Hand, Wind)
	.byte $5D, $55	; Frame 1 (Hand, Wind)

PRG011_A503:

	; This masks the bottom of the hand by deliberately drawing 8 junk sprites
	; 16 pixels beneath it to force the hardware to stop drawing at that 
	; scanline; it's dirty, but effective -- so long as no other sprites
	; are on that scanline to be noticeably effected :)
	LDX #$07	 ; X = 7
PRG011_A505:
	TXA		 
	ASL A		 
	ASL A		 
	TAY		 	; Y = X << 2 (* 4, or for 7 sprites...)

	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y	; Store Y

	LDA #$27	 
	STA Sprite_RAM+$01,Y	; Pattern

	LDA #%00100011
	STA Sprite_RAM+$02,Y	; Place sprite behind BG, flipped horizontally and vertically

	LDA #$00	 
	STA Sprite_RAM+$03,Y	; X = 0

	DEX		 	; X--
	BPL PRG011_A505	 	; While X >= 0, loop!

WarpWindHandTrap_Draw:
	LDX <Temp_Var3		; X = Temp_Var3 (warp wind palette)

	; The warp wind sprite Y
	LDA <Map_WWOrHT_Y	; A = Map_WWOrHT_Y
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64

	LDA <Temp_Var3		; A = Temp_Var3
	BEQ PRG011_A544	 	; If Temp_Var3 = 0, jump to PRG011_A544 (AFAIK, this is never the case)

	LDA Map_PlyrSprOvrY
	CMP #$f8
	BNE PRG011_A56B	 	; If Map_PlyrSprOvrY <> $f8, jump to PRG011_A56B

	; Disable Player map sprite!
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90

	JMP PRG011_A56B	 	; Jump to PRG011_A56B...

PRG011_A544:
	; Otherwise, not disabling Player map sprite...

	LDA <Map_WWOrHT_Cnt
	AND #$10
	BEQ PRG011_A56B

	; Restore Player's map sprite Y
	LDA Map_PlyrSprOvrY
	STA Sprite_RAM+$8C
	STA Sprite_RAM+$90
	SUB #16
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

	LDA Sprite_RAM+$85
	CMP #$27	 
	BNE PRG011_A56B	 	; If the pattern in use is not $27, jump to PRG011_A56B

	; Otherwise, disable half the sprite
	LDA #$f8	 
	STA Sprite_RAM+$84
	STA Sprite_RAM+$88

PRG011_A56B:
	; Set the warp wind's attributes (white palette)
	LDA Map_WW_Pal,X
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	; Set the warp wind's X
	LDA <Temp_Var2		; Map_WWOrHT_X
	STA Sprite_RAM+$63
	ADD #$08	 
	STA Sprite_RAM+$67	; Map_WWOrHT_X + 8

	LDY Map_WW_Pattern,X	; Get the pattern for the wind/hand

	LDA <Map_WWOrHT_Cnt
	AND #$10	 
	BEQ PRG011_A58B	 
	LDY Map_WW_Pattern+2,X	; Every 16 tics, use the second frame

PRG011_A58B:
	; Store the pattern for the first sprite
	STY Sprite_RAM+$61

	INY	
	INY			; Pattern += 2
	STY Sprite_RAM+$65	; Store the pattern for the second sprite

	LDA <Map_WWOrHT_Dir
	BEQ PRG011_A5AA	 	; If Map_WWOrHT_Dir = 0, jump to PRG011_A5AA

	; Flip the wind patterns!
	STY Sprite_RAM+$61
	DEY		
	DEY		
	STY Sprite_RAM+$65

	; Set the flip attribute
	LDA Sprite_RAM+$62	; Get old attributes
	ORA #$40	 	; H-Flip attr
	STA Sprite_RAM+$62	
	STA Sprite_RAM+$66	

PRG011_A5AA:

	; This draw a couple high-priority sprites at the border's edge 
	; using border patterns to clip the warp wind sprite!

	; Sprite set to Y
	LDA <Map_WWOrHT_Y
	STA Sprite_RAM+$00
	STA Sprite_RAM+$04

	; Pattern 1
	LDA #$01	 
	STA Sprite_RAM+$01

	; Pattern $B
	LDA #$0b	 
	STA Sprite_RAM+$05

	; Attributes
	LDA #$01	 
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	; And X = 1
	STA Sprite_RAM+$07

	; And X = 8
	LDA #$08	 
	STA Sprite_RAM+$03

	LDA <Temp_Var2	 ; MapWWOrHT_X
	AND #$80	 
	BEQ PRG011_A5DC	 ; If MapWWOrHT_X is not in the right half of the screen, jump to PRG011_A5DC (RTS)

	; Otherwise, put the border patch on the RIGHT side!
	LDA #$f0	
	STA Sprite_RAM+$03
	LDA #$f8	 
	STA Sprite_RAM+$07

PRG011_A5DC:
	RTS		 ; Return


GameOver_TwirlToStart:
	LDX Player_Current	 

	LDA <Map_SkidBack
	BNE PRG011_A63D	 ; If Map_SkidBack is set, jump to PRG011_A63D

	LDY World_Num	 ; Y = World_Num

	LDA <World_Map_Y,X
	SUB Map_Y_Starts,Y
	STA <Map_Skid_DeltaY

	LDA <World_Map_X,X
	SUB #$20
	STA <Map_Skid_DeltaX

	LDA #$00
	STA <Map_Skid_TravDirs
	STA <Map_Skid_DeltaFracX
	STA <Map_Skid_DeltaFracY

	LDA <World_Map_X,X
	CMP #32
	BGE PRG011_A610	 ; If Player's Map X >= 32 (the common start X of all maps), jump to PRG011_A610

	; Player's Map X < 32...

	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
	LDA #$01
	STA <Map_Skid_TravDirs

	; Negate Map_Skid_DeltaX
	LDA #$ff
	EOR <Map_Skid_DeltaX
	TAY
	INY
	STY <Map_Skid_DeltaX

PRG011_A610:
	LDY World_Num	 ; Y = World_Num

	LDA <World_Map_Y,X
	CMP Map_Y_Starts,Y
	BGE PRG011_A628	 ; If Player's Map Y >= the starting Y of the map, jump to PRG011_A628

	; Player's Map Y < the starting Y of the map...

	; Negate Map_Skid_DeltaY
	LDA #$ff
	EOR <Map_Skid_DeltaY
	TAY
	INY
	STY <Map_Skid_DeltaY

	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
	LDA <Map_Skid_TravDirs
	ORA #$02
	STA <Map_Skid_TravDirs

PRG011_A628:

	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
	LDY #$04	 ; Y = 4
PRG011_A62A:
	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
	ROR <Map_Skid_DeltaFracY		; Set as bit 7 of Map_Skid_DeltaFracY

	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
	ROR <Map_Skid_DeltaFracX		; Set as bit 7 of Map_Skid_DeltaFracX

	DEY			; Y--
	BPL PRG011_A62A		; While Y >= 0, loop!

	; Map_Skid_Counter = $20
	LDA #$20
	STA <Map_Skid_Counter

	INC <Map_SkidBack		 ; Set Map_SkidBack

PRG011_A63D:

	; Skid sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A65E	 ; If Player is traveling left, jump to PRG011_A65E

	; Traveling to the right...

	; Map_Skid_FracX += Map_Skid_DeltaFracX
	LDA <Map_Skid_FracX
	ADD <Map_Skid_DeltaFracX
	STA <Map_Skid_FracX

	; Add and carry into the full X
	LDA <World_Map_X,X
	ADC <Map_Skid_DeltaX
	STA <World_Map_X,X

	; Any additional carry into Map XHi
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	JMP PRG011_A671	 ; Jump to PRG011_A671

PRG011_A65E:

	; Traveling to the left

	; Map_Skid_FracX -= Map_Skid_DeltaFracX
	LDA <Map_Skid_FracX
	SUB <Map_Skid_DeltaFracX
	STA <Map_Skid_FracX

	; Subtract and carry into the full X
	LDA <World_Map_X,X
	SBC <Map_Skid_DeltaX
	STA <World_Map_X,X

	; Any additional carry into Map XHi
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

PRG011_A671:
	LDA <Map_Skid_TravDirs
	AND #$02
	BEQ PRG011_A687	 ; If Player is traveling up, jump to PRG011_A65E

	; Traveling downward

	; Map_Skid_FracY += Map_Skid_DeltaFracY
	LDA <Map_Skid_FracY
	ADD <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	; Add and carry into the full Y
	LDA <World_Map_Y,X
	ADC <Map_Skid_DeltaY
	STA <World_Map_Y,X

	JMP PRG011_A694	 ; Jump to PRG011_A694

PRG011_A687:

	; Traveling downward

	; Map_Skid_FracY -= Map_Skid_DeltaFracY
	LDA <Map_Skid_FracY
	SUB <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	; Subtract and carry into the full Y
	LDA <World_Map_Y,X
	SBC <Map_Skid_DeltaY
	STA <World_Map_Y,X

PRG011_A694:
	DEC <Map_Skid_Counter	; Map_Skid_Counter--
	BNE PRG011_A6BC	 ; If Map_Skid_Counter <> 0, jump to PRG011_A6BC

PRG011_A698:
	; GameOver_State = 8 (we've landed, we're done)
	LDA #$08
	STA GameOver_State

	LDX Player_Current	 ; X = Player_Current

	LDA #$00
	STA <Map_SkidBack
	STA World_Map_Twirl,X	 ; Twirling is done
	STA Map_Prev_XOff2,X
	STA Map_Prev_XHi2,X

	; Set the previous values at the twirl landing spot

	; Map_Previous_Y = World_Map_Y
	LDA <World_Map_Y,X
	STA Map_Previous_Y,X

	; Map_Previous_X/Hi = Map_Previous_X/Hi
	LDA <World_Map_XHi,X
	STA Map_Previous_XHi,X
	LDA <World_Map_X,X
	STA Map_Previous_X,X

PRG011_A6BC:
	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


GameOver_TwirlFromAfar:
	LDX Player_Current	 ; X = Player_Current

	; Map X -= 2 (Player flying from way off goes directly left)
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	BNE PRG011_A6E4	 ; If Player Map X <> Horz_Scroll, jump to PRG011_A6E4

	LDA #$00
	STA Map_Prev_XOff,X
	STA Map_Prev_XHi,X
	STA Map_Entered_XHi,X

	INC GameOver_State	 ; GameOver_State++

PRG011_A6E4:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JSR Map_DrawBorderForPlayer	 ; Draw border sprites to cover twirling Player

	JMP WorldMap_UpdateAndDraw	 ; Update and draw world map and don't come back


Map_DrawBorderForPlayer:
	LDX Player_Current	; X = Player_Current

	; Set Map Border Sprite Y
	LDA <World_Map_Y,X
	STA Sprite_RAM+$00
	STA Sprite_RAM+$04

	; Set Map Border Sprite left Pattern
	LDA #$01
	STA Sprite_RAM+$01

	; Set Map Border Sprite right Pattern
	LDA #$0b
	STA Sprite_RAM+$05

	; Set Map Border Sprite attributes
	LDA #SPR_PAL0
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06

	; Set Map Border left Sprite X
	STA Sprite_RAM+$07

	; Set Map Border right Sprite X
	LDA #$08
	STA Sprite_RAM+$03

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	AND #$80
	BEQ PRG011_A727	 ; If difference is positive, jump to PRG011_A727 (RTS)

	; Set Map Border Sprite X
	LDA #240
	STA Sprite_RAM+$03
	LDA #248
	STA Sprite_RAM+$07

PRG011_A727:
	RTS		 ; Return


GameOver_AlignToStartY
	LDX Player_Current	 ; X = Player_Current

	; Enter from right side
	LDA #240
	STA <World_Map_X,X

	LDY World_Num		 ; Y = World_Num
	LDA Map_Y_Starts,Y	 ; Get start Y
	STA <World_Map_Y,X	 ; Set Player at start Y

	INC GameOver_State	 ; GameOver_State++
	JMP PRG011_A6E4	 	; Jump to PRG011_A6E4

GameOver_ReturnToStartX:
	LDX Player_Current	 ; X = Player_Current

	; Player's Map X -= 2 (skidding towards Start panel)
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X

	CMP #$20
	BNE PRG011_A74E	 ; If Player is not at $20 (fixed start point X), jump to PRG011_A74E

	JMP PRG011_A698	 ; Jump to PRG011_A698

PRG011_A74E:

	; Play skidding sound (actually pointless from where it jumps)
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JMP PRG011_A6E4	 ; Jump to PRG011_A6E4

MO_SkidToPrev:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_SkidBack
	BEQ PRG011_A760	 ; If Map_SkidBack is not set, jump to PRG011_A760

	JMP PRG011_A834	 ; Jump to PRG011_A834

PRG011_A760:

	; Checks all map objects to see if Player has died while in a map object

	LDY #(MAPOBJ_TOTAL-1)	; Y = (MAPOBJ_TOTAL-1)
PRG011_A762:
	LDA Map_Objects_IDs,Y
	BNE PRG011_A76D	 ; If this map object slot is not empty, jump to PRG011_A76D

PRG011_A767:
	DEY		 ; Y--
	BNE PRG011_A762	 ; While Y > 0, loop!  (Ignores the HELP bubble)
	JMP PRG011_A79D	 ; Jump to PRG011_A79D

PRG011_A76D:

	; If Player is not on top of the airship, jump to PRG011_A767
	LDA <World_Map_Y,X
	CMP Map_Objects_Y,Y
	BNE PRG011_A767

	LDA <World_Map_XHi,X
	CMP Map_Objects_XHi,Y
	BNE PRG011_A767

	LDA <World_Map_X,X
	CMP Map_Objects_XLo,Y
	BNE PRG011_A767

	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_AIRSHIP
	BNE PRG011_A791

	; Player is on top of the airship
	; NOTE: Assumes Index 1 is the Airship!

	; Set airship count = $20 (orders it to scurry away)
	LDA #$20
	STA Map_March_Count+1

	JMP PRG011_A767	 ; Jump to PRG011_A767

PRG011_A791:
	CMP #MAPOBJ_COINSHIP
	BNE PRG011_A767	 ; If this is NOT a Coin Ship, jump to PRG011_A767

	; Player was on top of a coin ship and DIED!!, return to Hammer Bro!
	LDA #MAPOBJ_HAMMERBRO
	STA Map_Objects_IDs,Y

	JMP PRG011_A767	 ; Jump to PRG011_A767

PRG011_A79D:

	; Player died on top of something not an Airship or a Coin ship...

	LDA Map_Previous_Y,X
	SUB <World_Map_Y,X
	STA <Map_Skid_DeltaY

	LDA Map_Previous_XHi,X
	CMP <World_Map_XHi,X
	BEQ PRG011_A7B0	 ; If Player is on the same map screen as he was before, jump to PRG011_A7B0
	BGE PRG011_A7B7	 ; If Player is on a map screen to the right, jump to PRG011_A7B7
	BLT PRG011_A7CB	 ; If Player is on a map screen to the left, jump to PRG011_A7CB

PRG011_A7B0:

	; Player is on the same map screen he was previously...

	LDA Map_Previous_X,X
	CMP <World_Map_X,X
	BLT PRG011_A7CB	 ; If Player is to the left from where he was, jump to PRG011_A7CB

PRG011_A7B7:

	; Player is to the right from where he was...

	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
	LDA Map_Previous_X,X
	SUB <World_Map_X,X
	STA <Map_Skid_DeltaFracX

	; Map_Skid_DeltaX starts as straight difference in X Hi
	LDA Map_Previous_XHi,X
	SBC <World_Map_XHi,X	
	STA <Map_Skid_DeltaX

	; Do not set bit 0 on Map_Skid_TravDirs (travel left instead of right)
	LDY #$00	 ; Y = 0

	JMP PRG011_A7DC	 ; Jump to PRG011_A7DC

PRG011_A7CB:

	; Player is to the left from where he was

	; Map_Skid_DeltaFracX starts as straight difference in X, to be corrected
	LDA <World_Map_X,X
	SUB Map_Previous_X,X
	STA <Map_Skid_DeltaFracX

	; Map_Skid_DeltaX starts as straight difference in X Hi
	LDA <World_Map_XHi,X
	SBC Map_Previous_XHi,X
	STA <Map_Skid_DeltaX

	; Set bit 0 on Map_Skid_TravDirs (travel right instead of left)
	LDY #$01	 ; Y = 1

PRG011_A7DC:
	STY <Map_Skid_TravDirs	 ; Set Map_Skid_TravDirs

	LDA #$00
	STA <Map_Skid_FracX
	STA <Map_Skid_DeltaFracY

	LDA Map_Previous_Y,X
	CMP <World_Map_Y,X
	BGE PRG011_A7F9	 ; If Player is lower than he was before, jump to PRG011_A7F9

	; Player was higher than before... negate Map_Skid_DeltaY
	LDA #$ff
	EOR <Map_Skid_DeltaY
	TAY
	INY
	STY <Map_Skid_DeltaY

	; Set bit 1 on Map_Skid_TravDirs (travel down instead of up)
	LDA <Map_Skid_TravDirs
	ORA #$02
	STA <Map_Skid_TravDirs

PRG011_A7F9:
	LDA <Map_Skid_DeltaX
	BNE PRG011_A817	 ; If Player is left/right of where he was before, jump to PRG011_A817

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	TAY

	LDA <Map_Skid_TravDirs
	AND #$01
	BNE PRG011_A811	 ; If Player is traveling right, jump to PRG011_A811

	TYA
	ADD <Map_Skid_DeltaFracX
	BCC PRG011_A81D	 ; If no carry, jump to PRG011_A81D
	BCS PRG011_A817	 ; Otherwise, jump to PRG011_A817

PRG011_A811:
	TYA
	SUB <Map_Skid_DeltaFracX
	BCS PRG011_A81D	 ; If carry set, jump to PRG011_A81D

PRG011_A817:
	INC Map_Operation	 ; Map_Operation++ (go to the "twirl from afar" state)
	JMP MO_SkidToPrevAfar	 ; Jump to MO_SkidToPrevAfar

PRG011_A81D:

	; Lowest 4 bits of Map_Skid_DeltaY/X -> Upper 4 bits of Map_Skid_DeltaFracY/X
	LDY #$04	 ; Y = 4
PRG011_A81F:
	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaY		; Bit 0 of Map_Skid_DeltaY -> carry
	ROR <Map_Skid_DeltaFracY	; Set as bit 7 of Map_Skid_DeltaFracY

	CLC		 ; Clear carry
	LSR <Map_Skid_DeltaX		; Bit 0 of Map_Skid_DeltaX -> carry
	ROR <Map_Skid_DeltaFracX	; Set as bit 7 of Map_Skid_DeltaFracX; Bit 0 -> Carry
	ROR <Map_Skid_FracX		; Set as bit 7 of <Map_Skid_FracX

	DEY			; Y--
	BPL PRG011_A81F		; While Y >= 0, loop!

	; Map_Skid_Counter = $20
	LDA #$20
	STA <Map_Skid_Counter

	INC <Map_SkidBack		 ; Set Map_SkidBack

PRG011_A834:
	LDA <Map_Skid_Counter
	BEQ PRG011_A891	 ; If Map_Skid_Counter = 0, jump to PRG011_A891

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	LDA <Map_Skid_TravDirs
	AND #$01
	BNE PRG011_A859	 ; If Player is traveling right, jump to PRG011_A859

	LDA <Map_Skid_FracCarry
	ADD <Map_Skid_FracX
	STA <Map_Skid_FracCarry

	LDA <World_Map_X,X
	ADC <Map_Skid_DeltaFracX
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	ADC <Map_Skid_DeltaX
	STA <World_Map_XHi,X

	JMP PRG011_A86C	 ; Jump to PRG011_A86C

PRG011_A859:
	LDA <Map_Skid_FracCarry
	SUB <Map_Skid_FracX
	STA <Map_Skid_FracCarry

	LDA <World_Map_X,X
	SBC <Map_Skid_DeltaFracX
	STA <World_Map_X,X

	LDA <World_Map_XHi,X
	SBC <Map_Skid_DeltaX
	STA <World_Map_XHi,X

PRG011_A86C:
	LDA <Map_Skid_TravDirs
	AND #$02
	BNE PRG011_A882	 ; If Player is traveling down, jump to PRG011_A882

	LDA <Map_Skid_FracY
	ADD <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	LDA <World_Map_Y,X
	ADC <Map_Skid_DeltaY
	STA <World_Map_Y,X

	JMP PRG011_A88F	 ; Jump to PRG011_A88F

PRG011_A882:
	LDA <Map_Skid_FracY
	SUB <Map_Skid_DeltaFracY
	STA <Map_Skid_FracY

	LDA <World_Map_Y,X
	SBC <Map_Skid_DeltaY
	STA <World_Map_Y,X

PRG011_A88F:
	DEC <Map_Skid_Counter		 ; Map_Skid_Counter--

PRG011_A891:
	JSR WorldMap_UpdateAndDraw	 ; Update and draw map

	LDA <Map_Skid_Counter
	ORA Map_March_Count+1	; <--- Airship's movement counter
	ORA Map_Pan_Count
	BNE PRG011_A8C8	 ; If skidding, the airship is moving, or the map is panning, jump to PRG011_A8C8 (RTS)

	; Map_Operation = $0B (Hammer bros march around)
	LDA #$0b
	STA Map_Operation

	LDX Player_Current	 ; X = Player_Current

	; Ensure Player is precisely at his previous position
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff,X

	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi,X

	; Clear skid vars
	LDA #$00
	STA <Map_SkidBack
	STA Map_Player_SkidBack,X

PRG011_A8C8:
	RTS		 ; Return

MO_SkidToPrevAfar:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A8E9	 ; If Player is traveling left, jump to PRG011_A8E9

	; Far away Player skidding directly to the left; Map X -= 2
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	BEQ PRG011_A8FF	 ; If Player hit left edge, jump to PRG011_A8FF

	JMP PRG011_A90E	 ; Jump to PRG011_A90E

PRG011_A8E9:

	; Far away Player skidding directly to the right; Map X += 2
	LDA <World_Map_X,X
	ADD #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	SUB <Horz_Scroll
	CMP #240
	BNE PRG011_A90E	 ; If Player has not hit right edge, jump to PRG011_A90E

PRG011_A8FF:

	; Player hit edge of the screen

	LDA Map_Prev_XOff2,X
	STA Map_Prev_XOff,X

	LDA Map_Prev_XHi2,X
	STA Map_Prev_XHi,X

	INC Map_Operation	 ; Map_Operation++

PRG011_A90E:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	JSR Map_DrawBorderForPlayer	 ; Draw border to block Player sprite

	JMP WorldMap_UpdateAndDraw	 ; Update and draw map and don't come back!

MO_SkidAfarPrep:
	LDX Player_Current	 ; X = Player_Current

	; Set Player's Y and XHi to their previous values
	LDA Map_Previous_Y,X
	STA <World_Map_Y,X
	LDA Map_Previous_XHi,X
	STA <World_Map_XHi,X

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A946	 ; If Player is traveling left, jump to PRG011_A946

	; Traveling rightward

	LDY #240	 ; Y = 240

	LDA <Horz_Scroll
	BEQ PRG011_A941		; If horizontal scroll = 0, jump to PRG011_A941

	LDA Map_Previous_X,X
	ADD <Horz_Scroll
	LDA Map_Previous_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDY #112	 ; Y = 112

PRG011_A941:
	STY <World_Map_X,X ; Set proper World Map X to begin skidding from

	JMP PRG011_A95B	 ; Jump to PRG011_A95B

PRG011_A946:

	; Traveling leftward

	LDA <Horz_Scroll
	BEQ PRG011_A957	 ; If Horz_Scroll = 0, jump to PRG011_A957

	LDA Map_Previous_X,X
	SUB <Horz_Scroll
	LDA Map_Previous_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

PRG011_A957:
	LDA <Horz_Scroll
	STA <World_Map_X,X

PRG011_A95B:

	; Play skidding sound
	LDA #SND_LEVELSKID
	STA Sound_QLevel2

	INC Map_Operation	 ; Map_Operation++

	JMP PRG011_A90E	 ; Jump to PRG011_A90E

MO_SkidAfarFinish:
	LDX Player_Current	 ; X = Player_Current

	LDA <Map_Skid_TravDirs
	AND #$01
	BEQ PRG011_A986	 ; If Player is traveling left, jump to PRG011_A946

	; Player traveling left

	; Map X -= 2
	LDA <World_Map_X,X
	SUB #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	SBC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	CMP Map_Previous_X,X
	BEQ PRG011_A99A	 ; If Player Map X is at his previous X, jump to PRG011_A99A

	JMP PRG011_A9B5	 ; Otherwise, jump to PRG011_A9B5 (indirect to PRG011_A90E)

PRG011_A986:

	; Player traveling right

	; Map X += 2
	LDA <World_Map_X,X
	ADD #$02
	STA <World_Map_X,X
	LDA <World_Map_XHi,X
	ADC #$00
	STA <World_Map_XHi,X

	LDA <World_Map_X,X
	CMP Map_Previous_X,X
	BNE PRG011_A9B5	 ; If Player Map X is not at his previous X, jump to PRG011_A9B5 (indirect to PRG011_A90E)

PRG011_A99A:

	; Player has finally arrived at his "previous" position, completing the skid back from afar

	; Map_Operation = $0B (Hammer bros march around)
	LDA #$0b
	STA Map_Operation

	; Ensure Player is precisely at his previous position
	LDA <World_Map_Y,X
	STA Map_Entered_Y,X
	LDA <World_Map_XHi,X
	STA Map_Entered_XHi,X
	LDA <World_Map_X,X
	STA Map_Entered_X,X

	LDA #$00
	STA <Map_SkidBack
	STA Map_Player_SkidBack,X

PRG011_A9B5:
	JMP PRG011_A90E	 ; Jump to PRG011_A90E

	; Indexed by Map_ClearLevelFXCnt * 2
Map_ClearLevelFXPatterns:

	; "Poof" effect
	.byte $45, $47	; 0
	.byte $45, $47	; 1
	.byte $49, $31	; 2
	.byte $49, $35	; 3
	.byte $49, $39	; 4
	.byte $49, $41	; 5

	; "Flip" effect
	.byte $B5, $B5	; 6
	.byte $A1, $A1	; 7
	.byte $B5, $B5	; 8

	; Indexed by Player and tile quadrant (except the last three which are hardcoded specific)
Map_CompleteTile:
	.byte TILE_MARIOCOMP_P, TILE_LUIGICOMP_P, TILE_MARIOCOMP_O, TILE_LUIGICOMP_O
	.byte TILE_MARIOCOMP_G, TILE_LUIGICOMP_G, TILE_MARIOCOMP_R, TILE_LUIGICOMP_R
	.byte TILE_FORTRUBBLE, TILE_FORTRUBBLE, TILE_ALTRUBBLE

	; This just forces "poof" completion on the following tiles (in quadrant zero, since all other
	; quadrants always "poof" except fortress tiles)
Map_ForcePoofTiles:
	.byte TILE_TOADHOUSE, TILE_SPADEBONUS, TILE_HANDTRAP, TILE_DANCINGFLOWER, TILE_ALTTOADHOUSE
Map_ForcePoofTiles_End

Map_PanelCompletePats:
	.byte $88, $89, $8A, $8B	; Mario Complete panel patterns
	.byte $DC, $DD, $DE, $DF	; Luigi Complete panel patterns
	.byte $68, $BB, $69, $BD	; Fortress rubble panel patterns

	; These are the select few tiles that "completing" their associated area
	; will not cause the Player to end their turn (in a 2P game)
Map_NoLoseTurnTiles:
	.byte TILE_TOADHOUSE, TILE_ALTTOADHOUSE, TILE_SPADEBONUS, TILE_PIPE, TILE_SPIRAL
Map_NoLoseTurnTiles_End

MO_DoLevelClear:

	; Check if this one of the tiles that does not cause a Player to lose their turn
	JSR Map_GetTile	 	; Get current tile Player is standing on

	LDX #(Map_NoLoseTurnTiles_End - Map_NoLoseTurnTiles - 1)
PRG011_A9F0:
	CMP Map_NoLoseTurnTiles,X
	BEQ PRG011_A9FB	 ; If this tile matches one of the "don't lose a turn" tiles, jump to PRG011_A9FB

	DEX		 ; X--
	BPL PRG011_A9F0	 ; While X >= 0, loop

	JMP PRG011_A9FE	 ; Jump to PRG011_A9FE

PRG011_A9FB:
	INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn

PRG011_A9FE:
	JSR Map_GetTile	 	; Get current tile Player is standing on

	AND #$c0	 	; Only keeping the upper 2 bits of it
	CLC		 
	ROL A		 
	ROL A		 
	ROL A		 
	TAY		 	; Y = upper 2 bits of map tile shifted down; the "tile quadrant"

	LDX #(Map_ForcePoofTiles_End - Map_ForcePoofTiles - 1)
	LDA <World_Map_Tile
PRG011_AA0C:
	CMP Map_ForcePoofTiles,X
	BEQ PRG011_AA19	 ; If this tile matches, jump to PRG011_AA19

	DEX		 ; X--
	BPL PRG011_AA0C	 ; While X >= 0, loop

	; This tile is not in the Map_ForcePoofTiles set...

	CMP Tile_AttrTable+4,Y
	BLT PRG011_AA26	 ; If this tile is not possibly an "enterable" tile, jump to PRG011_AA26

	; This is one of the Map_ForcePoofTiles tiles, or at least a (potentially) enterable one

PRG011_AA19:
	LDA <Map_ClearLevelFXCnt
	BEQ PRG011_AA29	 ; If "map poof" is not currently in use, jump to PRG011_AA29

	LDA <Counter_1
	AND #$03
	BEQ PRG011_AA4C	 ; 1:4 ticks jump to PRG011_AA4C

PRG011_AA23:
	JMP PRG011_AB1B	 ; Otherwise, jump to PRG011_AB1B

PRG011_AA26:
	JMP PRG011_AB61	 ; Jump to PRG011_AB61

PRG011_AA29:

	; Map poof is not in use...

	CPY #$00
	BNE PRG011_AA39	 ; If tile is NOT quadrant 0 ($00-$3F), jump to PRG011_AA39

	; Quadrant 0 tiles only...

	; Map_ClearLevelFXCnt = 7 (begin panel flipover effect)
	LDA #$07
	STA <Map_ClearLevelFXCnt

	; Play "flip over" sound
	LDA #SND_MAPINVENTORYFLIP
	STA Sound_QMap

	JMP PRG011_AA23	 ; Jump to PRG011_AA23 (PRG011_AB1B)

PRG011_AA39:

	; All non-quadrant 0 tiles use the "poof" to clear

	LDA <World_Map_Tile
	CMP #TILE_FORT
	BEQ PRG011_AA4C	 ; If the completed tile is a Mini-Fortress, jump to PRG011_AA4C

	CMP #TILE_LARGEFORT
	BEQ PRG011_AA4C	 ; If the completed tile is a Large Fortress (Unused!!), jump to PRG011_AA4C

	CMP #TILE_ALTFORT
	BEQ PRG011_AA4C	 ; If the completed tile is a Mini-Fortress (alternate color), jump to PRG011_AA4C

	; If not a fortress...

	; Play the "poof" sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

	; "Poof" effect starts Map_ClearLevelFXCnt at 1, which it will be shortly...

PRG011_AA4C:

	; Updating whatever effect we're performing

	INC <Map_ClearLevelFXCnt	 ; Map_ClearLevelFXCnt++

	; Remember these compares are immediately following the INC...
	LDA <Map_ClearLevelFXCnt
	CMP #$07
	BEQ PRG011_AA58	 ; If Map_ClearLevelFXCnt = $07 (end of Fortress "poof" effect), jump to PRG011_AA58

	CMP #$0a
	BNE PRG011_AA23	 ; If Map_ClearLevelFXCnt <> $0A (end of completed level panel flip), jump to PRG011_AA23 (PRG011_AB1B)

PRG011_AA58:

	; Map_ClearLevelFXCnt = 0 (effect over)
	LDA #$00
	STA <Map_ClearLevelFXCnt

	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_XHi,X
	ASL A		 ; 2 byte index
	TAY		 ; -> Y
	LDA Tile_Mem_Addr,Y	; Get tile address low for this map screen
	ADD #$f0	 	; Base map offset
	STA <Map_Tile_AddrL	; -> Map_Tile_AddrL

	LDA Tile_Mem_Addr+1,Y	; Get tile address high for this map screen
	ADC #$00	 	; Apply carry
	STA <Map_Tile_AddrH	; -> Map_Tile_AddrH

	; Calculate a row/column offset
	LDA <World_Map_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <World_Map_Y,X
	TAY		 ; -> 'Y'

	LDA [Map_Tile_AddrL],Y	 ; Get the tile here
	PHA		 ; Save tile value

	AND #%11000000
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAX		 ; X = tile quadrant * 2 (0, 2, 4, 6)

	LDA Player_Current
	BEQ PRG011_AA8C	 ; If Player is Mario, jump to PRG011_AA8C

	INX		 ; Otherwise, X++

PRG011_AA8C:
	PLA		 ; Restore tile value

	CMP #TILE_FORT
	BEQ PRG011_AA95	 ; If this was a Mini-Fortress, jump to PRG011_AA95

	CMP #TILE_LARGEFORT
	BNE PRG011_AA9C	 ; If this was NOT a Large Fortress (Unused!!), jump to PRG011_AA9C

PRG011_AA95:

	; Crumble sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDX #$08	 ; X = 8

PRG011_AA9C:
	CMP #TILE_ALTFORT
	BNE PRG011_AAA7	 ; If this was a Mini-Fortress (Alternate color), jump to PRG011_AAA7

	; Crumble sound
	LDA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDX #$09	 ; X = 9

PRG011_AAA7:
	LDA Map_CompleteTile,X	; Get appropriate "complete" tile for this level
	STA [Map_Tile_AddrL],Y	; Set it in memory
	STA <World_Map_Tile	; ... as well as the tile detected

	JSR Map_MarkLevelComplete	 ; Mark this level as complete!

	LDY Player_Current	 ; Y = Player_Current
	LDX <World_Map_X,Y	 ; X = Player Map X
	LDA World_Map_Y,Y	 ; A = Player Map Y
	JSR Map_Calc_NT2Addr_By_XY	 ; Nametable 2 Offset -> Temp_Var15

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	; Set high byte of video address
	LDA <Temp_Var15
	STA Graphics_Buffer+$00,X
	STA Graphics_Buffer+$05,X

	; Set low byte of video address for first row of level panel change
	LDA <Temp_Var16
	STA Graphics_Buffer+$01,X

	; Set low byte of video address for second row of level panel change
	ADD #32		; +32 for next row
	STA Graphics_Buffer+$06,X

	; Run length of 2 for both
	LDA #$02
	STA Graphics_Buffer+$02,X
	STA Graphics_Buffer+$07,X

	LDY #$08	 ; Y = 8 (Fortress Rubble)

	; If we're doing Fortress rubble, jump to PRG011_AAEF
	LDA <World_Map_Tile
	CMP #TILE_FORTRUBBLE
	BEQ PRG011_AAEF
	CMP #TILE_ALTRUBBLE
	BEQ PRG011_AAEF

	LDY #$00	 	; Y = 0 (Mario Complete)
	LDX Player_Current	; X = Player_Current
	BEQ PRG011_AAEF	 	; If Player is Mario, jump to PRG011_AAEF
	LDY #$04	 	; Otherwise, Y = 4 (Luigi Complete)

PRG011_AAEF:
	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	; Add in the four replacement patterns to cover over the completed level
	LDA Map_PanelCompletePats,Y
	STA Graphics_Buffer+$03,X
	LDA Map_PanelCompletePats+1,Y
	STA Graphics_Buffer+$08,X
	LDA Map_PanelCompletePats+2,Y
	STA Graphics_Buffer+$04,X
	LDA Map_PanelCompletePats+3,Y
	STA Graphics_Buffer+$09,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$0A,X

	; Graphics_BufCnt += 10
	LDA Graphics_BufCnt
	ADD #10
	STA Graphics_BufCnt

	JMP PRG011_AB61	 ; Jump to PRG011_AB61

PRG011_AB1B:
	LDX Player_Current	 ; X = Player_Current

	; Copy Player's Map Y/X -> Temp_Var1/2
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDY <Map_ClearLevelFXCnt
	CPY #$07
	BLT PRG011_AB5B	 ; If Map_ClearLevelFXCnt < 7 (doing Fortress poof rather than panel flip), jump to PRG011_AB5B

	; Set "flip" sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64

	DEY		 ; Y--

	; Y *= 2 (two patterns per count)
	TYA
	ASL A
	TAY

	; Set the two patterns for the panel flip sprites
	LDA Map_ClearLevelFXPatterns,Y
	STA Sprite_RAM+$61
	STA Sprite_RAM+$65

	; Set left panel flip sprite attribute
	LDA #SPR_PAL3
	STA Sprite_RAM+$62

	; Set right panel flip sprite attribute
	LDA #(SPR_PAL3 | SPR_HFLIP)
	STA Sprite_RAM+$66

	; Set left panel flip sprite X
	LDA <Temp_Var2
	SUB <Horz_Scroll
	STA Sprite_RAM+$63

	; Set right panel flip sprite X
	ORA #$08
	STA Sprite_RAM+$67

PRG011_AB58:
	JMP PRG011_ABBE	 ; Jump to PRG011_ABBE

PRG011_AB5B:
	JSR Map_DrawClearLevelPoof	 ; Draw the "poof"
	JMP PRG011_ABCC	 ; Jump to PRG011_ABCC (MapObjects_UpdateDrawEnter)

PRG011_AB61:
	LDA Map_WasInPipeway
	BNE PRG011_AB58	 ; If we were just in a pipe, jump to PRG011_AB58 (PRG011_ABBE) (do short cycle because we didn't do anything)

	; Here we check if Player was on top of a map object, thus assumed to be the cause of level entry, thus needs to be "completed."

	LDY #(MAPOBJ_TOTAL - 1)	 ; Y = (MAPOBJ_TOTAL - 1) (For all map objects)
	LDX Player_Current	 ; X = Player_Current
PRG011_AB6B:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_AB89	 	; If this map object slot is empty, jump to PRG011_AB89

	LDA Map_Objects_Y,Y
	STA <Temp_Var1		; Temp_Var1 = this map object's Y
	CMP <World_Map_Y,X
	BNE PRG011_AB89	 	; If Player is not on this map object vertically, jump to PRG011_AB89

	LDA Map_Objects_XHi,Y
	CMP <World_Map_XHi,X
	BNE PRG011_AB89	 	; If Player is not on the same screen as this map object, jump to PRG011_AB89

	LDA Map_Objects_XLo,Y
	STA <Temp_Var2		; Temp_Var2 = this map object's X

	CMP <World_Map_X,X
	BEQ PRG011_AB8F 	; If Player is definitely on top of this map object, jump to PRG011_AB8F

PRG011_AB89:
	DEY		 	; Y--
	BPL PRG011_AB6B		; While Y >= 0, loop

	JMP PRG011_ABBE	 ; Jump to PRG011_ABBE

PRG011_AB8F:
	STY <Map_HideObj	; Index of map object Player is standing on -> Map_HideObj (hide this object and can't re-enter it)

	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_AIRSHIP
	BNE PRG011_AB9E	 	; If Player is NOT on the airship, jump to PRG011_AB9E

	; Player is on the airship...

	; NOTE: Actually this is never used, this allows for the Airship to be "completed"
	; although by the way this is done it just disappears rather than "poofs" away...
	; If you remove this exception you can actually make the Airship "completable"

	INC Map_Operation	; Map_Operation++
	JMP PRG011_ABCC	 	; Jump to PRG011_ABCC (MapObjects_UpdateDrawEnter)

PRG011_AB9E:
	LDA <Map_ClearLevelFXCnt
	BNE PRG011_ABA7	 ; If Map_ClearLevelFXCnt <> 0, jump to  PRG011_ABA7

	; "Poof" sound
	LDA #SND_LEVELPOOF
	STA Sound_QLevel1

PRG011_ABA7:
	LDA <Counter_1
	AND #$03
	BNE PRG011_AB5B	 ; 1:4 ticks proceed, otherwise jump to PRG011_AB5B

	INC <Map_ClearLevelFXCnt	; Map_ClearLevelFXCnt++

	LDA <Map_ClearLevelFXCnt
	CMP #$07
	BNE PRG011_AB5B	 ; If Map_ClearLevelFXCnt = 7 (end of "poof" effect), jump to  PRG011_AB5B

	; Map object will now disappear!
	LDA #MAPOBJ_EMPTY
	STA Map_Objects_IDs,Y		; Empty the slot
	STA <Map_ClearLevelFXCnt	; Stop the clear effect (poof)
	STA <Map_HideObj		; Clear the hidden object index

PRG011_ABBE:
	LDA <Map_ClearLevelFXCnt
	BNE PRG011_ABCC	 ; If Map_ClearLevelFXCnt <> 0, jump to PRG011_ABCC

	; Level clearing effect is over...

	LDA #$00
	STA Map_WasInPipeway

	; Map_Operation = 8
	LDA #$08
	STA Map_Operation

PRG011_ABCC:
	JMP MapObjects_UpdateDrawEnter	 ; Jump to MapObjects_UpdateDrawEnter


	; Draws the "Poof" effect that occurs after a Fortress is completed
Map_DrawClearLevelPoof:
	; Temp_Var1 = Y
	; Temp_Var2 = X

	; Set poof top Y 8 pixels above (centered over point)
	LDA <Temp_Var1
	SUB #$08	
	STA Sprite_RAM+$60
	STA Sprite_RAM+$64
	STA Sprite_RAM+$68
	STA Sprite_RAM+$6C

	; Set poof bottom Y 8 pixels below (centered over point)
	ADD #16
	STA Sprite_RAM+$70
	STA Sprite_RAM+$74
	STA Sprite_RAM+$78
	STA Sprite_RAM+$7C

	LDY #$00	 ; Y = 0
	LDA <Temp_Var2	 
	SUB <Horz_Scroll 
	SUB #$08	 ; Set X coordinate relative to screen scroll - 8
PRG011_ABF9:
	; Set poof X coordinates
	STA Sprite_RAM+$63,Y	; Top
	STA Sprite_RAM+$73,Y	; Bottom

	ADD #$08	 ; X += 8

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	CPY #$10	 
	BNE PRG011_ABF9	 ; If 'Y' <> $10, jump to PRG011_ABF9

	; Palette select 3 
	LDA #$03
	STA Sprite_RAM+$62
	STA Sprite_RAM+$66

	; Palette select 3 and horizontal flip
	LDA #$43
	STA Sprite_RAM+$6A
	STA Sprite_RAM+$6E

	; Palette select 3 and vertical flip
	LDA #$83
	STA Sprite_RAM+$72
	STA Sprite_RAM+$76

	; Palette select 3 and both flip
	LDA #$c3
	STA Sprite_RAM+$7A
	STA Sprite_RAM+$7E

	LDX <Map_ClearLevelFXCnt	 ; X = Map_ClearLevelFXCnt
	DEX		 ; X-- (off by 1)
	TXA
	ASL A
	TAX		 ; X *= 2

	; Set pattern
	LDA Map_ClearLevelFXPatterns,X
	STA Sprite_RAM+$61
	STA Sprite_RAM+$6D
	STA Sprite_RAM+$71
	STA Sprite_RAM+$7D

	; Set pattern
	LDA Map_ClearLevelFXPatterns+1,X
	STA Sprite_RAM+$65
	STA Sprite_RAM+$69
	STA Sprite_RAM+$75
	STA Sprite_RAM+$79

	RTS		 ; Return


Map_WhiteObjects:
	.byte MAPOBJ_NSPADE, MAPOBJ_WHITETOADHOUSE, MAPOBJ_COINSHIP, MAPOBJ_UNK0C 
Map_WhiteObjects_End

MO_CheckForBonus:

	; Temp_Var16 is our loop counter
	LDA #(Map_WhiteObjects_End - Map_WhiteObjects - 1)
	STA <Temp_Var16

PRG011_AC57:
	LDY <Temp_Var16	 	; Y = Temp_Var16
	LDX #(MAPOBJ_TOTAL-1)	; X = (MAPOBJ_TOTAL-1)

	LDA Map_WhiteObjects,Y
PRG011_AC5E:
	CMP Map_Objects_IDs,X
	BEQ PRG011_AC69	 ; If this is the "white" bonus object we're looking for, jump to PRG011_AC69 (we already have one, can't have more)

	DEX		 ; X-- (previous "white" bonus object to consider)
	BPL PRG011_AC5E	 ; While X >= 0, loop!

	JSR MO_CheckForBonusRules	; Since we don't have one of these, check the rules to see if we've earned one!

PRG011_AC69:
	DEC <Temp_Var16	 ; Temp_Var16--
	BPL PRG011_AC57	 ; While Temp_Var16 >= 0, loop!

	INC Map_Operation	 ; Map_Operation++
	JMP WorldMap_UpdateAndDraw	 ; Update and draw map, and don't come back!

MO_CheckForBonusRules:
	LDA <Temp_Var16
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word MapBonusChk_NSpade		; Check if an N-Spade should appear
	.word MapBonusChk_WhiteToadHouse	; Check if a White Toad House should appear
	.word MapBonusChk_CoinShip		; Check if a Coin Ship should appear
	.word MapBonusChk_MAPOBJ_UNK0C		; Check if the UNKNOWN MAPOBJ_UNK0C should appear


; N-Spade will appear on the map every 80,000 points you earn
MapBonusChk_NSpade:
	LDA World_Num
	CMP #$07
	BEQ PRG011_ACF0	 ; If World_Num = 7 (World 8), jump to PRG011_ACF0 (RTS)

	LDX Player_Current	 ; X = Player_Current

	LDA Player_Score
	CMP Map_NSpade_NextScore
	BLT PRG011_ACF0	 ; If Score high digit < Map_NSpade_NextScore, jump to PRG011_ACF0 (RTS)
	BEQ PRG011_AC97	 ; If Score high digit = Map_NSpade_NextScore, jump to PRG011_AC97

	JMP PRG011_ACAC	 ; Jump to PRG011_ACAC

PRG011_AC97:
	LDA Player_Score+1
	CMP Map_NSpade_NextScore+1
	BLT PRG011_ACF0	 ; If Score middle digit < Map_NSpade_NextScore+1, jump to PRG011_ACF0 (RTS)
	BEQ PRG011_ACA4	 ; If Score middle digit = Map_NSpade_NextScore+1, jump to PRG011_ACA4

	JMP PRG011_ACAC	 ; Jump to PRG011_ACAC

PRG011_ACA4:
	LDA Player_Score+2
	CMP Map_NSpade_NextScore+2
	BLT PRG011_ACF0	 ; If Score low digit < Map_NSpade_NextScore+2, jump to PRG011_ACF0 (RTS)

PRG011_ACAC:
	JSR Map_FindEmptyObjectSlot

	; Set the N-Spade's location!
	LDA Map_BonusAppY
	STA Map_Objects_Y,Y
	STA Map_Object_ActY,Y

	LDA Map_BonusAppXHi
	STA Map_Objects_XHi,Y
	STA Map_Object_ActXH,Y

	LDA Map_BonusAppX
	STA Map_Objects_XLo,Y
	STA Map_Object_ActX,Y

	LDX <Temp_Var16	 	; X = Temp_Var16
	LDA Map_WhiteObjects,X	; Load the proper bonus object ID (will always be MAPOBJ_NSPADE; this is a bit superfluous)
	STA Map_Objects_IDs,Y	; Set the N-Spade ID

	; N-Spade appears every 80,000 points, but the leading zero is fake, so 8000

	; +8000 (80,000 points) to the Map_NSpade_NextScore

	; High byte of the N-Spade score
	LDA Map_NSpade_NextScore+2
	ADD #LOW(8000)
	STA Map_NSpade_NextScore+2

	; Middle byte of the N-Spade score
	LDA Map_NSpade_NextScore+1
	ADC #HIGH(8000)
	STA Map_NSpade_NextScore+1

	; Low byte of the N-Spade score
	LDA Map_NSpade_NextScore
	ADC #$00
	STA Map_NSpade_NextScore

	; Bonus appearance sound!
	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

PRG011_ACF0:
	RTS		 ; Return


MapBonusChk_WhiteToadHouse:
	LDA Map_WhiteHouse
	BNE PRG011_AD30	 ; If you already got the White Toad House, jump to PRG011_AD30 (RTS)

	LDA Map_BonusType
	CMP #$01
	BNE PRG011_AD30	 ; If Map_BonusType <> 1 (White Toad House enable), jump to PRG011_AD30 (RTS)

	LDA Coins_ThisLevel
	CMP Map_BonusCoinsReqd
	BLT PRG011_AD30	 ; If coins collected this level < Map_BonusCoinsReqd (coins needed for White Toad House), jump to PRG011_AD30 (RTS)

	; Find an empty map object slot
	JSR Map_FindEmptyObjectSlot

	; Put the White Toad House here!
	LDA #MAPOBJ_WHITETOADHOUSE
	STA Map_Objects_IDs,Y

	; Set the White Toad House's location!
	LDA Map_BonusAppY
	STA Map_Objects_Y,Y
	STA Map_Object_ActY,Y

	LDA Map_BonusAppXHi
	STA Map_Objects_XHi,Y
	STA Map_Object_ActXH,Y

	LDA Map_BonusAppX
	STA Map_Objects_XLo,Y
	STA Map_Object_ActX,Y

	INC Map_WhiteHouse	 ; Set Map_WhiteHouse (you got the White Toad House, there won't be any more!)

	; Bonus appearance sound!
	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

PRG011_AD30:
	RTS		 ; Return


; The old Coin Ship ruleset:
; 1.) End the stage with an even number on the clock.
; 2.) Coins must be a Multiple of 11.
; 3.) The 10′s digit of your score must be the multiple of 11 that corresponds to your coins.
; 4.) Finally it must be in World 1, 3, 5, and 6.
;	NOTE: The worlds that don't count are literally because there's no "Hammer Bro"
;	map objects there; the code doesn't actually care about the world number!

MapBonusChk_CoinShip:
	LDA Map_CoinShip	 
	BNE PRG011_AD5F	 ; If you already got the Coin Ship, jump to PRG011_AD30 (RTS)

	LDA StatusBar_CoinH
	CMP StatusBar_CoinL
	BNE PRG011_AD5F	 ; If the two digits of your coins are not the same, jump to PRG011_AD5F (RTS)

	CMP StatusBar_Score+5
	BNE PRG011_AD5F	 ; If the tens digit of your score is not the same as the equal coins, jump to PRG011_AD5F (RTS) 

	LDY #$00	 ; Y = 0
PRG011_AD45:
	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_HAMMERBRO
	BEQ PRG011_AD52	 ; If this is a hammer brother, jump to PRG011_AD52

	INY		 ; Y++
	CPY #MAPOBJ_TOTAL
	BNE PRG011_AD45	 ; If index <> passed the last map object, loop!

	RTS		 ; Return

PRG011_AD52:

	; Change the Hammer Bro to the Coin Ship
	LDA #MAPOBJ_COINSHIP
	STA Map_Objects_IDs,Y

	INC Map_CoinShip	 ; Set Map_CoinShip (you got the Coin Ship, there won't be any more!)

	; Bonus appearance sound!
	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

PRG011_AD5F:
	RTS		 ; Return


	; This will always appear at the same location!!
MAPOBJ_UNK0C_Y:	.byte $60
MAPOBJ_UNK0C_X:	.byte $60

MapBonusChk_MAPOBJ_UNK0C:
	LDA Map_BonusType
	CMP #$02
	BNE PRG011_AD9C	 ; If Map_BonusType <> 2, jump to PRG011_AD9C (RTS)

	LDA Coins_ThisLevel
	CMP Map_BonusCoinsReqd
	BLT PRG011_AD9C	 ; If Coins_ThisLevel < Map_BonusCoinsReqd, jump to PRG011_AD9C (RTS)

	; Find an empty map object slot
	JSR Map_FindEmptyObjectSlot

	; Put the MAPOBJ_UNK0C here
	LDA #MAPOBJ_UNK0C
	STA Map_Objects_IDs,Y

	; Set the MAPOBJ_UNK0C Y
	LDA MAPOBJ_UNK0C_Y
	STA Map_Objects_Y,Y
	STA Map_Object_ActY,Y

	LDA MAPOBJ_UNK0C_X
	PHA		 ; Save original value

	; Set the MAPOBJ_UNK0C XHi
	AND #%00001111	 ; The lower 4 bits are the X Hi
	STA Map_Objects_XHi,Y
	STA Map_Object_ActXH,Y

	PLA		 ; Restore original value
 
	; Set the MAPOBJ_UNK0C X
	AND #%11110000
	STA Map_Objects_XLo,Y
	STA Map_Object_ActX,Y

	; Bonus appearance sound!
	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

PRG011_AD9C:
	RTS		 ; Return


	; This looks for an empty map object slot and returns the index in 'Y'
	; Assumes that the first two slots are always occupied...
	; NOTE: Dangerous!  If all slots are filled, this could loop for eternity
	; or return a bad index!  There's just an assumption of a free slot!
	;
	; A better implemention per what the rest of the engine would do is make
	; sure we don't loop beyond the last object ((MAPOBJ_TOTAL-1)) and in failure
	; "Do Not Return to Caller" (double PLA instruction), but oh well...
Map_FindEmptyObjectSlot:
	LDY #$02	 ; Y = 2
PRG011_AD9F:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADA8	 ; If this map object slot is empty, jump to PRG011_ADA8 (RTS)

	INY		 ; Y++
	JMP PRG011_AD9F	 ; Loop

PRG011_ADA8:
	RTS		 ; Return

Map_March_InitValues:
	; Initializes Map_March_Count values per Map_Object_ID
	; Generally the value is $20 (Marching time amount) and $00 (Don't march)
	; There's some restriction on these values because of internal ANDings.

	; Also, an object won't actually march unless it is tied into the march
	; function (check function pointer list @ PRG011_AE0B), but if it uses 
	; the Map_Object_Stationary function, it will briefly animate slightly
	; faster (as does a Hammer Brother marching around) due to a jump it
	; makes; this is used to make the World 7 Plant look ferocious (I suppose)
	; and would happen with World 8 stuff too, but they use $00 values so
	; the net effect is absolutely nothing.
	.byte $00	; None
	.byte $00	; HELP
	.byte $00	; Airship
	.byte $20	; Hammer Bro
	.byte $20	; Boomerang Bro
	.byte $20	; Heavy Bro
	.byte $20	; Fire Bro
	.byte $20	; World 7 Plant (doesn't really "go" anywhere, though!)
	.byte $20	; Unknown/unused marching glitch object
	.byte $00	; N-Spade
	.byte $00	; White Toad House
	.byte $20	; Coin Ship (does "sail" around the map)
	.byte $00	; Unknown white colorization of $0F (goes to World 7 level??)
	.byte $00	; World 8 Battleship
	.byte $00	; World 8 Tank
	.byte $00	; World 8 Airship
	.byte $00	; Canoe

	.byte $00, $00, $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_Object_Do_All
;
; Runs update code on all map objects, e.g. what makes a 
; Hammer Brother march, an airship fly, etc.  Does NOT have
; anything to do with the interaction of the object, except
; for the canoe, which simply sets the "In Canoe" flag if
; the Player is standing in it.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Map_Object_Do_All:
	LDA Map_NoLoseTurn
	BNE PRG011_ADF4	 ; If Map_NoLoseTurn is set, jump to PRG011_ADF4 (RTS)

	LDY #(MAPOBJ_TOTAL-1) 	; Total map objects which may exist on the map (only 8 are defined at start)
	STY <Temp_Var13		; Temp_Var13 = $0D

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_ADE6	 	; If Map_Operation <> $0B (Hammer Bro marching around), jump to PRG011_ADE6

	LDA Map_MarchInit
	BNE PRG011_ADE6	 	; If Map_MarchInit is set, jump to PRG011_ADE6

PRG011_ADD2:
	LDA Map_Objects_IDs,Y
	BEQ PRG011_ADDE	 	; If the object ID is zero, nothing to do, jump to PRG011_ADDE
	TAX		 	; X = A

	; Initialize all the map march values
	LDA Map_March_InitValues,X	; For this object's ID, get the init value
	STA Map_March_Count,Y	 	; Store it in this object's slot

PRG011_ADDE:
	DEY		 ; Y--
	CPY #$01	 
	BNE PRG011_ADD2	 ; While Y <> 1, loop!


	INC Map_MarchInit	 ; Set Map_MarchInit (March initialization complete!)

PRG011_ADE6:
	LDX <Temp_Var13		; X = Temp_Var13
	LDA Map_Objects_IDs,X
	BEQ PRG011_ADF0	 	; If the object ID is zero, nothing to do, jump to PRG011_ADF0
	JSR Map_Object_Do 	; Process this map object!

PRG011_ADF0:
	DEC <Temp_Var13		; Temp_Var13--
	BPL PRG011_ADE6	 	; While Temp_Var13 >= 0, loop!

PRG011_ADF4:
	RTS		 ; Return


Map_Object_Do:
	; Map object to do...
	JSR Map_Object_CheckVisibility	 ; Check and store if this object is visible

	LDA Map_Objects_IDs,X	; Get the ID
	CMP #MAPOBJ_CANOE
	BGE PRG011_AE0B	 	; If object ID >= $10 (Canoe), jump to PRG011_AE0B

	LDY Map_Operation	; Y = Map_Operation
	CPY #MAPOBJ_COINSHIP
	BNE PRG011_AE0B	 	; If Map_Operation <> $0B, jump to PRG011_AE0B

	LDY Map_March_Count,X
	BEQ PRG011_ADF4	 ; If march count = 0, jump to PRG011_ADF4

PRG011_AE0B:
	; Based on the ID, jump to proper routine for how it should act on the map
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; None (Just RTS)
	.word PRG011_ADF4		; HELP (Just RTS)
	.word Map_Object_Airship	; Airship
	.word Map_Object_March		; Hammer Bro
	.word Map_Object_March		; Boomerang Bro
	.word Map_Object_March		; Heavy Bro
	.word Map_Object_March		; Fire Bro
	.word Map_Object_Stationary	; World 7 Plant
	.word Map_Object_March		; Unknown marching glitch object
	.word Map_Object_March		; N-Spade
	.word Map_Object_March		; White Toad House
	.word Map_Object_March		; Coin Ship
	.word Map_Object_Stationary	; Unknown white colorization of 15 (goes to World 7 level??)
	.word Map_Object_Stationary	; World 8 Battleship
	.word Map_Object_Stationary	; World 8 Tank
	.word Map_Object_Stationary	; World 8 Airship
	.word Map_Object_Canoe		; Canoe

	; Based on march travel direction, these are the movements
Map_Object_Travel_Y:	.byte 0, 0, 1, -1
Map_Object_Travel_X:	.byte 1, -1, 0, 0
Map_Object_Travel_XHi:	.byte 0, -1, 0, 0

Map_Object_March_Offset:
	; For a 32 position march, offset to the object's X coordinate
	.byte -8, -7, -6, -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7
	.byte  8,  7,  6,  5,  4,  3,  2,  1,  0, -1, -2, -3, -4, -5, -6, -7

Map_Object_March_OffsetXHi:
	; For a 32 position march, offset to the object's X Hi coordinate
	.byte -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0
	.byte  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1

Map_Object_March:
	; For all map objects which "march" back and forth (includes Hammer/etc. Brothers, and bonuses...)
	LDA Map_Operation
	CMP #$0d	 	
	BNE Map_Object_March_NonNormal	 	; If Map_Operation <> $0D (Normal operation), jump to Map_Object_March_NonNormal

	; Normal operation, objects just "marching" around...
	LDA Map_Objects_IDs,X	; A = object's ID
	CMP #MAPOBJ_NSPADE
	BLT Map_Object_MusicBoxCheck ; If object ID < MAPOBJ_NSPADE (includes hammer brother types and the world 7 plant), jump to Map_Object_MusicBoxCheck

	CMP #MAPOBJ_BATTLESHIP
	BLT PRG011_AE93	 	; If object ID < MAPOBJ_BATTLESHIP (includes bonus items), jump to PRG011_AE93 (they don't "sleep")

Map_Object_MusicBoxCheck:
	LDA Map_MusicBox_Cnt
	BNE PRG011_AED1	 	; If music box is active, jump to PRG011_AED1

PRG011_AE93:
	TXA
	AND #$01
	STA <Temp_Var16	; Temp_Var16 = object's index AND'ed 1 (mixes up the marching a little; left/right swap)

	LDA Map_March_Count
	AND #$10
	LSR A	
	LSR A	
	LSR A	
	LSR A			; A = (Map_March_Count & $10) >> 4
	STA Map_Object_Data,X	; Data in the context of a "marcher" is 0/1 depending which direction they're walking (every 16 tics, reverse direction)

	LDA <Temp_Var16	; Get the march flip
	BEQ PRG011_AEAE	 	; If no flip needed, jump to PRG011_AEAE

	; Flip the march direction
	EOR Map_Object_Data,X
	STA Map_Object_Data,X

PRG011_AEAE:
	LDA <Temp_Var16
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var16	; Temp_Var16 <<= 4

	LDA Map_March_Count
	AND #$1f	 	; March count is basically 0-31, flipping at 16
	EOR <Temp_Var16	; Flip the upper bit as appropriate

	TAY		 		; Y = A (the adjusted march)
	LDA Map_Objects_XLo,X		; A = object's X coordinate (low part)
	ADD Map_Object_March_Offset,Y	; Add the proper offset in their march
	STA Map_Object_ActX,X	 	; Store this as their display X

	; X Hi offset as needed
	LDA Map_Object_ActXH,X	
	ADC Map_Object_March_OffsetXHi,Y
	STA Map_Object_ActXH,X	 

PRG011_AED1:
	RTS		 ; Return

Map_Object_March_NonNormal:
	; For marchers when Map_Operation <> $0D ...

	CMP #$0b	 
	BNE PRG011_AED1	 	; If Map_Operation <> $0B (Hammer Brothers march around), jump to PRG011_AED1 (RTS)

	LDA Map_MusicBox_Cnt
	BNE PRG011_AF46	 	; If music box is active, jump to PRG011_AF46

	; Hammer brothers need to march about...
	LDY <Temp_Var13		; Y = Temp_Var13 (current object we're working on)
	LDX #$01	 	; X = 1

	; For both players...
PRG011_AEDF:

	; Check if Player is standing on map object
	LDA <World_Map_Y,X
	CMP Map_Object_ActY,Y
	BNE PRG011_AEFA	 	; If Player's Y is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA <World_Map_XHi,X
	CMP Map_Object_ActXH,Y
	BNE PRG011_AEFA	 	; If Player's X Hi is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA <World_Map_X,X
	CMP Map_Object_ActX,Y
	BNE PRG011_AEFA	 	; If Player's X Lo is not equal to this map object, jump to PRG011_AEFA (do nothing)

	LDA #$00
	STA Map_March_Count,Y	; Clear Map_March_Count for this object (why??)
	RTS		 	; Return...

PRG011_AEFA:
	DEX		 ; X--
	BPL PRG011_AEDF	 ; If X >= 0, loop!

	LDA Map_March_Count,Y
	AND #$1f	 	; Cap Map_March_Count to $00-$1F
	BNE PRG011_AF0C	 	; If Map_March_Count value is not zero, jump to PRG011_AF0C

	LDA RandomN,Y	 	; Pulls a random number from the pool (NOTE: This only works for first 7 objects, after that not random)
	AND #$03	 	; Cap value 0-3
	JSR Map_MarchValidateTravel	; Validates traveling in this direction OR does not return here!

PRG011_AF0C:
	LDY <Temp_Var13		; Y = Index of current object we're working with
	LDA Map_Objects_IDs,Y	; Get this object's ID
	BEQ PRG011_AF46	 	; If ID = 0, jump to PRG011_AF46 (shouldn't ever happen??)

	; If object ID is < MAPOBJ_HAMMERBRO or >= MAPOBJ_W7PLANT (not one of the hammer/etc. brothers), jump to PRG011_AF26
	CMP #MAPOBJ_HAMMERBRO
	BLT PRG011_AF26
	CMP #MAPOBJ_W7PLANT	 
	BGE PRG011_AF26

	LDA <Counter_1
	AND #$0f	 ; Restrict counter to 0-15
	BNE PRG011_AF26	 ; If not zero, jump to PRG011_AF26

	LDA #SND_LEVELMARCH	 	
	STA Sound_QLevel2	; Play Marching sound

PRG011_AF26:
	LDX Map_Object_Data,Y	 ; Get march direction

	; The moment you've all been waiting for:
	; The actual march movement!

	; Travel Y
	LDA Map_Object_ActY,Y
	ADD Map_Object_Travel_Y,X
	STA Map_Object_ActY,Y

	; Travel X
	LDA Map_Object_ActX,Y	
	ADD Map_Object_Travel_X,X
	STA Map_Object_ActX,Y	

	; Travel X Hi byte
	LDA Map_Object_ActXH,Y
	ADC Map_Object_Travel_XHi,X
	STA Map_Object_ActXH,Y	

PRG011_AF46:
	; Jumps here if music box is active
	LDX <Temp_Var13			; X = Temp_Var13
	JSR Map_Object_March_UpdateXs	; Copy updated X's to the map RAM

	DEC Map_March_Count,X	 	; Decrement the march counter
	BNE PRG011_AF84	 		; If not zero, jump to PRG011_AF84 (RTS)

	LDA Map_MusicBox_Cnt
	BNE PRG011_AF84	 		; If music box active, jump to PRG011_AF84

	; This is going to loop through all OTHER objects...
	; Basically to make sure this object didn't land on top of another
	LDY #$0d	 
PRG011_AF57:
	CPY <Temp_Var13
	BEQ PRG011_AF81		; If this is the object we're working with, skip this loop!

	LDA Map_Objects_IDs,Y 	; Get this object ID
	BEQ PRG011_AF81	 	; If 0 (no object here), jump to PRG011_AF81
	CMP #MAPOBJ_CANOE
	BGE PRG011_AF81	 	; If ID >= MAPOBJ_CANOE (canoe), jump to PRG011_AF81

	LDA Map_March_Count,Y
	BNE PRG011_AF81

	LDA Map_Object_ActY,Y
	CMP Map_Object_ActY,X
	BNE PRG011_AF81		; Y's are different, OK

	LDA Map_Object_ActXH,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_AF81		; X hi's are different, OK

	LDA Map_Object_ActX,Y
	CMP Map_Object_ActX,X
	BEQ PRG011_AF85		; Gah, everything matched!  I'm standing on something, jump to PRG011_AF85

PRG011_AF81:
	DEY		 ; Y--
	BNE PRG011_AF57	 ; While Y >= 0, loop!

PRG011_AF84:
	RTS		 ; Return

PRG011_AF85:
	; I landed on something, so I gotta re-march
	LDA #$20
	STA Map_March_Count,X	; Redo march

	CPY #$01
	BEQ PRG011_AF93

	LDA #$20	
	STA Map_March_Count,Y

PRG011_AF93:
	RTS		 ; Return


Map_Object_Stationary:
	; For objects like the World 7 plant or World 8 artillery
	; that don't go anywhere ever...

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_AF93	 ; If Map_Operation <> $0B (March Around time), jump to PRG011_AF93 (RTS)
	JMP PRG011_AF46	 ; During the would-be marching period, just animate faster (but no movement)



	; These tables define the possible places that an Airship may
	; travel on the world map; note there are three sets of six
	; possible destinations per world.  And yes, there is space
	; for World 8, though it is unused (zeroed out)

Map_Airship_Dest_YSets:
	.word MAT_Y_W1A, MAT_Y_W1B, MAT_Y_W1C	; World 1 Airship Y Sets
	.word MAT_Y_W2A, MAT_Y_W2B, MAT_Y_W2C	; World 2 Airship Y Sets
	.word MAT_Y_W3A, MAT_Y_W3B, MAT_Y_W3C	; World 3 Airship Y Sets
	.word MAT_Y_W4A, MAT_Y_W4B, MAT_Y_W4C	; World 4 Airship Y Sets
	.word MAT_Y_W5A, MAT_Y_W5B, MAT_Y_W5C	; World 5 Airship Y Sets
	.word MAT_Y_W6A, MAT_Y_W6B, MAT_Y_W6C	; World 6 Airship Y Sets
	.word MAT_Y_W7A, MAT_Y_W7B, MAT_Y_W7C	; World 7 Airship Y Sets
	.word MAT_Y_W8A, MAT_Y_W8B, MAT_Y_W8C	; World 8 Airship Y Sets

Map_Airship_Dest_XSets:
	.word MAT_X_W1A, MAT_X_W1B, MAT_X_W1C	; World 1 Airship X Sets
	.word MAT_X_W2A, MAT_X_W2B, MAT_X_W2C	; World 2 Airship X Sets
	.word MAT_X_W3A, MAT_X_W3B, MAT_X_W3C	; World 3 Airship X Sets
	.word MAT_X_W4A, MAT_X_W4B, MAT_X_W4C	; World 4 Airship X Sets
	.word MAT_X_W5A, MAT_X_W5B, MAT_X_W5C	; World 5 Airship X Sets
	.word MAT_X_W6A, MAT_X_W6B, MAT_X_W6C	; World 6 Airship X Sets
	.word MAT_X_W7A, MAT_X_W7B, MAT_X_W7C	; World 7 Airship X Sets
	.word MAT_X_W8A, MAT_X_W8B, MAT_X_W8C	; World 8 Airship X Sets

	; Map_Airship_Trav selects which world/set to use
	; Map_Airship_Dest selects shich index within to use (0-5)
MAT_Y_W1A:	.byte $A0, $20, $20, $A0, $20, $20	; World 1 Airship Y Set 0
MAT_Y_W1B:	.byte $20, $20, $A0, $A0, $20, $20	;                   Set 1
MAT_Y_W1C:	.byte $20, $20, $A0, $A0, $A0, $A0	;                   Set 2
MAT_Y_W2A:	.byte $20, $60, $20, $40, $40, $40	; World 2 Airship Y Set 0
MAT_Y_W2B:	.byte $60, $40, $20, $20, $60, $20	;                   Set 1
MAT_Y_W2C:	.byte $20, $20, $60, $40, $20, $60	;                   Set 2
MAT_Y_W3A:	.byte $80, $80, $60, $20, $60, $60	; World 3 Airship Y Set 0
MAT_Y_W3B:	.byte $80, $20, $60, $60, $20, $60	;                   Set 1
MAT_Y_W3C:	.byte $60, $20, $60, $60, $60, $20	;                   Set 2
MAT_Y_W4A:	.byte $80, $60, $40, $60, $60, $40	; World 4 Airship Y Set 0
MAT_Y_W4B:	.byte $80, $40, $60, $60, $40, $60	;                   Set 1
MAT_Y_W4C:	.byte $60, $80, $40, $60, $60, $40	;                   Set 2
MAT_Y_W5A:	.byte $80, $80, $40, $80, $40, $80	; World 5 Airship Y Set 0
MAT_Y_W5B:	.byte $40, $80, $80, $60, $40, $20	;                   Set 1
MAT_Y_W5C:	.byte $60, $40, $20, $60, $40, $20	;                   Set 2
MAT_Y_W6A:	.byte $80, $A0, $40, $40, $80, $80	; World 6 Airship Y Set 0
MAT_Y_W6B:	.byte $A0, $40, $40, $80, $80, $80	;                   Set 1
MAT_Y_W6C:	.byte $80, $80, $A0, $A0, $40, $40	;                   Set 2
MAT_Y_W7A:	.byte $90, $70, $30, $90, $70, $30	; World 7 Airship Y Set 0
MAT_Y_W7B:	.byte $70, $30, $90, $50, $30, $90	;                   Set 1
MAT_Y_W7C:	.byte $50, $50, $30, $30, $30, $30	;                   Set 2
MAT_Y_W8A:	.byte $00, $00, $00, $00, $00, $00	; World 8 Airship Y Set 0
MAT_Y_W8B:	.byte $00, $00, $00, $00, $00, $00	;                   Set 1
MAT_Y_W8C:	.byte $00, $00, $00, $00, $00, $00 	;                   Set 2

	; NOTE: To specify a high 'X' (i.e. which map screen of the world
	; the airship is traveling to) you specify it in the LOWER 4 bits.
	; So $A2 equates to coordinate $A0 on the third screen of the map.
MAT_X_W1A:	.byte $60, $60, $C0, $60, $60, $C0	; World 1 Airship X Set 0
MAT_X_W1B:	.byte $C0, $C0, $60, $60, $60, $60	;                   Set 1
MAT_X_W1C: 	.byte $60, $C0, $60, $60, $60, $60	;                   Set 2
MAT_X_W2A:	.byte $A0, $01, $01, $80, $80, $80	; World 2 Airship X Set 0
MAT_X_W2B:	.byte $01, $80, $01, $A0, $01, $01	;                   Set 1
MAT_X_W2C:	.byte $01, $A0, $01, $80, $01, $01	;                   Set 2
MAT_X_W3A:	.byte $B2, $B2, $01, $21, $01, $A0	; World 3 Airship X Set 0
MAT_X_W3B:	.byte $B2, $21, $01, $A0, $40, $A0	;                   Set 1
MAT_X_W3C:	.byte $01, $21, $E0, $A0, $A0, $40	;                   Set 2
MAT_X_W4A:	.byte $E0, $21, $A1, $41, $C1, $01	; World 4 Airship X Set 0
MAT_X_W4B:	.byte $E0, $01, $21, $41, $A1, $C1	;                   Set 1
MAT_X_W4C:	.byte $21, $E0, $A1, $C1, $41, $01	;                   Set 2
MAT_X_W5A:	.byte $A1, $61, $C1, $A1, $C1, $61	; World 5 Airship X Set 0
MAT_X_W5B:	.byte $C1, $61, $A1, $80, $80, $20	;                   Set 1
MAT_X_W5C:	.byte $80, $80, $20, $80, $80, $20	;                   Set 2
MAT_X_W6A:	.byte $02, $61, $C1, $C0, $A0, $21	; World 6 Airship X Set 0
MAT_X_W6B:	.byte $61, $C1, $C0, $02, $21, $A0	;                   Set 1
MAT_X_W6C:	.byte $02, $02, $61, $61, $C0, $C1	;                   Set 2
MAT_X_W7A:	.byte $A1, $A1, $81, $A1, $A1, $81	; World 7 Airship X Set 0
MAT_X_W7B:	.byte $A1, $81, $A1, $F0, $81, $A1	;                   Set 1
MAT_X_W7C:	.byte $F0, $F0, $40, $40, $81, $81	;                   Set 2
MAT_X_W8A:	.byte $00, $00, $00, $00, $00, $00	; World 8 Airship X Set 0
MAT_X_W8B:	.byte $00, $00, $00, $00, $00, $00	;                   Set 1
MAT_X_W8C:	.byte $00, $00, $00, $00, $00, $00	;                   Set 2


PRG011_B11E:
	.byte $03, $04, $05, $00, $00, $05, $00, $00



Map_Object_Airship:
	LDA Map_Operation
	CMP #$0d
	BNE Map_Airship_Travel_To	; If Map_Operation <> $0D (normal), jump to Map_Airship_Travel_To

	LDA #$00
	STA <Temp_Var15		; Temp_Var15 = 0 (Airship facing to the right)
	LDY Player_Current	; Y = Player_Current

	LDA World_Map_XHi,Y	; A = Player's X Hi byte
	CMP Map_Object_ActXH+1	; Airship's X Hi byte
	BEQ PRG011_B140	 	; If they're equal (we're on the same screen), jump to PRG011_B140

	BGE PRG011_B14C	 	; If the airship's X Hi is greater, jump to PRG011_B14C
	BLT PRG011_B148	 	; If the airship's X Hi is lesser, jump to PRG011_B148

PRG011_B140:
	LDA World_Map_X,Y	; Get Player's X
	CMP Map_Object_ActX+1	; Airship's X byte
	BGE PRG011_B14C	 	; If Airship's X >= Player's X, jump to PRG011_B14C

PRG011_B148:
	LDA #$01	 	
	STA <Temp_Var15		; Temp_Var15 = 1 (Airship facing to the left)

PRG011_B14C:
	LDA <Temp_Var15	
	STA Map_Object_Data+1	; Store facing direction into Airship's data
PRG011_B151:
	RTS		 	; Return...

Map_Airship_Travel_To:
	LDA Map_Airship_Trav	
	ASL A		 	
	TAY		 	; Y = Map_Airship_Trav << 1 (indexing...)

	; Based on Map_Airship_Trav, a different base offset into the Tables
	; is selected; provides a little variance on where the Airship will
	; go each time...

	; Get address into Map_Airship_Dest_YSets
	LDA Map_Airship_Dest_YSets,Y
	STA <Temp_Var1		 
	LDA Map_Airship_Dest_YSets+1,Y
	STA <Temp_Var2		 

	; Get address into Map_Airship_Dest_XSets
	LDA Map_Airship_Dest_XSets,Y
	STA <Temp_Var3	
	LDA Map_Airship_Dest_XSets+1,Y
	STA <Temp_Var4	

	LDA Map_Operation
	CMP #$04
	BNE PRG011_B1A7	 ; If Map_Operation <> 4, jump to PRG011_B1A7

	LDA Map_Anchored
	BEQ PRG011_B17A	 ; If Airship is not anchored, jump to PRG011_B17A

	JMP PRG011_B2B8	 ; Airship anchored!  Jump to PRG011_B2B8

PRG011_B17A:
	LDA #$00
	STA Map_March_Count+1	; Clear Airship's counter

	LDY Map_Airship_Dest
	CPY #$06	 
	BGE PRG011_B1A2	 	; If Map_Airship_Dest >= 6, jump to PRG011_B1A2

	; Get and set the destination Y of the Airship travel
	LDA [Temp_Var1],Y	; Get the Y from the table
	STA Map_Object_ActY+1
	STA Map_Objects_Y+1

	; Get and set the destination X of the Airship travel
	LDA [Temp_Var3],Y	; Get the X from the table
	PHA		 	; Save 'A'

	; High part
	AND #$0f	 	; Get only the low bits (this is used to specify the "high" part, funny enough)
	STA Map_Object_ActXH+1
	STA Map_Objects_XHi+1

	; Low part
	PLA		 	; Restore 'A"
	AND #$f0	 	; Only the high bits specify the low X byte
	STA Map_Object_ActX+1
	STA Map_Objects_XLo+1

PRG011_B1A2:
	LDX #$01	 		; X = 1 (the Airship's object index)
	JMP Map_Object_March_UpdateXs	; Update changed X coordinates

PRG011_B1A7:
	; Airship when Map_Operation <> 4

	LDA Map_March_Count+1	; Airship's "March count"
	BEQ PRG011_B151	 	; If zero, jump to PRG011_B151 (RTS)

	LDA <Map_Airship_DC
	BEQ PRG011_B1B3	 	; If Map_Airship_DC = 0 (deltas not yet computed), jump to PRG011_B1B3
	JMP PRG011_B2B8	 	; Otherwise, jump to PRG011_B2B8...

PRG011_B1B3:
	LDY Map_Airship_Dest	; Y = Map_Airship_Dest
	CPY #$06	 
	BLT PRG011_B1BD	 	; If Airship still has moves left, jump to PRG011_B1BD
	JMP PRG011_B221	 	; Otherwise, jump to PRG011_B221

PRG011_B1BD:
	LDA Map_Object_ActXH+1	
	ORA Map_Object_ActX+1	; A = Airship's current X with XHi OR'd into the low bits
	CMP [Temp_Var3],Y	; Check if airship is at X destination yet
	BNE PRG011_B1CE	 	; If not, jump to PRG011_B1CE

	LDA Map_Object_ActY+1	; A = Airship's Y
	CMP [Temp_Var1],Y	; Check if airship is at Y destination yet
	BEQ PRG011_B21B	 	; If it is, jump to PRG011_B21B

PRG011_B1CE:
	LDA [Temp_Var1],Y	; Get Y destination from table
	STA <Temp_Var5		; Store into Temp_Var5

	LDA [Temp_Var3],Y	; Get X destination from table
	AND #$0f	 	; Only keep lower part (XHi)
	STA <Temp_Var7		; Store into Temp_Var7

	LDA [Temp_Var3],Y	; Get X destination from table
	AND #$f0	 	; Only keep higher part (X lo)
	STA <Temp_Var6		; Store into Temp_Var6

	LDA <Temp_Var5
	SUB #32	
	STA <Temp_Var5		; Temp_Var5 (Y destination) -= 32

	LDA <Temp_Var6
	SUB #32
	STA <Temp_Var6		; Temp_Var6 (X lo destination) -= 32
	LDA <Temp_Var7	
	SBC #$00
	STA <Temp_Var7		; Temp_Var7 (X hi destination) applies carry as appropriate

	LDX Total_Players
	DEX			; X = 0 for 1P mode, 1 for 2P mode

PRG011_B1F6:
	; The following are calculating differences between the Airship and players, but I'm not sure for what purpose
	; Maybe to keep the airship from landing directly on top of a Player?
	; This may be troublesome...
	LDA Map_Previous_Y,X	; Get previous Y position for Player
	SUB <Temp_Var5		; Subtract the Y destination 
	CMP #$41	 
	BGE PRG011_B215	 	; If result >= $41, jump to PRG011_B215 (What is this for??)

	LDA Map_Previous_X,X	; Get previous X position for Player
	SUB <Temp_Var6		; Subtract the X lo destination 
	STA <Temp_Var6		; And update Temp_Var6

	LDA Map_Previous_XHi,X 	; Get previous X Hi position for Player
	SBC <Temp_Var7		; Subtract carry from Temp_Var7
	BNE PRG011_B215	 	; If greater than zero, jump to PRG011_B215

	LDA <Temp_Var6		; Get adjusted result
	CMP #$41	 	; 
	BLT PRG011_B21B	 	; If result < $41, jump to PRG011_B21B (stops Airship)

PRG011_B215:
	DEX		 
	BPL PRG011_B1F6	 	; If 2P mode, jump to PRG011_B1F6 (do it again for other Player)
	JMP PRG011_B229	 	; Otherwise, jump to PRG011_B229

PRG011_B21B:
	; Airship's at destination!
	INC Map_Airship_Dest	; Use next destination if it has to travel again...
	JMP PRG011_B1B3	 	; Jump to PRG011_B1B3 (verifies Airship has no moves left; it apparently can change course if needed?)

PRG011_B221:
	; Airship has no moves left..
	LDX <Temp_Var13		; Retores index of object we were processing 
	LDA #$00	 	
	STA Map_March_Count+1	; Clear moves
	RTS			; Return...

PRG011_B229:
	; After Player difference statements...
	LDX <Temp_Var13		; X = Object we were processing
	LDY Map_Airship_Dest	; Y = Current Airship destination index (0-5)
	LDA #$00	 
	STA Map_Object_Data+1	; Airship's data = 0 (facing direction)
	STA <Map_Airship_Dir	; Map_Airship_Dir = 0

	LDA [Temp_Var1],Y	; A = Airship Y destination
	SUB Map_Object_ActY+1	; Difference against its current Y
	STA <Map_Airship_DY	; Store into Map_Airship_DY

	LDA [Temp_Var3],Y	; A = Airship X destination
	AND #$f0	 	; Just the X Lo part
	SUB Map_Object_ActX+1	; Difference to its current X Lo
	STA <Map_Airship_DX	; Store into Map_Airship_DX

	LDA [Temp_Var3],Y	; A = Airship X destination
	AND #$0f	 	; Just the X Hi part 
	SBC Map_Object_ActXH+1	; Difference to its current X Hi (taking into account the low too)
	STA <Map_Airship_DXHi	; Store into Map_Airship_DXHi


	LDA [Temp_Var3],Y	; Get airship X target
	AND #$0f	 	; Only lower bits (hi part)
	CMP Map_Object_ActXH+1	; Compare against its current X hi...

	BEQ PRG011_B25D	 	; If the same, jump to PRG011_B25D
	BPL PRG011_B27D	 	; Airship X Hi > target X Hi, jump to PRG011_B27D
	BMI PRG011_B266	 	; Airship X Hi < target X Hi, jump to PRG011_B266
PRG011_B25D:
	; Airship X achieved
	LDA [Temp_Var3],Y
	AND #$f0
	CMP Map_Object_ActX+1
	BGE PRG011_B27D	 ; If target X (aligned to grid) >= airship X , jump to PRG011_B27D

PRG011_B266:
	; Airship X Hi < target X Hi
	LDA #$01	 	
	STA <Map_Airship_Dir	; Map_Airship_Dir = 1 (H negation active)

	; Negate Map_Airship_DXHi
	LDA #$ff	 	
	EOR <Map_Airship_DXHi	
	STA <Map_Airship_DXHi

	; Negate Map_Airship_DX
	LDA #$ff	 	
	EOR <Map_Airship_DX
	STA <Map_Airship_DX
	INC <Map_Airship_DX

	LDA #$01	 
	STA Map_Object_Data+1	; Airship's data = 1 (facing direction)

PRG011_B27D:
	; Airship Hi > target X Hi or coming in from above...

	LDA [Temp_Var1],Y	
	CMP Map_Object_ActY+1	
	BGE PRG011_B292	 	; If target Y >= current Y, jump to PRG011_B292

	; Otherwise, negate Map_Airship_DY
	LDA #$ff	
	EOR <Map_Airship_DY
	STA <Map_Airship_DY
	INC <Map_Airship_DY

	; Set V negation active bit in Map_Airship_Dir
	LDA <Map_Airship_Dir
	ORA #$02	 	
	STA <Map_Airship_Dir	

PRG011_B292:


	; This loop shifts Map_Airship_DY and Map_Airship_DXHi/Map_Airship_DX to the right four bits,
	; and stores the shifted out lower 4 bits as high bits to a new variable.
	; The resulting Map_Airship_DY / Map_Airship_DX are map row/col values instead
	LDY #$04	 	; Y = 4
PRG011_B294:
	CLC		 	; Clear carry
	LSR <Map_Airship_DY	; Map_Airship_DY >> 1 
	ROR <Map_Airship_YNib	; Accumulating the pushed out bits

	CLC			; Clear carry
	LSR <Map_Airship_DXHi	; Map_Airship_DXHi >> 1
	ROR <Map_Airship_DX	; Bit from above pushed into Map_Airship_DX as topmost bit, carry out
	ROR <Map_Airship_XNib	; Accumulating the pushed out bits

	DEY		 	; Y--
	BPL PRG011_B294	 	; While Y >= 0, loop!

	; The end result here is actually a 16-bit shift to the LEFT
	; for Map_Airship_DXHi/Map_Airship_DX
	LDA <Map_Airship_DX
	STA <Map_Airship_DXHi	; Map_Airship_DXHi = Map_Airship_DX
	LDA <Map_Airship_XNib
	STA <Map_Airship_DX	; Map_Airship_DX = Map_Airship_XNib

	; Clear Map_Airship_XNib for next time
	LDA #$00
	STA <Map_Airship_XNib	; Map_Airship_XNib = 0

	LDA #$01	 
	STA <Map_Airship_DC	; Map_Airship_DC = 1 (deltas computed!)

	LDA #32
	STA Map_Intro_Tick	; Map_Intro_Tick = 32

PRG011_B2B8:
	; Deltas are computed and we're going...
	; Do a 32 tick "flash" effect first before moving...
	LDA Map_Intro_Tick
	BEQ PRG011_B2C0	 		; If ticks = 0, jump to PRG011_B2C0
	JMP FX_MonoFlash_By_MapTick	; Otherwise, jump to FX_MonoFlash_By_MapTick (on Page 10)

PRG011_B2C0:
	LDA Map_Anchored
	BEQ PRG011_B2D0	 	; If Map_Anchored = 0 (Airship not anchorned), jump to PRG011_B2D0

	; Airship's anchored!
	LDA #$00	 
	STA Map_March_Count+1		; Stop Airship
	STA Map_Airship_Dest		; Reset destination index
	JMP Map_Object_March_UpdateXs	; And that's it...

PRG011_B2D0:
	LDA SndCur_Level2	
	AND #$08	 	
	BNE PRG011_B2DF	 	; If Airship sound effect is playing, jump to PRG011_B2DF

	; Otherwise, re-queue it (effective loop)
	LDA Sound_QLevel2
	ORA #SND_LEVELAIRSHIP
	STA Sound_QLevel2

PRG011_B2DF:
	LDX #$01	 		; X = 1 (the Airship index)

	; This ultimately controls how fast the Airship flies on the map
	; You should see it fly with no delay :)
	LDA <Counter_1			
	AND #$03
	BNE Map_Object_March_UpdateXs	; Basically only do something once every 4 ticks

	; For the 1:4 tick...
	LDA <Map_Airship_Dir
	AND #$01	 
	BNE PRG011_B307	 	; If Map_Airship_Dir = 1 (to the right), jump to PRG011_B307

	; Reuse of Map_Airship_XNib...
	LDA <Map_Airship_XNib	
	ADD <Map_Airship_DX	
	STA <Map_Airship_XNib	; Map_Airship_XNib += Map_Airship_XNib

	; Advances Airship's X Hi / X, positive
	LDA Map_Object_ActX+1
	ADC <Map_Airship_DXHi
	STA Map_Object_ActX+1
	LDA Map_Object_ActXH+1
	ADC #$00	
	STA Map_Object_ActXH+1

	JMP PRG011_B31E

PRG011_B307:
	LDA <Map_Airship_XNib
	SUB <Map_Airship_DX
	STA <Map_Airship_XNib	; Map_Airship_XNib -= Map_Airship_XNib

	; Advances Airship's X Hi / X, negative
	LDA Map_Object_ActX+1
	SBC <Map_Airship_DXHi
	STA Map_Object_ActX+1
	LDA Map_Object_ActXH+1
	SBC #$00
	STA Map_Object_ActXH+1

PRG011_B31E:
	LDA <Map_Airship_Dir
	AND #$02	 
	BNE PRG011_B336	 	; If traveling upward, jump to PRG011_B336

	; Positive advancement of Y
	LDA <Map_Airship_YAcc
	ADD <Map_Airship_YNib
	STA <Map_Airship_YAcc
	LDA Map_Object_ActY+1
	ADC <Map_Airship_DY
	STA Map_Object_ActY+1

	JMP PRG011_B345	 	; Jump to PRG011_B345

PRG011_B336:

	; Negative advancement of Y
	LDA <Map_Airship_YAcc
	SUB <Map_Airship_YNib
	STA <Map_Airship_YAcc
	LDA Map_Object_ActY+1
	SBC <Map_Airship_DY
	STA Map_Object_ActY+1

PRG011_B345:
	LDX #$01	 		; The Airship's index
	DEC Map_March_Count+1	
	BNE Map_Object_March_UpdateXs	; While more moves to go, just update

	; Out of moves; Airship has stopped!
	; Make sure it's right where it should be!
	LDA Map_Object_ActY+1	
	STA Map_Objects_Y+1	
	LDA Map_Object_ActXH+1	
	STA Map_Objects_XHi+1	
	LDA Map_Object_ActX+1	
	STA Map_Objects_XLo+1	

	LDX #$01	 	; X = 1 (Airship's index)
	INC Map_Airship_Dest	; Use next destination next time

Map_Object_March_UpdateXs:
	; Copy the object's moved X lo & hi to the stored map versions
	LDA Map_Object_ActX,X
	STA Map_Objects_XLo,X
	LDA Map_Object_ActXH,X
	STA Map_Objects_XHi,X
	RTS		 	; Return


	; Travel directions:
	; 0 = Right, 1 = Left, 2 = Down, 3 = Up
Map_Object_March_YOffByDir:	.byte 0, 0, 16, -16	; Travel direction Y offsets for marching map brother
				.byte 0, 0, 32, -32	; Next tile over; if the first tile is OK, see if the destination is OK too

Map_Object_March_XOffByDir:	.byte 16, -16, 0, 0	; Travel direction X offsets for marching map brother
				.byte 32, -32, 0, 0	; Next tile over; if the first tile is OK, see if the destination is OK too

Map_Object_March_XHiOffByDir:	.byte 0, -1, 0, 0	; Travel direction X Hi offsets for marching map brother
				.byte 0, -1, 0, 0	; Next tile over; if the first tile is OK, see if the destination is OK too

	; Tiles that are forbidden for the marching object to "land" on
Map_Object_Forbid_LandingTiles:
	.byte TILE_MARIOCOMP_O, TILE_LUIGICOMP_O, TILE_MARIOCOMP_P, TILE_LUIGICOMP_P
	.byte TILE_DANCINGPALM, TILE_DANCINGBUSH, TILE_PIPE,        TILE_SPADEBONUS 
	.byte TILE_SPIRAL,      TILE_ALTSPIRAL,   TILE_FORTRUBBLE,  TILE_MARIOCOMP_G
	.byte TILE_LUIGICOMP_G, TILE_MARIOCOMP_R, TILE_LUIGICOMP_R, TILE_ALTRUBBLE
	.byte TILE_START
Map_Object_Forbid_LT_End

	; This makes it safe to expand the above
	; There's a mistake in here somewhere, I think Nintendo did their loop/indexing wrong
	; See notes at PRG011_B406
MOV_Landings2Check = (Map_Object_Forbid_LT_End - Map_Object_Forbid_LandingTiles) + 1


	; Extra tiles that a hammer bro is forbidden from stepping on
	; I don't know why these are split from the above?
Map_MarchXtraForbidTiles:
	.byte TILE_TOADHOUSE, TILE_ALTTOADHOUSE, TILE_CASTLEBOTTOM, TILE_PATHANDNUB	; <-- Last one is weird "enterable"!
Map_MarchXtraForbidTiles_End


Map_MarchValidateTravel:
	; A = pseudo-random value, 0-3
	STA <Temp_Var1		; Temp_Var1 = random val 0-3
	LDA #$04
	STA <Temp_Var2		; Temp_Var2 = 4

PRG011_B3A3:
	LDY <Temp_Var13		; Y = Temp_Var13 (Current object we're working on)
	DEC <Temp_Var1		; Temp_Var1--

	LDA RandomN,Y	 	; Get the full random value
	ASL A		 	; A << 1
	BCC PRG011_B3B1	 	; If the bit 7 was not set, carry is clear, and jump to PRG011_B3B1

	INC <Temp_Var1
	INC <Temp_Var1		; Otherwise, Temp_Var1 (the 0-3 input) += 2

PRG011_B3B1:
	LDA <Temp_Var1		; A = Temp_Var1 (0-5 now)
	AND #$03	 
	STA <Temp_Var1		; Enforcing 0-3 cap on Temp_Var1

	; Temp_Var1 is a value from 0-3 that specifies a travel direction

	EOR Map_Object_Data,Y	; March direction possible invert
	CMP #$01	 
	BEQ PRG011_B3A3	 	; If current result = 1, jump to PRG011_B3A3

	DEC <Temp_Var2		; Temp_Var2--
	BPL PRG011_B3CA	 	; If Temp_Var2 >= 0, jump to PRG011_B3CA

	LDA #$00
	STA Map_March_Count,Y	; Clear Map_March_Count value

	; ******!!!
	; NOTE: Don't actually return to caller; return to caller's caller!
	PLA		 
	PLA
	RTS		 ; Return

LT0B:
PRG011_B3CA:
	BNE PRG011_B3D3	 	; If Temp_Var2 <> 0, jump to PRG011_B3D3

	; When Temp_Var2 = 0...
	LDA Map_Object_Data,Y	; Get march direction
	EOR #$01	 	; Flip it
	STA <Temp_Var1		; Store that to Temp_Var1

PRG011_B3D3:
	LDX <Temp_Var1		; X = Temp_Var1 (0-3)
	JSR Map_Object_March_PickTravel	; Sets Map_Tile_Addr, figures travel destination in Temp_Var3 (upper 4 containing target row, lower 4 containing target column)

	LDA <Temp_Var1		; A = Temp_Var1 (0-3) travel dir
	ASL A		 	; A << 1 (index)
	TAX		 	; X = A

	; Get address Map_Object_Valid_Tiles (on page 10), store into Temp_Var15
	; This lists valid tiles the object may travel over...
	LDA Map_Object_Valid_Tiles,X
	STA <Temp_Var15	
	LDA Map_Object_Valid_Tiles+1,X
	STA <Temp_Var16

	LDY <Temp_Var3		; Y = Temp_Var3 (travel target)
	LDA [Map_Tile_AddrL],Y	; Get tile here

	LDY #(Map_Object_Valid_Tiles2Check-1)	; Check all possible travel-over tiles
PRG011_B3EC:
	CMP [Temp_Var15],Y
	BEQ PRG011_B3F5	 	; If this tile is valid to travel over, jump to PRG011_B3F5
	DEY		 ; Y--
	BPL PRG011_B3EC	 ; While Y >= 0, loop!
	BMI PRG011_B3A3	 ; If we couldn't find a tile valid to travel over, jump to PRG011_B3A3 to choose anew...

PRG011_B3F5:
	; Valid tile in front of us, now check if we can move one more!
	; (Moves are in two tiles, not one; make sure "landing zone" is safe)
	LDY <Temp_Var13	 ; Y = Temp_Var13 (object we're working on)
	LDA <Temp_Var1	 ; A = Temp_Var1
	ADD #$04	 ; Offset the travel dir +4; check next tile over (since moves are made by 2 tiles, not 1)

	TAX		 ; X = A (travel dir)
	JSR Map_Object_March_PickTravel	 ; Get next tile over, "landing zone"

	LDY <Temp_Var3			; Y = Temp_Var3 (travel target)
	LDA [Map_Tile_AddrL],Y		; Get tile here

	LDY #(MOV_Landings2Check-1)
PRG011_B406:
	; NOTE: For some reason, they were checking one byte prior to the actual
	; LUT, but then they won't decrement 'Y' down to zero (so it stays within
	; the LUT); there must have been a mistake here somewhere? :)
	CMP Map_Object_Forbid_LandingTiles-1,Y
	BNE PRG011_B40E	 ; If this is not a forbidden landing tile, jump to PRG011_B40E
	JMP PRG011_B3A3	 ; Otherwise, jump to PRG011_B3A3

PRG011_B40E:
	DEY		 ; Y--
	BNE PRG011_B406	 ; While Y > 0, loop!

	LDX <Temp_Var13		 	; X = Temp_Var13
	LDY #(Map_MarchXtraForbidTiles_End - Map_MarchXtraForbidTiles)	
PRG011_B415:
	; NOTE: Like PRG011_B406, this loop doesn't hit index 0.  Wonder why??
	CMP Map_MarchXtraForbidTiles-1,Y
	BEQ PRG011_B42A	 ; If tile is one of the additional forbidden tiles, jump to PRG011_B42A

	DEY		 ; Y--
	BNE PRG011_B415	 ; While Y <> 0, loop!

	PHA		 ; Save tile

	; Calculate tile quadrant
	ASL A
	ROL A
	ROL A
	AND #$03
	TAY	; -> 'Y'

	PLA		 ; Restore tile

	CMP Tile_AttrTable+4,Y
	BLT PRG011_B435	 ; If this tile is not enterable, jump to PRG011_B435 (safe landing)

PRG011_B42A:

	LDA #$20
	CMP Map_March_Count,X
	BNE PRG011_B435	 ; If March counter <> $20, jump to PRG011_B435

	; More time to march
	ASL A		 ; A = $40
	STA Map_March_Count,X	 ; -> March counter

PRG011_B435:
	; Safe landing!
	LDA <Temp_Var1
	STA Map_Object_Data,X

	RTS		 ; Return

Map_Object_March_PickTravel:
	; Sets Map_Tile_Addr, figures travel destination in Temp_Var3 (upper 4 containing target row, lower 4 containing target column)

	LDA Map_Object_ActY,Y	 ; A = Map object's Y
	ADD Map_Object_March_YOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the Y coordinate
	STA <Temp_Var3		 ; Result into Temp_Var3

	LDA Map_Object_ActX,Y	 ; A = Map object's X
	ADD Map_Object_March_XOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the X coordinate
	STA <Temp_Var4		 ; Result into Temp_Var4

	LDA Map_Object_ActXH,Y	 ; A = Map object's X hi byte
	ADC Map_Object_March_XHiOffByDir,X	 ; X = 0-3 travel direction; add indexed value to the X Hi
	ASL A		 	; Index into Tile_Mem_Addr
	TAX		 	; X = A

	; Get to proper offset for where object stands, +$F0
	LDA Tile_Mem_Addr,X
	ADD #$f0
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	ADC #$00
	STA <Map_Tile_AddrH

	LDA <Temp_Var4	
	LSR A		
	LSR A		
	LSR A		
	LSR A		
	ORA <Temp_Var3	; Makes an assumption that the object's Y value is row-aligned (which it generally is)
	STA <Temp_Var3	; Temp_Var3 = (Temp_Var4 >> 4) | Temp_Var3
	RTS		; Return

	; First column is for when the object is sleeping by Music Box (if applicable)
	; The other two are the animation...

MapObject_Pat1:
	.byte $00, $49, $29	; 01=HELP
	.byte $00, $C9, $D9	; 02=Airship
	.byte $ED, $C5, $D5	; 03=Hammer Bro
	.byte $ED, $C5, $D5	; 04=Boomerang Bro
	.byte $ED, $C5, $D5	; 05=Heavy Bro
	.byte $ED, $C5, $D5	; 06=Fire Bro
	.byte $6B, $E1, $F1	; 07=World 7 Plant
	.byte $25, $21, $23	; 08=Unknown marching glitch object
	.byte $11, $11, $11	; 09=N-Spade
	.byte $13, $13, $13	; 0A=White Toad House
	.byte $17, $17, $17	; 0B=Coin Ship
	.byte $FD, $FD, $1B	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.byte $F5, $F5, $F9	; 0D=World 8 Battleship
	.byte $E5, $E5, $E9	; 0E=World 8 Tank
	.byte $FD, $FD, $1B	; 0F=World 8 Airship
	.byte $00, $71, $75	; 10=Canoe

MapObject_Pat2:
	.byte $00, $49, $2B	; 01=HELP
	.byte $00, $CB, $DB	; 02=Airship
	.byte $EF, $C7, $D7	; 03=Hammer Bro
	.byte $EF, $C7, $D7	; 04=Boomerang Bro
	.byte $EF, $C7, $D7	; 05=Heavy Bro
	.byte $EF, $C7, $D7	; 06=Fire Bro
	.byte $6D, $E1, $F1	; 07=World 7 Plant
	.byte $25, $23, $21	; 08=Unknown marching glitch object
	.byte $21, $21, $21	; 09=N-Spade
	.byte $15, $15, $15	; 0A=White Toad House
	.byte $19, $19, $19	; 0B=Coin Ship
	.byte $FF, $FF, $BB	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.byte $F7, $F7, $FB	; 0D=World 8 Battleship
	.byte $E7, $E7, $EB	; 0E=World 8 Tank
	.byte $FF, $FF, $BB	; 0F=World 8 Airship
	.byte $00, $73, $77	; 10=Canoe

MapObject_Attr1:
	.byte $00, $03, $03	; 01=HELP
	.byte $00, $01, $01	; 02=Airship
	.byte $02, $02, $02	; 03=Hammer Bro
	.byte $02, $02, $02	; 04=Boomerang Bro
	.byte $02, $02, $02	; 05=Heavy Bro
	.byte $02, $02, $02	; 06=Fire Bro
	.byte $01, $01, $01	; 07=World 7 Plant
	.byte $02, $02, $42	; 08=Unknown marching glitch object
	.byte $03, $03, $03	; 09=N-Spade
	.byte $03, $03, $03	; 0A=White Toad House
	.byte $03, $03, $03	; 0B=Coin Ship
	.byte $03, $03, $03	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.byte $02, $02, $02	; 0D=World 8 Battleship
	.byte $02, $02, $02	; 0E=World 8 Tank
	.byte $01, $01, $01	; 0F=World 8 Airship
	.byte $00, $02, $02	; 10=Canoe

MapObject_Attr2:
	.byte $00, $03, $03	; 01=HELP
	.byte $00, $01, $01	; 02=Airship
	.byte $02, $02, $02	; 03=Hammer Bro
	.byte $02, $02, $02	; 04=Boomerang Bro
	.byte $02, $02, $02	; 05=Heavy Bro
	.byte $02, $02, $02	; 06=Fire Bro
	.byte $01, $41, $41	; 07=World 7 Plant
	.byte $42, $02, $42	; 08=Unknown marching glitch object
	.byte $03, $03, $03	; 09=N-Spade
	.byte $03, $03, $03	; 0A=White Toad House
	.byte $03, $03, $03	; 0B=Coin Ship
	.byte $03, $03, $03	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.byte $02, $02, $02	; 0D=World 8 Battleship
	.byte $02, $02, $02	; 0E=World 8 Tank
	.byte $01, $01, $01	; 0F=World 8 Airship
	.byte $00, $02, $02	; 10=Canoe

	; This is a rotated array of Sprite_RAM offsets, helps distribute
	; the map object display so even if there's scanline overflows,
	; there will be at least some visibility of all objects.
Map_SpriteRAM_Offset:
	.byte $08, $60, $10, $58, $18, $50, $20, $48, $28, $40, $30, $38 


MapObjects_UpdateDrawEnter:
	JSR Map_Object_Do_All	 ; Runs update code for all map objects
	JSR FX_World_8_Darkness	 ; Performs / updates the World 8 darkness effect, if active

	; Temp_Var13 = $0D
	LDA #$0D	 	; Total map objects which may exist on the map (only 8 are defined at start)
	STA <Temp_Var13

	; Map_SprRAMOffDistr runs from $00 to $0A, inclusive
	INC Map_SprRAMOffDistr
	LDA Map_SprRAMOffDistr
	CMP #$0b
	BLT PRG011_B554

	LDA #$00
	STA Map_SprRAMOffDistr

PRG011_B554:

	; Temp_Var6 = 0
	LDA #$00
	STA <Temp_Var6

	LDY <Temp_Var13	 ; Y = Temp_Var13 (current map slot index)
	BEQ PRG011_B56E	 ; If Temp_Var13 = 0, jump to PRG011_B56E

	DEY		 ; Y--
	TYA
	ADD Map_SprRAMOffDistr	 ; A = Map_SprRAMOffDistr + Temp_Var13

	CMP #$0b
	BLT PRG011_B568	 ; If value didn't overflow, jump to PRG011_B568

	SBC #$0b	 ; Otherwise, keep it in range of $00 - $0A (modulus)

PRG011_B568:
	TAX		 ; -> 'X'

	LDA Map_SpriteRAM_Offset,X	; Get Sprite_RAM offset
	STA <Temp_Var6		 	; -> Temp_Var6

PRG011_B56E:
	LDX <Temp_Var13		 ; X = Temp_Var13

	LDA Map_Objects_Vis,X
	BEQ PRG011_B578	 ; If this object isn't visible, jump to PRG011_B578

	JSR MapObject_DrawSleepEnter	 ; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered

PRG011_B578:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG011_B554	 ; While Temp_Var13 >= 0, loop!

PRG011_B57C:
	LDA Map_Operation
	CMP #$0d
	BNE PRG011_B58C	 ; If the map operation <> $0D (normal), jump to PRG011_B58C (RTS)

	LDA <Counter_1
	AND #$03
	BNE PRG011_B58C

	INC Map_March_Count	; Increment Map_March_Count every 4 ticks

PRG011_B58C:
	RTS		 ; Return


	; Draw the map object, put it to sleep (if applicable), and enter it if it should be entered
MapObject_DrawSleepEnter:
	LDA Map_Objects_IDs,X

	CPX <Map_HideObj
	BNE PRG011_B599	 ; If this map object slot index <> Map_HideObj, jump to PRG011_B599

	CPX #$00	 
	BEQ PRG011_B599	 ; If this map object slot index = 0, jump to PRG011_B599

	RTS		 ; Return

PRG011_B599:

	; Map object slot 0 (typ. HELP bubble) or any object that is not in the Map_HideObj override slot

	; Jump by the Map Object ID (this is largely wasted here...)
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG011_ADF4		; 00=None (RTS)
	.word MapObj_DrawAndEnter	; 01=HELP
	.word MapObj_DrawAndEnter	; 02=Airship
	.word MapObj_DrawAndEnter	; 03=Hammer Bro
	.word MapObj_DrawAndEnter	; 04=Boomerang Bro
	.word MapObj_DrawAndEnter	; 05=Heavy Bro
	.word MapObj_DrawAndEnter	; 06=Fire Bro
	.word MapObj_DrawAndEnter	; 07=World 7 Plant
	.word MapObj_DrawAndEnter	; 08=Unknown marching glitch object
	.word MapObj_DrawAndEnter	; 09=N-Spade
	.word MapObj_DrawAndEnter	; 0A=White Toad House
	.word MapObj_DrawAndEnter	; 0B=Coin Ship
	.word MapObj_DrawAndEnter	; 0C=Unknown white colorization of $0F (goes to World 7 level??)
	.word MapObj_DrawAndEnter	; 0D=World 8 Battleship
	.word MapObj_DrawAndEnter	; 0E=World 8 Tank
	.word MapObj_DrawAndEnter	; 0F=World 8 Airship
	.word MapObj_DrawAndEnter	; 10=Canoe

MapObj_DrawAndEnter:
	LDA #$00	 ; A = 0 (no offset on map sprite)

	LDY Map_Objects_IDs,X
	CPY #MAPOBJ_CANOE
	BNE PRG011_B5C9	 ; If this not a Canoe, jump to PRG011_B5C9

	LDA #$07	 ; Otherwise, A = 7 (Canoe offset 7)

PRG011_B5C9:
	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Set Y for map object sprite
	ADD Map_Object_ActY,X
	STA Sprite_RAM+$98,Y
	STA Sprite_RAM+$9C,Y

	; Set X for map object sprite
	LDA Map_Object_ActX,X
	SUB <Horz_Scroll
	STA Sprite_RAM+$9B,Y

	; Right half
	ADD #$08
	STA Sprite_RAM+$9F,Y

	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	; Map object ID -> Temp_Var8
	LDA Map_Objects_IDs,X
	STA <Temp_Var8

	LDX #%00001000	 ; X = 8 (masking value against Counter_1 for animation)

	CMP #MAPOBJ_CANOE
	BGE PRG011_B60A	 ; If this is a canoe (or greater??), jump to PRG011_B60A
 
	CMP #MAPOBJ_HELP
	BNE PRG011_B5FA	 ; If this NOT the HELP bubble, jump to PRG011_B5FA

	LDX #%00110000	 ; X = $30 (masking value against Counter_1 for animation)
	JMP PRG011_B60A	 ; Jump to PRG011_B60A

PRG011_B5FA:
	; HELP bubble only

	LDA Map_Operation
	CMP #$0b
	BNE PRG011_B60A	 ; If Map_Operation <> $0B (hammer brothers aren't marching around), jump to PRG011_B60A

	; Hammer brothers are marching around the map...

	LDY <Temp_Var13		 ; Y = Temp_Var13 (the map object slot index)

	; NOTE: This is improper, the Map_March_Count should be indexed by ID, not by slot index
	LDA Map_March_Count,Y
	BEQ PRG011_B60A	 ; 

	LDX #%00000100	 ; X = 4 (masking value against Counter_1 for animation)

PRG011_B60A:
	STX <Temp_Var9	 ; -> Temp_Var9 (masking value for animation)

	LDA <Temp_Var8	 ; A = map object ID
	ASL A		 ; Multiply by 2
	ADD <Temp_Var8	 ; Total multiply is 3
	TAX		 ; X = ID * 3

	; Heh, they had to compare AFTER making it a multiple of 3... :P

	CPX #(MAPOBJ_HAMMERBRO * 3)
	BLT PRG011_B628	 ; If ID < MAPOBJ_HAMMERBRO (None, HELP, Airship), jump to PRG011_B628

	; So not nothing, a "HELP" bubble, or the airship...

	CPX #(MAPOBJ_CANOE * 3)
	BEQ PRG011_B628	 ; If ID = MAPOBJ_CANOE, jump to PRG011_B628

	; Not a canoe...

	CPX #(MAPOBJ_BATTLESHIP * 3)
	BLT PRG011_B623	 ; If ID < MAPOBJ_BATTLESHIP (Not a World 8 Tank / Battleship / Airship), jump to PRG011_B623

	; Canoe was technically already eliminated, but it checks again anyway
	; In any case, one of the World 8 battle implements

	CPX #(MAPOBJ_CANOE * 3)
	BLT PRG011_B628	 ; Otherwise, jump to PRG011_B628

PRG011_B623:

	; Map object $03 - $0C

	LDA Map_MusicBox_Cnt
	BNE PRG011_B630	 ; If a music box is active, jump to PRG011_B630

PRG011_B628:
	INX	; Use first column pattern

	LDA <Counter_1
	AND <Temp_Var9
	BEQ PRG011_B630	 ; Animation time dependent on Temp_Var9; periodically jump to PRG011_B630

	INX	; Use second column pattern

PRG011_B630:
	LDY <Temp_Var6		 ; Y = Temp_Var6 (Sprite_RAM offset)

	; Load the patterns of the map object
	LDA MapObject_Pat1-3,X
	STA Sprite_RAM+$99,Y	
	LDA MapObject_Pat2-3,X	
	STA Sprite_RAM+$9D,Y	

	; Load the attributes of the map object
	LDA MapObject_Attr1-3,X	
	STA Sprite_RAM+$9A,Y	
	LDA MapObject_Attr2-3,X	
	STA Sprite_RAM+$9E,Y	

	LDX <Temp_Var13		 ; X = Temp_Var13 (the map object slot index)

	LDA Map_Objects_IDs,X

	CMP #MAPOBJ_HELP
	BEQ PRG011_B657	 ; If this is the HELP bubble, jump to PRG011_B657 (RTS)

	CMP #MAPOBJ_CANOE
	BLT PRG011_B658	 ; If this is not the canoe, jump to PRG011_B658

PRG011_B657:
	RTS		 ; Return

PRG011_B658:

	; Not the HELP bubble or canoe...

	CMP #$07
	BEQ PRG011_B68B	 ; If this is the World 7 Plant, jump to PRG011_B68B

	CMP #$09
	BLT PRG011_B664	 ; Basically if one of the marchers (map object ID $02-$06/$08), jump to PRG011_B664

	CMP #$0d
	BLT PRG011_B68B	 ; If NOT one of the World 8 implements, jump to PRG011_B68B

PRG011_B664:

	; "Marching" objects come here (map object ID $02-$06/$08)
	; Horizontal flip for "marching" type objects when their Data is non-zero

	LDA Map_Object_Data,X
	BNE PRG011_B68B		; If data <> 0, jump to PRG011_B68B

	LDA Sprite_RAM+$9D,Y
	CMP Sprite_RAM+$99,Y
	BEQ PRG011_B68B	 ; If the sprite patterns are the same, jump to PRG011_B68B

	; Swaps the pattern and attributes and marks horizontal flip (i.e. mirrors the map object sprite)
	LDX Sprite_RAM+$99,Y
	STA Sprite_RAM+$99,Y
	TXA
	STA Sprite_RAM+$9D,Y
	LDA Sprite_RAM+$9A,Y
	EOR #$40
	STA Sprite_RAM+$9A,Y
	LDA Sprite_RAM+$9E,Y
	EOR #$40
	STA Sprite_RAM+$9E,Y

PRG011_B68B:
	LDY <Temp_Var13		 ; Y = Temp_Var13 (the map object slot index)

	; HELP bubble was already eliminated

	; Map Object ID $03-$08  all jump to PRG011_B69C
	; Otherwise, jump to PRG011_B6A1
	LDA Map_Objects_IDs,Y
	CMP #MAPOBJ_AIRSHIP
	BEQ PRG011_B6A1
	CMP #MAPOBJ_NSPADE
	BLT PRG011_B69C
	CMP #MAPOBJ_CANOE
	BLT PRG011_B6A1

PRG011_B69C:

	; Map Object IDs $03-$08 come here (basically everything that "sleeps")

	LDA Map_MusicBox_Cnt
	BNE PRG011_B6F5	 ; If Music Box is active, jump to PRG011_B6F5 (RTS)

PRG011_B6A1:
	LDA Map_DrawPanState
	BNE PRG011_B6F5	 ; If some kind of map drawing/panning activity is occurring, jump to PRG011_B6F5 (RTS)

	LDA Map_Pan_Count
	BNE PRG011_B6F5	 ; If the map is panning, jump to PRG011_B6F5 (RTS)

	LDA Map_Operation
	CMP #$0D
	BNE PRG011_B6F5	 ; If Map_Operation <> $0D (something is going on), jump to PRG011_B6F5 (RTS)

	LDX Player_Current	 ; X = Player_Current

	; If the Player is not perfectly situated on top of the map object, jump to PRG011_B6F5 (RTS)

	LDA Map_Objects_Y,Y
	CMP <World_Map_Y,X
	BNE PRG011_B6F5

	LDA Map_Objects_XHi,Y
	CMP <World_Map_XHi,X
	BNE PRG011_B6F5

	LDA Map_Objects_XLo,Y
	CMP <World_Map_X,X
	BNE PRG011_B6F5	

	; Player is going to "enter" this map object...

	LDX Player_Current	 ; X = Player_Current (needless reload?)

	LDA #$00
	STA Map_Player_SkidBack,X
	STA World_EnterState

	; Store the object ID -> Map_EnterViaID
	LDA Map_Objects_IDs,Y
	STA <Map_EnterViaID

	; If this is a N-Spade or White Toad house, jump to PRG011_B6E2
	CMP #MAPOBJ_NSPADE
	BEQ PRG011_B6E2
	CMP #MAPOBJ_WHITETOADHOUSE
	BNE PRG011_B6E5

PRG011_B6E2:
	; N-Spade and White Toad House only...
	INC Map_NoLoseTurn	 ; Set Map_NoLoseTurn

PRG011_B6E5:
	LDA Map_Objects_Itm,Y
	STA Level_TreasureItem

	; Begin level entry
	LDA #$0f
	STA Map_Operation

	; Don't return to caller!
	PLA
	PLA

	JMP PRG011_B57C	; Jump to PRG011_B57C

PRG011_B6F5:
	RTS		 ; Return

	; FIXME: Anyone want to claim this?  (Exact same routine appears in PRG010 @ $D228)
; $B6F6 
	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_Dir,X	; Get Player's map direction
	EOR #$03
	CMP #$03
	BNE PRG011_B703	 	; If Player did not travel left or right, jump to PRG011_B703

	EOR #$0f	 ; Otherwise invert all direction bits??

PRG011_B703:
	STA <World_Map_Dir,X	 ; -> World_Map_Dir

	RTS		 ; Return

	; FIXME: Anyone want to claim this?
	; Gets a tile based on an input 'Y' value to pick from one of the offset sets below...
PRG011_B706:	.byte -16, -16, 0, -32
PRG011_B70A:	.byte $00, $FF, $00, $00	; 16-bit sign extensions
PRG011_B70E:	.byte 16, -16, 0, 0

; $B712
	LDX Player_Current	 ; X = Player_Current

	LDA <World_Map_Y,X
	ADD PRG011_B706,Y
	STA <Temp_Var15	

	LDA <World_Map_X,X
	ADD PRG011_B70E,Y
	STA <Temp_Var16	

	LDA <World_Map_XHi,X
	ADC PRG011_B70A,Y
	ASL A		 ; 2 byte index per map screen
	TAX		 ; -> 'X'

	; Set pointer to map screen tiles
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH
	INC <Map_Tile_AddrH	; Map is always on lower part

	; Form row/column offset
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	STA <Temp_Var16
	LDA <Temp_Var15
	AND #$f0
	ORA <Temp_Var16
	TAY	 ; -> 'Y'

	LDA [Map_Tile_AddrL],Y	; Get tile
	RTS		 ; Return


PRG011_B74A:
	LDX Map_Unused738		; X =  Map_Unused738

	LDA Map_Unused7DC6,X
	CMP #$09
	BLT MapStarsIntro_DoStarFX	; If Map_Unused7DC6[X] < 9, jump to MapStarsIntro_DoStarFX

	; Map_StarsState = 1
	LDA #$01
	STA <Map_StarsState

	LDX Player_Current	; X = Player_Current

	LDY Map_Unused7992
	INY
	TYA	; A = Map_Unused7992 + 1

	ASL A
	ASL A
	ASL A
	ASL A
	ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
	CMP <World_Map_Move,X	
	BEQ MapStarsIntro_DoStarFX	 ; If movement is same as Player's current movement, jump to MapStarsIntro_DoStarFX

	JMP WorldMap_UpdateAndDraw	 ; Draw and update map and don't come back

MapStarsIntro_DoStarFX:
	LDA Map_StarFX_State
	JSR DynJump

	.word MapStarsIntro_Init
	.word WWFX_WarpWhistleFlash	; THIS STATE IS NOT USED (accidentally/on-purpose skipped)
	.word MapStarsIntro_Do

	; Default "radius" values for each star on the world intro
MSI_DefaultRadii:	.byte $14, $10, $0C, $08, $04, $00, $1C, $18

	; Per-radius size values
MSI_RadSize:		.byte 0, 24, 48, 71, 90, 106, 118, 125, 128, 125, 118, 106, 90, 71, 48, 24


	; Patterns used by the "stars" in the intro
MapStarsIntro_Patterns:	.byte $67, $69 

MapStarsIntro_Init:
	LDA #SND_MAPENTERWORLD	
	STA Sound_QMap	; Play the starry entrance sound

	; Preload the default "radius" values for each star
	LDX #$07
PRG011_B799:
	LDA MSI_DefaultRadii,X
	STA <Map_StarsRadius,X
	DEX		 	; X--
	BPL PRG011_B799	 	; While X >= 0, loop!

	LDX <Map_StarsState
	BNE PRG011_B7AD	 	; If Map_StarsState <> 0, jump to PRG011_B7AD

	; Stars emanating from center
	LDA #$80	 
	STA <Map_StarsCenterX	; Map_StarsCenterX = $80
	STA <Map_StarsCenterY	; Map_StarsCenterY = $80
	BNE PRG011_B800	 	; Jump (technically always) to PRG011_B800

PRG011_B7AD:
	CPX #$01	 
	BNE PRG011_B7CC	 	; If Map_StarsState <> 1, jump to PRG011_B7CC

	; Stars emanating from Player start
	LDX Player_Current	; X = Player_Current

	LDA <World_Map_X,X
	ADD <Horz_Scroll
	STA <Map_StarsCenterX	; Map_StarsCenterX = Player's Map X + Horz_Scroll

	LDA <World_Map_Y,X	
	STA <Map_StarsCenterY	; Map_StarsCenterY = Player's Map Y

	LDA #$86
	STA Map_Stars_PRelX	; Map_Stars_PRelX = $86

	LDA #$d0	
	STA Map_Stars_PRelY	; Map_Stars_PRelY = $D0

	JMP PRG011_B7E6	 ; Jump to PRG011_B7E6

PRG011_B7CC:
	; Map_StarsState = 2

	LDA #$88
	STA <Map_StarsCenterX	; Map_StarsCenterX = 136

	LDA #$5c
	STA <Map_StarsCenterY	; Map_StarsCenterY = 92

	LDX Player_Current	; X = Player_Current

	LDA <World_Map_X,X
	ADD <Horz_Scroll
	STA Map_Stars_PRelX	 	; Map_Stars_PRelX = Player's map X coordinate + Horz_Scroll

	LDA <World_Map_Y,X
	STA Map_Stars_PRelY	 	; Map_Stars_PRelY = Player's map Y coordinate

	INC <Map_StarFX_State	; Next state... (NOTE: Incremented again below!)

PRG011_B7E6:

	; Calculate step and deltas
	LDX <Map_StarsCenterX
	LDA Map_Stars_PRelX
	JSR MSI_CalcDeltaAndSteps
	STA <Map_StarsXSteps
	STX Map_StarsDeltaX

	LDX <Map_StarsCenterY
	LDA Map_Stars_PRelY
	JSR MSI_CalcDeltaAndSteps
	STA <Map_StarsYSteps	
	STX Map_StarsDeltaY

PRG011_B800:
	LDA #$00
	STA <Map_StarsFrame	; Map_StarsFrame = 0
	STA <Map_StarsLandRad	; Map_StarsLandRad = 0
	STA <Map_StarsOutRad	; Map_StarsOutRad = 0

	LDA #$67
	STA <Map_StarsPattern

	LDA #$09
	STA <Map_StarsConst9	; Map_StarsConst9 = 9 (forever?)

	INC Map_StarFX_State	; Next state... (technically, +2 before it gets back)

	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B81C	 	; If Map_StarsState = 2, jump to PRG011_B81C (RTS)

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B81C:
	RTS		 	; Return


	; FIXME: Anyone want to claim this?
; $B81D
	JMP PRG011_B8B1	; Jump to PRG011_B8B1

MapStarsIntro_Do:
	LDA <Map_StarsLandRad
	BNE PRG011_B834	 		; If Map_StarsLandRad <> 0 (we're doing the "landing" now), jump to PRG011_B834

	LDA <Map_StarsOutRad
	ADD #$04	 
	CMP #$5f	 
	BGE PRG011_B830	 	; If Map_StarsOutRad + 4 >= $5F, jump to PRG011_B830 (change direction)

	; Otherwise, jump to PRG011_B8AF
	JMP PRG011_B8AF	

PRG011_B830:
	LDA #$01	 
	STA <Map_StarsLandRad		; Map_StarsLandRad = 1

PRG011_B834:
	; Stars landing

	LDA <Map_StarsState
	BEQ PRG011_B874	 		; If Map_StarsState = 0, jump to PRG011_B874

	LDA <Map_StarsCenterX
	CMP Map_Stars_PRelX
	BGE PRG011_B84B	 		; If Map_StarsCenterX >= Map_Stars_PRelX (Player's landing is to the left), jump to PRG011_B84B

	; Player's landing is to the right...
	ADC Map_StarsDeltaX		; Map_StarsCenterX += Map_StarsDeltaX
	TAX		 		; X = A
	DEC <Map_StarsXSteps		; Map_StarsXSteps--
	BMI PRG011_B854			; If Map_StarsXSteps < 0, jump to PRG011_B854
	INX		 		; X++
	JMP PRG011_B854	 		; Jump to PRG011_B854

PRG011_B84B:
	SBC Map_StarsDeltaX	 	; Map_StarsCenterX -= Map_StarsDeltaX
	TAX		 		; X = A
	DEC <Map_StarsXSteps		; Map_StarsXSteps--
	BMI PRG011_B854	 		; If Map_StarsXSteps < 0, jump to PRG011_B854
	DEX				; X--

PRG011_B854:
	STX <Map_StarsCenterX		; Update Map_StarsCenterX

 
	LDA <Map_StarsCenterY
	CMP Map_Stars_PRelY
	BGE PRG011_B869	 		; If Map_StarsCenterY >= Map_Stars_PRelY (Player's landing is above), jump to PRG011_B869

	; Player's landing is below...
	ADC Map_StarsDeltaY		; Map_StarsCenterY += Map_StarsDeltaY
	TAX		 		; X = A
	DEC <Map_StarsYSteps		; Map_StarsYSteps--
	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
	INX		 		; X++
	JMP PRG011_B872	 		; Jump to PRG011_B872

PRG011_B869:
	SBC Map_StarsDeltaY	 	; Map_StarsCenterY -= Map_StarsDeltaY
	TAX		 		; X = A
	DEC <Map_StarsYSteps		; Map_StarsYSteps--
	BMI PRG011_B872	 		; If Map_StarsYSteps < 0, jump to PRG011_B872
	DEX		 		; X--

PRG011_B872:
	STX <Map_StarsCenterY		; Update Map_StarsCenterY

PRG011_B874:
	LDA <Map_StarsOutRad
	SUB #$04	 
	BNE PRG011_B8AF	 		; If Map_StarsOutRad - 4 <> 0, jump to PRG011_B8AF

	LDA #$00	 
	STA Map_StarFX_State	 	; Map_StarFX_State = 0
	STA <Map_StarsLandRad		; Map_StarsLandRad = 0

	LDA <Map_StarsState
	CMP #$02	 
	BEQ PRG011_B8A5			; If Map_StarsState = 2, jump to PRG011_B8A5


	; FIXME: CHECKME: Might be some dead code here
	LDX Map_Unused738	 ; X = Map_Unused738

	LDA Map_Unused7DC6,X
	CMP #$09
	BLT PRG011_B8A5	 ; If Map_Unused7DC6[X] FIXME < 9, jump to PRG011_B8A5

	; Map_Unused7992 -= 10 (FIXME)
	SUB #10
	STA Map_Unused7992

	LDX Player_Current	; X = Player_Current

	TAY
	INY
	TYA

	ASL A
	ASL A
	ASL A
	ASL A
	ASL A			; A = (A + 1) * 32 (the amount of a normal level move, two spaces on map)
	STA <World_Map_Move,X	; Player moves by this amount (but not during the stars display??)

PRG011_B8A5:
	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B8AE	 	; If Map_StarsState = 2, jump to PRG011_B8AE (RTS)

	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B8AE:
	RTS		 ; Return

PRG011_B8AF:
	; Stars taking off

	STA <Map_StarsOutRad	; Update Map_StarsOutRad

PRG011_B8B1:
	; This just adds 32 each display frame and toggles the Map_StarsFrame when it overflows
	LDA <Map_StarsAnimCnt
	ADD #32
	STA <Map_StarsAnimCnt	; Map_StarsAnimCnt += 32
	BCC PRG011_B8C6		; If it hasn't overflowed, jump to PRG011_B8C6

	; So Map_StarsFrame toggles every 8 frames
	LDA <Map_StarsFrame	
	EOR #$01	 
	STA <Map_StarsFrame	; Toggle Map_StarsFrame (0/1)

	TAX		 
	LDA MapStarsIntro_Patterns,X	 ; Based on Map_StarsFrame, get the pattern number
	STA <Map_StarsPattern		 ; Store into Map_StarsPattern

PRG011_B8C6:
	LDY #$00	 ; Y = 0

	LDX #$07	 ; X = 7

	; This just adds $70 each display frame and toggles the Map_StarsFrame when it overflows
	LDA <Map_StarsRadCnt
	ADD #$70
	STA <Map_StarsRadCnt	; Map_StarsRadCnt += $70
	BCC PRG011_B8D5	 	; If it hasn't overflowed, jump to PRG011_B8D5

	; So roughly every 2.29 display frames...
	LDY #$01	 	; Y = 1 (+1 to the rotation)

PRG011_B8D5:
	STY <Map_StarsDeltaR	; Map_StarsDeltaR = Y (0 or 1)

PRG011_B8D7:

	; Add to each star's radius 0 or 1, capping the value at 0-31
	LDA <Map_StarsRadius,X	
	ADD <Map_StarsDeltaR	
	AND #$1f	 
	STA <Map_StarsRadius,X	; Map_StarsRadius[X] = (Map_StarsRadius[X] + 1) & $1f

	JSR MSI_CalcStarsXY	; Calculate this star's X and Y (and Temp_Var10 contains the X for the second sprite)
	JSR MSI_DrawStar	; Draw this star!
	DEX		 	; X--
	BPL PRG011_B8D7	 	; If X >= 0, loop!

	LDX <Map_StarsState
	CPX #$02	 
	BEQ PRG011_B8F2		; If Map_StarsState = 2, jump to PRG011_B8F2
	JMP WorldMap_UpdateAndDraw	 ; Jump to WorldMap_UpdateAndDraw

PRG011_B8F2:
	RTS		 ; Return

; MSI_CalcStarsXY
;
; Calculates the current X and Y position of each star
MSI_CalcStarsXY:
	LDA <Map_StarsRadius,X
	AND #$0f		; Only using values 0-15 of the "radius"	 
	TAY
	LDA MSI_RadSize,Y
	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
	LDY <Map_StarsConst9	; Y = Map_StarsConst9
	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

	LDA <Map_StarsRadius,X	
	AND #$18	 
	CMP #16
	BLT PRG011_B917	 	; If (Map_StarsRadius[X] & $18) < 16, jump to PRG011_B917

	; Otherwise...
	LDA #-1
	STA <Temp_Var1		; Temp_Var1 = -1

	LDA <Map_StarsCenterX
	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
	JMP PRG011_B91F	 	; Jump to PRG011_B91F

PRG011_B917:
	LDA #$01
	STA <Temp_Var1		; Temp_Var1 = 1

	LDA <Map_StarsCenterX
	ADC <Temp_Var3		; A = Map_StarsCenterX + Temp_Var3

PRG011_B91F:
	STA <Map_StarsX,X	; Set this as the star's X position
	STA <Temp_Var7		; Temp_Var7 = star's X position

	LDA <Map_StarsCenterX
	STA <Temp_Var8		; Temp_Var8 = all stars center X

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

	LDA <Map_StarsX,X
	ADD #8
	STA <Temp_Var10		; Temp_Var10 = star's X + 8 (will be second sprite's offset)
	STA <Temp_Var7		; Temp_Var7 = Temp_Var10

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6		
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980

	LDA <Map_StarsRadius,X	
	ADD #$08	 
	AND #$0f	 
	TAY		 	; Y = (radius value + 8) & $F
	LDA MSI_RadSize,Y
	STA <Temp_Var1		; Temp_Var1 = MSI_RadSize[Y] (size for this radius)

	LDA <Map_StarsOutRad	; A = Map_StarsOutRad
	LDY <Map_StarsConst9	; Y = Map_StarsConst9
	JSR MSI_CalcXOffset	; Generates Temp_Var3 X offset value

	LDA <Map_StarsRadius,X
	SUB #$08	
	AND #$18
	CMP #16
	BLT PRG011_B968	 	; If ((Map_StarsRadius[X] - 8) & $18) < 16, jump to PRG011_B968

	LDA #-1
	STA <Temp_Var1		; Temp_Var1 = -1

	LDA <Map_StarsCenterY
	SBC <Temp_Var3		; A = Map_StarsCenterX - Temp_Var3 (calculated value from MSI_CalcXOffset)
	JMP PRG011_B970	 	; Jump to PRG011_B970

PRG011_B968:
	LDA #1
	STA <Temp_Var1		; Temp_Var1 = 1

	LDA <Map_StarsCenterY
	ADC <Temp_Var3		

PRG011_B970:
	STA <Map_StarsY,X	; star's Y = Map_StarsCenterY + Temp_Var3
	STA <Temp_Var7		; Temp_Var7 = star's Y

	LDA <Map_StarsCenterY	
	STA <Temp_Var8		; Temp_Var8 = all stars center Y

	JSR PRG011_SUB_B9D4	; Returns 1 or -1 in Temp_Var6

	LDA <Temp_Var6	
	BMI PRG011_B980	 	; If Temp_Var6 < 0, jump to PRG011_B980
	RTS		 	; Return

PRG011_B980:
	LDA #$f8
	STA <Map_StarsY,X	; star's Y = $F8 (hides sprite)
	LDA #$00	 
	STA <Map_StarsX,X	; star's X = 0 (we're hiding the sprite)

	STA <Temp_Var10		; Temp_Var10 = star's X (0) (will be second sprite's offset)
	RTS		 	; Return

MSI_CalcXOffset:
	; A = Map_StarsOutRad
	; Y = Map_StarsConst9 (9)

	; MAPOBJ_HAMMERBROFIXME: I don't really understand the algorithm (I think it's some kind of
	; division or fractional multiplication routine?), produces X offset in Temp_Var3

	STA <Temp_Var2	; Temp_Var2 = Map_StarsOutRad

	LDA #$00	
	STA <Temp_Var3	; Temp_Var3 = 0
	STA <Temp_Var4	; Temp_Var4 = 0

PRG011_B993:
	ASL <Temp_Var4
	ROL <Temp_Var3
	ASL <Temp_Var1
	BCC PRG011_B9A6

	LDA <Temp_Var4
	ADD <Temp_Var2
	STA <Temp_Var4

	BCC PRG011_B9A6

	INC <Temp_Var3

PRG011_B9A6:
	DEY		 ; Y--
	BNE PRG011_B993	 ; While Y >= 0, loop

	RTS		 ; Return

; MSI_DrawStar
;
; Generates the hardware sprites for a star
MSI_DrawStar:
	TXA
	ASL A
	ASL A
	ASL A
	TAY		; Y = X << 3

	; Store the Y part of this star's sprites
	LDA <Map_StarsY,X	 
	STA Sprite_RAM+$98,Y	 
	STA Sprite_RAM+$9C,Y	 

	; Store the patterns for this star's sprites
	LDA <Map_StarsPattern	
	STA Sprite_RAM+$99,Y	
	STA Sprite_RAM+$9D,Y	

	; First sprite is palette 3
	LDA #$03	 
	STA Sprite_RAM+$9A,Y

	; Second sprite is same but also HV flipped
	LDA #$c3
	STA Sprite_RAM+$9E,Y

	; Store X coordinate for first sprite
	LDA <Map_StarsX,X
	STA Sprite_RAM+$9B,Y

	; Store X coordinate for second sprite
	LDA <Temp_Var10
	STA Sprite_RAM+$9F,Y

	RTS		 ; Return

PRG011_SUB_B9D4:
	; Temp_Var1 = 1 or -1
	; Temp_Var7 = star's X position
	; Temp_Var8 = all stars center X

	LDA <Temp_Var7
	EOR <Temp_Var8
	AND #$80	 
	BEQ PRG011_B9EA	 	; If Temp_Var7 and Temp_Var8 are oppositely signed, jump to PRG011_B9EA

	LDA <Temp_Var1
	BPL PRG011_B9E6	 	; If Temp_Var1 >= 0, jump to PRG011_B9E6

	LDA <Temp_Var7
	BMI PRG011_B9EF	 	; If Temp_Var7 < 0, jump to PRG011_B9EF
	BPL PRG011_B9EA	 	; Otherwise, jump to PRG011_B9EA

PRG011_B9E6:
	LDA <Temp_Var7
	BPL PRG011_B9EF	 	; If Temp_Var7 >= 0, jump to PRG011_B9EF

PRG011_B9EA:
	LDA #1
	STA <Temp_Var6		; Temp_Var6 = 1
	RTS		 	; Return...

PRG011_B9EF:
	LDA #-1
	STA <Temp_Var6		; Temp_Var6 = -1
	RTS		 	; Return...

MSI_CalcDeltaAndSteps:

	; X = Map_StarsCenterX
	; A = Map_Stars_PRelX

	STX <Temp_Var4	; Temp_Var4 = Map_StarsCenterX
	STA <Temp_Var5	; Temp_Var5 = Map_Stars_PRelX
 
	SUB <Temp_Var4	
	STA <Temp_Var1	; Temp_Var1 = Temp_Var5 (Map_Stars_PRelX) - Temp_Var4 (Map_StarsCenterX)

	LDA <Temp_Var5	
	CMP <Temp_Var4	
	BGE PRG011_BA0B	; If Temp_Var5 >= Temp_Var4, jump to PRG011_BA0B

	; Otherwise, Temp_Var1 is negative; negate it!
	LDA <Temp_Var1
	EOR #$ff	
	ADC #$01	
	STA <Temp_Var1	

	; FIXME: I don't really understand the algorithm (I think it's some kind of
	; division routine?), but it finds the delta X/Y values for the star intro
	; and the number of steps to complete the move
PRG011_BA0B:
	LDA #$00
	STA <Temp_Var3	; Temp_Var3 = 0

	LDY #$07	; Y = 7
PRG011_BA11:
	ASL <Temp_Var3
	ROL <Temp_Var1
	ROL A		
	BCS PRG011_BA1C	

	CMP #$17
	BLT PRG011_BA20	

PRG011_BA1C:
	SBC #$17	
	INC <Temp_Var3	; Temp_Var3++

PRG011_BA20:
	DEY		 ; Y--
	BPL PRG011_BA11	 ; While Y >= 0, loop!

	LDX <Temp_Var3	 ; X = Temp_Var3
	RTS		 ; Return

Map_CompleteY:
	.byte $20, $30, $40, $50, $60, $70, $80
Map_CompleteY_End

Map_CompleteBit:
	.byte $80, $40, $20, $10, $08, $04, $02, $01

Map_MarkLevelComplete:
	LDX Player_Current 	 ; X = Player_Current

	LDA Map_Player_SkidBack,X
	BNE PRG011_BA89	 ; If Player skid back, we didn't complete this level, so jump to PRG011_BA89 (RTS)

	LDY #(Map_CompleteY_End - Map_CompleteY - 1)
	LDA <World_Map_Y,X	 ; Get Player's Map Y
PRG011_BA41:
	CMP Map_CompleteY,Y
	BEQ PRG011_BA4B	 ; If this is the Y coordinate of the level that the Player completed, jump to PRG011_BA4B

	DEY		 ; Y--
	BPL PRG011_BA41	 ; While Y >= 0, loop!

	; If it was none of those, assume the bottom
	LDY #$07	 ; Y = $07

PRG011_BA4B:
	STY <Temp_Var13	 ; completion vertical index -> Temp_Var13

	; Form a column location out of Map X/Hi position
	LDA <World_Map_XHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var1		; Map screen * 16
	LDA <World_Map_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var1		; Specific column on map screen (0-15)
	TAY		 ; -> 'Y'

	CPX #$00
	BEQ PRG011_BA67	 ; If Player is Mario, jump to PRG011_BA67

	; Offset to Luigi's Map_Completions
	TYA
	ADD #$40
	TAY

PRG011_BA67:
	LDX <Temp_Var13		 ; X = Temp_Var13 (completion vertical index)

	; Mark this completion!
	LDA Map_Completions,Y
	ORA Map_CompleteBit,X
	STA Map_Completions,Y

	LDA <World_Map_Tile
	CMP #TILE_FORTRUBBLE
	BEQ PRG011_BA7C		; If a Fortress was just completed, jump to PRG011_BA7C

	CMP #TILE_ALTRUBBLE
	BNE PRG011_BA89		; If not a Fortress, jump to PRG011_BA89

PRG011_BA7C:

	; Fortress only... mark complete on both Players (so it remains after Game Over)

	; If we did Mario, now do Luigi, or vice versa...
	TYA
	EOR #$40
	TAY

	LDA Map_Completions,Y
	ORA Map_CompleteBit,X
	STA Map_Completions,Y

PRG011_BA89:
	RTS		 ; Return

Map_Object_CheckVisibility:
	; For a given object, check if it's visible on the map.  This value is
	; stored into the Map_Objects_Vis array
	; X is the index to the map object we need to work with!
	LDY #$00	 	; Object is not visible until proven visible...

	LDA Map_Objects_XHi,X
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var2		; Temp_Var2 = object's X Hi byte << 4

	LDA Map_Objects_XLo,X
	LSR A		 
	LSR A		 
	LSR A		 
	LSR A		 
	ORA <Temp_Var2		
	STA <Temp_Var2		; OR'ing the low X >> 4; Temp_Var2 now contains a proper "column" position

	LDA <Scroll_ColumnR
	SUB #$02	 	; A = Scroll_ColumnR - 2
	CMP <Temp_Var2
	BLT PRG011_BAB1	 	; If object is less than the right scroll column, jump to PRG011_BAB1

	LDA <Scroll_ColumnL	; A = Scroll_ColumnL
	CMP <Temp_Var2	
	BGE PRG011_BAB1	 	; If object is greater-equal to the left scroll column, jump to PRG011_BAB1

	LDY #$01	 	; Object is visible!
PRG011_BAB1:
	TYA		 	; A = Y
	STA Map_Objects_Vis,X 	; Mark this object as visible or not
	RTS		 	; Return

Map_Object_Canoe:
	LDY Player_Current	; Y = Player_Current
	LDA Map_InCanoe_Flag
	BEQ PRG011_BAD9	 	; If Map_InCanoe_Flag = 0, jump to PRG011_BAD9

	; Otherwise, the Canoe is updated to match the Player's
	; position; this seems to only allow one canoe per map!
	; Though it could probably be fixed somehow...
	LDA World_Map_Y,Y 
	STA Map_Objects_Y,X
	STA Map_Object_ActY,X
	LDA World_Map_X,Y	
	STA Map_Objects_XLo,X	
	STA Map_Object_ActX,X	
	LDA World_Map_XHi,Y	
	STA Map_Objects_XHi,X	
	STA Map_Object_ActXH,X	

PRG011_BAD9:

	; Basically if Player is standing in Canoe, it activates the Map_InCanoe_Flag flag
	LDA World_Map_Move,Y
	ORA Map_Player_SkidBack,Y
	BNE PRG011_BAFE	 

	LDA World_Map_Y,Y
	CMP Map_Object_ActY,X
	BNE PRG011_BAFE

	LDA World_Map_XHi,Y
	CMP Map_Object_ActXH,X
	BNE PRG011_BAFE	 

	LDA World_Map_X,Y
	CMP Map_Object_ActX,X
	BNE PRG011_BAFE	 

	; Map_InCanoe_Flag = 1 (In canoe!)
	LDA #$01
	STA Map_InCanoe_Flag

PRG011_BAFE:
	RTS		 ; Return

W8D_CircSprs:
	.byte $F8, $81, $01, $F0
	.byte $F0, $83, $01, $F8
	.byte $E8, $85, $01, $00
	.byte $E8, $85, $41, $08
	.byte $F0, $83, $41, $10
	.byte $F8, $81, $41, $18
	.byte $08, $81, $81, $F0
	.byte $10, $83, $81, $F8
	.byte $18, $85, $81, $00
	.byte $18, $85, $C1, $08
	.byte $10, $83, $C1, $10
	.byte $08, $81, $C1, $18
	.byte $E8, $0B, $01, $F0
	.byte $E8, $0B, $01, $18
	.byte $18, $0B, $01, $F0
	.byte $18, $0B, $01, $18
	.byte $F0, $0B, $01, $E8
	.byte $00, $0B, $01, $E8
	.byte $10, $0B, $01, $E8
	.byte $F0, $0B, $01, $20
	.byte $00, $0B, $01, $20
W8D_CircSprs_Unaligned

	.byte $10, $0B, $01, $20
	.byte $E0, $87, $01, $F8
	.byte $E0, $87, $01, $10
	.byte $20, $87, $81, $F8
W8D_CircSprs_Aligned

PRG011_BB63:
	.byte $20, $87, $81

PRG011_BB66:
	.byte $10, $E0, $E8, $D8, $F0, $D0, $F8

FX_World_8_Darkness:
	LDY World_8_Dark	; Y = World_8_Dark
	BEQ PRG011_BB7A	 	; If not in the World 8 darkness, jump to PRG011_BB7A (RTS)
	LDX Player_Current	; X = Player_Current
	LDA Map_Player_SkidBack,X
	BEQ PRG011_BB7B	 	; If Player's Map_Player_SkidBack = 0, jump to PRG011_BB7B

PRG011_BB7A:
	RTS		 	; Otherwise, return...

PRG011_BB7B:
	CPY #$07	 
	BGE PRG011_BB9A	 	; If World_8_Dark >= 7 (effect complete), jump to PRG011_BB9A

	LDA #$00	
	STA Map_W8D_Idx	 	; Map_W8D_Idx = 0

	LDA <World_Map_X,X	; Player's X coordinate -> A
	ADD PRG011_BB66,Y	; Add an offset based on World_8_Dark

	LDY <World_Map_Y,X	; Y = Player's Y coordinate
	LDX #$01	 	; X = 1

	JSR Map_W8DarknessUpdate	; Update darkness around Player

	INC World_8_Dark	; World_8_Dark++

	LDA World_8_Dark	 
	LSR A		 	
	BCC FX_World_8_Darkness	; Loops if carry not set by the "LSR A" (so only loops on 2, 4, 6)

PRG011_BB9A:
	LDX Player_Current	; X = Player_Current

	LDY #$00	 ; Y = 0

	LDA <World_Map_Move,X
	AND #$07	; Cap 0-7
	CMP #$06
	BEQ PRG011_BBAC	 ; On "6" of every "0-7" jump to PRG011_BBAC

	CMP #$02
	BNE PRG011_BBBB	 ; If not "2" of every "0-7" jump to PRG011_BBBB

	INY		 ; Otherwise, Y++

PRG011_BBAC:
	STY Map_W8D_Idx	 ; -> Map_W8D_Idx

	LDA <World_Map_X,X
	PHA		 ; Save Player's map X

	LDY <World_Map_Y,X	 ; Y = Player's map Y

	LDA <World_Map_Dir,X
	TAX		 ; X = Player's map direction of travel

	PLA		 ; A = Player's map X

	; Update darkness around Player
	JSR Map_W8DarknessUpdate

PRG011_BBBB:
	LDY #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	LDX Player_Current	 ; X = Player_Current

	; Temp_Var1/2 = Player's Map Y/X
	LDA <World_Map_Y,X
	STA <Temp_Var1
	LDA <World_Map_X,X
	STA <Temp_Var2

	LDX #(W8D_CircSprs_Unaligned - W8D_CircSprs)

	AND #$0f	 ; Get lower 4 bits of X
	BNE PRG011_BBD0	 ; If Player is not perfectly aligned in column, jump to PRG011_BBD0

	LDX #(W8D_CircSprs_Aligned - W8D_CircSprs)

PRG011_BBD0:

	; Set circle sprite Y
	LDA <Temp_Var1
	ADD W8D_CircSprs,X
	STA Sprite_RAM+$08,Y

	; Set circle sprite pattern
	LDA W8D_CircSprs+1,X
	STA Sprite_RAM+$09,Y

	; Set circle sprite attribute
	LDA W8D_CircSprs+2,X
	STA Sprite_RAM+$0A,Y

	; Set circle sprite X
	LDA <Temp_Var2
	ADD W8D_CircSprs+3,X
	STA Sprite_RAM+$0B,Y

	DEY
	DEY
	DEY
	DEY	; Y -= 4 (previous sprite)

	DEX
	DEX
	DEX
	DEX	; X -= 4 (previous circle sprite def)

	BMI PRG011_BC00	 ; If out of sprites, jump to PRG011_BC00

	CPX #(W8D_CircSprs_Unaligned - W8D_CircSprs)
	BNE PRG011_BBD0	 ; If not at end of aligned circle sprites, loop

	LDX #$3c
	BNE PRG011_BBD0	 ; If X <> $3C (?), loop

PRG011_BC00:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Map_DoAnimations
;
; This subroutine takes care of the simplistic animations
; that occur on the world maps.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Map_AnimSpeeds:
	; These define the ticks to wait for each frame of the
	; map animation per world.  Interestingly, this allows
	; for different pauses on each frame, but it appears 
	; that this functionality was left unused,
	.byte $11, $11, $11, $11	; World 1
	.byte $1F, $1F, $1F, $1F	; World 2
	.byte $17, $17, $17, $17	; World 3
	.byte $17, $17, $17, $17	; World 4
	.byte $00, $00, $00, $00	; World 5
	.byte $0B, $0B, $0B, $0B	; World 6
	.byte $1D, $1D, $1D, $1D	; World 7
	.byte $0F, $0F, $0F, $0F	; World 8
	.byte $14, $14, $14, $14	; World 9 (Warp Zone)

Map_AnimCHRROM:
	; This sets the CHRROM page in use per animation frame (common to all worlds)
	.byte $14, $70, $72, $74

Map_DoAnimations:	; $BC29
	LDX World_Num	; X = World_Num
	CPX #4	 	
	BNE PRG011_BC34	; If not on World 5, jump to PRG011_BC34

	; World 5...
	LDY #$00		; Otherwise, Y = 0
	BPL Map_NoAnimUpdate	; (technically always) jump to Map_NoAnimUpdate (World 5 does not animate)

PRG011_BC34:
	; Any world but 5 goes here...
	CPX #7		
	BNE PRG011_BC46	 	; If World is NOT 8, jump to PRG011_BC46

	; World 8
	LDY Player_Current	; Y = Player_Current
	LDA World_Map_XHi,Y	; Get player's hi byte coordinate (what "level" of world 8 we're on...)
	CMP #$03
	BNE PRG011_BC46		; If NOT on the final screen of World 8 (Bowser's castle), jump to PRG011_BC46

	; World 8 Final screen
	LDY #$00	 	; Otherwise, Y = 0
	BEQ Map_NoAnimUpdate	; (technically always) jump to Map_NoAnimUpdate (final screen doesn't animate)

PRG011_BC46:
	LDY World_Map_AnimF	; Get current world map animation frame
	DEC World_Map_AnimT	; World_Map_AnimT--
	BPL Map_NoAnimUpdate 	; If ticks remain, jump to Map_NoAnimUpdate

	INY		 ; Y++ (next frame)
	TYA		 ; A = frame
	CPX #2
	BNE PRG011_BC5D	 ; If world is NOT 3, jump to PRG011_BC5D

	; World 3 limits animation to one of two frames, since part
	; of that animation includes the draw bridges.
	AND #$01	 	; Only allowing one frame through (0 and 1)
	LDY World3_Bridge	; Get the bridge state
	BEQ PRG011_BC5D	 	; If World3_Bridge = 0 (bridges are down), jump to PRG011_BC5D
	ORA #$02	 	; Otherwise, jump the animation higher (between 0 and 3)

PRG011_BC5D:
	AND #$03	 	; Cap animation to 0-3
	STA World_Map_AnimF	; Store the updated frame

	; Reset the animation clock
	TAY
	TXA
	ASL A
	ASL A
	ORA World_Map_AnimF
	TAX		 
	LDA Map_AnimSpeeds,X	 ; X = World_Num * 4 + World_Map_AnimF (get tick for frame 0-3 in this world)
	STA World_Map_AnimT	 ; Store this new tick

Map_NoAnimUpdate:
	LDA Map_AnimCHRROM,Y	; Get the correct CHRROM page
	STA PatTable_BankSel	  	; Put it to use
	RTS		  ; Return!

; Rest of ROM bank was empty

