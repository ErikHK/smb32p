; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-12-14 17:45:42.706614297 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup02 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $02 (i.e. objects starting at ID $48) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup02_InitJumpTable:
	.word ObjInit_TinyCheepCheep	; Object $48 - OBJ_TINYCHEEPCHEEP
	.word ObjInit_FloatingBGCloud	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjInit_BoomBoomQBall	; Object $4A - OBJ_BOOMBOOMQBALL
	.word ObjInit_BoomBoom		; Object $4B - OBJ_BOOMBOOMJUMP
	.word ObjInit_BoomBoom		; Object $4C - OBJ_BOOMBOOMFLY
	.word ObjInit_DoNothing		; Object $4D
	.word ObjInit_DoNothing		; Object $4E
	.word ObjInit_DoNothing		; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjInit_BobOmbExplode	; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjInit_RotoDiscDualCCW	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjInit_TreasureBox	; Object $52 - OBJ_TREASUREBOX
	.word ObjInit_PodobooCeiling	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjInit_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjInit_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjInit_PiranhaSidewaysL	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjInit_PiranhaSidewaysR	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjInit_FireChomp		; Object $58 - OBJ_FIRECHOMP
	.word ObjInit_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjInit_RotoDiscDualCW	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjInit_RotoDiscDualCCW	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjInit_DoNothing		; Object $5C - OBJ_ICEBLOCK
	.word ObjInit_Tornado		; Object $5D - OBJ_TORNADO
	.word ObjInit_RotoDiscDualCW	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjInit_RotoDiscDualCW	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjInit_RotoDiscDualCW	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjInit_BlooperWithKids	; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjInit_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjInit_BigBerthaBirther	; Object $63 - OBJ_BIGBERTHABIRTHER
	.word ObjInit_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjInit_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjInit_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjInit_LavaLotus		; Object $67 - OBJ_LAVALOTUS
	.word ObjInit_Twirling		; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjInit_Twirling		; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjInit_BlooperWithKids	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.word ObjInit_PileDriver	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup02_NormalJumpTable:
	.word ObjNorm_TinyCheepCheep	; Object $48 - OBJ_TINYCHEEPCHEEP
	.word ObjNorm_FloatingBGCloud	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjNorm_BoomBoomQBall	; Object $4A - OBJ_BOOMBOOMQBALL
	.word ObjNorm_BoomBoom		; Object $4B - OBJ_BOOMBOOMJUMP
	.word ObjNorm_BoomBoom		; Object $4C - OBJ_BOOMBOOMFLY
	.word ObjNorm_DoNothing		; Object $4D
	.word ObjNorm_DoNothing		; Object $4E
	.word ObjNorm_ChainChompFree	; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjNorm_BobOmb		; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjNorm_RotoDiscDual	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjNorm_TreasureBox	; Object $52 - OBJ_TREASUREBOX
	.word ObjNorm_PodobooCeiling	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjNorm_DonutLift		; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjNorm_BobOmb		; Object $55 - OBJ_BOBOMB
	.word ObjNorm_PiranhaSideways	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjNorm_PiranhaSideways	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjNorm_FireChomp		; Object $58 - OBJ_FIRECHOMP
	.word ObjNorm_FireSnake		; Object $59 - OBJ_FIRESNAKE
	.word ObjNorm_RotoDisc		; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjNorm_RotoDisc		; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjNorm_IceBlock		; Object $5C - OBJ_ICEBLOCK
	.word ObjNorm_Tornado		; Object $5D - OBJ_TORNADO
	.word ObjNorm_RotoDiscDualOpp	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjNorm_RotoDiscDualOpp2	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjNorm_RotoDiscDual	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjNorm_Blooper		; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjNorm_Blooper		; Object $62 - OBJ_BLOOPER
	.word ObjNorm_BigBerthaBirther	; Object $63 - OBJ_BIGBERTHABIRTHER
	.word ObjNorm_CheepCheepHopper	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjNorm_WaterCurrent	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjNorm_WaterCurrent	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjNorm_LavaLotus		; Object $67 - OBJ_LAVALOTUS
	.word ObjNorm_TwirlingShell	; Object $68 - OBJ_TWIRLINGBUZZY
	.word ObjNorm_TwirlingShell	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjNorm_Blooper		; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.word ObjNorm_PileDriver	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup02_CollideJumpTable:
	.word ObjHit_DoNothing	; Object $48 - OBJ_TINYCHEEPCHEEP
	.word ObjHit_DoNothing	; Object $49 - OBJ_FLOATINGBGCLOUD
	.word ObjHit_DoNothing	; Object $4A - OBJ_BOOMBOOMQBALL
	.word ObjHit_DoNothing	; Object $4B - OBJ_BOOMBOOMJUMP
	.word ObjHit_DoNothing	; Object $4C - OBJ_BOOMBOOMFLY
	.word ObjHit_DoNothing	; Object $4D
	.word ObjHit_DoNothing	; Object $4E
	.word ObjHit_DoNothing	; Object $4F - OBJ_CHAINCHOMPFREE
	.word ObjHit_DoNothing	; Object $50 - OBJ_BOBOMBEXPLODE
	.word ObjHit_DoNothing	; Object $51 - OBJ_ROTODISCDUAL
	.word ObjHit_DoNothing	; Object $52 - OBJ_TREASUREBOX
	.word ObjHit_DoNothing	; Object $53 - OBJ_PODOBOOCEILING
	.word ObjHit_DoNothing	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.word ObjHit_DoNothing	; Object $55 - OBJ_BOBOMB
	.word ObjHit_DoNothing	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.word ObjHit_DoNothing	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.word ObjHit_DoNothing	; Object $58 - OBJ_FIRECHOMP
	.word ObjHit_DoNothing	; Object $59 - OBJ_FIRESNAKE
	.word ObjHit_DoNothing	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.word ObjHit_DoNothing	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.word ObjHit_DoNothing	; Object $5C - OBJ_ICEBLOCK
	.word ObjHit_DoNothing	; Object $5D - OBJ_TORNADO
	.word ObjHit_DoNothing	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.word ObjHit_DoNothing	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.word ObjHit_DoNothing	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.word ObjHit_DoNothing	; Object $61 - OBJ_BLOOPERWITHKIDS
	.word ObjHit_DoNothing	; Object $62 - OBJ_BLOOPER
	.word ObjHit_DoNothing	; Object $63 - OBJ_BIGBERTHABIRTHER
	.word ObjHit_DoNothing	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.word ObjHit_DoNothing	; Object $65 - OBJ_WATERCURRENTUPWARD
	.word ObjHit_DoNothing	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.word ObjHit_DoNothing	; Object $67 - OBJ_LAVALOTUS
	.word OCSPECIAL_KILLCHANGETO | OBJ_BUZZYBEATLE	; Object $68 - OBJ_TWIRLINGBUZZY
	.word OCSPECIAL_KILLCHANGETO | OBJ_SPINY	; Object $69 - OBJ_TWIRLINGSPINY
	.word ObjHit_DoNothing	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.word ObjHit_DoNothing	; Object $6B - OBJ_PILEDRIVER

	
	; Object group $02 (i.e. objects starting at ID $48) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup02_Attributes:
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $48 - OBJ_TINYCHEEPCHEEP
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OA1_PAL3 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $4D
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $4E
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $52 - OBJ_TREASUREBOX
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $55 - OBJ_BOBOMB
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH24	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $58 - OBJ_FIRECHOMP
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $59 - OBJ_FIRESNAKE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $5C - OBJ_ICEBLOCK
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $5D - OBJ_TORNADO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $62 - OBJ_BLOOPER
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $63 - OBJ_BIGBERTHABIRTHER
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $67 - OBJ_LAVALOTUS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $6B - OBJ_PILEDRIVER

	; Object group $02 (i.e. objects starting at ID $48) second set attribute bits

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup02_Attributes2:
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $48 - OBJ_TINYCHEEPCHEEP
	.byte OA2_TDOGRP0	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP2	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP2	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OA2_TDOGRP0	; Object $4D
	.byte OA2_TDOGRP0	; Object $4E
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $52 - OBJ_TREASUREBOX
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA2_STOMPDONTCARE | OA2_TDOGRP1	; Object $55 - OBJ_BOBOMB
	.byte OA2_TDOGRP0	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA2_TDOGRP0	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $58 - OBJ_FIRECHOMP
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $59 - OBJ_FIRESNAKE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $5C - OBJ_ICEBLOCK
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5D - OBJ_TORNADO
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $62 - OBJ_BLOOPER
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $63 - OBJ_BIGBERTHABIRTHER
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA2_TDOGRP0	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA2_TDOGRP0	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA2_TDOGRP0	; Object $67 - OBJ_LAVALOTUS
	.byte OA2_TDOGRP1	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA2_TDOGRP1	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup02_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $48 - OBJ_TINYCHEEPCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $4D
	.byte OA3_HALT_HOTFOOTSPECIAL 	; Object $4E
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OA3_HALT_NORMALONLY 	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $51 - OBJ_ROTODISCDUAL
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $52 - OBJ_TREASUREBOX
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $53 - OBJ_PODOBOOCEILING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OA3_HALT_NORMALONLY 	; Object $55 - OBJ_BOBOMB
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OA3_HALT_NORMALONLY 	; Object $58 - OBJ_FIRECHOMP
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $59 - OBJ_FIRESNAKE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5C - OBJ_ICEBLOCK
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $5D - OBJ_TORNADO
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $62 - OBJ_BLOOPER
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $63 - OBJ_BIGBERTHABIRTHER
	.byte OA3_HALT_NORMALONLY 	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $67 - OBJ_LAVALOTUS
	.byte OA3_HALT_NORMALONLY 	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE 	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OA3_HALT_NORMALONLY 	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup02_PatTableSel:
	.byte OPTS_SETPT5 | $1A	; Object $48 - OBJ_TINYCHEEPCHEEP
	.byte OPTS_SETPT5 | $36	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte OPTS_SETPT5 | $13	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte OPTS_SETPT6 | $33	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte OPTS_SETPT6 | $33	; Object $4C - OBJ_BOOMBOOMFLY
	.byte OPTS_NOCHANGE	; Object $4D
	.byte OPTS_NOCHANGE	; Object $4E
	.byte OPTS_SETPT5 | $0A	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte OPTS_SETPT5 | $36	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte OPTS_SETPT5 | $12	; Object $51 - OBJ_ROTODISCDUAL
	.byte OPTS_SETPT5 | $05	; Object $52 - OBJ_TREASUREBOX
	.byte OPTS_SETPT5 | $12	; Object $53 - OBJ_PODOBOOCEILING
	.byte OPTS_SETPT5 | $0E	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte OPTS_SETPT5 | $0B	; Object $55 - OBJ_BOBOMB
	.byte OPTS_SETPT5 | $5A	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte OPTS_SETPT5 | $5A	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte OPTS_SETPT5 | $0E	; Object $58 - OBJ_FIRECHOMP
	.byte OPTS_SETPT5 | $0E	; Object $59 - OBJ_FIRESNAKE
	.byte OPTS_SETPT5 | $12	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte OPTS_SETPT5 | $12	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte OPTS_SETPT6 | $4F	; Object $5C - OBJ_ICEBLOCK
	.byte OPTS_NOCHANGE	; Object $5D - OBJ_TORNADO
	.byte OPTS_SETPT5 | $12	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte OPTS_SETPT5 | $12	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte OPTS_SETPT5 | $12	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte OPTS_SETPT5 | $1A	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte OPTS_SETPT5 | $1A	; Object $62 - OBJ_BLOOPER
	.byte OPTS_SETPT5 | $1A	; Object $63 - OBJ_BIGBERTHABIRTHER
	.byte OPTS_SETPT6 | $4F	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte OPTS_NOCHANGE	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte OPTS_NOCHANGE	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte OPTS_SETPT6 | $1B	; Object $67 - OBJ_LAVALOTUS
	.byte OPTS_SETPT5 | $0B	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte OPTS_SETPT5 | $0B	; Object $69 - OBJ_TWIRLINGSPINY
	.byte OPTS_SETPT5 | $1A	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte OPTS_SETPT6 | $4F	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) "Kill Action"
	; Determines what action is taken when object is in "Killed" state (6)
	; See Object_DoKillAction for the jump table
	; NOTE: Any action type other than zero always sets the frame to 2 (unless object is not general purpose, i.e. index >= 5)

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup02_KillAction:
	.byte KILLACT_JUSTDRAW16X16	; Object $48 - OBJ_TINYCHEEPCHEEP
	.byte KILLACT_STANDARD	; Object $49 - OBJ_FLOATINGBGCLOUD
	.byte KILLACT_STANDARD	; Object $4A - OBJ_BOOMBOOMQBALL
	.byte KILLACT_NORMALANDKILLED	; Object $4B - OBJ_BOOMBOOMJUMP
	.byte KILLACT_NORMALANDKILLED	; Object $4C - OBJ_BOOMBOOMFLY
	.byte KILLACT_STANDARD	; Object $4D
	.byte KILLACT_STANDARD	; Object $4E
	.byte KILLACT_NORMALANDKILLED	; Object $4F - OBJ_CHAINCHOMPFREE
	.byte KILLACT_JUSTDRAW16X16	; Object $50 - OBJ_BOBOMBEXPLODE
	.byte KILLACT_STANDARD	; Object $51 - OBJ_ROTODISCDUAL
	.byte KILLACT_STANDARD	; Object $52 - OBJ_TREASUREBOX
	.byte KILLACT_JUSTDRAWMIRROR	; Object $53 - OBJ_PODOBOOCEILING
	.byte KILLACT_STANDARD	; Object $54 - OBJ_DONUTLIFTSHAKEFALL
	.byte KILLACT_JUSTDRAW16X16	; Object $55 - OBJ_BOBOMB
	.byte KILLACT_POOFDEATH	; Object $56 - OBJ_PIRANHASIDEWAYSLEFT
	.byte KILLACT_POOFDEATH	; Object $57 - OBJ_PIRANHASIDEWAYSRIGHT
	.byte KILLACT_NORMALSTATE	; Object $58 - OBJ_FIRECHOMP
	.byte KILLACT_NORMALSTATE	; Object $59 - OBJ_FIRESNAKE
	.byte KILLACT_STANDARD	; Object $5A - OBJ_ROTODISCCLOCKWISE
	.byte KILLACT_STANDARD	; Object $5B - OBJ_ROTODISCCCLOCKWISE
	.byte KILLACT_NORMALSTATE	; Object $5C - OBJ_ICEBLOCK
	.byte KILLACT_STANDARD	; Object $5D - OBJ_TORNADO
	.byte KILLACT_STANDARD	; Object $5E - OBJ_ROTODISCDUALOPPOSE
	.byte KILLACT_STANDARD	; Object $5F - OBJ_ROTODISCDUALOPPOSE2
	.byte KILLACT_STANDARD	; Object $60 - OBJ_ROTODISCDUALCCLOCK
	.byte KILLACT_NORMALSTATE	; Object $61 - OBJ_BLOOPERWITHKIDS
	.byte KILLACT_JUSTDRAWMIRROR	; Object $62 - OBJ_BLOOPER
	.byte KILLACT_NORMALANDKILLED	; Object $63 - OBJ_BIGBERTHABIRTHER
	.byte KILLACT_JUSTDRAW16X16	; Object $64 - OBJ_CHEEPCHEEPHOPPER
	.byte KILLACT_STANDARD	; Object $65 - OBJ_WATERCURRENTUPWARD
	.byte KILLACT_STANDARD	; Object $66 - OBJ_WATERCURRENTDOWNARD
	.byte KILLACT_NORMALANDKILLED	; Object $67 - OBJ_LAVALOTUS
	.byte KILLACT_JUSTDRAWMIRROR	; Object $68 - OBJ_TWIRLINGBUZZY
	.byte KILLACT_JUSTDRAWMIRROR	; Object $69 - OBJ_TWIRLINGSPINY
	.byte KILLACT_NORMALSTATE	; Object $6A - OBJ_BLOOPERCHILDSHOOT
	.byte KILLACT_NORMALSTATE	; Object $6B - OBJ_PILEDRIVER


	; Object group $02 (i.e. objects starting at ID $48) pattern index starts
	; These are used for all states except "normal"

OG2_POff .func (\1 - ObjectGroup02_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup02_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG2_POff(ObjP48), OG2_POff(ObjP49), OG2_POff(ObjP4A), OG2_POff(ObjP4B)
	.byte OG2_POff(ObjP4C), OG2_POff(ObjP4D), OG2_POff(ObjP4E), OG2_POff(ObjP4F)
	.byte OG2_POff(ObjP50), OG2_POff(ObjP51), OG2_POff(ObjP52), OG2_POff(ObjP53)
	.byte OG2_POff(ObjP54), OG2_POff(ObjP55), OG2_POff(ObjP56), OG2_POff(ObjP57)
	.byte OG2_POff(ObjP58), OG2_POff(ObjP59), OG2_POff(ObjP5A), OG2_POff(ObjP5B)
	.byte OG2_POff(ObjP5C), OG2_POff(ObjP5D), OG2_POff(ObjP5E), OG2_POff(ObjP5F)
	.byte OG2_POff(ObjP60), OG2_POff(ObjP61), OG2_POff(ObjP62), OG2_POff(ObjP63)
	.byte OG2_POff(ObjP64), OG2_POff(ObjP65), OG2_POff(ObjP66), OG2_POff(ObjP67)
	.byte OG2_POff(ObjP68), OG2_POff(ObjP69), OG2_POff(ObjP6A), OG2_POff(ObjP6B)


	; Object group $02 (i.e. objects starting at ID $48) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup02_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup02_PatternSets:
	; (End restricted alignment space)

ObjP49:
ObjP4D:
ObjP4E:
ObjP4F:
ObjP5D:
ObjP65:
ObjP66:
	.byte $91, $93, $9D, $9F, $9D, $9F
ObjP52:
	.byte $AB, $AD, $85, $85, $87, $87, $9D, $9F, $81, $81, $83, $83, $8B, $8B, $B5, $B7, $91, $93, $A9, $A9, $95, $97, $99, $9B, $A1, $A3, $89, $8D
ObjP53:
	.byte $8D, $8D
ObjP5C:
	.byte $8F, $8F, $B5, $B5
ObjP6B:
	.byte $75, $75
ObjP68:
	.byte $95, $97, $91, $93, $A1, $A1
ObjP69:
	.byte $81, $83, $85, $87, $89, $89
ObjP54:
	.byte $91, $93, $91, $93
ObjP55:
	.byte $B1, $B3, $B5, $B7, $A7, $B9, $A7, $B9
ObjP50:
	.byte $9D, $BF, $BB, $BD, $BB, $BD, $BB, $BD
ObjP4A:
	.byte $BD, $BF
ObjP48:
	.byte $93, $95, $93, $97, $93, $97
ObjP4B:
ObjP4C:
	.byte $C1, $C1, $CF, $CD, $C1, $C1, $C5, $C7, $C1, $C1, $CF, $CD, $C1, $C1, $C5, $C7, $C1, $C1, $CF, $CD, $C1, $C1, $C5, $C7, $D3, $D3, $ED, $ED, $D9, $D9, $DD, $DD, $71, $71, $E7, $E9, $71, $71, $E9, $E7, $C1, $C1, $C7, $C7, $C1, $C1, $C5, $C5, $81, $81, $85, $87, $81, $81, $8D, $8F, $89, $89, $91, $93, $81, $81, $87, $85, $81, $81, $8F, $8D, $89, $89, $93, $91, $71, $71, $AD, $99, $71, $71, $9D, $9F, $A1, $A1, $A5, $A5, $A7, $A7, $AB, $AB
ObjP56:
ObjP57:
	.byte $81, $83, $87, $89
ObjP67:
	.byte $C1, $C5, $C3, $C7, $C9, $CD, $CB, $CF, $D1, $D5, $D3, $E7
ObjP58:
	.byte $AF, $AF, $99, $9B, $95, $97
ObjP59:
	.byte $A1, $A3, $A5, $A7, $A5, $A7
ObjP51:
ObjP5A:
ObjP5B:
ObjP5E:
ObjP5F:
ObjP60:
	.byte $99, $9B, $9D, $9F
ObjP61:
ObjP62:
ObjP6A:
	.byte $B1, $B1, $B3, $B3, $B1, $B1
ObjP63:
	.byte $81, $83, $8D, $A1, $81, $83, $87, $89, $81, $83, $87, $89
ObjP64:
	.byte $E7, $E9, $E7, $EF, $E7, $EF


ObjNorm_IceBlock:

	; This may seem confusing, but an Ice Block is in held state when grabbed,
	; shelled state when kicked, and just comes here to get busted...

	LDA #$03	 ; A = 3
	JMP PRG003_A4DD	 ; Jump to PRG003_A4DD

ObjInit_TreasureBox:
	LDA Level_TreasureItem	 
	STA <Objects_Var5,X	; Var5 = what item we're gonna get
	TAY		 ; -> 'Y'

	LDA ToadItem_PalPerItem,Y
	STA Palette_Buffer+$1A
	LDA #$30
	STA Palette_Buffer+$19
	LDA #$0f
	STA Palette_Buffer+$1B

	; Update the palette!
	LDA #$06
	STA Graphics_Queue

	; Timer = $1F (ticks until appearance)
	LDA #$1f
	STA Objects_Timer,X

	RTS		 ; Return

TBoxItem_MirrorFlags:
	.byte $00, $81, $82, $03, $80, $81, $82, $03, $00, $81, $02, $03, $00, $01

ObjNorm_TreasureBox:
	LDA Objects_Timer,X
	BEQ PRG003_A2DB	 ; If timer has expired, jump to PRG003_A2DB

	CMP #$18
	BNE PRG003_A2DA	; If timer <> $18, jump to PRG003_A2DA (RTS)

	; Treasure box appear sound 
	LDA Sound_QLevel1
	ORA #SND_LEVELPOOF
	STA Sound_QLevel1

	JSR TreasureBox_Poof	 ; "Poof" and it appears!

PRG003_A2DA:
	RTS		 ; Return

PRG003_A2DB:
	LDA <Objects_Var4,X
	BNE PRG003_A300	 ; If Var4 is non-zero (box is now the rising power up), jump to PRG003_A300

	JSR Object_DoMoveBounceConveyor	 ; Treasure box will bounce when it falls or even get carried by conveyors

	JSR Object_HitTest	 ; Check if Player has touched the box yet
	BCC PRG003_A2F8	 	; If Player has not yet touched box, jump to PRG003_A2F8

	; Powerup rising sound
	LDA #SND_LEVELRISE
	STA Sound_QLevel1

	; Stop the clock
	STA Level_TimerEn

	; Var4++ (box is now a rising power up)
	INC <Objects_Var4,X

	; Item Y velocity
	LDA #-$30
	STA <Objects_YVel,X

	JSR TreasureBox_Poof	 ; Do another poof on opening

PRG003_A2F8:
	LDA #$00
	STA Objects_Frame,X
	JMP Object_ShakeAndDraw	 ; Just draw treasure box and don't come back

PRG003_A300:
	LDA Objects_Timer2,X
	BEQ PRG003_A30E	 ; If timer 2 is expired, jump to PRG003_A30E

	CMP #$01
	BEQ PRG003_A321	 ; If timer 2 has one tick left, jump to PRG003_A321

	; Otherwise...
	AND #%00001100
	BNE PRG003_A33A	 ; 12 ticks on, 12 ticks off; jump to PRG003_A33A

	RTS		 ; Return

PRG003_A30E:

	; Timer 2 expired

	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	INC <Objects_YVel,X
	BMI PRG003_A33A	 ; If Y velocity is still negative, jump to PRG003_A33A

	; Item has slowed to apex...

	; Set timer 2 to $70
	LDA #$70
	STA Objects_Timer2,X

	; "You got it" sound
	LDA #SND_MAPBONUSAPPEAR
	STA Sound_QMap

	BNE PRG003_A33A	 ; Jump (technically always) to PRG003_A33A

PRG003_A321:

	; Timer 2 has one tick left

	; Give Player the treasure item
	LDA Level_TreasureItem
	JSR Player_GetItem

	LDX <SlotIndexBackup		 ; X = object slot index

	; ?? This is the "full power" ringing noise, and really can't be heard this way
	LDA Sound_QPlayer
	ORA #SND_PLAYERPOWER
	STA Sound_QPlayer

	JSR Object_SetDeadEmpty	 ; Destroy the treasure box object

	; Countdown until exit
	LDA #$60
	STA LevelEvent_Cnt

	RTS		 ; Return

PRG003_A33A:

	; Timer 2 has time yet... or Y velocity is still negative...

	LDA Level_TreasureItem
	TAY
	STA Objects_Frame,X	 ; Item -> Frame

	; Set sprite attribute
	LDA #$02
	STA Objects_SprAttr,X

	LDA TBoxItem_MirrorFlags,Y
	BPL PRG003_A34E	 ; If bit 7 not set, jump to PRG003_A34E

	JMP Object_ShakeAndDrawMirrored	 ; Draw treasure box item mirrored

PRG003_A34E:
	JMP Object_ShakeAndDraw	 ; Draw treasure box item without mirroring


TreasureBox_Poof:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot or don't come back here!

	; The "poof" from when it appears	 
	LDA #SOBJ_POOF
	STA SpecialObj_ID,Y

	; Set the poof where the box will be
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Set the "poof" counter
	LDA #$1f
	STA SpecialObj_Data,Y

	RTS		 ; Return

ObjInit_PodobooCeiling:

	; Store original Y/Hi into Var5/Var4
	LDA <Objects_Y,X
	STA <Objects_Var5,X
	LDA <Objects_YHi,X
	STA <Objects_Var4,X

	RTS		 ; Return

ObjNorm_PodobooCeiling:
	LDA Objects_Timer,X
	BEQ PRG003_A387	 ; If timer expired, jump to PRG003_A387

	STA Objects_SprHVis,X	 ; Set horizontal off-scren bits (a stupid way of preventing drawing?)

	LSR A
	BNE PRG003_A386	 ; If timer > 1, jump to PRG003_A386 (RTS)

	; Propel downwards
	LDA #$58
	STA <Objects_YVel,X

PRG003_A386:
	RTS		 ; Return

PRG003_A387:
	LDA <Player_HaltGame
	BNE PRG003_A3D5	 ; If gameplay halted, jump to PRG003_A3D5

	JSR Player_HitEnemy	 ; Handle Player collision with Podoboo

	; Flip vertically based on velocity
	LDA <Objects_YVel,X
	EOR #SPR_VFLIP
	AND #SPR_VFLIP
	STA Objects_FlipBits,X

	LDA <Counter_1
	AND #$03
	BNE PRG003_A3AA	 ; Proceed 1:4 ticks, otherwise jump to PRG003_A3AA

	; Frame loop 0-2
	INC Objects_Frame,X
	LDY Objects_Frame,X
	CPY #$03
	BNE PRG003_A3AA

	STA Objects_Frame,X	; Zero the frame

PRG003_A3AA:
	LDA <Objects_YVel,X
	BPL PRG003_A3C2	 ; If Podoboo is moving downward, jump to PRG003_A3C2

	LDA <Objects_Y,X
	CMP <Objects_Var5,X

	LDA <Objects_YHi,X
	SBC <Objects_Var4,X
	BCS PRG003_A3C2	 ; If Podoboo has not returned to origin, jump to PRG003_A3C2

	; Podoboo went back to where he came from; reload timer with random value $40-$7F
	LDA RandomN,X
	AND #$3f
	ORA #$40
	STA Objects_Timer,X

PRG003_A3C2:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BPL PRG003_A3CD	 ; If Podoboo is moving downward, jump to PRG003_A3CD

	CMP #-$6F
	BLT PRG003_A3D2	 ; If Podoboo is not moving upward faster than -$6F, jump to PRG003_A3D2

PRG003_A3CD:
	SUB #$02		; Accelerate Podoboo
	STA <Objects_YVel,X	; Update Y velocity

PRG003_A3D2:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

PRG003_A3D5:
	JMP Object_ShakeAndDrawMirrored	 ; Draw Podoboo and don't come back!

ObjInit_PileDriver: 
	RTS		 ; Return


PileDriver_TowardsPlayerXVel:	.byte $10, -$10

	; Runs compare against object's state to see if it's state 2 (Normal)
Object_CheckIfNormalState:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	RTS		 ; Return


ObjNorm_PileDriver
	JSR Object_CheckIfNormalState
	BEQ PRG003_A3E9	 ; If in normal state, jump to PRG003_A3E9

	JMP BrickBust_MicroGoomba	 ; Bust out the Micro Goomba

PRG003_A3E9:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BEQ PRG003_A3F3	 ; If gameplay halted, jump to PRG003_A3F3

	JMP PRG003_A47A	 ; Jump to PRG003_A47A

PRG003_A3F3:
	LDA <Objects_Var5,X
	BEQ PRG003_A40F	 ; If Var5 = 0, jump to PRG003_A40F

	DEC <Objects_Var5,X	 ; Var5--

	BNE PRG003_A424	 ; If Var5 <> 0, jump to PRG003_A424

	; Piledriver jumps!
	LDA #-$60
	STA <Objects_YVel,X

	; Timer set to $70
	LDA #$70
	STA Objects_Timer,X

	JSR Level_ObjCalcXDiffs

	; Jump towards Player
	LDA PileDriver_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

	JMP PRG003_A424	 ; Jump to PRG003_A424

PRG003_A40F:
	LDA Objects_Timer,X
	BNE PRG003_A424		; If timer not expired, jump to PRG003_A424

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$30
	CMP #$60
	BGE PRG003_A424	 ; If Player is not close enough, jump to PRG003_A424

	; Var5 = $28
	LDA #$28
	STA <Objects_Var5,X

PRG003_A424:
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BMI PRG003_A434	 ; If Piledriver is moving upward, jump to PRG003_A434

	CMP #$70
	BGE PRG003_A446	 ; If Piledriver is falling at or faster $70, jump to PRG003_A446
	BLT PRG003_A437	 ; Otherwise, jump to PRG003_A437

PRG003_A434:
	JSR Negate	 ; Negate the velocity value (absolute value)

PRG003_A437:
	LSR A
	LSR A		; Divide current velocity by 4
 
	; I'm not sure what this check is for?  The Y velocity will never be
	; negative because of the PRG003_A434 Negate, so maybe this is in error?
	LDY <Objects_YVel,X
	BPL PRG003_A43F	 ; If Piledriver is moving upward, jump to PRG003_A43F

	; Probably unreachable?
	LSR A
	LSR A

PRG003_A43F:
	ADD #$01		; +1 to divided Y velocity
	ADC <Objects_YVel,X
	STA <Objects_YVel,X	; Update Y velocity

PRG003_A446:
	JSR Object_WorldDetectN1	 ; Detect world

	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped underneath

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG003_A456	 ; If Piledriver hit ceiling, jump to PRG003_A456

	; Bounce off ceiling
	LDA #$01
	STA <Objects_YVel,X

PRG003_A456:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A471	 ; If Piledriver hits ground, jump to PRG003_A471

	LDA <Objects_YVel,X
	CMP #$20
	BLT PRG003_A46A	 ; If Piledriver is not moving at least $20, jump to PRG003_A46A

	; Wa-bam! Landing sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

PRG003_A46A:
	JSR Object_HitGround	 ; Align Piledriver to ground

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG003_A471:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A47A	 ; If Piledriver has hit a wall, jump to PRG003_A47A

	JSR Object_AboutFace	 ; Turn around

PRG003_A47A:
	JSR Object_ShakeAndDrawMirrored	 ; Draw the Piledriver

	; Add little Microgoomba sticking out the bottom
	LDA Sprite_RAM+$00,Y
	SUB #$01
	STA Sprite_RAM+$00,Y
	LDA Sprite_RAM+$04,Y
	SBC #$01
	STA Sprite_RAM+$04,Y

	JSR Object_AnySprOffscreen
	BNE PRG003_A4DA	 ; If any of Piledriver's sprites are off-screen, jump to PRG003_A4DA

	LDA <Objects_YVel,X
	ASL A		; Sets carry if negative

	LDA #$02	 ; A = 2
	BCS PRG003_A4A1	 ; If Piledriver is moving upward, jump to PRG003_A4A1

	LDA <Objects_Var5,X
	BEQ PRG003_A4DA	 ; If Var5 = 0, jump to PRG003_A4DA

	LSR A
	LSR A
	LSR A	; A = Var5 / 8

PRG003_A4A1:
	TAX		 ; -> 'X'

	; Set Y offset
	LDA Sprite_RAM+$00,Y
	SUB Piledriver_YOff,X
	STA Sprite_RAM+$00,Y
	LDA Sprite_RAM+$04,Y
	SUB Piledriver_YOff,X
	STA Sprite_RAM+$04,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$08,Y

	; NOTE: This sprite is not visible... I suspect this may originally
	; not have been the microgoomba, but a regular goomba, hence the
	; timed toggled horizontal flip to do his "walking" animation...
	;;;;;;;;;;;;;;;;;;

	LDA <Objects_SpriteX,X
	ADD #$04
	STA Sprite_RAM+$0B,Y

	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	LSR A

	LDA #SPR_PAL3	 ; palette selected 3
	BCC PRG003_A4D2	 ; 16 ticks on, 16 ticks off; jump to PRG003_A4D2

	LDA #(SPR_HFLIP | SPR_PAL3)	 ; horizontal flip, palette select 3

PRG003_A4D2:
	STA Sprite_RAM+$0A,Y	 ; Set attribute

	; Pattern $FF (not visible)
	LDA #$ff
	STA Sprite_RAM+$09,Y

	;;;;;;;;;;;;;;;;;;

PRG003_A4DA:
	RTS		 ; Return


BrickBust_MicroGoomba:
	LDA #$04	 ; A = 4 (the Microgoomba that falls out of a Piledriver)

PRG003_A4DD:
	STA <Temp_Var16	 ; Input value -> Temp_Var16

	; Crumbling brick sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	JSR Object_SetDeadEmpty	; Destroy the Ice Block

	; Break apart into the four brick bust pieces
PRG003_A4EA:
	JSR BustBlock_Segment 	; Generate Ice block segment

	DEC <Temp_Var16		; Temp_Var16--
	BPL PRG003_A4EA		; While Temp_Var16 >= 0, loop!

	RTS		 ; Return

Piledriver_YOff:	.byte $01, $00, $02, $04, $05, $02

	; "Bust block" is an ice block that smashed into wall or a Microgoomba brick getting busted
	; First four are the brick bits, the last is the microgoomba
BustBlock_YOffByInput:	.byte -$04, -$04, $04, $04, $00
BustBlock_YHiOffByInput:	.byte  $FF,  $FF, $00, $00, $00
PRG003_A502:	.byte $00, $08, $00, $08, $04
BustBlock_YVelByInput:	.byte $C0, $C0, $D0, $D0, $D0
BustBlock_XVelByInput:	.byte $F8, $08, $F8, $08, $00 

	; Generates a segment of the busted brick (or microgoomba in the case of the Piledriver)
BustBlock_Segment:
	LDY #$07	 ; Y = 7 (wider expanse of special object slots)

	JSR SpecialObj_FindEmptyAbortY	 ; Find an empty special object slot or don't come back here...

	; Temp_Var1 = Ice Block's Y
	LDA <Objects_Y,X
	STA <Temp_Var1

	; Temp_Var3 = Ice Block's Y Hi
	LDA <Objects_YHi,X
	STA <Temp_Var3

	; Temp_Var2 = Ice Block's X
	LDA <Objects_X,X
	STA <Temp_Var2

	; X = Temp_Var16 (input value for Ice Block)
	LDX <Temp_Var16

	; Add Y offset by input
	LDA <Temp_Var1
	ADD BustBlock_YOffByInput,X
	STA SpecialObj_YLo,Y
	LDA <Temp_Var3
	ADC BustBlock_YHiOffByInput,X
	STA SpecialObj_YHi,Y

	; X Lo = Temp_Var2
	LDA <Temp_Var2
	STA SpecialObj_XLo,Y

	; Set Ice Block Y Velocity by input
	LDA BustBlock_YVelByInput,X
	STA SpecialObj_YVel,Y

	; Set Ice Block X Velocity by input
	LDA BustBlock_XVelByInput,X
	STA SpecialObj_XVel,Y

	LDA #SOBJ_BRICKDEBRIS	 ; Busting brick, input value 4 only
 
	CPX #$04	 ; X = 4
	BNE PRG003_A54E	 ; If input value <> 4, jump to PRG003_A54E

	LDA #SOBJ_MICROGOOMBA	 ; Otherwise, micro Goomba

PRG003_A54E:
	STA SpecialObj_ID,Y	 ; Set appropriate ID

	LDA #$ff
	STA SpecialObj_Data,Y
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_ICEBLOCK
	BEQ PRG003_A567	 ; If this is an Ice Block, jump to PRG003_A567

	LDA #$00
	STA SpecialObj_Timer,Y

PRG003_A567:
	RTS		 ; Return

Twirler_InitXVel:	.byte $08, -$08

ObjInit_Twirling:
	JSR Level_ObjCalcXDiffs

	; Set twirler X velocity towards Player
	LDA Twirler_InitXVel,Y
	STA <Objects_XVel,X

	; Set vertically flipped
	LDA #SPR_VFLIP
	STA Objects_FlipBits,X

	DEC <Objects_Y,X	 ; Start one pixel higher

	LDY <Objects_Y,X
	INY	
	BNE PRG003_A580
	DEC <Objects_YHi,X	 ; Apply carry
PRG003_A580:

	RTS		 ; Return

; FIXME: Anybody want to claim this?
; $A581
	.byte $F8, $08

ObjNorm_TwirlingShell:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR TwirlShell_Draw	 	; Draw the twirling shell enemy

	LDA <Player_HaltGame
	BNE PRG003_A5EF	 ; If gameplay halted, jump to PRG003_A5EF

	JSR Object_HandleBumpUnderneath	 ; Handle getting bumped from underneath

	LDA Level_ObjectID,X
	CMP #OBJ_BUZZYBEATLE
	BNE PRG003_A59A	 ; If object has not become a Buzzle Beatle, jump to PRG003_A59A

	JMP Object_SetShellState ; Set shell state and don't come back!

PRG003_A59A:
	LDY #$00	 ; Y = 0

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A5A3	 ; 8 ticks on, 8 ticks off; jump to PRG003_A5A3

	INY		 ; Y = 1

PRG003_A5A3:
	TYA
	STA Objects_Frame,X	 ; Toggle frame 0/1

	JSR Object_ApplyXVel	 ; Apply X velocity

	; Maintain Y Velocity = -$01 (sticks to ceiling)
	LDA #-$01
	STA <Objects_YVel,X

	JSR Object_WorldDetectN1 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$08
	BNE PRG003_A5CA	 ; If still detecting ceiling, jump to PRG003_A5CA

	; No more ceiling!

	INC Objects_Var7,X	 ; Var7++

	LDA Objects_Var7,X
	CMP #$02
	BGE PRG003_A5DB	 	; If Var7 >= 2, jump to PRG003_A5DB

	JSR Object_AboutFace	; Turn around
	JSR Object_ApplyXVel	; Apply X velocity
	JMP PRG003_A5CF		; Jump to PRG003_A5CF

PRG003_A5CA:
	; Var7 = 0
	LDA #$00
	STA Objects_Var7,X

PRG003_A5CF:
	JSR Level_ObjCalcXDiffs	

	LDA <Temp_Var16
	ADD #$30
	CMP #$60
	BGE PRG003_A5EF	 ; If Player is not close enough, jump to PRG003_A5EF

PRG003_A5DB:

	; Go into "kicked" state!
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	LDA ObjGroupRel_Idx
	ASL A		; 2 byte index for ObjectGroup02_CollideJumpTable
	TAY		; Y = offset into ObjectGroup_CollideJumpTable

	LDA ObjectGroup02_CollideJumpTable,Y
	STA Level_ObjectID,X	 ; Change into the appropriate target object

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG003_A5EF:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A5F8	 ; If object has not hit a wall, jump to PRG003_A5F8

	JSR Object_AboutFace	 ; Otherwise, turn around...

PRG003_A5F8:
	RTS		 ; Return

	; Unused data I think?  Possibly was for the twirling shell
PRG003_A5F9:
	.byte $00, $40, $00, $00, $40, $40, $00, $40

TwirlShell_Draw:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

	LDA Objects_Frame,X
	CMP #$02
	BLT PRG003_A613	 ; If frame < 2, jump to PRG003_A613

	; Clear horizontal flip on frame 2+
	LDA Objects_FlipBits,X
	AND #~SPR_HFLIP
	STA Objects_FlipBits,X

PRG003_A613:
	JMP Object_ShakeAndDraw	 ; Draw shelled enemy and don't come back!

ObjInit_DonutLift: 
	RTS		 ; Return

ObjNorm_DonutLift:
	JSR Object_SetPaletteFromAttr	 ; Set palette

	LDY #$5a	 ; Y = $5A (Patterns for donut lift, vertical only)

	LDA Level_7Vertical
	BNE PRG003_A62A	 ; If this level is vertical, jump to PRG003_A62A

	LDA Level_TilesetIdx
	CMP #$01
	BNE PRG003_A62D	 ; If tileset is not Mini-Fortress style, jump to PRG003_A62D

	LDY #$12	 ; Y = $12 (Patterns for donut lift, Mini-Fortress only)

PRG003_A62A:

	; Mini-Fortress or vertical orientation only...

	STY PatTable_BankSel+4

PRG003_A62D:
	JSR Object_AnySprOffscreen
	BNE PRG003_A64E	 ; If object falls off-screen at all, jump to PRG003_A64E (destroys it)

	JSR Object_ShakeAndDraw		; Draw donut lift

	LDA <Player_HaltGame
	BNE PRG003_A651	 ; If gameplay is halted, jump to PRG003_A651 (RTS)

	LDA Objects_Var7,X
	BNE PRG003_A66A	 ; If Var7 is non-zero, jump to PRG003_A66A

	JSR Object_HitTest	 ; Do Player to object collision test

	LDA Objects_PlayerHitStat,X
	BNE PRG003_A652	 ; If Player is not touching object, jump to PRG003_A652

	LDA Level_ChgTileEvent
	BNE PRG003_A651	 ; If a tile change event is active, jump to PRG003_A651

	JSR DonutLift_ChangeBlock	; Do block change

PRG003_A64E:
	JSR Object_SetDeadEmpty	 ; Mark as dead/empty

PRG003_A651:
	RTS		 ; Return

PRG003_A652:
	DEC <Objects_Var5,X	 ; Var5--
	BNE PRG003_A65A	 	; If Var5 > 0, jump to PRG003_A65A

	INC Objects_Var7,X	 ; Var7++

	RTS		 ; Return

PRG003_A65A:
	LDA <Counter_1
	AND #$07
	STA Objects_Timer4,X	 ; Timer4 = 0 to 7

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_A669	 ; If Player has not touched donut lift, jump to PRG003_A669 (RTS)

	JSR PRG003_A67C

PRG003_A669:
	RTS		 ; Return

PRG003_A66A:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y limit

	LDA <Objects_YVel,X
	CMP #$40
	BGS PRG003_A677	 ; If donut lift is moving downward faster than $40, jump to PRG003_A677

	; Gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG003_A677:
	JSR Object_HitTest	 ; Do Player to object collision detection
	BCC PRG003_A691	 ; If no collision, jump to PRG003_A691 (RTS)

PRG003_A67C:
	LDA <Player_YVel
	BMI PRG003_A691	 ; If Player is moving upward, jump to PRG003_A691 (RTS)

	; Otherwise, lock Player at 31 pixels above donut lift
	LDA <Objects_Y,X
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Player is not in air
	LDA #$00
	STA <Player_InAir

PRG003_A691:
	RTS		 ; Return

DonutLift_ChangeBlock:
	; Queue tile change event
	LDA #CHNGTILE_DELETEDONUT
	STA Level_ChgTileEvent

	; Block change to occur at Y+1
	LDA <Objects_Y,X
	ADD #$01
	STA Level_BlockChgYLo
	LDA <Objects_YHi,X
	ADC #$00
	STA Level_BlockChgYHi

	LDA <Objects_XHi,X
	STA Level_BlockChgXHi
	LDA <Objects_X,X
	STA Level_BlockChgXLo

	RTS		 ; Return

	; Bob-omb's starting X velocity depending on where Player is
BobOmb_StartXVel:	.byte $08, -$08

	; Bob-omb's starting X velocity depending on where Player is
BobOmbExp_StartXVel:	.byte $10, -$10

ObjInit_BobOmb:
	JSR Level_ObjCalcXDiffs

	; Start Bob-omb moving towards Player
	LDA BobOmb_StartXVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_BobOmbExplode:
	JSR Level_ObjCalcXDiffs

	; Start Bob-omb moving towards Player
	LDA BobOmbExp_StartXVel,Y
	STA <Objects_XVel,X

	INC Objects_Var7,X	 ; Var7 = 1 for exploding Bob-omb!

	RTS		 ; Return

ObjNorm_BobOmb:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Objects_Var5,X
	CMP #$02
	BEQ PRG003_A6DD	 ; If Var5 = 2 (Exploding), jump to PRG003_A6DD

	JSR Object_ShakeAndDraw	 ; Normally draw Bob-omb (Except when exploding)

	LDA <Player_HaltGame
	BNE PRG003_A6E8	 ; If gameplay halted, jump to PRG003_A6E8 (RTS)

	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

PRG003_A6DD:
	LDA <Objects_Var5,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BobOmb_WalkAround		; 0: Unsquashed Bob-omb minding his own business
	.word BobOmb_FlashToExplode	; 1: Squashed Bob-omb who then flashes and explodes
	.word BobOmb_DoExplosion	; 2: Do the explosion, kill things, etc.

PRG003_A6E8:
	RTS		 ; Return

BobOmb_WalkAround:
	JSR Object_Move	 ; Do standard movements

	LDA Objects_Var7,X
	BEQ PRG003_A6FF	 ; If Var7 = 0 (Bob-omb not ready to explode), jump to PRG003_A6FF

	; Bob-omb has been squashed and ready to blow!

	LDA Objects_Timer3,X
	ORA <Objects_Var5,X
	BNE PRG003_A6FF	 ; If timer 3 not expired or Var5 <> 0 (initial internal state), jump to PRG003_A6FF

	INC <Objects_Var5,X	 ; Var5++ (next internal state)

	; Set timer to $60
	LDA #$60
	STA Objects_Timer,X

PRG003_A6FF:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A730	 ; If Bob-omb's not on the ground, jump to PRG003_A730

	LDA #-$20
	STA <Objects_YVel,X

	LDY #$00	 ; Y = 0

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A712	 ; 8 ticks on, 8 ticks off; jump to PRG003_A712

	INY		 ; Y = 1

PRG003_A712:
	; Little walking frame
	TYA
	STA Objects_Frame,X

	JSR Object_HitGround	 ; Align to floor

	LDA Objects_Var7,X
	BEQ PRG003_A730	 ; If Var7 = 0 (not ready to explode), jump to PRG003_A730

	INC Objects_Var3,X	 ; Var3++
	LDA Objects_Var3,X
	AND #$3f	 
	BNE PRG003_A730	 ; Every 1:64 ticks proceed, otherwise jump to PRG003_A730

	JSR Level_ObjCalcXDiffs

	; March toward Player
	LDA BobOmbExp_StartXVel,Y
	STA <Objects_XVel,X

PRG003_A730:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A739	 ; If Bob-omb has not hit wall, jump to PRG003_A739

	JSR Object_AboutFace	 ; Otherwise, turn around

PRG003_A739:
	JSR Object_HandleBumpUnderneath
	BCC PRG003_A75E	 ; If Bob-omb wasn't hit from underneath, jump to PRG003_A75E

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_A75E	 ; If Player didn't touch Bob-omb, jump to PRG003_A75E (RTS)

	LDA Player_Kuribo
	BEQ PRG003_A74B	 ; If Player is not in Kuribo's shoe, jump to PRG003_A74B

	JMP BobOmb_Kill	 ; Jump to BobOmb_Kill

PRG003_A74B:
	INC <Objects_Var5,X

	LDA #$ff
	STA Objects_Timer,X

	LDA #$08
	STA Objects_Timer2,X

	; Little bounce for the Player
	LDA #-$30
	STA <Player_YVel

	JMP PRG003_A7FE	 ; Just do Bob-omb death

PRG003_A75E:
	RTS		 ; Return

PRG003_A75F:
	.byte $10, $20, $30, $40, $FC, $F8, $F4, $F0

BobOmb_FlashToExplode:
	; Toggles between frames 2 and 3, but these are indiscernable,
	; both look like the "eyes closed, footless" Bob-omb...
	; Maybe was supposed to animate crank or something?
	LDY #$02	; Y = 2

	LDA <Counter_1
	AND #$08
	BEQ PRG003_A770	 ; 8 ticks on, 8 ticks off; jump to PRG003_A770

	INY		 ; Y = 3

PRG003_A770:
	TYA
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BNE PRG003_A798	 ; If timer not expired, jump to PRG003_A798

	; Timer expired...

BobOmb_Explode:
	; Var3 = 0
	LDA #$00
	STA Objects_Var3,X

	; Set internal state to 2
	LDA #$02
	STA <Objects_Var5,X

	; Reset timer to $28 (length of explosion)
	LDA #$28
	STA Objects_Timer,X

	; Ba-boom
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	; Since Bob-omb is exploding, he no longer needs to enforce his pattern bank
	INC Objects_DisPatChng,X

SetRotatingColor:
	LDA #$10
	STA RotatingColor_Cnt

	RTS		 ; Return


PRG003_A798:

	; Bob-omb's timer hasn't gone out yet...

	CMP #$40
	BGE PRG003_A79F	 ; If timer >= $40, jump to PRG003_A79F
 
	STA Objects_ColorCycle,X	 ; Otherwise, start flashing

PRG003_A79F:
	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_A7CC	 ; If Bob-omb has not hit floor, jump to PRG003_A7CC

	; This whole block works to get the X velocity arithmetically divided by 2
	LDA <Objects_XVel,X
	PHP		 ; Save CPU state
	; Get absolute value of X velocity
	BPL PRG003_A7B0
	JSR Negate
PRG003_A7B0:
	LSR A		 ; Divide by 2
	PLP		 ; Restore CPU state
	BPL PRG003_A7B7	 ; If the X velocity was positive, jump to PRG003_A7B7
	JSR Negate	 ; Otherwise, make this negative again
PRG003_A7B7:
	STA <Objects_XVel,X	 ; X velocity now divided by 2

	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	JSR Object_HitGround	 ; Align to floor

	PLA		 ; Restore Y velocity
	BMI PRG003_A7CC	 ; If it's negative, jump to PRG003_A7CC

	; Bob-omb was falling downward...
	LSR A		; Divide by 2
	JSR Negate	 ; Negate it (bounce back up)
	CMP #$fc
	BGE PRG003_A7CC	 ; If the velocity was small enough, then just stop

	STA <Objects_YVel,X	 ; Otherwise, bounce away

PRG003_A7CC:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG003_A7DC	 ; If Bob-omb did not hit a wall, jump to PRG003_A7DC

	; Otherwise bounce off
	LDA <Objects_XVel,X
	JSR Negate
	STA <Objects_XVel,X

	; ... and sort of arithmetically divide by 2
	ASL A
	ROR <Objects_XVel,X

PRG003_A7DC:
	JSR Object_HitTest
	BCC PRG003_A7F0	 ; If Player and Bob-omb didn't collide, jump to PRG003_A7F0 (RTS)

	LDA Objects_Timer2,X
	BNE PRG003_A7F0	 ; If timer2 has not expired, jump to PRG003_A7F0 (RTS)

	LDA Player_Kuribo
	BNE BobOmb_Kill	 ; If Player is in Kuribo's shoe, kill Bob-omb, jump to BobOmb_Kill

	; Otherwise, set Bob-omb's state to 4 (Held, doesn't really make sense)
	LDA #OBJSTATE_HELD
	STA Objects_State,X

PRG003_A7F0:
	RTS		 ; Return

BobOmb_Kill:
	; Player bounces
	LDA #-$30
	STA <Player_YVel

	; Set Bob-omb state to Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; A little bounce from the Bob-omb
	LDA #-$10
	STA <Objects_YVel,X

PRG003_A7FE:
	LDA Kill_Tally
	INC Kill_Tally
	JSR Score_Get100PlusPts	 ; Get score according to Kill Tally

	; "Kick" noise
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	RTS		 ; Return

	; X and Y offsets for the exploding Bob-omb stars
BombStars_XOff:	.byte -$04, $04, $08, $04, -$04, -$08, $00, $08, $08, $00, -$08, -$08
BombStars_YOff:	.byte -$08, -$08, $00, $08, $08, $00, $08, $04, -$04, -$08, -$04, $04

BobOmb_DoExplosion:
	LDA <Player_HaltGame
	BNE PRG003_A82E	 ; If gameplay is halted, jump to PRG003_A82E

	INC <Objects_Var4,X	 ; Otherwise, Var4++

PRG003_A82E:
	LDA Objects_Timer,X
	BNE PRG003_A836	 ; If timer has not expired, jump to PRG003_A836

	JMP Object_SetDeadEmpty	 ; Otherwise, mark Bob-omb as Dead/Empty and don't come back!

PRG003_A836:
	JSR Object_CalcSpriteXY_NoHi

	; Temp_Var16 = 5
	LDA #$05
	STA <Temp_Var16

PRG003_A83D:
	; Temp_Var1 = Bob-omb's sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1	

	; Temp_Var2 = Bob-omb's sprite X + 4
	LDA <Objects_SpriteX,X
	ADD #$04
	STA <Temp_Var2

	LDA <Objects_Var4,X
	LSR A		 ; Var4 / 2
	PHA		 ; Save value

	; Temp_Var3 = 0 to 3, depending on Var4 / 2
	AND #$03
	STA <Temp_Var3

	LDX <Temp_Var16	 ; X = Temp_Var16

	PLA		 ; Restore Var4 / 2

	AND #$04	 ; Mask 0-3
	BEQ PRG003_A85C	 ; If result is zero, jump to PRG003_A85C

	; Otherwise, X += 6
	TXA
	ADD #$06
	TAX

PRG003_A85C:
	LDA <Temp_Var1
	ADD BombStars_YOff,X
	STA <Temp_Var1

	LDA <Temp_Var2
	ADD BombStars_XOff,X
	STA <Temp_Var2

	DEC <Temp_Var3	 ; Temp_Var3--
	BPL PRG003_A85C	 ; While Temp_Var3 >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	JSR Sprite_NoCarryIfVisible
	BCS PRG003_A89D	 ; If this star is not visible, jump to PRG003_A89D

	LDA <Temp_Var16
	ASL A
	ASL A		; A = Temp_Var16 * 4 (one sprite per star)
	ADC Object_SprRAM,X	 ; Add the base Sprite_RAM offset
	TAY		 ; -> 'Y'

	; Star Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Star X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; Star pattern
	LDA #$73
	STA Sprite_RAM+$01,Y

	LDA <Counter_1
	LSR A	
	LSR A	
	ADD <SlotIndexBackup
	AND #$03	 ; Palette select 0 to 3
	STA Sprite_RAM+$02,Y	 ; Set attributes

	JSR PRG003_BD1E	 ; Uses part of the "Tail" hurt code, checks if Player has been hit by explosion

PRG003_A89D:
	DEC <Temp_Var16	 ; Temp_Var16--
	BPL PRG003_A83D	 ; While Temp_Var16 >= 0, loop!

	JSR Object_AnySprOffscreen
	BNE PRG003_A8D2	 ; If any part of the exploding Bob-omb has fallen off-screen, jump to PRG003_A8D2

	JSR BobOmb_CalcULOffXY	; (large bounding box for explosion)

	; Temp_Var13 = 0
	LDA #$00
	STA <Temp_Var13

	JSR PRG000_DC09	 ; Object-to-object collision test sans visibility check and bounding box calculation
	BCC PRG003_A8D2	 ; If there hasn't been a collision, jump to PRG003_A8D2 (RTS)

	; "Kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	; Set object to state Killed
	LDA #OBJSTATE_KILLED
	STA Objects_State,Y

	; Killed object bounces up a bit
	LDA #-$30
	STA Objects_YVel,Y

	; Halt horizontal movement
	LDA #$00
	STA Objects_XVel,Y

	; Var3 works as a kill counter for things killed by the explosion
	LDA Objects_Var3,X
	INC Objects_Var3,X

	JSR Score_Get100PlusPtsY	 ; Get score for that

PRG003_A8D2:
	RTS		 ; Return

	; Calculates an upper left X/Y offset
BobOmb_CalcULOffXY:
	; Temp_Var3 = Bob-omb's Sprite X - 24
	LDA <Objects_SpriteX,X	 
	SUB #24
	STA <Temp_Var3

	; Temp_Var7 = Bob-omb's Sprite Y - 24
	LDA <Objects_SpriteY,X
	SUB #24
	STA <Temp_Var7

	; Temp_Var4 and Temp_Var8 = $40
	LDA #$40
	STA <Temp_Var4
	STA <Temp_Var8

	RTS		 ; Return

ObjNorm_BoomBoomQBall:
	LDY Objects_Timer,X	; Y = timer
	BEQ PRG003_A8FF	 	; If timer expired, jump to PRG003_A8FF

	; This timer is active after time has been converted to score,
	; in that momentary pause after that before exiting

	STY Player_VibeDisable	; Cause Player to be vibrationally disabled
	DEY		 ; Y--
	BNE PRG003_A8FE	 ; If timer > 1, jump to PRG003_A8FE (RTS)

	; Y = 0 at this point...

	STY Map_ReturnStatus	 ; Map_ReturnStatus = 0 (clear level)

	; Set the lock busting / bridge building effect for this ball
	LDA <Objects_Var4,X
	STA Map_DoFortressFX

	INC Level_ExitToMap	 ; Flag to exit to map

PRG003_A8FE:
	RTS		 ; Return

PRG003_A8FF:
	LDA <Objects_Var5,X
	BEQ PRG003_A911	 ; If Var5 = 0, jump to PRG003_A911

	STA Player_VibeDisable	 ; Clear Player vibrationally disabled flag

	JSR DoTimeBonus	 ; Convert remaining time into score
	BNE PRG003_A910	 ; If not done converting, jump to PRG003_A910 (RTS)

	; Set timer to $40
	LDA #$40
	STA Objects_Timer,X

PRG003_A910:
	RTS		 ; Return

PRG003_A911:
	LDA <Player_HaltGame
	BNE PRG003_A92D	 ; If gameplay is halted, jump to PRG003_A92D

	LDA <Objects_YVel,X
	BMI PRG003_A92D	 ; If ball moving upwards, jump to PRG003_A92D

	JSR Object_HitTest
	BCC PRG003_A92D	 ; If Player is not touching it, jump to PRG003_A92D

	; A living Player has grabbed it!

	INC <Objects_Var5,X	 ; Var5++

	; Do the color cycle effect
	LDA #$1e
	STA RotatingColor_Cnt

	; Victory fanfare
	LDA Sound_QMusic1
	ORA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

PRG003_A92D:
	JSR Object_ShakeAndDraw	 ; Draw it

Object_DoMoveBounceConveyor:
	JSR Object_Move	 ; Do standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ ObjInit_BoomBoomQBall ; If ball hasn't hit ground, jump to ObjInit_BoomBoomQBall (RTS)

	LDA Level_ObjectID,X
	CMP #OBJ_BOOMBOOMQBALL
	BNE PRG003_A946	 ; If this isn't a Boom Boom ball, jump to PRG003_A946

	LDA <Objects_Y,X
	CMP #$70
	BLT ObjInit_BoomBoomQBall ; If ball is higher than $70, jump to ObjInit_BoomBoomQBall

PRG003_A946:
	JSR Object_HandleConveyorCarry	 ; Carry ball along conveyor

	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	JSR Object_HitGround	 ; Align to floor

	PLA		 ; Restore Y velocity
	LSR A
	LSR A		 ; Current Y velocity / 4

	JSR Negate	 ; Bounce at a quarter of impact

	CMP #$fe	 
	BCS ObjInit_BoomBoomQBall	; If the bounce is really small, jump to ObjInit_BoomBoomQBall (RTS)

	STA <Objects_YVel,X	 ; Update Y velocity for a bounce

ObjInit_BoomBoomQBall:
	RTS		 ; Return


ObjNorm_FloatingBGCloud:
	LDA <Player_HaltGame
	BNE PRG003_A98C	 ; If gameplay is halted, jump to PRG003_A98C

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR PRG003_A98C
	JSR Object_ApplyXVel	 	 ; Apply X velocity
	JMP Fish_FixedY_ExceptHitFloor	 ; Jump to Fish_FixedY_ExceptHitFloor and don't come back

FloatingBGCloud_Patterns:
	.byte $B7, $B9, $FF, $71, $71, $71, $01, $01
	.byte $B7, $B9, $B9, $FF, $71, $71, $01, $01
	.byte $B7, $B9, $B9, $B9, $FF, $71, $01, $01
	.byte $B7, $B9, $B9, $B9, $B9, $FF, $01, $01

PRG003_A98C:
	; Temp_Var16 = 0
	LDA #$00
	STA <Temp_Var16

	JSR Object_CalcSpriteXY_NoHi

	; Temp_Var1 = Sprite Y - 1
	LDA <Objects_SpriteY,X
	SUB #$01
	STA <Temp_Var1

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2

PRG003_A99E:
	LDA <Temp_Var2
	JSR Sprite_NoCarryIfVisible
	BCS PRG003_A9DA	 ; If carry set, not visible, jump to PRG003_A9DA

	LDA <Temp_Var16
	ASL A
	ASL A	; Temp_Var16 * 4 (index by sprite)
	ADC Object_SprRAM,X	; Add base offset into Sprite_RAM
	TAY		 ; -> 'Y'

	LDA <Objects_Var5,X
	ASL A
	ASL A
	ASL A	; A = Var5 * 8	(base index)
	ADC <Temp_Var16		; Add loop index 
	TAX		; -> 'X'

	LDA FloatingBGCloud_Patterns,X	 ; Get this pattern

	LDX <SlotIndexBackup	 ; X = object slot index

	CMP #$71
	BEQ PRG003_A9DA	 ; If pattern is $71, jump to PRG003_A9DA

	CMP #$ff
	BLT PRG003_A9C4	 ; If pattern < $FF, jump to PRG003_A9C4

	LDA #$b7	 ; Otherwise, use pattern $B7

PRG003_A9C4:
	STA Sprite_RAM+$01,Y	 ; Store pattern

	LDA #$22	 ; A = $22 (last pattern < $FF)
	BLT PRG003_A9CD	 ; If last pattern < $FF, jump to PRG003_A9CD

	ORA #SPR_HFLIP	 ; Otherwise, apply horizontal flip

PRG003_A9CD:
	STA Sprite_RAM+$02,Y	 ; Store attributes

	; Store Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Store X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

PRG003_A9DA:

	; X += 8 (next sprite over)
	LDA <Temp_Var2
	ADD #$08
	STA <Temp_Var2

	INC <Temp_Var16	; Temp_Var16++

	LDA <Temp_Var16
	CMP #$06	
	BNE PRG003_A99E	 ; If loop counter <> 6, loop!

	RTS		 ; Return

ObjInit_BoomBoom:

	; Set Var4 to Boom Boom's Y Hi -- this will select which value goes into Map_DoFortressFX
	; So if Boom Boom's Y Hi is 1, then Map_DoFortressFX = 1, etc.
	; The actual assignment to Map_DoFortressFX is done with the (?) ball after Boom Boom is defeated
	LDA <Objects_YHi,X
	STA <Objects_Var4,X

	; Boom Boom will always appear at Y Hi = 1 (since this was used as a parameter)
	LDA #$01
	STA <Objects_YHi,X
	STA Objects_IsGiant,X	 ; Boom Boom is considered a "giant" enemy

	; Boom Boom requires 37 fire balls before going down 
	LDA #37
	STA Objects_HitCount,X

	; Boom Boom starts on frame 7
	LDA #$07
	STA Objects_Frame,X

ObjInit_FloatingBGCloud:
	RTS		 ; Return

BoomBoom_TowardsPlayerXVel:	.byte $10, -$10

BoomBoom_FinalAttackXVel:
	.byte $20, -$20, $18, -$18	; First two values are for any world besides World 1, last two are World 1 only

BoomBoom_GetupFrames:
	.byte $0A, $06, $07, $07, $07, $07, $06, $0A, $10, $14
	.byte $15, $15, $15, $15, $14, $10

ObjNorm_BoomBoom:

	; Boom Boom's graphics
	LDA #$4d
	STA PatTable_BankSel+4

	LDA Level_TilesetIdx
	CMP #11
	BNE PRG003_AA25	 ; If Level_TilesetIdx <> 11 (ice level), jump to PRG003_AA25

	STA Objects_Var2,X	 ; Var2 = 11

PRG003_AA25:
	LDA Objects_HitCount,X
	CMP #$20
	BNE PRG003_AA3B	 ; If HitCount <> $20, jump to PRG003_AA3B

	DEC Objects_HitCount,X	 ; HitCount--

	; Var5 = 5
	LDA #$05
	STA <Objects_Var5,X

	; Timer = $50
	LDA #$50
	STA Objects_Timer,X

	JMP BoomBoom_Draw	 ; Draw Boom Boom and don't come back

PRG003_AA3B:
	JSR BoomBoom_Draw	 ; Draw Boom Boom
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	JSR Object_CheckIfNormalState
	BEQ PRG003_AA5D	 ; If Boom Boom is in normal state, jump to PRG003_AA5D

	; Not normal state... any state not normal is considered Boom Boom has
	; been killed, and as such will cause him to turn into the "(?)" ball.

	LDA <Objects_Var5,X
	BEQ PRG003_AA5D	 ; If Var5 = 0, jump to PRG003_AA5D

	; Set state Normal (for the end ball)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	LDA #$70
	STA <Objects_Y,X
	STA <Objects_X,X

	LDA #$01
	STA <Objects_YHi,X

	LSR A		 ; A = 0
	JMP PRG003_AE95	 ; Jump to PRG003_AE95

PRG003_AA5D:
	LDA <Player_HaltGame
	BNE ObjInit_FloatingBGCloud	; If gameplay halted, jump to ObjInit_FloatingBGCloud (RTS)

	LDA <Objects_Var5,X
	CMP #$05
	BEQ PRG003_AAD9	 ; If Var5 (internal state) = 5, jump to PRG003_AAD9

	; Var5 (Internal state) < 5...

	LDY Objects_Timer2,X
	BEQ PRG003_AA92	 ; If timer 2 expired, jump to PRG003_AA92
	DEY		 ; Y--
	BNE PRG003_AA72	 ; If Y > 0, jump to PRG003_AA72

	JSR BoomBoom_ResetVar6	 ; Sets Var6 to $2F

PRG003_AA72:
	LDY #$08	 ; Y = 8

	; Boom Boom's squashed wiggle frames

	LDA <Counter_1
	AND #$04
	BEQ PRG003_AA7B	 ; On for 4 ticks, off 4 ticks; jump to PRG003_AA7B every other

	INY		 ; Y = 9

PRG003_AA7B:
	LDA Level_ObjectID,X
	CMP #OBJ_BOOMBOOMFLY
	BNE PRG003_AA8D	 ; If this is not a flying Boom Boom, jump to PRG003_AA8D

	LDA <Objects_Var5,X
	CMP #$03
	BNE PRG003_AA8D	 ; If Var5 (Internal State) <> 3, jump to PRG003_AA8D

	; Add 10 to 'Y' (Boom Boom's wings appear)
	TYA
	ADD #$0a
	TAY

PRG003_AA8D:

	; Set frame
	TYA
	STA Objects_Frame,X

	RTS		 ; Return

PRG003_AA92:
	LDA Objects_Var6,X
	BEQ PRG003_AAD3	 ; If Var6 = 0, jump to PRG003_AAD3

	DEC Objects_Var6,X
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = Var6 / 8

	; Set frames while Boom Boom is "getting up"
	LDA BoomBoom_GetupFrames,Y
	STA Objects_Frame,X

	LDA Objects_Var6,X
	CMP #$10
	BNE PRG003_AABC	 ; If Var6 <> $10, jump to PRG003_AABC

	; Boom Boom hops a bit when he gets up
	LDA #-$2D
	STA <Objects_YVel,X

	LDA Objects_Var2,X
	BNE PRG003_AABC	 ; If Var2 <> 0, jump to PRG003_AABC

	JSR Level_ObjCalcXDiffs

	; Set X Velocity towards Player
	LDA BoomBoom_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

PRG003_AABC:
	LDA <Counter_1
	LSR A
	BCC PRG003_AACD	 ; Every other tick, jump to PRG003_AACD

	LDA <Objects_XVel,X
	BEQ PRG003_AACD	 ; If Boom Boom is not moving horizontally, jump to PRG003_AACD
	BPL PRG003_AACB	 ; If moving to the right, jump to PRG003_AACB

	; Moving to the left...

	; Double increment because it hits the decrement, basically a single increment
	INC <Objects_XVel,X	; Moving left, slow down
	INC <Objects_XVel,X

PRG003_AACB:
	DEC <Objects_XVel,X	; Moving right, slow down

PRG003_AACD:
	JSR BoomBoom_HitTest	; Test for collisions between Player and Boom Boom
	JMP PRG003_AB8E	 	; Jump to PRG003_AB8E

PRG003_AAD3:
	JSR BoomBoom_HitTest	; Test for collisions between Player and Boom Boom

	INC Objects_Var3,X	 ; Var3++

PRG003_AAD9:
	LDA <Objects_Var5,X	; Var5 is internal state for Boom Boom
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BoomBoom_Init		; 0: Initial state, wait for Player
	.word BoomBoom_Unused		; 1: Lost state?  Never used, just goes to state 2
	.word BoomBoom_PrimaryAttack	; 2: Boom Boom's run around with fists flailing
	.word BoomBoom_SeconaryAttack	; 3: Boom Boom jumps about or flies, depending
	.word BoomBoom_FinalAttack	; 4: Second hit
	.word BoomBoom_Death		; 5: Kaboom Death

BoomBoom_Init:

	; Boom Boom awaits in his crouch frame
	LDA #$07
	STA Objects_Frame,X
	STA Objects_SprHVis,X	 ; ??

	LDA <Horz_Scroll
	CMP #$07
	BGE PRG003_AB1E	 ; If the horizontal scroll is any greater than 7, jump to PRG003_AB1E (RTS) (Waits for screen to come around to Boom Boom)

	; Lock horizontal scroll to zero point
	LDA #$00
	STA <Horz_Scroll

	; Halt Player horizontally
	LDY #$00
	STY <Player_XVel

	LDA <Player_InAir
	BNE PRG003_AB1E		; If Player is not on ground, jump to PRG003_AB1E (RTS)

	STA Level_PSwitchCnt	 ; Cancel any active P-Switch

	; Play boss music
	LDA Sound_QMusic2
	ORA #MUS2B_BOSS
	STA Sound_QMusic2

	; Lock horizontal scrolling
	INC LevelJctBQ_Flag

	; Lock vertical scrolling
	LDA #$02
	STA Level_FreeVertScroll

	; Var5 = 2
	STA <Objects_Var5,X


BoomBoom_ResetVar6:

	; Var6 = $2F
	LDA #$2f
	STA Objects_Var6,X

PRG003_AB1E:
	RTS		 ; Return


BoomBoom_Unused:
	INC <Objects_Var5,X	 ; Just jumps to state 2
	RTS		 ; Return

BoomBoom_XVelLimit:	.byte $10, -$10	; Boom Boom primary attack limits
BoomBoom_XVelFastLimit:	.byte $30, -$30	; Boom Boom final attack limits
BoomBoom_XVelAccel:	.byte $01, -$01	; Boom Boom primary attack acceleration
BoomBoom_XVelFastAccel:	.byte $02, -$02	; Boom Boom final attack acceleration

BoomBoom_PrimaryAttack:
	LDA Objects_Var2,X
	BEQ PRG003_AB52	 ; If Var2 = 0, jump to PRG003_AB52

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_XVelLimit,Y
	BEQ PRG003_AB42	 ; If Boom Boom is at his X velocity limit, jump to PRG003_AB42

	; Boom Boom X velocity not at his limit...

	ADD BoomBoom_XVelAccel,Y	; Accelerate
	STA <Objects_XVel,X		; Update X velocity

	; While Boom Boom is accelerating...

	INC Objects_Var3,X	 ; Var3++

PRG003_AB42:
	INC Objects_Var1,X	 ; Var1++

	LDA Objects_Var1,X
	BNE PRG003_AB4F	 ; If Var1 has not overflowed, jump to PRG003_AB4F

	; When Var1 overflows, Boom Boom goes back into his shell

	; Var6 = $3F
	LDA #$3f
	STA Objects_Var6,X

PRG003_AB4F:
	JMP PRG003_AB78	 ; Jump to PRG003_AB78

PRG003_AB52:
	INC Objects_Var1,X	 ; Var1++

	LDA Objects_Var1,X
	BNE PRG003_AB6C	 ; If Var1 has not overflowed, jump to PRG003_AB6C

	; Var6 = $3F
	LDA #$3f
	STA Objects_Var6,X

	JSR Level_ObjCalcXDiffs

	; Boom Boom slides a bit when he jumps back in his shell
	LDA BoomBoom_XVelSlide,Y
	STA <Objects_XVel,X

	JMP PRG003_AA92	 ; Jump to PRG003_AA92

BoomBoom_XVelSlide:	.byte $20, -$20

PRG003_AB6C:
	AND #$3f
	BNE PRG003_AB78	 ; 1:64 counts on Var1 proceed, otherwise jump to PRG003_AB78

	; Shift Boom Boom's horizontal direction towards Player
	JSR Level_ObjCalcXDiffs
	LDA BoomBoom_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

PRG003_AB78:
	LDA Objects_Var3,X
	AND #$03
	BNE PRG003_AB8E	 ; Proceed 1:4 Var3 counts, otherwise jump to PRG003_AB8E

	INC Objects_Frame,X	 ; Boom Boom's frame++

	; Loop frames 0-6
	LDA Objects_Frame,X
	CMP #$06
	BLT PRG003_AB8E	 ; If Boom Boom frame < 6, jump to PRG003_AB8E

	LDA #$00
	STA Objects_Frame,X

PRG003_AB8E:
	JSR Object_Move	 ; Boom Boom does standard movements

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_AB9A	 ; If Boom Boom did not hit the ground, jump to PRG003_AB9A

	JSR Object_HitGround	 ; Align to floor

PRG003_AB9A:
	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG003_ABC3	 ; If Boom Boom has not hit ceiling, jump to PRG003_ABC3

	; Boom Boom Y Vel = 1, i.e. hit off ceiling
	LDA #$01
	STA <Objects_YVel,X

	; Set tile detection coordinates

	LDA <Objects_X,X
	ADD #$08
	STA ObjTile_DetXLo

	LDA <Objects_XHi,X
	STA ObjTile_DetXHi

	LDA <Objects_Y,X
	ADC #$0c
	STA ObjTile_DetYLo

	LDA #$01
	STA ObjTile_DetYHi

	LDA Object_TileFeet2
	JSR Object_BumpBlocks	 ; Boom Boom can hit blocks! (???)

PRG003_ABC3:
	LDA <Objects_DetStat,X	
	AND #$03
	BNE PRG003_ABDB	 ; If Boom Boom has hit a wall, jump to PRG003_ABDB

	; Boom Boom has not hit a wall...

PRG003_ABC9:
	LDA <Objects_XVel,X
	BPL PRG003_ABD5	 ; If Boom Boom is not moving left, jump to PRG003_ABD5

	; Boom Boom is moving leftward...

	LDA <Objects_SpriteX,X
	CMP #$08
	BGE PRG003_ABDE	 ; If Boom Boom's Sprite X >= 8, jump to PRG003_ABDE (RTS)
	BLT PRG003_ABDB	 ; Otherwise, jump to PRG003_ABDB

PRG003_ABD5:

	; Boom Boom is moving rightward...

	LDA <Objects_SpriteX,X
	CMP #224
	BLT PRG003_ABDE	 ; If Boom Boom's Sprite X < 224, jump to PRG003_ABDE (RTS)

PRG003_ABDB:
	JSR Object_AboutFace	 ; Boom Boom turns around

PRG003_ABDE:
	RTS		 ; Return


BoomBoom_SeconaryAttack:
	LDA Level_ObjectID,X
	CMP #OBJ_BOOMBOOMFLY
	BNE PRG003_ABE9	 ; If this is not the flying Boom Boom, jump to PRG003_ABE9

	JMP PRG003_AC70	 ; Jump to PRG003_AC70

PRG003_ABE9:

	; Non-flying Boom Boom

	LDA Objects_Var7,X
	BEQ PRG003_AC1A	 ; If Var7 = 0, jump to PRG003_AC1A

	LDA <Counter_1
	AND #$03
	BNE PRG003_AC00	 ; Every 1:4 ticks, proceed, otherwise jump to PRG003_AC00

	LDA <Objects_XVel,X
	BEQ PRG003_AC00	 ; If Boom Boom is not moving horizontally, jump to PRG003_AC00
	BPL PRG003_ABFE	 ; If Boom Boom is moving to the right, jump to PRG003_ABFE

	; Moving to the left...

	; Double increment because it hits the decrement, basically a single increment
	INC <Objects_XVel,X	; Moving left, slow down
	INC <Objects_XVel,X

PRG003_ABFE:
	DEC <Objects_XVel,X	; Moving right, slow down

PRG003_AC00:

	; Jump tensing frame
	LDA #$0B
	STA Objects_Frame,X

	DEC Objects_Var7,X	 ; Var7--

	BNE PRG003_AC11	 ; If Var7 <> 0, jump to PRG003_AC11

	; Boom Boom's jump!
	LDA #-$60
	STA <Objects_YVel,X

	JSR BoomBoom_SetXVelTowardsPlayer	 ; Jump towards Player

PRG003_AC11:
	LDA Objects_Var2,X
	BEQ PRG003_AC19	 ; If Var2 = 0, jump to PRG003_AC19 (RTS)

	JSR Object_ApplyXVel	 ; Apply X Velocity

PRG003_AC19:
	RTS		 ; Return

PRG003_AC1A:
	LDA <Objects_DetStat,X
	AND #$04
	BNE PRG003_AC23	 ; If Boom Boom hit floor, jump to PRG003_AC23

	JSR Object_ApplyXVel	 ; Otherwise, apply X velocity while jumping

PRG003_AC23:
	JSR PRG003_AB78		; Boom Boom flails arms while jumping

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_AC69	 ; If Boom Boom has NOT hit floor, jump to PRG003_AC69 (RTS)

	; Boom Boom hit floor...
	
	LDA Objects_Var2,X
	BEQ PRG003_AC47	 ; If Var2 = 0, jump to PRG003_AC47

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_XVelLimit,Y
	BEQ PRG003_AC44	 ; If Boom Boom is at his X velocity limit, jump to PRG003_AC44

	ADD BoomBoom_XVelAccel,Y	; Boom Boom accelerates towards Player
	STA <Objects_XVel,X	 ; Update X Velocity

	INC Objects_Var3,X	 ; Var3++

PRG003_AC44:
	JMP PRG003_AC4D	 	; Jump to PRG003_AC4D

PRG003_AC47:
	LDA <Counter_1
	AND #$3f
	BEQ BoomBoom_SetXVelTowardsPlayer	 ; Every 64 ticks, move towards Player

PRG003_AC4D:
	LDA <Counter_1
	ADD #$1f	; Offsets counter
	ASL A	
	BNE PRG003_AC69	 ; If offset counter has NOT overflowed, jump to PRG003_AC69 (RTS)

	LDA #$18	 ; A = $18

	LDY World_Num
	BNE PRG003_AC5D	 ; If any world besides 1, jump to PRG003_AC5D

	ASL A		 ; Otherwise, A = $36 (World 1 only difficulty modifier)

PRG003_AC5D:
	STA Objects_Var7,X	 ; Set Var7 (ticks tensed until jump)

	RTS		 ; Return

BoomBoom_SetXVelTowardsPlayer:
	JSR Level_ObjCalcXDiffs	 

	LDA BoomBoom_TowardsPlayerXVel,Y
	STA <Objects_XVel,X

PRG003_AC69: 
	RTS		 ; Return

BoomBoom_FlyXVelLimit:	.byte $20, -$20
BoomBoom_FlyAccel:	.byte $01, -$01
BoomBoom_FlyYVelAccel:	.byte $10, -$10

PRG003_AC70:

	; Flying Boom Boom

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_FlyXVelLimit,Y
	BEQ PRG003_AC80	 ; If flying Boom Boom is at his X velocity limit, jump to PRG003_AC80

	; Flying Boom Boom accelerates
	ADD BoomBoom_FlyAccel,Y
	STA <Objects_XVel,X

PRG003_AC80:
	JSR PRG003_ABC9	 ; Handle Boom Boom hitting against walls

	LDA Objects_Var13,X	; current flight state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word BoomBoom_FlightToPlan	; 0: Plan a flight towards the Player
	.word BoomBoom_ExecuteFlight	; 1: Execute flight

BoomBoom_FlightToPlan:
	JSR Object_ApplyXVel	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDY #$00	 ; Y = 0

	LDA <Objects_Y,X
	CMP #16
	BLT PRG003_AC9C	 ; If Boom Boom's Y < 16, jump to PRG003_AC9C

	INY		 ; Y = 1

PRG003_AC9C:
	LDA <Objects_YVel,X
	CMP BoomBoom_FlyYVelAccel,Y
	BEQ PRG003_ACA9	 ; If Boom Boom is flying at his vertical velocity limit, jump to PRG003_ACA9

	; Otherwise, accelerate flight
	ADD BoomBoom_FlyAccel,Y
	STA <Objects_YVel,X

PRG003_ACA9:
	LDA <Objects_Y,X
	CMP #32
	BGE PRG003_ACC2	 ; If Boom Boom's Y >= 32, jump to PRG003_ACC2

	INC Objects_Var14,X

	LDA Objects_Var14,X
	BNE PRG003_ACC2	 ; If Objects_Var14 <> 0, jump to PRG003_ACC2

	JSR BoomBoom_PlanFlight	 ; Plan a flight towards the Player

	INC Objects_Var13,X	 ; Next flight state

	; timer = $18
	LDA #$18
	STA Objects_Timer,X

PRG003_ACC2:
	LDA #$03	 ; A = 3
	BNE PRG003_ACF0	 ; Jump (technically always) to PRG003_ACF0

BoomBoom_ExecuteFlight:
	LDA Objects_Timer,X
	BEQ PRG003_ACD1	; If timer expired, jump to PRG003_ACD1

	; Set Boom Boom to frame $0C (first frame of flight animation)
	LDA #$0c
	STA Objects_Frame,X

	RTS		 ; Return

PRG003_ACD1:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_Y,X
	CMP #80
	BLT PRG003_ACEE	 ; If Boom Boom's Y < 80, jump to PRG003_ACEE

	; Return to initial flight state
	LDA #$00
	STA Objects_Var13,X

	LDA RandomN,X
	AND #$03
	BNE PRG003_ACEE	 ; Only 1:4 chance we'll proceed, otherwise jump to PRG003_ACEE

	; Set Var6 = $3F
	LDA #$3f
	STA Objects_Var6,X

PRG003_ACEE:
	LDA #$01

PRG003_ACF0:
	AND <Counter_1
	BNE PRG003_AD03	 ; Every other tick, jump to PRG003_AD03 (RTS)

	INC Objects_Frame,X	 ; Frame++

	; Boom Boom's flight animation, frames $0C to $12
	LDA Objects_Frame,X
	CMP #$12
	BLT PRG003_AD03	 ; If Boom Boom's frame < $12, jump to PRG003_AD03

	; Set Boom Boom's frame to $0C
	LDA #$0c
	STA Objects_Frame,X

PRG003_AD03:
	RTS		 ; Return


BoomBoom_FinalAttack:
	INC Objects_Var3,X	 ; Var3++

	JSR PRG003_AB78		 ; Reuse some of Boom Boom's primary attack code

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_AD3E	 ; If Boom Boom hasn't hit the floor, jump to PRG003_AD3E

	LDA Objects_Var2,X
	BEQ PRG003_AD29	 ; If Var2 = 0, jump to PRG003_AD29

	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP BoomBoom_XVelFastLimit,Y
	BEQ PRG003_AD28	 ; If Boom Boom is at his X velocity limit, jump to PRG003_AD28

	ADD BoomBoom_XVelFastAccel,Y	; Boom Boom accelerates towards Player
	STA <Objects_XVel,X	 ; Update X Velocity

	INC Objects_Var3,X	 ; Var3++

PRG003_AD28:
	RTS		 ; Return

PRG003_AD29:
	LDA <Counter_1
	AND #$1f
	BNE PRG003_AD3E	 ; 1:32 ticks proceed, otherwise jump to PRG003_AD3E

	JSR Level_ObjCalcXDiffs

	LDA World_Num
	BNE PRG003_AD39	 ; If World_Num <> 0 (World 1, difficulty modifier), jump to PRG003_AD39

	; Otherwise, Y += 2 (World 1 difficulty modifier)
	INY
	INY

PRG003_AD39:
	; Set Boom Boom's X velocity towards Player as appropriate for direction and world
	LDA BoomBoom_FinalAttackXVel,Y
	STA <Objects_XVel,X

PRG003_AD3E:
	RTS		 ; Return

BoomBoom_PlanFlight:
	LDA #$20 
	JSR BoomBoom_CalcFlightPath	 ; Calculate a flight plan towards the Player

	; Set velocities in accordance with flight plan
	LDA <Temp_Var1
	STA <Objects_YVel,X
	LDA <Temp_Var2
	STA <Objects_XVel,X

	RTS		 ; Return

	; Boom Boom's left arm patterns
BoomBoom_PatternLeft:
	.byte $C9, $D1, $C3, $C3, $CB, $C9, $D5, $DB, $DF, $EB, $C3, $C3, $83, $8B, $71, $83
	.byte $8B, $71, $95, $9B, $A3, $A9

	; Boom Boom's right arm patterns
BoomBoom_PatternRight:
	.byte $C3, $CB, $C9, $C9, $D1, $C3, $D5, $DB, $EB, $DF, $C3, $C3, $83, $8B, $71, $83
	.byte $8B, $71, $95, $9B, $A3, $A9

	; Boom Boom's left arm Y offset
BoomBoom_SprYOffArmLeft:
	.byte $08, $10, $10, $10, $10, $08, $10, $10, $10, $10, $10, $10, $08, $10, $10, $08
	.byte $10, $10, $10, $10, $10, $10

	; Boom Boom's right arm Y offset
BoomBoom_SprYOffArmRight:
	.byte $10, $10, $08, $08, $10, $10, $10, $10, $10, $10, $10, $10, $08, $10, $10, $08
	.byte $10, $10, $10, $10, $10, $10

	.byte $00, $02, $08, $0E, $10, $0E, $08, $02, $04, $03, $00, $03, $04, $07, $08, $07

PRG003_ADB5:
	RTS

BoomBoom_Draw:

	; Copy horizontal visibility -> Temp_VarNP0
	LDA Objects_SprHVis,X
	STA Temp_VarNP0

	LDA <Objects_Y,X
	PHA		 ; Save Boom Boom's Y

	LDA Objects_Var7,X
	BEQ PRG003_ADC8	 ; If Var7 = 0, jump to PRG003_ADC8

	; Draw +2 pixels down
	INC <Objects_Y,X
	INC <Objects_Y,X

PRG003_ADC8:
	LDA <Objects_X,X
	PHA		 ; Save Boom Boom's X

	ADD #$08	 
	STA <Objects_X,X ; Object's X += 8

	LDA <Objects_XHi,X
	PHA		 ; Save Boom Boom's X Hi
	ADC #$00		; Apply carry
	STA <Objects_XHi,X	; Update X Hi

	ASL Objects_SprHVis,X

	JSR Object_DrawTallAndHFlip	 ; Draw large, mirrored sprite

	; Restore X Hi
	PLA
	STA <Objects_XHi,X

	; Restore X
	PLA
	STA <Objects_X,X

	; Restore Y
	PLA
	STA <Objects_Y,X

	; Beginning of arm drawing logic

	JSR Object_CalcSpriteXY_NoHi
	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_SprVVis,X
	BNE PRG003_ADB5	 ; If any sprite is vertically off-screen, jump to PRG003_ADB5 (RTS)

	; Temp_Var1 = Sprite Y
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; X = frame
	LDA Objects_Frame,X
	TAX

	LDA Temp_VarNP0
	BMI PRG003_AE07	 ; If this sprite is off-screen, jump to PRG003_AE07

	; Add offset to sprite Y
	LDA <Temp_Var1
	ADD BoomBoom_SprYOffArmLeft,X
	STA Sprite_RAM+$10,Y

PRG003_AE07:
	LDA Temp_VarNP0
	AND #$10
	BNE PRG003_AE17	 ; If the other side sprite is off-screen, jump to PRG003_AE17

	; Add offset to sprite Y
	LDA <Temp_Var1
	ADD BoomBoom_SprYOffArmRight,X
	STA Sprite_RAM+$14,Y

PRG003_AE17:
	LDA BoomBoom_PatternLeft,X
	STA Sprite_RAM+$11,Y

	LDA BoomBoom_PatternRight,X
	STA Sprite_RAM+$15,Y

	; Copies attributes across
	LDA Sprite_RAM+$02,Y
	STA Sprite_RAM+$12,Y

	; Horizontal flag
	ORA #SPR_HFLIP
	STA Sprite_RAM+$16,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	; Temp_Var2 = Sprite X
	LDA <Objects_SpriteX,X
	STA <Temp_Var2	

	; Set Sprite Xs
	STA Sprite_RAM+$13,Y
	ADD #24
	STA Sprite_RAM+$17,Y

	RTS		 ; Return

BoomBoom_HitTest:
	JSR Object_HandleBumpUnderneath	 ; Hm, Boom Boom handles getting bumped underneath?

	LDA Objects_PlayerHitStat,X
	BEQ PRG003_AE87	 ; If Player is not hitting Boom Boom at all, jump to PRG003_AE87 (RTS)

	LDA Objects_Frame,X
	CMP #$07
	BNE PRG003_AE50	 ; If Boom Boom's frame <> 7 (Spiky Shell), jump to PRG003_AE50

	JMP Player_HurtIfNotDieOffBehind	 ; Hurt Player and don't come back!

PRG003_AE50: 
	LDA <Player_YVel
	BMI PRG003_AE87	 ; If Player is moving upward, jump to PRG003_AE87 (RTS)

	; Play squish sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Get 1000, 2000, or 4000 points
	LDA <Objects_Var5,X
	ADD #$07
	JSR Score_PopUp

	; Player Y Vel = -$30 (bounce off)
	LDA #-$30
	STA <Player_YVel

	LDA <Objects_Var5,X
	INC <Objects_Var5,X	; Var5++ (Next internal state)
	CMP #$04	 
	BEQ PRG003_AE82	 ; If next up is internal state 4 (Death), jump to PRG003_AE82

	; Halt Boom Boom's movement
	LDA #$00
	STA <Objects_YVel,X
	STA <Objects_XVel,X

	; Clear Var7 and Var3
	STA Objects_Var7,X
	STA Objects_Var3,X

	; Timer2 = $30 (ticks till he gets back up)
	LDA #$30
	STA Objects_Timer2,X

	RTS		 ; Return

PRG003_AE82:

	; Object's timer = $80
	LDA #$80
	STA Objects_Timer,X

PRG003_AE87:
	RTS		 ; Return

BoomBoom_Death:
	LDA #$08 
	STA Objects_SprHVis,X	; ??
	STA Objects_Frame,X	; Set Boom Boom's frame = 8

	LDA Objects_Timer,X
	BNE PRG003_AEE3	 ; If timer not expired, jump to PRG003_AEE3

PRG003_AE95:
	STA Objects_FlipBits,X	; Update flip bits

	; Boom Boom becomes the "(?)" ball
	LDA #OBJ_BOOMBOOMQBALL
	STA Level_ObjectID,X

	LDA #$01
	STA BrickBust_En	 ; Enable brick bust slot 1
	STA Level_TimerEn	 ; Halt the level timer

	; Brick bust slot 1 "half" enable
	LDA #$1f
	STA BrickBust_HEn

	; Relative Y -> BrickBust_YUpr
	LDA <Objects_Y,X
	SUB Level_VertScroll
	STA BrickBust_YUpr

	; +8 to center the ball
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X

	PHP		 ; Save CPU state (the carry bit)

	; Relative X -> BrickBust_X
	SUB <Horz_Scroll
	STA BrickBust_X

	PLP		 ; Restore CPU state (the carry bit)

	; Apply carry
	LDA <Objects_XHi,X
	ADC #$00
	STA <Objects_XHi,X

	LDA #$00
	STA <Objects_XVel,X	; Stop any movement
	STA <Objects_Var5,X	; Var5 = 0
	STA Objects_Frame,X	; Frame = 0

	; Ball bounces up a bit
	LDA #-$38
	STA <Objects_YVel,X

	; Play ba-boom sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	JSR SetRotatingColor	 ; Litle light show

	JMP Explode_Stars	; Jump to Explode_Stars and don't come back

PRG003_AEE3:
	STA Objects_ColorCycle,X	; Timer -> color cycle

	RTS		 ; Return

Star_Vel:
	.byte -$20, -$17, $00, $17, $20, $17, $00, -$17
Star_VelEnd

Explode_Stars:
	LDY #(Star_VelEnd - Star_Vel - 1)

PRG003_AEF1:
	; Explosion star
	LDA #SOBJ_EXPLOSIONSTAR
	STA SpecialObj_ID,Y

	; Star X +4
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Star Y +16
	LDA <Objects_Y,X
	ADD #16
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,X

	; Set Y velocity
	LDA Star_Vel,Y
	STA SpecialObj_YVel,Y

	; X is rotated around by offset
	TYA
	ADD #$02
	AND #$07
	TAX

	; Set X velocity
	LDA Star_Vel,X
	STA SpecialObj_XVel,Y

	; SpecialObj_Timer = $3F
	LDA #$3F
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	DEY		 ; Y--
	BPL PRG003_AEF1	; While Y >= 0, loop!

	RTS		 ; Return

ObjInit_PiranhaSidewaysR:
	; Right-way piranha +16 X (basically start outside of pipe instead of inside)
	LDA #16
	ADD <Objects_X,X
	STA <Objects_X,X

ObjInit_PiranhaSidewaysL:

	; Start X + 1 over
	LDA <Objects_X,X
	ADD #$01
	STA <Objects_Var5,X

	; Start Y + 7 over
	LDA <Objects_Y,X
	ADD #$07
	STA <Objects_Y,X

	RTS		 ; Return


ObjNorm_PiranhaSideways:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JSR SidePiranha_Draw	 ; Draw piranha
	JSR Player_HitEnemy	 ; Player to piranha collision

	LDA <Player_HaltGame
	BNE PRG003_AF9C	 ; If gameplay halted, jump to PRG003_AF9C

	; Var3 is the animation timer; toggles frame 0 and 1 every 8 ticks
	INC Objects_Var3,X	; Var3++
	LDA Objects_Var3,X
	LDY #$00	 ; Y = 0
	AND #$08	 
	BEQ PRG003_AF60	 ; 8 ticks on, 8 ticks off; jump to PRG003_AF60
	INY		 ; Y = 1
PRG003_AF60:
	TYA		 
	STA Objects_Frame,X	 ; Update frame

	; Perform the state action of Var4 (0-3)
	LDA <Objects_Var4,X
	AND #$03
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word SidePiranha_HideInPipe	; Piranha hides in pipe until timer expires
	.word SidePiranha_Emerge	; Piranha emerges from pipe
	.word SidePiranha_Chomp		; Piranha sits there and chomps for a bit
	.word SidePiranha_Receed	; Piranha goes back into pipe

SidePiranha_Emerge:
	LDA <Objects_Var5,X
	SUB #25
	CMP <Objects_X,X
	BGE PRG003_AF95	 ; If (Var5 - 25) >= Piranha's X, jump to PRG003_AF95

	LDA #-$10	; Leftward moving piranha
	BNE PRG003_AF8B	 ; Jump (technically always) to PRG003_AF8B

SidePiranha_Receed:
	LDA <Objects_X,X
	ADD #$01
	CMP <Objects_Var5,X
	BGE PRG003_AF95	 ; If piranha's X >= Var5, jump to PRG003_AF95

	LDA #$10	; Rightward moving piranha

PRG003_AF8B:
	STA <Objects_XVel,X	 ; Update X velocity

	JMP Object_ApplyXVel	 ; Apply X velocity and don't come back!

SidePiranha_Chomp:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

PRG003_AF95:
	INC <Objects_Var4,X	 ; Var4++ (next internal state)

	; Reset timer to $38
	LDA #$38
	STA Objects_Timer,X

PRG003_AF9C:
	RTS		 ; Return

SidePiranha_HideInPipe:
	LDA Objects_Timer,X
	BNE PRG003_AFA4	 ; If timer not expired, jump to PRG003_AFA4 (RTS)

	BEQ PRG003_AF95	 ; Otherwise, jump to PRG003_AF95

PRG003_AFA4:
	RTS		 ; Return

SidePiranha_EndSprXOff:
	.byte 16, 0

SidePiranha_Draw:
	LDA #$20	 ; A = $20 (leftward piranha attributes)

	LDY Level_ObjectID,X
	CPY #OBJ_PIRANHASIDEWAYSLEFT
	BEQ PRG003_AFB2	 ; If this is a leftward piranha, jump to PRG003_AFB2

	LDA #$60	 ; A = $60 (rightward piranha attributes)

PRG003_AFB2:
	STA Objects_FlipBits,X	 ; Set piranha attributes

	LDA <Objects_X,X
	PHA		 ; Save piranha's X

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG003_AFC9	 ; If piranha is not horizontally flipped, jump to PRG003_AFC9

	ASL Objects_SprHVis,X

	; Piranha's X += 8 (Piranha is 24 pixels wide, of which there's no routine for exactly)
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X

PRG003_AFC9:
	JSR Object_ShakeAndDraw	 ; Draw most of piranha

	PLA		 ; Restore 'X'
	STA <Objects_X,X	 ; -> 'X'

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	AND #SPR_HFLIP
	BEQ PRG003_AFDC	 ; If piranha is NOT horizontally flipped, jump to PRG003_AFDC

	INY		 ; Y = 1

PRG003_AFDC:
	LDA <Objects_SpriteX,X	 ; Get piranha's sprite X
	ADD SidePiranha_EndSprXOff,Y
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X for piranha's remaining bit

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Set sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y

	; Temp_Var1 = vertical visibility
	LDA Objects_SprVVis,X
	STA <Temp_Var1

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1
	BCS PRG003_AFFA	 ; If piranha's last bit isn't vertically visible, jump to PRG003_AFFA

	STA Sprite_RAM+$10,Y	 ; Otherwise, set the Y

PRG003_AFFA:
	LDA Sprite_RAM+$02,Y	; Get attribute value from earlier piranha segment
	AND #~$03		; Clear palette select
	ORA #SPR_PAL2		; Set palette select 2
	STA Sprite_RAM+$12,Y	; -> Sprite's attribute

	; Use pattern $85
	LDA #$85
	STA Sprite_RAM+$11,Y

	RTS		 ; Return

LavaLotus_RightEdgePatTop:	.byte $C1, $C9, $D1
LavaLotus_RightEdgePatBottom:	.byte $C3, $CB, $D3

ObjNorm_LavaLotus:
	JSR Object_CheckIfNormalState
	BNE PRG003_B05F	 ; If not in normal state, jump to PRG003_B05F

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BNE PRG003_B05F		; If gameplay is halted, jump to PRG003_B05F

	JSR Player_HitEnemy	 ; Player to Lava Lotus collision

	LDA Objects_SprHVis,X
	AND #%11100000
	CMP #%11100000
	BNE PRG003_B030	 ; If the Lava Lotus does not have three horizontally off-screen sprites, jump to PRG003_B030

	; Var5 = $FF
	LDA #$ff
	STA <Objects_Var5,X

	; Var4 = $05
	LDA #$05
	STA <Objects_Var4,X

PRG003_B030:
	DEC <Objects_Var5,X	 ; Var5--

	LDA <Objects_Var5,X
	CMP #$50
	BLT PRG003_B056	 ; If Var5 < $50, jump to PRG003_B056

	LDY #$00	 ; Y = 0

	AND #%00001100
	BEQ PRG003_B03F	 ; Periodically jump to PRG003_B03F
 
	INY		 ; Y = 1

PRG003_B03F:
	TYA		 
	STA Objects_Frame,X	 ; Set frame 0/1

	LDA Level_NoStopCnt
	AND #$1f
	BNE PRG003_B053	 ; 1:32 ticks proceed, otherwise, jump to PRG003_B053

	LDA <Objects_Var4,X
	BEQ PRG003_B053	 ; If Var4 = 0, jump to PRG003_B053

	DEC <Objects_Var4,X	 ; Var4--

	JSR LavaLotus_SpitFire	 ; Spit a fireball

PRG003_B053:
	JMP PRG003_B05F	; Jump to PRG003_B05F

PRG003_B056:

	; Var4 = 5
	LDA #$05
	STA <Objects_Var4,X

	; Frame = 2 (open lotus)
	LDA #$02
	STA Objects_Frame,X

PRG003_B05F:
	; Clear flip bits
	LDA #$00
	STA Objects_FlipBits,X

	; Draw most of lotus
	JSR Object_Draw16x32Sprite

	LDA Objects_SprHVis,X
	AND #%00100000
	BNE PRG003_B0B1	 ; If edge sprite of lotus is off-screen, jump to PRG003_B0B1 (RTS)

	; Need to draw one more sprite for lotus...

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Right edge sprite, so +16
	LDA <Objects_SpriteX,X
	ADD #16
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Vertical off-screen bits -> Temp_Var1
	LDA Objects_SprVVis,X
	STA <Temp_Var1

	LDA <Objects_SpriteY,X
	LSR <Temp_Var1	
	BCS PRG003_B08A	 ; If this sprite is vertically off-screen, jump to PRG003_B08A

	STA Sprite_RAM+$10,Y	 ; Store this sprite's Y

PRG003_B08A:
	LSR <Temp_Var1
	BCS PRG003_B094	 ; If this sprite is vertically off-screen, jump to PRG003_B08A

	ADD #16
	STA Sprite_RAM+$14,Y	 ; Store this sprite's Y

PRG003_B094:
	LDA Sprite_RAM+$02,Y	 ; Get sprite attributes from left edge
	ORA #SPR_HFLIP
	STA Sprite_RAM+$12,Y	 ; Horizontally flipped compared to left edge
	STA Sprite_RAM+$16,Y	 ; Horizontally flipped compared to left edge

	LDA Objects_Frame,X
	TAX
	LDA LavaLotus_RightEdgePatTop,X	
	STA Sprite_RAM+$11,Y	 ; Set top pattern

	LDA LavaLotus_RightEdgePatBottom,X
	STA Sprite_RAM+$15,Y	 ; Set bottom pattern

	LDX <SlotIndexBackup		 ; X = object slot index

PRG003_B0B1:
	RTS		 ; Return

LavaLotusFire_XOff:	.byte $03, $0D, $06, $0B, $08
LavaLotusFire_XVel:	.byte $FB, $05, $FD, $03, $00
LavaLotusFire_YVel:	.byte $F5, $F5, $F0, $F0, $EE

LavaLotus_SpitFire:
	JSR Object_AnySprOffscreen
	BNE PRG003_B0D0	 ; If any part of Lava Lotus is off-screen, jump to PRG003_B0D0 (RTS)

	LDY #$07	 ; Y = 7

	; This loop really could be replaced by 
	;JSR SpecialObj_FindEmptyAbortY

PRG003_B0C8:
	LDA SpecialObj_ID,Y
	BEQ PRG003_B0D1	 ; If this special object slot is free, jump to PRG003_B0D1

	DEY		 ; Y--
	BPL PRG003_B0C8	; If Y >= 0, loop!

PRG003_B0D0:
	RTS		 ; Return

PRG003_B0D1:

	; Lava Lotus fireball
	LDA #SOBJ_LAVALOTUSFIRE
	STA SpecialObj_ID,Y

	LDA #$c0
	STA SpecialObj_Var2,Y

	; Fireball at Y + 7
	LDA <Objects_Y,X
	ADD #$07
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA SpecialObj_YHi,Y

	; Temp_Var1 = Var4 (which fireball we're on)
	LDA <Objects_Var4,X
	STA <Temp_Var1

	; Fireball X
	LDA <Objects_X,X
	CLC	
	LDX <Temp_Var1		 ; X = Temp_Var1 (Var4)
	ADC LavaLotusFire_XOff,X
	STA SpecialObj_XLo,Y

	; Fireball Y velocity
	LDA LavaLotusFire_YVel,X
	STA SpecialObj_YVel,Y

	; Fireball X velocity
	LDA LavaLotusFire_XVel,X
	STA SpecialObj_XVel,Y

	; Fireball data = 1
	LDA #$01
	STA SpecialObj_Data,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	; Store parent's object index into SpecialObj_Var1
	TXA
	STA SpecialObj_Var1,Y

	RTS		 ; Return

ObjInit_LavaLotus:

	; Var5 = $FF
	LDA #$ff
	STA <Objects_Var5,X

	; Var4 = 5
	LDA #$05
	STA <Objects_Var4,X

	; Mark object as in water
	INC Objects_InWater,X

ObjInit_WaterCurrent:
	RTS		 ; Return

CurrentUpward_YAccel:	.byte -$03, -$03, -$02, -$01, $00, $00, $00, $00, $00
CurrentDownward_YAccel:	.byte  $03,  $02,  $01,  $00, $00, $00, $00, $00, $00

ObjNorm_WaterCurrent:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	JSR Object_AnySprOffscreen
	ORA <Player_HaltGame
	BNE PRG003_B197	 ; If object falls off-screen or gameplay is halted, jump to PRG003_B197

	JSR Level_ObjCalcXDiffs

	LDA <Temp_Var16
	ADD #$08
	CMP #$20
	BGE PRG003_B18C	 ; If Player is not close enough, jump to PRG003_B18C

	JSR Level_ObjCalcYDiffs

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B157	 ; If this is a downward current, jump to PRG003_B157

	; For upward current...

	; Negate Temp_Var16
	LDA <Temp_Var16	
	JSR Negate	
	STA <Temp_Var16	
	DEY		 ; Y-- (change direction)

PRG003_B157:
	CPY #$00
	BNE PRG003_B18C	 ; If Player is on wrong side of current object, jump to PRG003_B18C

	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = index relative of Player's Y offset

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BNE PRG003_B177	 ; If this is not a downard current, jump to PRG003_B177

	; Downward current...

	LDA <Player_YVel
	CMP #$3b
	BGS PRG003_B18C	 ; If Player's Y velocity >= $3B, jump to PRG003_B18C

	ADD CurrentDownward_YAccel,Y	 ; Push Player downward

	JMP PRG003_B186	 ; Jump to PRG003_B186

PRG003_B177:
	LDA Player_HitCeiling
	BNE PRG003_B18C	 ; If Player just hit off ceiling, jump to PRG003_B18C

	LDA <Player_YVel
	CMP #-$3C
	BMI PRG003_B18C	 ; If Player's Y velocity is already moving faster than -$3C, jump to PRG003_B18C

	ADD CurrentUpward_YAccel,Y	 ; Push Player upward

PRG003_B186:
	STA <Player_YVel	; Update Player's Y velocity

	; Flag Player as mid-air
	LDA #$01
	STA <Player_InAir

PRG003_B18C:
	INC <Objects_Var5,X	 ; Var5++

	LDA <Objects_Var5,X
	AND #$0f
	BNE PRG003_B197	 ; 1:16 ticks proceed, otherwise jump to PRG003_B197

	JSR Current_GenerateBubble	; Generate a bubble

PRG003_B197:
	RTS		 ; Return

Current_GenerateBubble:
	LDY #$01
	JSR SpecialObj_FindEmptyAbortY	; Find a free special object in one of the first two slots or don't come back!

	; SpecialObj_Timer = $28
	LDA #$28
	STA SpecialObj_Timer,Y

	; A bubble
	LDA #SOBJ_BUBBLE
	STA SpecialObj_ID,Y

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,Y

	STY <Temp_Var1	 ; Special object index -> Temp_Var1

	; Apply a bit of randomness to the bubble's X
	TYA
	ADC RandomN,Y
	AND #$17
	ADD <Objects_X,X
	LDY <Temp_Var1		 ; Y = special object index
	STA SpecialObj_XLo,Y	 ; Store slightly random adjusted X -> Bubble X

	LDA Level_ObjectID,X
	CMP #OBJ_WATERCURRENTDOWNARD
	BEQ PRG003_B1D7	 ; If this is a downard current, jump to PRG003_B1D7

	; Bubble appears at Y - 8
	LDA <Objects_Y,X
	SBC #$08
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = -$80
	LDA #-$80
	STA SpecialObj_YVel,Y

	RTS		 ; Return

PRG003_B1D7:
	; Bubble appears at Y + 3
	LDA <Objects_Y,X
	ADC #$03
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X	; Bug? They don't apply the carry (ADC) here!
	STA SpecialObj_YHi,Y

	; Bubble's Y velocity = $7F
	LDA #$7f
	STA SpecialObj_YVel,Y

	RTS		 ; Return

ObjInit_BigBerthaBirther:
	INC Objects_InWater,X	 ; Flag as in water

	; Objects_Var10 = X
	LDA <Objects_X,X
	STA Objects_Var10,X

	; Objects_Var11 = X Hi
	LDA <Objects_XHi,X
	STA Objects_Var11,X

PRG003_B1F6:
	RTS		 ; Return

BigBerthaLCC_XVelAccel:		.byte $01, -$01
BigBerthaLCC_XVelLimit:		.byte $18, -$18
BigBerthaLCC_XVelLowLimit:	.byte $08, -$08

ObjNorm_BigBerthaBirther:
	JSR Object_CheckIfNormalState
	BEQ PRG003_B205	 ; If Big Bertha's in normal state, jump to PRG003_B205

	JMP BigBerthaLCC_Draw	 ; Jump to BigBerthaLCC_Draw

PRG003_B205:
	JSR Object_SetHFlipByXVel 	; Set horizontal flip by travel direction
	JSR BigBerthaLCC_Draw	 	; Draw Big Bertha
	JSR Object_DeleteOffScreen_N2	; If Big Bertha falls off-screen, delete it!

	LDA <Player_HaltGame
	BNE PRG003_B1F6	 ; If gameplay is halted, jump to PRG003_B1F6 (RTS)

	INC <Objects_Var5,X	 ; Var5++

	JSR Player_HitEnemy	 ; Player to Bertha collision
	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

	LDY #$02	 ; Y = $02

	LDA <Counter_1
	AND #$40
	BEQ PRG003_B227	 ; 64 ticks on, 64 ticks off; jump to PRG003_B227

	LDY #-$02	 ; Y = -$02

PRG003_B227:
	STY <Objects_YVel,X	 ; Y Velocity = $02 or -$02

	LDA Objects_Timer,X
	BEQ PRG003_B250	 ; If timer expired, jump to PRG003_B250

	CMP #$01
	BNE PRG003_B23A	 ; If timer <> 1, jump to PRG003_B23A

	JSR Object_AnySprOffscreen
	BNE PRG003_B23F	 ; If any part of Big Bertha has fallen off-screen, jump to PRG003_B23F

	JSR BigBertha_SpitOutCheepCheep	 ; Big Bertha spits out the little Cheep Cheep

PRG003_B23A:

	; Big Bertha frame 1
	LDA #$01
	STA Objects_Frame,X

PRG003_B23F:
	LDA <Objects_XVel,X
	BEQ PRG003_B24B	 ; If Big Bertha is not moving, jump to PRG003_B24B

	BPL PRG003_B249	 ; If Big Bertha is moving to the right, jump to PRG003_B249

	; Double increment because it hits the decrement, basically a single increment
	INC <Objects_XVel,X	; Moving left, slow down
	INC <Objects_XVel,X

PRG003_B249:
	DEC <Objects_XVel,X	; Moving right, slow down

PRG003_B24B:
	RTS		 ; Return

BigBertha_XMove:	.byte -$10, $10
BigBertha_XHiMove:	.byte $FF, $00

PRG003_B250:
	LDA <Objects_Var5,X
	LSR A
	BCC PRG003_B2A4	 ; If Var5 is even, jump to PRG003_B2A4

	LDA Objects_Var7,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Objects_Var10 is Big Bertha's original X
	LDA Objects_Var10,X
	ADD BigBertha_XMove,Y
	STA <Temp_Var2	

	; Objects_Var11 is Big Bertha's original X Hi
	LDA Objects_Var11,X
	ADC BigBertha_XHiMove,Y
	STA <Temp_Var1	

	LDY #$00	 ; Y = 0

	LDA <Objects_X,X
	CMP <Temp_Var2	

	LDA <Objects_XHi,X
	SBC <Temp_Var1	
	BLT PRG003_B279	 ; If Big Bertha is to the left of origin, jump to PRG003_B279

	INY		 ; Y = 1

PRG003_B279:
	LDA <Objects_XVel,X
	CMP BigBerthaLCC_XVelLimit,Y
	BEQ PRG003_B28B	 ; If Big Bertha is at X velocity limit, jump to PRG003_B28B

	ADD BigBerthaLCC_XVelAccel,Y
	STA <Objects_XVel,X	 ; Update X velocity

	BNE PRG003_B28B	 ; If X velocity is not at zero, jump to PRG003_B28B

	INC Objects_Var7,X	 ; Otherwise, Var7++

PRG003_B28B:
	CMP BigBerthaLCC_XVelLowLimit,Y
	BNE PRG003_B2A4	 ; If Big Bertha is at low limit, jump to PRG003_B2A4

	LDA Objects_Timer3,X
	BNE PRG003_B2A4	 ; If timer 3 not expired, jump to PRG003_B2A4

	LDA RandomN,X
	BPL PRG003_B2A4	 ; Random 50/50, jump to PRG003_B2A4

	; Set timer to $26
	LDA #$26
	STA Objects_Timer,X

	; Set timer to $80
	LDA #$80
	STA Objects_Timer3,X

PRG003_B2A4:
	RTS		 ; Return

BigBertha_HVisByFlip:	.byte $20, $80
BigBertha_SpriteXOff:	.byte $10, $00

BigBerthaLCC_Draw:

	; Save Big Bertha's X/Hi
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA

	LDA Objects_SprHVis,X
	STA Temp_VarNP0	 ; Store horizontal visibility bits -> Temp_VarNP0

	LDA Objects_FlipBits,X
	ASL A
	BEQ PRG003_B2CB	 ; If Big Bertha is NOT horizontally flipped, jump to PRG003_B2CB

	ASL Objects_SprHVis,X

	; Move over 8 pixels
	LDA <Objects_X,X
	ADD #$08
	STA <Objects_X,X
	LDA <Objects_XHi,X
	ADC #$00
	STA <Objects_XHi,X

PRG003_B2CB:
	JSR Object_Draw16x32Sprite	 ; Draw part of Big Bertha

	; Restore Big Bertha's X/Hi
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	JSR Object_CalcSpriteXY_NoHi

	LDY #$00	 ; Y = 0

	LDA Objects_FlipBits,X
	ASL A
	BEQ PRG003_B2E0	 ; If Big Bertha is NOT horizontally flipped, jump to PRG003_B2E0

	INY		 ; Y = 1

PRG003_B2E0:
	LDA Temp_VarNP0
	AND BigBertha_HVisByFlip,Y
	BNE PRG003_B341	 ; If check sprite for Big Bertha is off-screen, jump to PRG003_B341 (RTS)

	; Calculate Sprite X with appropriate offset
	LDA <Objects_SpriteX,X
	ADD BigBertha_SpriteXOff,Y
	STA <Temp_Var2	

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Store sprite Xs
	LDA <Temp_Var2
	STA Sprite_RAM+$13,Y
	STA Sprite_RAM+$17,Y

	; Temp_Var1 = Sprite vertical visibility bits
	LDA Objects_SprVVis,X
	STA <Temp_Var1	

	LDA <Objects_SpriteY,X	
	LSR <Temp_Var1
	BCS PRG003_B309	 ; If this sprite is vertically off-screen, jump to PRG003_B309

	STA Sprite_RAM+$10,Y	 ; Otherwise, store Sprite Y

PRG003_B309:
	LSR <Temp_Var1
	BCS PRG003_B312	 ; If this sprite is vertically off-screen, jump to PRG003_B312

	ADC #16
	STA Sprite_RAM+$14,Y	 ; Otherwise, store Sprite Y

PRG003_B312:
	; Copy attributes across
	LDA Sprite_RAM+$02,Y
	STA Sprite_RAM+$12,Y
	STA Sprite_RAM+$16,Y

	; Store pattern
	LDA #$85
	STA Sprite_RAM+$11,Y

	LDA <Objects_Var5,X
	LSR A
	LSR A
	LSR A

	; Select appropriate pattern by animation frame
	LDA #$8b
	BCS PRG003_B32B	
	LDA #$91
PRG003_B32B:
	; Store pattern
	STA Sprite_RAM+$15,Y

	LDA Objects_FlipBits,X
	BPL PRG003_B341	 ; If Big Bertha is not vertically flipped, jump to PRG003_B341

	; Otherwise swap Sprite Ys
	LDA Sprite_RAM+$10,Y
	PHA
	LDA Sprite_RAM+$14,Y
	STA Sprite_RAM+$10,Y
	PLA
	STA Sprite_RAM+$14,Y

PRG003_B341:
	RTS		 ; Return

TinyCheep_XVel:	.byte -$28, $28
TinyCheep_XOff:	.byte $00, $08
TinyCheep_Flip:	.byte $00, SPR_HFLIP


BigBertha_SpitOutCheepCheep:
	LDY #$04	 ; Y = 4
PRG003_B34A:
	LDA Objects_State,Y
	BEQ PRG003_B353	 ; If this object slot is dead/empty, jump to PRG003_B353

	DEY		 ; Y--
	BPL PRG003_B34A	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG003_B353:
	TYA		 
	TAX		 ; X = open object slot index

	JSR Level_PrepareNewObject

	LDX <SlotIndexBackup		 ; X = object slot index

	; Set to normal state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,Y

	; This is the tiny Cheep Cheep that comes out of Big Bertha
	LDA #OBJ_TINYCHEEPCHEEP
	STA Level_ObjectID,Y

	; Cheep Cheep emerges at +14
	LDA <Objects_Y,X
	ADC #14
	STA Objects_Y,Y
	LDA <Objects_YHi,X
	ADC #$00
	STA Objects_YHi,Y

	; Temp_Var1 = 0
	LDA #$00
	STA <Temp_Var1

	LDA Objects_FlipBits,X
	BEQ PRG003_B37D	 ; If Big Bertha is not flipped, jump to PRG003_B37D

	INC <Temp_Var1	 ; Otherwise, Temp_Var1 = 1

PRG003_B37D:
	LDA <Objects_X,X
	LDX <Temp_Var1		 ; X = 0 or 1
	ADC TinyCheep_XOff,X
	STA Objects_X,Y	 ; Set Tiny Cheep Cheep's X

	; Set tiny Cheep Cheep's X velocity
	LDA TinyCheep_XVel,X
	STA Objects_XVel,Y

	; Set tiny Cheep Cheep's flip
	LDA TinyCheep_Flip,X
	STA Objects_FlipBits,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	; Set tiny Cheep Cheep's X Hi
	LDA <Objects_XHi,X
	ADC #$00
	STA Objects_XHi,Y

	; Set tiny Cheep Cheep palette select 1 and flag as under water
	LDA #SPR_PAL1
	STA Objects_SprAttr,Y
	STA Objects_InWater,Y

	; Tiny Cheep Cheep's Var1 holds Big Bertha's object index
	TXA
	STA Objects_Var1,Y

	; Timer set to $30
	LDA #$30
	STA Objects_Timer,Y

	RTS		 ; Return

TinyCheepCheep_XVelLimit:	.byte $08, -$08
PRG003_B3B0:	.byte $FF, $01

ObjNorm_TinyCheepCheep:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	; Toggle frame by counter
	LDA Level_NoStopCnt
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	LDA <Player_HaltGame
	BNE PRG003_B439	 ; If gameplay is halted, jump to PRG003_B439

	LDY #$02	 ; Y = $02

	LDA <Counter_1
	AND #$10
	BEQ PRG003_B3CD	 ; Every 1:16 ticks, jump to PRG003_B3CD

	LDY #-$02	 ; Y = -$02

PRG003_B3CD:
	STY <Objects_YVel,X	 ; Set Y velocity

	LDY #$00	 ; Y = 0 (moving to the right)

	LDA <Objects_XVel,X
	BPL PRG003_B3D6	 ; If moving to the right, jump to PRG003_B3D6

	INY		 ; Y = 1 (moving to the left)

PRG003_B3D6:
	CMP TinyCheepCheep_XVelLimit,Y 
	BEQ PRG003_B3E1	 ; If hit the limit, jump to PRG003_B3E1

	ADD PRG003_B3B0,Y	 ; Accelerate
	STA <Objects_XVel,X	 ; Update X Vel

PRG003_B3E1:
	JSR Object_ApplyXVel	 	; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	; Apply Y velocity
	JSR Player_HitEnemy		; Player interaction with enemy

	LDA Objects_Timer,X
	BNE PRG003_B439	 ; If timer not expired, jump to PRG003_B439

	; Timer expired...

	LDY Objects_Var1,X	 ; Y = Var1 (parent Big Birtha Birther)

	LDA Objects_State,Y
	CMP #OBJSTATE_NORMAL
	BNE PRG003_B42E	 ; If Big Birtha Birther's state is not Normal, jump to PRG003_B42E
 
	LDA Level_ObjectID,Y	
	CMP #OBJ_BIGBERTHABIRTHER
	BNE PRG003_B42E	 ; If this is no longer a Big Bertha Birther, jump to PRG003_B42E

	LDA <Objects_X,X
	SBC Objects_X,Y
	STA <Temp_Var1		 ; Temp_Var1 = difference between the little Cheep's position and Big Bertha

	ADC #$20
	CMP #$48
	BGE PRG003_B439	 ; If too far right, jump to PRG003_B439

	LDA <Temp_Var1
	ADC #$08
	CMP #$18
	BGE PRG003_B41E	 ; If too far left, jump to PRG003_B41E

	JSR Object_SetDeadEmpty	 ; Eradicate the Cheep Cheep
	STA Objects_Frame,Y	 ; Clear the frame (?)

	JMP PRG003_B439	 ; Jump to PRG003_B439

PRG003_B41E:
	LDA #$08	 ; A = $08

	LDY <Temp_Var1	 ; Y = Temp_Var1
	BMI PRG003_B426	 ; If Temp_Var1 (difference) is negative, jump to PRG003_B426

	LDA #-$08	 ; A = -$08

PRG003_B426:
	ADD <Objects_XVel,X	 ; Add to X velocity
	STA <Objects_XVel,X	 ; Update X Velocity

	JMP PRG003_B439	 ; Jump to PRG003_B439

PRG003_B42E:
	LDA #$08	 ; A = $08

	LDY Objects_FlipBits,X
	BNE PRG003_B437	 ; If not horizontally flipped, jump to PRG003_B437

	LDA #-$08	 ; A = -$08

PRG003_B437:
	STA <Objects_XVel,X	 ; Update X Velocity

PRG003_B439:
	JMP Object_ShakeAndDraw	; Draw object and don't come back!

CheepCheepHopper_InitXVel:	.byte $0C, -$0C

ObjInit_CheepCheepHopper:
	JSR Level_ObjCalcXDiffs

	; Set hopper's initial X velocity
	LDA CheepCheepHopper_InitXVel,Y
	STA <Objects_XVel,X

ObjInit_TinyCheepCheep:
	RTS		 ; Return


ObjNorm_CheepCheepHopper:
	JSR Object_DeleteOffScreen	; Delete object if it falls too far off-screen
	JSR Object_SetHFlipByXVel 	; Set horizontal flip by travel direction
	JSR Object_ShakeAndDraw	 	; Draw Cheep Chep

	LDA <Player_HaltGame
	BNE PRG003_B47A	 ; If gameplay is halted, jump to PRG003_B47A

	JSR Object_Move	 	; Do standard movements
	JSR Player_HitEnemy	 ; Player to Cheep Cheep collision

	LDA Objects_InWater,X
	BEQ PRG003_B471	 	; If Cheep Cheep is NOT in water, jump to PRG003_B471

	JSR Level_ObjCalcXDiffs	

	LDY #-$30	 ; Y = -$30

	LDA <Temp_Var16
	ADD #$40
	CMP #$80
	BGE PRG003_B46F	 ; If Cheep Cheep is not close enough to Player, jump to PRG003_B46F

	LDY #-$60	 ; Otherwise, Y = -$60
PRG003_B46F:
	STY <Objects_YVel,X	 ; Update Y velocity

PRG003_B471:

	; Toggle frame 0/1
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

PRG003_B47A:
	RTS		 ; Return

Tornado_InitXVel:	.byte $08, -$08

ObjInit_Tornado:
	JSR Level_ObjCalcXDiffs

	; Set initial X velocity towards Player
	LDA Tornado_InitXVel,Y
	STA <Objects_XVel,X

	; Var4 = $A5
	LDA #$a5
	STA <Objects_Var4,X

	RTS		 ; Return

Tornado_ParticleOffsets:
	.byte $18, $18, $17, $17, $16, $15, $14, $13, $11, $0F, $0D, $0B, $09, $07, $05, $02
	.byte $12, $12, $11, $11, $10, $0F, $0F, $0E, $0C, $0B, $09, $08, $06, $05, $03, $01
	.byte $0E, $0E, $0D, $0D, $0C, $0C, $0B, $0B, $09, $08, $07, $06, $05, $04, $02, $01
	.byte $0A, $0A, $09, $09, $09, $08, $08, $07, $07, $06, $05, $04, $03, $02, $02, $00
	.byte $07, $07, $06, $06, $06, $06, $05, $05, $04, $04, $03, $03, $02, $02, $01, $00
	.byte $03, $03, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01, $00, $00, $00
	.byte $02, $02, $01, $01, $01, $01, $01, $01, $01, $01, $01, $00, $00, $00, $00, $00
	.byte $01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

Tornado_ScatterY:
	.byte $00, $0C, $18, $24, $30, $3C, $48, $54

	; Causes wider to narrow spreading based on position of tornado particle
Tornado_SpreadFreq:
	.byte $38, $30, $28, $20, $18, $10, $08, $00

Tornado_ParticleDivCnt:
	.byte $01, $02

PRG003_B51C:
	.byte $01, $02, $01, $FF, $20, $E0

Tornado_MaskOffset:
	.byte $09, $09, $09, $08, $07, $06, $07, $08

ObjNorm_Tornado:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BNE PRG003_B534	 ; If gameplay is halted, jump to PRG003_B534

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG003_B534:
	LDY <Objects_Var4,X	 ; Y = Var4
	BNE PRG003_B53B	 ; If Var4 <> 0, jump to PRG003_B53B

	JMP Object_Delete	 ; Delete object and don't come back!

PRG003_B53B:
	LDA <Counter_1
	AND #$01
	BNE PRG003_B543	 ; Every other tick, jump to PRG003_B543

	DEC <Objects_Var4,X	 ; Var4--

PRG003_B543:
	CPY #$40
	BGE PRG003_B551	 ; If Var4 >= $40, jump to PRG003_B551

	; They possibly intended this to divide Counter_1, but because of
	; the previous AND instruction, this will shift it to nothing...
	LSR A
	LSR A
	LSR A
	LSR A

	ADD #$03
	JMP PRG003_B55D	 ; Jump to PRG003_B55D

PRG003_B551:
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7, by counter / 16

	LDA Tornado_MaskOffset,Y

PRG003_B55D:
	STA <Objects_Var5,X	 ; -> Var5

	ADD <Objects_VarBSS,X
	STA <Objects_VarBSS,X

	STA <Temp_Var15		 ; -> Temp_Var15

	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA Tornado_ParticleDivCnt,Y
	STA <Temp_Var13		 ; -> Temp_Var13

	JSR Object_CalcSpriteXY_NoHi	 ; Calculate sprites

	; Draw 7 scatter particles to represent the tornado
	LDX #$07	 ; X = 7
PRG003_B578:
	STX <Temp_Var16	 ; -> Temp_Var16

	JSR Tornado_ScatterParticle	 ; Scatters tornado particle
	JSR Tornado_DrawParticle	 ; Draw the tornado particle

	DEX		 ; X--
	BPL PRG003_B578	 ; While X >= 0, loop
 
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Player_IsDying
	ORA Player_OffScreen
	BNE PRG003_B5C2	 ; If Player is dead or off-screen, jump to PRG003_B5C2 (RTS)

	LDA Objects_Var3,X
	BEQ PRG003_B5C3	 ; If Var3 = 0, jump to PRG003_B5C3

	LDA <Counter_1
	AND #$1f
	ORA #$20
	STA Player_TwisterSpin	 ; Set Player as twirling from Tornado

	LDY #$00	 ; Y = 0

	LDA <Player_Y
	CMP #48
	BLT PRG003_B5A4	 ; If Player Y < 48, jump to PRG003_B5A4

	INY		 ; Y = 1

PRG003_B5A4:

	; Var6 keeps a copy of how it has accelerate the Player
	LDA Objects_Var6,X
	CMP Tornado_PlayerYLimit,Y
	BEQ PRG003_B5B3	 ; If Var6 = Player Y limit, jump to PRG003_B5B3

	ADD Tornado_PlayerYAccel,Y	 ; Accelerate!
	STA Objects_Var6,X	 ; Update Var6

PRG003_B5B3:
	STA <Player_YVel	 ; Set same to Player's Y velocity

	; Halt Player's horizontal movement
	LDA #$00
	STA <Player_XVel

	JSR Level_ObjCalcXDiffs	

	; Set a little plug-along value to the Player
	LDA Tornado_PlayerXVelAdj,Y
	STA Player_XVelAdj

PRG003_B5C2:
	RTS		 ; Return


PRG003_B5C3:
	JSR Level_ObjCalcXDiffs	

	; Palette select 0/1 depending on which side the particle is on
	TYA
	STA Objects_FlipBits,X

	BEQ PRG003_B5D3	 ; If on the zero side, jump to PRG003_B5D3

	; Otherwise, negate Temp_Var16
	LDA <Temp_Var16
	JSR Negate
	STA <Temp_Var16

PRG003_B5D3:

	LDA <Temp_Var16
	CMP #$10
	BGE PRG003_B5EF	 ; If Temp_Var16 >= $10, jump to PRG003_B5EF

	LDA <Player_Y
	CMP #112
	BLT PRG003_B5EF	 ; If Player Y < 112, jump to PRG003_B5EF

	INC Objects_Var3,X	 ; Var3++

	; Push Player upward
	DEC <Player_Y
	DEC <Player_Y

	STA <Player_InAir ; Flag Player as mid-air

	; Upward Player!
	LDA #-$20
	STA <Player_YVel

	; Var6 = last set Player Y velocity
	STA Objects_Var6,X

PRG003_B5EF:
	LDA <Temp_Var16
	LSR A
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = 0-7, based on upper 3 bits of Temp_Var16
	STY <Temp_Var1	 ; -> Temp_Var1

	LDA Tornado_PlayerXVelAdj2,Y

	LDY Objects_FlipBits,X
	BNE PRG003_B604	 ; If on the 1 side, jump to PRG003_B604

	JSR Negate	 ; Otherwise, negate value from Tornado_PlayerXVelAdj2

PRG003_B604:
	STA Player_XVelAdj	 ; -> Player_XVelAdj

	LDA <Temp_Var16	
	CMP #$10
	BGE PRG003_B61C	 ; If Temp_Var16 >= $10, jump to PRG003_B61C

	LDA <Player_Y
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	TAY		 ; Y = upper 4 bits of Player's position (i.e. the tile grid row)

	; Accelerate Player based on his vertical position
	LDA <Player_YVel
	ADD Tornado_PlayerYVelAccelByRow,Y
	STA <Player_YVel

PRG003_B61C:
	RTS		 ; Return

Tornado_PlayerYLimit:	.byte $40, -$40
Tornado_PlayerYAccel:	.byte $04, -$04
Tornado_PlayerXVelAdj:	.byte -$08, $08

Tornado_PlayerXVelAdj2:
	.byte $18, $10, $0A, $06, $00, $00, $00, $00

Tornado_PlayerYVelAccelByRow:
	.byte $10, $04, -$08, -$08, -$08, -$08, -$08, -$08, -$02, -$02, -$02, -$02, $10, $10, $10, $10

Tornado_ScatterParticle:
	TXA		  
	ASL A
	ASL A
	ASL A
	ASL A
	STA <Temp_Var14	 ; Temp_Var14 = 'X' << 4

	; Temp_Var15 += Tornado_SpreadFreq[X]
	LDA <Temp_Var15
	ADD Tornado_SpreadFreq,X
	STA <Temp_Var15

	LDA <Temp_Var15
	AND #%00001111
	TAY		 ; Y = lower 4 bits of Temp_Var15

	LDA <Temp_Var15
	AND #%00010000
	BEQ PRG003_B659	 ; If Temp_Var15 bit 4 is NOT set, jump to PRG003_B659

	; Sort of negates 'Y'
	TYA
	EOR #$ff
	TAY

PRG003_B659:
	LDA #$00

	CPY #$10
	BEQ PRG003_B668	 ; If 'Y' = $10, jump to PRG003_B668

	TYA

	AND #%00001111
	ORA <Temp_Var14	 ; OR in Temp_Var14

	TAY

	LDA Tornado_ParticleOffsets,Y	 ; A = Tornado_ParticleOffsets[Y]

PRG003_B668:
	STA <Temp_Var10		 ; -> Temp_Var10 (particle offset X)

	LDA <Temp_Var15
	AND #%00001111
	TAY		 ; Y = lower 4 bits of Temp_Var15 

	LDA <Temp_Var15
	AND #%00010000
	BNE PRG003_B679	 ; If Temp_Var15 bit 4 is set, jump to PRG003_B679

	; Sort of negates 'Y'
	TYA
	EOR #$ff
	TAY

PRG003_B679:
	LDA #$00

	CPY #$10
	BEQ PRG003_B693	 ; If 'Y' = $10, jump to PRG003_B693

	TYA

	AND #%00001111
	ORA <Temp_Var14	 ; OR in Temp_Var14

	TAY

	LDA Tornado_ParticleOffsets,Y

	LSR A
	LSR A

	LDY <Temp_Var13	 ; Y = Temp_Var13

	DEY		 ; Y--

	BEQ PRG003_B693	 ; If Y = 0, jump to PRG003_B693

	LSR A

	DEY		 ; Y--
	BEQ PRG003_B693	 ; If Y = 0, jump to PRG003_B693 (... next line)

PRG003_B693:
	STA <Temp_Var9	; -> Temp_Var9 (particle offset Y)

	LDA <Temp_Var15
	AND #%00110000
	BEQ PRG003_B6B1	 ; If neither bit 4 or 5 is set, jump to PRG003_B6B1

	CMP #%00010000
	BEQ PRG003_B6A6	 ; If bit 4 is not set, jump to PRG003_B6A6

	CMP #%00110000
	BEQ PRG003_B6B2	 ; If bit 4 and 5 are not set, jump to PRG003_B6B2

	JSR PRG003_B6B2	 ; Negate Temp_Var10

PRG003_B6A6:
	LDY #$01	 ; Y = 1

PRG003_B6A8:
	; Negate Temp_Var9/10
	LDA Temp_Var9,Y
	JSR Negate
	STA Temp_Var9,Y

PRG003_B6B1:
	RTS		 ; Return

PRG003_B6B2:
	LDY #$00	 ; Y = 0
	BEQ PRG003_B6A8	 ; Jump (technically always) to PRG003_B6A8

PRG003_B6B6:
	.byte $00, $02, $04, $06, $08, $06, $04, $02, $00, $02, $04, $06, $08, $06, $04, $50

Tornado_Masks:
	.byte $0F, $03, $01, $00, $00, $00, $00, $00

Tornado_DrawParticle:
	LDY <SlotIndexBackup 	; Y = object's slot index

	LDA Objects_Var5,Y
	BEQ PRG003_B6B1	 ; If Var5 = 0, jump to PRG003_B6B1 (RTS)

	LSR A
	AND #$07
	TAY		 ; Y = 0 to 7

	TXA	; object slot index -> 'A'
	AND Tornado_Masks,Y
	STA <Temp_Var1	 ; -> Temp_Var1

	LDA <Counter_1
	AND Tornado_Masks,Y
	CMP <Temp_Var1
	BNE PRG003_B6B1	 ; If masked counter value = Temp_Var1, jump to PRG003_B6B1 (RTS)

	CPX #$06
	BLT PRG003_B6F3	 ; If object slot < 6, jump to PRG003_B6F3

	JSR Object_GetRandNearUnusedSpr

	LDX <SlotIndexBackup		 ; X = object slot index
	BGS PRG003_B6FD	 ; Jump (technically always) to PRG003_B6FD

PRG003_B6F3:
	TXA

	ASL A
	ASL A	; A *= 4 (next sprite over)

	LDX <SlotIndexBackup	 ; X = object slot index
	ADD Object_SprRAM,X	 ; Base Sprite_RAM offset

	TAY		 ; Sprite_RAM offset -> 'Y'

PRG003_B6FD:
	STY <Temp_Var14	 ; -> Temp_Var14

	LDA <Counter_1
	AND #$0f		; 0-15 counter value
	ADD Objects_SpriteY,X	; Add 0-15 to SpriteY

	; Temp_Var1 (Sprite Y) = Temp_Var16 + Tornado_ScatterY[X] + Temp_Var9
	LDX <Temp_Var16	
	ADD Tornado_ScatterY,X
	ADD <Temp_Var9
	STA <Temp_Var1

	BCS PRG003_B753	 	; If carry set, jump to PRG003_B753 (went too low, so skip it)

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$07	 ; A = 0-7
	ADD <Temp_Var16	 ; 'A' += Temp_Var16
	TAX		 ; -> 'X'

	; Temp_Var2 (Sprite X) = Tornado's Sprite X + Temp_Var10
	LDA PRG003_B6B6,X ; A = PRG003_B6B6[X]
	CLC		 ; Clear carry
	LDX <SlotIndexBackup		 ; X = object slot index
	ADC Objects_SpriteX,X
	ADD <Temp_Var10
	STA <Temp_Var2

	JSR Sprite_NoCarryIfVisible	
	BCS PRG003_B753	 ; If this particle is not visible, jump to PRG003_B753

	LDY <Temp_Var14		 ; Y = Temp_Var14

	; Set particle sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Set particle sprite X
	LDA <Temp_Var2	
	STA Sprite_RAM+$03,Y

	; Pattern $17
	LDA #$17
	STA Sprite_RAM+$01,Y

	LDX #$03	 ; X = 3

	LDA <Temp_Var15
	AND #$3F
	CMP #$20
	BLT PRG003_B74F	 ; If lower 5 bits of Temp_Var15 < $20, jump to PRG003_B74F

	LDX #$01	 ; Otherwise, X = 1

PRG003_B74F:

	; Set particle sprite attributes
	TXA
	STA Sprite_RAM+$02,Y

PRG003_B753:
	LDX <Temp_Var16	 ; X = Temp_Var16

ObjInit_Blooper:
	RTS		 ; Return

ObjInit_BlooperWithKids:

	; Var7 = 4 (kids left)
	LDA #$04
	STA Objects_Var7,X

	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	RTS		 ; Return

Blooper_YVelAccel:	
	.byte $02, -$02

Blooper_YVelLimit:
	.byte $24, -$24

PRG003_B763:
	.byte $00, $10, $00, $01, $FF

Blooper_FlipTowardsPlayer:
	.byte SPR_HFLIP, $00

ObjNorm_Blooper:
	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPER
	BNE PRG003_B781	 ; If this is not a straight Blooper, jump to PRG003_B781

	; Just a regular Blooper...

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA <Player_HaltGame
	BEQ PRG003_B77B	 ; If gameplay is not halted, jump to PRG003_B77B

	JMP Object_ShakeAndDrawMirrored	 ; Otherwise, draw Blooper and don't come back!

PRG003_B77B:
	JSR Player_HitEnemy	 ; Do Player to Blooper hit detection!
	JMP PRG003_B78B	 ; Jump to PRG003_B78B

PRG003_B781:
	JSR TailEnemy_DoStandard	 ; A Blooper with kids... gotta do Tail updates!

	LDA <Player_HaltGame
	BEQ PRG003_B78B	 ; If gameplay is not halted, jump to PRG003_B78B

	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_B78B:
	LDA Objects_Timer,X
	BEQ PRG003_B7A2	 ; If timer = 0, jump to PRG003_B7A2

	STA Objects_ColorCycle,X	; Cycle colors

	CMP #$01
	BNE PRG003_B79F	 ; If timer <> 1, jump to PRG003_B79F

	; Var7 = 0
	LDA #$00
	STA Objects_Var7,X

	JSR Blooper_LaunchKids	 ; Blooper launches off his four spawn

PRG003_B79F:
	JMP PRG003_B85C	 ; Jump to PRG003_B85C

PRG003_B7A2:
	LDA <Objects_Var5,X
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA <Objects_YVel,X
	ADD Blooper_YVelAccel,Y
	STA <Objects_YVel,X

	CMP Blooper_YVelLimit,Y
	BNE PRG003_B7B6	 ; If Blooper is not at his velocity limit, jump to PRG003_B7B6

	INC <Objects_Var5,X	 ; Otherwise, Var5++

PRG003_B7B6:
	LDA <Objects_YVel,X

	LDY Objects_FlipBits,X
	BEQ PRG003_B7C0	 ; If Blooper is not flipped, jump to PRG003_B7C0

	JSR Negate	 ; Otherwise, negate Y velocity

PRG003_B7C0:
	LDY <Objects_YVel,X
	BMI PRG003_B7DD	 ; If Bloope is moving upward, jump to PRG003_B7DD

	TXA
	LSR A
	BCC PRG003_B7D2	 ; If Blooper is an "even" slot, jump to PRG003_B7D2

	LDY #$00	 ; Y = 0

	LDA <Player_FlipBits
	BNE PRG003_B7CF	 ; If Blooper is flipped, jump to PRG003_B7CF

	INY		 ; Y = 1

PRG003_B7CF:
	JMP PRG003_B7D5	 ; Jump to PRG003_B7D5

PRG003_B7D2:
	JSR Level_ObjCalcXDiffs

PRG003_B7D5
	; Blooper faces Player
	LDA Blooper_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	LDA #$00	 ; A = 0

PRG003_B7DD:
	STA <Objects_XVel,X	 ; Update X Velocity

	JSR Object_WorldDetectN1	 ; Detect against world

	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG003_B7EB	 ; If Blooper hit a wall, jump to PRG003_B7EB

	JSR Object_ApplyXVel	 ; Otherwise, apply X Velocity

PRG003_B7EB:
	LDA <Objects_YVel,X
	PHA		 ; Save Y velocity

	CMP #$08
	BLS PRG003_B814	 ; If Y velocity < $08, jump to PRG003_B814

	LDA <Player_Y	
	PHA		 ; Save Player's Y

	SBC #23
	STA <Player_Y	 ; Subtract 23 from Player's Y

	LDA <Player_YHi
	PHA		 ; Save Player Y Hi
	SBC #$00	 ; Apply carry
	STA <Player_YHi	

	JSR Level_ObjCalcYDiffs

	; Restore Player Y/Hi
	PLA
	STA <Player_YHi
	PLA
	STA <Player_Y

	DEY		 ; Y--
	BEQ PRG003_B810	 ; If Y = 0, jump to PRG003_B810

	PLA		 ; Restore Y velocity

	LDA #$08
	PHA		 ; Save 8 instead

PRG003_B810:
	; Set velocity to $08
	LDA #$08
	STA <Objects_YVel,X

PRG003_B814:
	LDA <Objects_DetStat,X
	AND #$0c
	BNE PRG003_B826	 ; If Blooper hit floor or ceiling, jump to PRG003_B826

	LDA <Objects_YVel,X
	BPL PRG003_B823	 ; If Blooper is not moving upward, jump to PRG003_B823

	LDA Objects_InWater,X
	BEQ PRG003_B826	 ; If Blooper is not in water, jump to PRG003_B826

PRG003_B823:
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

PRG003_B826:
	PLA		 ; Restore Y Velocity
	STA <Objects_YVel,X	 ; Update Y Veocity

	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen

	LDA #$01	; A = 1

	LDY <Objects_YVel,X
	BPL PRG003_B833	 ; If Blooper is not moving upward, jump to PRG003_B833

	LSR A		; A = 0

PRG003_B833:
	STA Objects_Frame,X	 ; Set frame based on movement

	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPER
	BEQ PRG003_B85F	 ; If this is a normal Blooper, jump to PRG003_B85F

	CMP #OBJ_BLOOPERCHILDSHOOT
	BNE PRG003_B85C	 ; If this is NOT a Blooper that launches children, jump to PRG003_B85C

	INC Objects_Var2,X	; Var2++

	LDA Objects_Var2,X
	AND #$3f
	BNE PRG003_B85C	 ; If Var2 hasn't hit 64 ticks yet, jump to PRG003_B85C

	LDA Objects_Var7,X
	CMP #$04
	BNE PRG003_B859	 ; If Var7 <> 4, jump to PRG003_B859

	; After all this, set timer to $40
	LDA #$40
	STA Objects_Timer,X

	BNE PRG003_B85C	 ; Jump (technically always) to PRG003_B85C

PRG003_B859:
	INC Objects_Var7,X	 ; Var7++

PRG003_B85C:
	JMP Tail_DrawAndHurtPlayer	 ; Jump to Tail_DrawAndHurtPlayer

PRG003_B85F:
	JMP Object_ShakeAndDrawMirrored	 ; Draw Blooper and don't come back!

BlooperKid_YVel:	.byte $F8, $08, $08, $F8
BlooperKid_XVel:	.byte $08, $08, $F8, $F8
BlooperKid_Data:	.byte $00, $00, $01, $01
BlooperKid_UNKD:	.byte $00, $01, $01, $00

Blooper_LaunchKids:

	; Temp_Var1 = 3
	LDA #$03
	STA <Temp_Var1

PRG003_B876:
	JSR SpecialObj_FindEmptyAbort

	; Blooper child
	LDA #SOBJ_BLOOPERKID
	STA SpecialObj_ID,Y

	; Blooper child X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Blooper child Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y

	; Blooper child Y Hi
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	LDX <Temp_Var1	 ; X = Temp_Var1

	LDA BlooperKid_YVel,X
	STA SpecialObj_YVel,Y

	LDA BlooperKid_XVel,X
	STA SpecialObj_XVel,Y

	LDA BlooperKid_Data,X
	STA SpecialObj_Data,Y

	LDA BlooperKid_UNKD,X
	STA SpecialObj_Var1,Y

	LDA #$ff
	STA SpecialObj_Timer,Y

	LDX <SlotIndexBackup	 ; X = object slot index
	DEC <Temp_Var1		 ; Temp_Var1--
	BPL PRG003_B876	 ; While Temp_Var1 >= 0, loop 

	RTS		 ; Return

Object_SetHFlipByXVel:
	; Clear horizontal flip
	LDA Objects_FlipBits,X	 
	AND #~SPR_HFLIP

	LDY <Objects_XVel,X
	BEQ PRG003_B8C6		; If not moving horizontally, jump to PRG003_B8C6
	BMI PRG003_B8C3		; If moving leftward, jump to PRG003_B8C3

	; Moving to the right
	ORA #SPR_HFLIP	 ; Set horizontal flip

PRG003_B8C3:
	STA Objects_FlipBits,X	 ; Update flip bits

PRG003_B8C6:
	RTS		 ; Return

	; Temp_Var2 is an X input
	; I don't really understand this function, but it determines horizontal
	; visibility by Sprite X somehow. Carry set if not visible.
Sprite_NoCarryIfVisible:
	LDA Objects_SprVVis,X	 
	BNE PRG003_B8E7	 ; If any of the sprites are vertically off-screen, jump to PRG003_B8E7

	LDA <Objects_SpriteY,X
	CMP #208
	BGE PRG003_B8E7	 ; If sprite Y >= 208, jump to PRG003_B8E7

	LDY #$40	 ; Y = $40

	LDA <Objects_SpriteX,X
	BMI PRG003_B8DA	 ; If sprite X >= $80, jump to PRG003_B8DA

	LDY #$C0	 ; Y = $C0

PRG003_B8DA:
	CPY <Temp_Var2	 ; Compare $40 or $C0 to input X value

	EOR Objects_SprHVis,X

	BMI PRG003_B8E5	 ; If there are inappropriate horizontally off-screen sprites (??) jump to PRG003_B8E5

	BLT PRG003_B8E7	 ; If input X value < 'Y', jump to PRG003_B8E7 (carry clear, but will set carry)
	BGE PRG003_B8E9	 ; If input X value >= 'Y', jump to PRG003_B8E9 (carry set, but will be clear)

PRG003_B8E5:
	BLT PRG003_B8E9	 ; If input X value < 'Y', jump to PRG003_B8E9 (carry clear)

PRG003_B8E7:
	SEC		 ; Set carry
	RTS		 ; Return

PRG003_B8E9:
	CLC		 ; Clear carry
	RTS		 ; Return

Chomp_JumpYVels:	.byte -$40, -$60
Chomp_XVels:		.byte $30, -$30

ObjNorm_ChainChompFree:
	JSR Object_CheckIfNormalState
	BEQ PRG003_B8F7	 ; If in normal state, jump to PRG003_B8F7

	JMP Tail_DrawAndHurtPlayer	 ; Otherwise, jump to Tail_DrawAndHurtPlayer

PRG003_B8F7:
	LDA <Player_HaltGame
	BEQ PRG003_B8FE	 ; If gameplay is not halted, jump to PRG003_B8FE

	JMP PRG003_BB17	 ; Jump to PRG003_BB17

PRG003_B8FE:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

	; Toggle frame
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	AND #$01
	STA Objects_Frame,X

	JSR Object_WorldDetectN1	 ; Detect world
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit from underneath

	LDA <Player_HaltGame
	BEQ PRG003_B918	 ; If gameplay is not halted, jump to PRG003_B918

	JMP PRG003_BB17	 ; Jump to PRG003_BB17

PRG003_B918:
	LDA Objects_Timer,X
	BNE PRG003_B95A		; If timer is not expired, jump to PRG003_B95A

	JSR Object_ApplyXVel	 ; Apply X Velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y Velocity

	LDA <Objects_YVel,X
	BMI PRG003_B92B	 ; If freed chomp is moving upward, jump to PRG003_B92B

	CMP #$70
	BGE PRG003_B932	 ; If Y velocity >= $70, jump to PRG003_B932

PRG003_B92B:
	; Chomp's gravity
	LDA <Objects_YVel,X
	ADD #$06
	STA <Objects_YVel,X

PRG003_B932:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_B95A	 ; If chomp has not hit ground, jump to PRG003_B95A

	; Timer = $0C
	LDA #$0c
	STA Objects_Timer,X

	JSR Object_HitGround	 ; Align to floor

	LDA RandomN,X
	AND #$01
	TAY		 ; Y = random 0 or 1

	; Random jump velocity of two
	LDA Chomp_JumpYVels,Y
	STA <Objects_YVel,X

	LDA <Objects_XVel,X
	ASL A
	ROL A
	AND #$01
	TAY		; Y = 0 or 1, depending if X Velocity is negative

	; Set X velocity in facing direction
	LDA Chomp_XVels,Y
	STA <Objects_XVel,X

	JMP PRG003_BDE6	 ; Jump to PRG003_BDE6

PRG003_B95A:
	JMP Enemy_DeleteIfOffAndDrawTail	 ; Jump to Enemy_DeleteIfOffAndDrawTail

ObjInit_FireSnake:
	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	; Set X velocity = 0
	LDA #$00
	STA <Objects_XVel,X

	BEQ PRG003_B96E	 ; Jump (technically always) to PRG003_B96E

ObjInit_FireChomp:
	JSR Object_InitTailBuffer	 ; Initialize tail buffer (if no buffer available, will be destroyed and won't come back)

	; Var5 = random value 
	LDA RandomN,X
	STA <Objects_Var5,X

PRG003_B96E:
	; Var7 = 4
	LDA #$04
	STA Objects_Var7,X

	RTS		 ; Return

	; Initializes the buffer which holds "tail" X and Y coordinates
Object_InitTailBuffer:
	LDY #$01	 ; Y = 1
PRG003_B976:
	LDA Buffer_Occupied,Y
	BEQ PRG003_B983	 ; If this buffer slot is empty, jump to PRG003_B983

	DEY		 ; Y--
	BPL PRG003_B976	 ; While Y >= 0, loop!

	; Giving up...

	; Do NOT return to caller
	PLA
	PLA
	JMP Object_SetDeadAndNotSpawned	; Fire Chomp can't be created...

PRG003_B983:
	; Mark buffer slot as occupied
	LDA #$01
	STA Buffer_Occupied,Y

	JSR Object_CalcSpriteXY_NoHi

	; Sprite Y -> Temp_Var1
	LDA <Objects_SpriteY,X
	STA <Temp_Var1

	; Sprite X -> Temp_Var2
	LDA <Objects_SpriteX,X
	STA <Temp_Var2

	TYA		
	STA Objects_Var6,X	 ; Store Buffer_Occupied slot index -> Var6

	LSR A
	ROR A
	LSR A
	LSR A	; A = $00 or $20

	; Copy sprite X and Y into buffer space
	TAX		 ; -> 'X'
	LDY #$1f	 ; Y = $1F
PRG003_B99E:
	LDA <Temp_Var1
	STA Object_BufferY,X
	LDA <Temp_Var2
	STA Object_BufferX,X

	INX		 ; X++

	DEY		 ; Y--
	BPL PRG003_B99E	 ; While Y >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	RTS		 ; Return

RotoDisc_VelAccels:
	.byte $01, $FF, $01, $FF, $01, $FF, $01, $FF, $02, $FE, $02, $FE

PRG003_B9BB:
	.byte $00, $03, $01

RotoDisc_VelLimits:
	.byte $10, $F0, $10, $F0, $10, $F0, $10, $F0

PRG003_B9C6:
	.byte $28, $D8, $28, $D8


ObjNorm_FireChomp:
	JSR TailEnemy_DoStandard	 ; Do standard tailed enemy states

	LDA <Player_HaltGame
	BEQ PRG003_B9D4	 ; If gameplay is not halted, jump to PRG003_B9D4

	JMP PRG003_BD92	 ; Jump (indirectly) to PRG003_BB17 (draws enemy) and don't come back!

PRG003_B9D4:

	; Set frame 0
	LDA #$00
	STA Objects_Frame,X

	LDA Objects_Timer,X
	BEQ PRG003_BA08	 ; If timer expired, jump to PRG003_BA08

	CMP #$10
	BNE PRG003_B9F2	 ; If timer <> $10, jump to PRG003_B9F2

	DEC Objects_Var7,X	 ; Var7--
	BNE PRG003_B9EF	 ; If Var7 <> 0, jump to PRG003_B9EF

	; Strips bit 0 off of X velocity?
	LSR <Objects_XVel,X
	ASL <Objects_XVel,X

	; Var4 = $FF
	LDA #$ff
	STA <Objects_Var4,X

PRG003_B9EF:
	JSR FireChomp_SpitFire	 ; Spit fire towards Player

PRG003_B9F2:

	; Gaping mouth
	INC Objects_Frame,X

	LDA Objects_Timer,X
	SUB #$08
	CMP #$10
	BGE PRG003_BA02	 ; If timer >= $18, jump to PRG003_BA02

	INC Objects_Frame,X	 ; Mouth open all the way

PRG003_BA02:
	JSR TailEnemy_MoveTailWithScroll	 ; Update tail with scroll
	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BA08:
	JSR FireChomp_MoveAndExplodeDeath	 ; Move and explode when out of fire balls!

Enemy_DeleteIfOffAndDrawTail:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls too far off-screen
	JMP Tail_DrawAndHurtPlayer	 ; Jump to Tail_DrawAndHurtPlayer

FireChomp_XVelLimit:	.byte $0A, -$0A, $10, -$10
FireChomp_XVelAccel:	.byte $01, -$01, $01, -$01

FireChomp_FlipTowardsPlayer:	.byte SPR_HFLIP, $00

FireChomp_YVelLimit:	.byte $12, -$12
FireChomp_YVelAccel:	.byte $01, -$01

FireChomp_MoveAndExplodeDeath:
	LDA <Objects_Var4,X	 
	BEQ PRG003_BA38	 ; If Var4 = 0, jump to PRG003_BA38

	DEC <Objects_Var4,X	 ; Var4--

	CMP #$40
	BGE PRG003_BA4C	 ; If Var4 >= $40, jump to PRG003_BA4C

	STA Objects_ColorCycle,X	 ; Cycle colors

	CMP #$01
	BNE PRG003_BA4C	 ; If Var4 <> 1, jump to PRG003_BA4C

	; Turn into a Bob-omb (for the explosion!)
	LDA #OBJ_BOBOMB
	STA Level_ObjectID,X

	JMP BobOmb_Explode	 ; Jump to BobOmb_Explode (do Bob-omb's explosion routine)

PRG003_BA38:

	; Var4 = 0...

	INC Objects_Var2,X	 ; Var2++

	LDA Objects_Var2,X
	AND #$7f
	BNE PRG003_BA4C	 ; 128 ticks on, 128 ticks off; jump to PRG003_BA4C

	LDA Objects_Var7,X
	BEQ PRG003_BA4C	 ; If Var7 = 0, jump to PRG003_BA4C

	; Timer = $20
	LDA #$20
	STA Objects_Timer,X

PRG003_BA4C:
	JSR Level_ObjCalcXDiffs

	; Face Player
	LDA FireChomp_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	LDA Objects_Var7,X
	BNE PRG003_BA5C	 ; If Var7 <> 0, jump to PRG003_BA5C

	; Y += 2
	INY
	INY

PRG003_BA5C:
	INC Objects_Var3,X	 ; Var3++

	LDA Objects_Var3,X
	LSR A
	BCC PRG003_BA72	 ; Every other tick, jump to PRG003_BA72

	LDA <Objects_XVel,X
	CMP FireChomp_XVelLimit,Y
	BEQ PRG003_BA72	 ; If Fire Chomp's X velocity is at limit, jump to PRG003_BA72

	; Otherwise, accelerate!
	ADD FireChomp_XVelAccel,Y
	STA <Objects_XVel,X

PRG003_BA72:
	JSR Object_ApplyXVel	 ; Apply X velocity

	LDA <Player_Y
	PHA		 ; Save Player's Y

	ADD #$00	; Add ... zero?
	STA <Player_Y	; Update Player's Y (pointless!)

	LDA <Player_YHi
	PHA		 ; Save Player's Y Hi

	ADC #$00	 ; Apply carry
	STA <Player_YHi	 ; Update Player's Y Hi

	JSR Level_ObjCalcYDiffs

	PLA		 
	STA <Player_YHi	; Restore Player's Y Hi

	PLA
	STA <Player_Y	; Restore Player's Y

	LDA Objects_Var3,X
	LSR A
	BCC PRG003_BAA0	 ; Every other count of Var3, jump to PRG003_BAA0

	LDA <Objects_YVel,X
	CMP FireChomp_YVelLimit,Y
	BEQ PRG003_BAA0	 ; If Fire Chomp's Y velocity is at limit, jump to PRG003_BAA0

	; Otherwise, accelerate!
	ADD FireChomp_YVelAccel,Y
	STA <Objects_YVel,X

PRG003_BAA0:
	JMP Object_ApplyYVel_NoLimit	 ; Apply Y velocity and don't come back!

	; Moves all tail segments based on screen scroll change
TailEnemy_MoveTailWithScroll:

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	ADD #31		; +31
	TAY		; -> 'Y'

	LDX #$1f	 ; X = $1F (all buffer entries)
PRG003_BAB0:
	; Update X by scroll
	LDA Object_BufferX,Y 
	SUB Level_ScrollDiffH
	STA Object_BufferX,Y

	; Update Y by scroll
	LDA Object_BufferY,Y
	SUB Level_ScrollDiffV
	STA Object_BufferY,Y

	DEY		 ; Y-- (previous buffer)
	DEX		 ; X-- (decrement counter)
	BPL PRG003_BAB0	; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

FireChompTail_Patterns:
	.byte $65, $67, $65, $67

FireChompTail_Attributes:
	.byte SPR_PAL1, SPR_PAL1, SPR_HFLIP | SPR_VFLIP | SPR_PAL1, SPR_HFLIP | SPR_VFLIP | SPR_PAL1


	; For objects which have "tails", like the Fire Snake, Blooper w/ kids, etc.
Tail_DrawAndHurtPlayer:
	JSR Object_DetermineHorzVis	 ; Determine is object is horizontally visible

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	PHA	; Save offset
	TAY	; -> 'Y'

	; Set buffer X
	LDA <Objects_X,X
	SUB <Horz_Scroll
	ADD Level_ScrollDiffH
	STA Object_BufferX,Y

	; Set buffer Y
	LDA <Objects_Y,X
	SUB Level_VertScroll
	ADD Level_ScrollDiffV
	STA Object_BufferY,Y

	PLA		 ; Restore offset
	ADD #$1e	 ; Add $1E (other end of the buffer)

	TAY		 ; -> 'Y'

	LDX #$1e	 ; X = $1E (going to work backward)
PRG003_BAFF:
	; Subtract and push down the line X
	LDA Object_BufferX,Y 
	SUB Level_ScrollDiffH
	STA Object_BufferX+1,Y

	; Subtract and push down the line Y
	LDA Object_BufferY,Y
	SUB Level_ScrollDiffV
	STA Object_BufferY+1,Y

	DEY		 ; Y-- (previous buffer byte)
	DEX		 ; X-- (previous buffer count)
	BPL PRG003_BAFF	 ; While X >= 0, loop!

PRG003_BB17:
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_BLOOPERCHILDSHOOT
	BEQ PRG003_BB24	 ; If this is a Blooper who launches off kids, jump to PRG003_BB24

	CMP #OBJ_BLOOPERWITHKIDS
	BNE PRG003_BB2A	 ; If this is not a Blooper w/ kids, jump to PRG003_BB2A

PRG003_BB24:
	JSR Object_ShakeAndDrawMirrored	 ; Draw object
	JMP PRG003_BB36	 ; Jump to PRG003_BB36

PRG003_BB2A:
	CMP #OBJ_FIRECHOMP
	BNE PRG003_BB33	 ; If this is not a Fire Chomp, jump to PRG003_BB33

	; For a Fire Chomp....

	LDA Objects_Frame,X
	BEQ PRG003_BB24	 ; If frame = 0, jump to PRG003_BB24

PRG003_BB33:
	JSR Object_ShakeAndDraw	 ; Draw object, not mirrored

PRG003_BB36:
	LDA Object_SprRAM,X
	ADD #$08
	STA <Temp_Var5		 ; Temp_Var5 = Sprite_RAM offset two bytes over

	; Essentially shift Var6 left 5 places, so A = $00 or $20 (buffer offset)
	LDA Objects_Var6,X
	LSR A
	ROR A
	LSR A
	LSR A

	ADD #$07
	STA <Temp_Var4		 ; Temp_Var4 = offset 7 bytes into the X/Y buffer

	LDA Objects_Var7,X
	BNE PRG003_BB52	 ; If Var7 <> 0, jump to PRG003_BB52

	JMP PRG003_BBF5	 ; Jump to PRG003_BBF5

PRG003_BB52:
	STA <Temp_Var16		 ; Var7 -> Temp_Var16 (Tail length)


	; TAIL DRAW / HURT LOGIC
	; The following 

PRG003_BB54:
	LDY <Temp_Var4		 ; Y = offset into X/Y Buffer

	; Temp_Var1 = Buffer Y @ Temp_Var4
	LDA Object_BufferY,Y
	STA <Temp_Var1	

	; Temp_Var2 = Buffer X @ Temp_Var4 + 4
	LDA Object_BufferX,Y
	ADD #$04
	STA <Temp_Var2

	JSR Sprite_NoCarryIfVisible
	BCS PRG003_BBE0	 ; If carry set, sprite is not visible, jump to PRG003_BBE0

	LDY <Temp_Var5		 ; Y = Temp_Var5 (Sprite_RAM offset)

	; Store Y and X into sprite RAM
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	LDA Level_ObjectID,X
	CMP #OBJ_ROTODISCCLOCKWISE
	BGE PRG003_BBBE	 ; Basically if a Blooper jump to PRG003_BBBE

	; Fire Snake, Fire Chomp, or freed Chain Chomp

	CMP #OBJ_FIRECHOMP
	BNE PRG003_BB9B	 ; If not a Fire Chomp, jump to PRG003_BB9B

	; Fire Chomp only

	LDA <Temp_Var16
	ASL A
	ADC Level_NoStopCnt
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	LDA FireChompTail_Patterns,X
	STA Sprite_RAM+$01,Y

	LDA FireChompTail_Attributes,X
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	JMP PRG003_BBDD	 ; Jump to PRG003_BBDD

PRG003_BB9B:
	CMP #OBJ_CHAINCHOMPFREE
	BEQ PRG003_BBB2	 ; If a freed Chain Chomp, jump to PRG003_BBB2

	; Fire snake

	; Sets the carry
	LDA Level_NoStopCnt
	LSR A
	LSR A

	; Something removed here
	NOP
	NOP

	LDA #$8b	 ; A = $8B
	BCC PRG003_BBAC	 ; 4 ticks on, 4 ticks off; jump to PRG003_BBAC

	LDA #$89	 ; A = $89

PRG003_BBAC:
	STA Sprite_RAM+$01,Y	 ; Store pattern $89 or $8B

	JMP PRG003_BBD2	 ; Jump to PRG003_BBD2

PRG003_BBB2:

	; Freed Chain Chomp 

	; Chain link pattern
	LDA #$9b
	STA Sprite_RAM+$01,Y

	; Palette select 3
	LDA #SPR_PAL3
	STA Sprite_RAM+$02,Y

	BNE PRG003_BBE0	 ; Jump (technically always) to PRG003_BBE0

PRG003_BBBE:
	LDA <Temp_Var16
	ASL A	
	ADC Level_NoStopCnt

	LDX #$b5	 ; X = $B5

	AND #$08
	BNE PRG003_BBCC	 ; 8 ticks on, 8 ticks off; jump to PRG003_BBCC

	LDX #$b7	 ; X = $B7

PRG003_BBCC:
	TXA		 ; Pattern -> 'X'
	STA Sprite_RAM+$01,Y	 ; Set pattern

	LDX <SlotIndexBackup	 ; X = object slot index
PRG003_BBD2:
	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	; Copies attribute from one sprite to the other
	LDA Sprite_RAM+$02,Y
	LDY <Temp_Var5
	STA Sprite_RAM+$02,Y

PRG003_BBDD:
	JSR Tail_CheckHurtPlayer	; Have the tail hurt the Player by touching it

PRG003_BBE0:
	LDA <Temp_Var4
	ADD #$08
	STA <Temp_Var4

	LDA <Temp_Var5
	ADD #$04
	STA <Temp_Var5

	DEC <Temp_Var16		 ; Temp_Var16-- (one less tail segment)

	BEQ PRG003_BBF5	 ; If out of segments, jump to PRG003_BBF5
	JMP PRG003_BB54	 ; Otherwise, loop!

PRG003_BBF5:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

RotoDiscSpin:
	LDA <Objects_Var4,X
	BEQ PRG003_BC6D		; If Var4 = 0, jump to PRG003_BC6D (RTS)

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_Var4,X
	CMP #$01
	BEQ PRG003_BC6D	 ; If Var4 = 1, jump to PRG003_BC6D

	; Var4 > 1...

	LSR A
	TAY		 ; Y = Var4 / 2

	INC Objects_Var3,X	; Var3++

	LDA Objects_Var3,X	; A = Var3
	AND PRG003_B9BB-1,Y	; -1 because Y will always be at least 1
	BNE PRG003_BC6D	 	; If masking of Var3 is non-zero, jump to PRG003_BC6D (RTS)

	LDA <Objects_Var4,X
	SUB #$02
	ASL A		; A = (Var4 - 2) << 1
	AND #%11111100	; Keep all bits but the lower 2
	PHA		; Save this value

	ADD Objects_TargetingXVal,X
	TAY		; -> 'Y'

	LDA <Objects_Var4,X
	AND #$01
	BEQ PRG003_BC2A	 ; If Var4 bit 0 is not set, jump to PRG003_BC2A
	INY		 ; Otherwise Y++
PRG003_BC2A:

	LDA <Objects_XVel,X
	CMP RotoDisc_VelLimits,Y
	BNE PRG003_BC3F	 ; If X velocity is not at its limit, jump to PRG003_BC3F

	PHA		 ; Save X Vel

	LDA Objects_TargetingXVal,X
	EOR #$01
	STA Objects_TargetingXVal,X

	TYA
	EOR #$01
	TAY

	PLA		 ; Restore X Vel

PRG003_BC3F:
	ADD RotoDisc_VelAccels,Y ; Accelerate
	STA <Objects_XVel,X	 ; Update X Velocity

	PLA		 ; Restore indexing value

	ADD Objects_TargetingYVal,X
	TAY		 ; -> 'Y'

	LDA <Objects_Var4,X
	AND #$01
	BEQ PRG003_BC52	 ; If Var4 bit 0 is not set, jump to PRG003_BC52
	INY		 ; Otherwise, Y++
PRG003_BC52:

	LDA <Objects_YVel,X
	CMP RotoDisc_VelLimits,Y
	BNE PRG003_BC67	 ; If Y velocity is not at its limit, jump to PRG003_BC67

	PHA		 ; Save Y velocity

	LDA Objects_TargetingYVal,X
	EOR #$01
	STA Objects_TargetingYVal,X

	TYA
	EOR #$01
	TAY

	PLA		 ; Restore Y velocity

PRG003_BC67:
	ADD RotoDisc_VelAccels,Y ; Accelerate
	STA <Objects_YVel,X	 ; Update Y Velocity

PRG003_BC6D:
	RTS		 ; Return

FireChomp_SpitFire:
	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot or don't come back!
 
	; Fire Chomp's fireball
	LDA #SOBJ_FIRECHOMPFIRE
	STA SpecialObj_ID,Y

	; Calculate a flight path towards Player
	LDA #$14
	JSR BoomBoom_CalcFlightPath

	; Send fireball along flight path
	LDA <Temp_Var1
	STA SpecialObj_YVel,Y
	LDA <Temp_Var2
	STA SpecialObj_XVel,Y

	; Set coordinates as offset from Fire Chomp
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	RTS		 ; Return

	; Calculates flying Boom Boom's path so he flies towards Player
BoomBoom_CalcFlightPath:
	STA <Temp_Var2	; Store input value -> Temp_Var2

	; Backup 'X' and 'Y'
	TXA
	PHA
	TYA
	PHA

	JSR Level_ObjCalcYDiffs
	STY <Temp_Var3		 ; Store Y difference indicator -> Temp_Var3

	; Get absolute value of Y difference
	LDA <Temp_Var16
	BPL PRG003_BCAA
	JSR Negate
PRG003_BCAA:
	STA <Temp_Var13		 ; -> Temp_Var13
 
	JSR Level_ObjCalcXDiffs
	STY <Temp_Var4		 ; Store X difference indicator -> Temp_Var4

	; Get absolute value of X difference
	LDA <Temp_Var16
	BPL PRG003_BCB8
	JSR Negate
PRG003_BCB8:
	STA <Temp_Var14		 ; -> Temp_Var14

	LDY #$00	 ; Y = 0
	LDA <Temp_Var14	
	CMP <Temp_Var13	
	BGE PRG003_BCCB	 ; If Y difference >= X difference, jump to PRG003_BCCB

	INY		 ; Y = 1

	; Swap differences (so greater difference will be in Temp_Var14)
	PHA
	LDA <Temp_Var13
	STA <Temp_Var14
	PLA
	STA <Temp_Var13

PRG003_BCCB:
	LDA #$00
	STA <Temp_Var12	; Clear Temp_Var12
	STA <Temp_Var1	; Clear Temp_Var1

	LDX <Temp_Var2		 ; X = Temp_Var2 (original input value)

PRG003_BCD3:
	LDA <Temp_Var12
	ADD <Temp_Var13		; A = Temp_Var12 + Temp_Var13 (the lesser difference)
	CMP <Temp_Var14		
	BLT PRG003_BCE0	 	; If (Temp_Var12 + Temp_Var13) < Temp_Var14 (the greater difference), jump to PRG003_BCE0

	; If (Temp_Var12 + Temp_Var13) >= Temp_Var14

	SBC <Temp_Var14		 ; Subtract total from Temp_Var14
	INC <Temp_Var1		 ; Temp_Var1++

PRG003_BCE0:
	STA <Temp_Var12		 ; Update Temp_Var12 with the previous total
	DEX		 	; X--
	BNE PRG003_BCD3		; While X >= 0, loop!

	TYA		 ; A = 0 or 1
	BEQ PRG003_BCF2	 ; If zero (don't need to swap), jump to PRG003_BCF2

	; Swap Temp_Var1 and Temp_Var2
	LDA <Temp_Var1
	PHA	
	LDA <Temp_Var2
	STA <Temp_Var1
	PLA	
	STA <Temp_Var2

PRG003_BCF2:
	LDA <Temp_Var1		 ; A = Temp_Var1

	LDY <Temp_Var3		 ; Y = Temp_Var3 (Y difference indicator)
	BEQ PRG003_BCFD	 	; If Player was lower than object, jump to PRG003_BCFD

	; Otherwise, negate Temp_Var1
	JSR Negate
	STA <Temp_Var1

PRG003_BCFD:
	LDA <Temp_Var2		 ; A = Temp_Var2

	LDY <Temp_Var4		 ; Y = Temp_Var4 (X difference indicator)
	BEQ PRG003_BD08	 	; If Player was lower than object, jump to PRG003_BD08

	; Otherwise, negate Temp_Var2
	JSR Negate
	STA <Temp_Var2

PRG003_BD08:

	; Restore 'Y' and 'X'
	PLA
	TAY
	PLA
	TAX 

	RTS		 ; Return

Tail_PlayerYOff:	.byte $12, $04	; Offset to Player Sprite Y for small/ducking, or not
Tail_PlayerYLimit:	.byte $0E, $18	; Limit value

	; For enemies with tails (e.g. Fire Snake, Fire Chomp, Blooper with Kids),
	; checks if the Player has touched any part of their tail and should be hurt.
Tail_CheckHurtPlayer:
	LDA <Temp_Var16
	ADD <Counter_1
	LSR A
	BCC PRG003_BD60	 ; Every other tick, jump to PRG003_BD60 (RTS)

	LDA Objects_Var1,X
	BNE PRG003_BD60	 ; If Var1 <> 0, jump to PRG003_BD60 (RTS)

PRG003_BD1E:
	LDY #$00	 ; Y = 0

	LDA <Player_Suit
	BEQ PRG003_BD2A	 ; If Player is small, jump to PRG003_BD2A

	LDA Player_IsDucking
	BNE PRG003_BD2A	 ; If Player is ducking, jump to PRG003_BD2A

	INY		 ; Y = 1

PRG003_BD2A:
	LDA <Temp_Var1
	CMP #$c3
	BGE PRG003_BD60	 ; If Temp_Var1 >= $C3, jump to PRG003_BD60 (RTS)

	ADD #$08
	SUB <Player_SpriteY
	SUB Tail_PlayerYOff,Y
	CMP Tail_PlayerYLimit,Y
	BGE PRG003_BD60	 ; If Player is not in good Y range, jump to PRG003_BD60 (RTS)

	LDA <Temp_Var2
	ADD #$04
	SUB <Player_SpriteX
	SBC #$00
	CMP #$10
	BGE PRG003_BD60	 ; If Player is not in good X range, jump to PRG003_BD60 (RTS)

	LDA Player_StarInv
	BNE PRG003_BD60	 ; If Player is invincible by Starman, jump to PRG003_BD60 (RTS)

Player_HurtIfNotDieOffBehind:
	ORA Player_IsDying  	; If Player is dying...
	ORA Player_OffScreen	; ... off-screen ...
	ORA Player_Behind_En	; ... or behind the scenes ...
	BNE PRG003_BD60	 	; ... jump to PRG003_BD60 (RTS)

	JSR Player_GetHurt	; Otherwise, hurt Player!

PRG003_BD60:
	RTS		 ; Return

FireSnake_XVelTowardsPlayer:	.byte $08, -$08

FireSnake_FlipForTick:	.byte $00, $00, SPR_HFLIP, SPR_HFLIP
FireSnake_FrameForTick:	.byte $00, $01, $00, $01

FireSnake_JumpYVel:	.byte -$18, -$24

FireSnake_RandomTimer3Vals:	.byte $50, $70, $00, $70, $50, $00, $00, $00

ObjNorm_FireSnake:
	LDA Level_NoStopCnt
	LSR A
	AND #$03
	TAY		 ; Y = 0 to 3

	; Set flip bit for this tick
	LDA FireSnake_FlipForTick,Y
	STA Objects_FlipBits,X

	; Set frame for this tick
	LDA FireSnake_FrameForTick,Y
	STA Objects_Frame,X

	JSR Object_WorldDetect4	 ; Detect against the world

	JSR TailEnemy_DoStandard	 ; Do standard tailed enemy states

	LDA <Player_HaltGame
	BEQ PRG003_BD95	 ; If gameplay is NOT halted, jump to PRG003_BD95

PRG003_BD92:
	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BD95:
	LDA Objects_Timer,X
	BNE PRG003_BDE6	 ; If timer not expired, jump to PRG003_BDE6

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BMI PRG003_BDA8	 ; If Fire Snake is moving upward, jump to PRG003_BDA8

	CMP #$18
	BGE PRG003_BDAA	 ; If Fire Snake is moving at $18 downward, jump to PRG003_BDAA

PRG003_BDA8:
	INC <Objects_YVel,X	 ; Fire Snake's light gravity

PRG003_BDAA:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG003_BDE6	 ; If Fire Snake has not touched ground, jump to PRG003_BDE6

	LDA Objects_Timer3,X
	BNE PRG003_BDE6	; If timer 3 is not expired, jump to PRG003_BDE6

	; timer = $15
	LDA #$15
	STA Objects_Timer,X

	JSR Object_HitGround	 ; Align Fire Snake to ground

	LDA RandomN,X
	AND #$01
	TAY		 ; Y = 0 or 1, random

	; Fire Snake's random hop
	LDA FireSnake_JumpYVel,Y
	STA <Objects_YVel,X

	JSR Level_ObjCalcYDiffs

	CPY #$00
	BNE PRG003_BDDB	; If Player is lower than Fire Snake, jump to PRG003_BDDB

	LDA RandomN,X
	AND #$07
	TAY		 ; Y = 0 to 7, random

	; Random timer 3 reload value
	LDA FireSnake_RandomTimer3Vals,Y
	STA Objects_Timer3,X

PRG003_BDDB:
	JSR Level_ObjCalcXDiffs

	; Set X velocity towards Player
	LDA FireSnake_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

	JMP PRG003_BDE6	 ; Jump to PRG003_BDE6 (... right down below)

PRG003_BDE6:
	JMP Enemy_DeleteIfOffAndDrawTail	 ; Delete if off-screen, draw tail, and don't come back!

PRG003_BDE9:
	JSR Object_SetHFlipByXVel ; Set horizontal flip by travel direction

TailEnemy_DoStandard:
	LDA Objects_Var1,X
	BEQ TailEnemy_InitOrHalt	 ; If Var1 = 0, jump to TailEnemy_InitOrHalt

	LDY <Player_HaltGame
	BEQ PRG003_BDFA	 ; If gameplay is not halted, jump to PRG003_BDFA

	; Do not return to caller!
	PLA
	PLA

	JMP PRG003_BB17	 ; Jump off to PRG003_BB17 (draws enemy) and don't come back!

PRG003_BDFA:
	; Jump based on Var1
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TailEnemy_InitOrHalt		; 0: Action to take initially or when gameplay is halted
	.word TailEnemy_DrawAndWaitTimer2	; 1: Draws object and waits for timer 2 to expire; WILL NOT RETURN TO CALLER!
	.word TailEnemy_DoDeath			; 2: Does "wiggle death" and draws tail; WILL NOT RETURN TO CALLER!

TailEnemy_InitOrHalt:
	JSR Object_CheckIfNormalState
	BEQ PRG003_BE1D	 ; If in normal state, jump to PRG003_BE1D

	; Not in normal state...

	; Var1 = 1 (next internal state)
	LDA #$01
	STA Objects_Var1,X

	LSR A
	STA <Objects_XVel,X	; Stop horizontal velocity
	STA <Objects_VarBSS+1,X

	; Color cycle!
	LDA #$10
	STA Objects_ColorCycle,X

	; Timer2 = 8
	LDA #$08
	STA Objects_Timer2,X

	RTS		 ; Return

PRG003_BE1D:
	LDA Level_ObjectID,X
	CMP #OBJ_FIRESNAKE
	BNE PRG003_BE27	 ; If this is NOT a Fire Snake, jump to PRG003_BE27

	JMP Object_HandleBumpUnderneath	 ; Otherwise just handle getting bumped underneath and don't come back!

PRG003_BE27:
	JMP Player_HitEnemy	 ; Handle full enemy-to-Player collision and don't come back!

TailEnemy_DrawAndWaitTimer2:
	LDA Objects_Timer2,X	 
	BNE PRG003_BE37	 ; If timer2 is not expired, jump to PRG003_BE37

	INC Objects_Var1,X	 ; Var1++ (next internal state)

	; Timer2 = $FF
	LDA #$ff
	STA Objects_Timer2,X

PRG003_BE37:
	; Do NOT return to caller!
	PLA
	PLA

	JMP Enemy_DeleteIfOffAndDrawTail	; Delete if off-screen, draw tail, and don't come back!

PRG003_BE3A:
	RTS		 ; Return

TailEnemy_DoDeath:
	LDA Objects_Timer2,X
	BNE PRG003_BE52	 ; If timer 2 is not expired, jump to PRG003_BE52

	; Timer 2 expired...

	STA Objects_Var1,X	 ; Var1 = 0 (Return to initial internal state)

	; Removes bit 7 (vertical flip)
	ASL Objects_FlipBits,X
	LSR Objects_FlipBits,X

	; Little hop upward
	LDA #-$10
	STA <Objects_YVel,X

	JMP PRG003_BE37	; Draw tail, Do NOT return to caller, and don't come back!


PRG003_BE52:

	; Sets vertical flip bit 7
	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel_NoLimit	 ; Apply Y velocity

	LDA <Objects_YVel,X
	BMI PRG003_BE67	 ; If enemy moving upward, jump to PRG003_BE67

	CMP #$18
	BGE PRG003_BE6B	 ; If enemy moving downward >= $18, jump to PRG003_BE6B

PRG003_BE67:
	; Apply gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

PRG003_BE6B:
	LDY #$08	 ; Y = $08

	LDA Level_NoStopCnt
	AND #$08
	BEQ PRG003_BE76	 ; 8 ticks on, 8 ticks off; jump to PRG003_BE76

	LDY #-$08	 ; Y = -$08

PRG003_BE76:
	STY <Objects_XVel,X	 ; Set X velocity as $08 or -$08

	JMP PRG003_BE37	; Draw tail, Do NOT return to caller, and don't come back!

ObjInit_RotoDiscDualCW:
	LDY #$03	 ; Y = 3
	LDA PRG003_B9C6+1
	BNE PRG003_BE87	 ; Jump (technically always) to PRG003_BE87

ObjInit_RotoDiscDualCCW:
	LDY #-$02	; Y = -$02

	; Set initial Y velocity
	LDA PRG003_B9C6

PRG003_BE87:
	STA <Objects_YVel,X
	STY <Temp_Var1	 ; Temp_Var1 = -$02

	LDA #$00
	STA <Objects_XVel,X
	STA Objects_XVelFrac,X
	STA Objects_YVelFrac,X

	LDA <Objects_X,X
	STA Objects_Var13,X	
	SUB #$30
	STA <Objects_X,X

	LDA <Objects_XHi,X
	STA Objects_Var10,X

	SBC #$00
	STA <Objects_XHi,X

	LDA <Objects_Y,X
	STA Objects_Var14,X

	ADD <Temp_Var1	
	STA <Objects_Y,X

	LDA #$00
	LDY <Temp_Var1
	BPL PRG003_BEBA
	LDA #$ff
PRG003_BEBA:
	ADC <Objects_YHi,X
	STA Objects_Var1,X

	RTS		 ; Return


ObjNorm_RotoDiscDualOpp:

	JSR ObjNorm_RotoDisc	 ; Partly a regular RotoDisc...

	; Backup the Y coordinates
	LDA <Objects_Y,X
	PHA
	LDA <Objects_YHi,X
	PHA

	; Calculate an opposite Y for the secondary RotoDisc
	LDA Objects_Var14,X
	SUB <Objects_Y,X
	PHA

	LDA Objects_Var1,X
	SBC <Objects_YHi,X
	TAY

	PLA
	ADD Objects_Var14,X
	STA <Objects_Y,X

	TYA
	ADC Objects_Var1,X
	STA <Objects_YHi,X

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of the RotoDisc
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of the RotoDisc
	JSR RotoDisc_CollideAndCycle	 ; Test for collision and cycle the second RotoDisc

	; Restore the Y coordinates
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X

	RTS		 ; Return

ObjNorm_RotoDiscDualOpp2:
	JSR ObjNorm_RotoDisc	 ; Partly a regular RotoDisc...

	; Backup the X coordinates
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA

	; Calculate an opposite X for the secondary RotoDisc
	LDA Objects_Var13,X
	SUB <Objects_X,X
	PHA

	LDA Objects_Var10,X
	SBC <Objects_XHi,X
	TAY
	PLA

	ADD Objects_Var13,X
	STA <Objects_X,X

	TYA
	ADC Objects_Var10,X
	STA <Objects_XHi,X

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of the RotoDisc
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of the RotoDisc
	JSR RotoDisc_CollideAndCycle	 ; Test for collision and cycle the second RotoDisc

	; Restore the X coordinates
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_RotoDiscDual:
	JSR ObjNorm_RotoDisc	 ; Partly a regular RotoDisc...

	; Backup all of the coordinates
	LDA <Objects_X,X
	PHA
	LDA <Objects_XHi,X
	PHA
	LDA <Objects_Y,X
	PHA
	LDA <Objects_YHi,X
	PHA


	; Calculate an opposite X and opposite Y for the secondary RotoDisc
	LDA Objects_Var13,X
	SUB <Objects_X,X
	PHA

	LDA Objects_Var10,X
	SBC <Objects_XHi,X
	TAY

	PLA
	ADD Objects_Var13,X
	STA <Objects_X,X
	TYA
	ADC Objects_Var10,X
	STA <Objects_XHi,X

	LDA Objects_Var14,X
	SUB <Objects_Y,X
	PHA

	LDA Objects_Var1,X
	SBC <Objects_YHi,X
	TAY

	PLA
	ADD Objects_Var14,X
	STA <Objects_Y,X

	TYA
	ADC Objects_Var1,X
	STA <Objects_YHi,X

	; Two sprites over
	LDA Object_SprRAM,X
	ADD #$08
	STA Object_SprRAM,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of the RotoDisc
	JSR Object_DetermineVertVis	 ; Determine vertical visibility of the RotoDisc
	JSR RotoDisc_CollideAndCycle	 ; Test for collision and cycle the second RotoDisc

	; Restore all of the coordinates
	PLA
	STA <Objects_YHi,X
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_XHi,X
	PLA
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_RotoDisc:
	LDA <Player_HaltGame
	BNE PRG003_BFAE	 ; If gameplay is halted, jump to PRG003_BFAE

	; Var4 = 6
	LDA #$06
	STA <Objects_Var4,X

	JSR RotoDiscSpin 		; Do Rotodisc spin logic
	JSR Object_DeleteOffScreen_N2	; Delete if falls off-screen
RotoDisc_CollideAndCycle:
	JSR Object_CalcSpriteXY_NoHi	; Calculate the sprite
	JSR Player_HitEnemy	 	; Player to Rotodisc collision detection

PRG003_BFAE:

	; Toggle between frame 0 and 1
	LDA <Counter_1
	AND #$01
	STA Objects_Frame,X

	; Cycle colors
	LDA <Counter_1
	LSR A
	LSR A
	STA Objects_ColorCycle,X

	JMP Object_ShakeAndDraw	 ; Draw Rotodisc and don't come back!

; Rest of ROM bank was empty

