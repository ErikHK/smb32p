; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-04-02 22:20:56.965729406 -0500
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
	; CAUTION!! ObjectGroup01 labels MUST appear at the 
	; address specified by the predefined constants!  I can't
	; verify this at the assembler level, so be careful!!
	; I'm using a ".org" directive to help enforce it, but
	; the assembler does not warn you if you overwrite and
	; instead will simply "stomp" on your code if you passed
	; that limit ... sorry, original coders assumed a constant
	; position on banks 1 - 5 and didn't use a LUT this time...

	; Object group $01 (i.e. objects starting at ID $24) State 1 jump table

	.org ObjectGroup_InitJumpTable	; <-- help enforce this table *here*
ObjectGroup01_InitJumpTable:
	.word ObjInit_CloudPlatFast	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjInit_PipewayCtlr	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjInit_WoodenPlat	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjInit_WoodenPlat	; Object $27 - OBJ_OSCILLATING_H
	.word ObjInit_WoodenPlat	; Object $28 - OBJ_OSCILLATING_V
	.word ObjInit_TowardsPlayer	; Object $29 - OBJ_SPIKE
	.word ObjInit_Patooie		; Object $2A - OBJ_PATOOIE
	.word ObjInit_DoNothing		; Object $2B - OBJ_GOOMBAINSHOE
	.word ObjInit_CloudPlatform	; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjInit_ChasingFish	; Object $2D - OBJ_BIGBERTHA
	.word ObjInit_InvisibleLift	; Object $2E - OBJ_INVISIBLELIFT
	.word ObjInit_DoNothing		; Object $2F - OBJ_BOO
	.word ObjInit_HotFootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjInit_Stretch		; Object $31 - OBJ_BOOSTRETCH
	.word ObjInit_StretchFlip	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word ObjInit_DoNothing		; Object $33 - OBJ_NIPPER
	.word ObjInit_Toad		; Object $34 - OBJ_TOAD
	.word ObjInit_DoNothing		; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjInit_WoodenPlatform	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjInit_OscillatingShort	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjInit_OscillatingShort	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjInit_NipperHopping	; Object $39 - OBJ_NIPPERHOPPING
	.word ObjInit_FallingPlatform	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjInit_ChasingFish	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjInit_WoodenFallingPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjInit_DoNothing		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjInit_FloatWoodenPlat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjInit_TowardsPlayer	; Object $3F - OBJ_DRYBONES
	.word ObjInit_BusterBeatle	; Object $40 - OBJ_BUSTERBEATLE
	.word ObjInit_DoNothing		; Object $41 - OBJ_ENDLEVELCARD
	.word ObjInit_CheepCheepP2P	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.word ObjInit_CheepCheepP2P2	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.word ObjInit_FallingPlatform	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjInit_HotFoot		; Object $45 - OBJ_HOTFOOT
	.word ObjInit_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjInit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) State 2 jump table

	.org ObjectGroup_NormalJumpTable	; <-- help enforce this table *here*
ObjectGroup01_NormalJumpTable:
	.word ObjNorm_CloudPlat		; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjNorm_PipewayCtlr	; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjNorm_WoodenPlatRider	; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjNorm_OscillatingH	; Object $27 - OBJ_OSCILLATING_H
	.word ObjNorm_OscillatingV	; Object $28 - OBJ_OSCILLATING_V
	.word ObjNorm_Spike		; Object $29 - OBJ_SPIKE
	.word ObjNorm_Patooie		; Object $2A - OBJ_PATOOIE
	.word ObjNorm_GoombaInShoe	; Object $2B - OBJ_GOOMBAINSHOE
	.word ObjNorm_CloudPlat		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjNorm_BigBertha		; Object $2D - OBJ_BIGBERTHA
	.word ObjNorm_InvisibleLift	; Object $2E - OBJ_INVISIBLELIFT
	.word ObjNorm_Boo		; Object $2F - OBJ_BOO
	.word ObjNorm_HotfootShy	; Object $30 - OBJ_HOTFOOT_SHY
	.word ObjNorm_Stretch		; Object $31 - OBJ_BOOSTRETCH
	.word ObjNorm_Stretch		; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word ObjNorm_Nipper		; Object $33 - OBJ_NIPPER
	.word ObjNorm_Toad		; Object $34 - OBJ_TOAD
	.word ObjNorm_ToadHouseItem	; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjNorm_WoodenPlatform	; Object $36 - OBJ_WOODENPLATFORM
	.word ObjNorm_OscillatingH	; Object $37 - OBJ_OSCILLATING_HS
	.word ObjNorm_OscillatingV	; Object $38 - OBJ_OSCILLATING_VS
	.word ObjNorm_Nipper		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjNorm_PathFollowPlat	; Object $3A - OBJ_FALLINGPLATFORM
	.word ObjNorm_CharginCheepCheep	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjNorm_PathFollowPlat	; Object $3C - OBJ_WOODENPLATFORMFALL
	.word ObjNorm_NipperFireBreathe	; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjNorm_WoodenPlatFloat	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjNorm_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjNorm_BusterBeatle	; Object $40 - OBJ_BUSTERBEATLE
	.word ObjNorm_EndLevelCard	; Object $41 - OBJ_ENDLEVELCARD
	.word ObjNorm_CheepCheepP2P	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.word ObjNorm_CheepCheepP2P2	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.word ObjNorm_PathFollowPlat	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word ObjNorm_Hotfoot		; Object $45 - OBJ_HOTFOOT
	.word ObjNorm_PiranhaSpikeBall	; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjNorm_GiantBlockCtl	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Collision routine jump table (if calling Object_HitTestRespond;
	; Special values of OCSPECIAL_KILLCHANGETO or OCSPECIAL_HIGHSCORE can be used here instead otherwise.)

	.org ObjectGroup_CollideJumpTable	; <-- help enforce this table *here*
ObjectGroup01_CollideJumpTable:
	.word ObjHit_CloudPlat		; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.word ObjHit_DoNothing		; Object $25 - OBJ_PIPEWAYCONTROLLER
	.word ObjHit_DoNothing		; Object $26 - OBJ_WOODENPLAT_RIDER
	.word ObjHit_DoNothing		; Object $27 - OBJ_OSCILLATING_H
	.word ObjHit_DoNothing		; Object $28 - OBJ_OSCILLATING_V
	.word ObjHit_DoNothing		; Object $29 - OBJ_SPIKE
	.word Player_GetHurt		; Object $2A - OBJ_PATOOIE
	.word ObjHit_GoombaInShoe	; Object $2B - OBJ_GOOMBAINSHOE
	.word ObjHit_CloudPlat		; Object $2C - OBJ_CLOUDPLATFORM
	.word ObjHit_DoNothing		; Object $2D - OBJ_BIGBERTHA
	.word ObjHit_DoNothing		; Object $2E - OBJ_INVISIBLELIFT
	.word Player_GetHurt		; Object $2F - OBJ_BOO
	.word Player_GetHurt		; Object $30 - OBJ_HOTFOOT_SHY
	.word Player_GetHurt		; Object $31 - OBJ_BOOSTRETCH
	.word Player_GetHurt		; Object $32 - OBJ_BOOSTRETCH_FLIP
	.word Player_GetHurt		; Object $33 - OBJ_NIPPER
	.word ObjHit_DoNothing		; Object $34 - OBJ_TOAD
	.word ObjHit_DoNothing		; Object $35 - OBJ_TOADHOUSEITEM
	.word ObjHit_DoNothing		; Object $36 - OBJ_WOODENPLATFORM
	.word ObjHit_DoNothing		; Object $37 - OBJ_OSCILLATING_HS
	.word ObjHit_DoNothing		; Object $38 - OBJ_OSCILLATING_VS
	.word Player_GetHurt		; Object $39 - OBJ_NIPPERHOPPING
	.word ObjHit_DoNothing		; Object $3A - OBJ_FALLINGPLATFORM
	.word Player_GetHurt		; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.word ObjHit_DoNothing		; Object $3C - OBJ_WOODENPLATFORMFALL
	.word Player_GetHurt		; Object $3D - OBJ_NIPPERFIREBREATHER
	.word ObjHit_DoNothing		; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.word ObjHit_DryBones		; Object $3F - OBJ_DRYBONES
	.word ObjHit_DoNothing		; Object $40 - OBJ_BUSTERBEATLE
	.word ObjHit_EndLevelCard	; Object $41 - OBJ_ENDLEVELCARD
	.word Player_GetHurt		; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.word Player_GetHurt		; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.word ObjHit_DoNothing		; Object $44 - OBJ_WOODENPLATUNSTABLE
	.word Player_GetHurt		; Object $45 - OBJ_HOTFOOT
	.word Player_GetHurt		; Object $46 - OBJ_PIRANHASPIKEBALL
	.word ObjHit_DoNothing		; Object $47 - OBJ_GIANTBLOCKCTL

	
	; Object group $01 (i.e. objects starting at ID $24) attribute bits set 1 (OA1_* flags valid here)

	.org ObjectGroup_Attributes	; <-- help enforce this table *here*
ObjectGroup01_Attributes:
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $25
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $27 - OBJ_OSCILLATING_H
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $28 - OBJ_OSCILLATING_V
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $29 - OBJ_SPIKE
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $2A - OBJ_PATOOIE
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2B - OBJ_GOOMBAINSHOE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA1_PAL1 | OA1_HEIGHT32 | OA1_WIDTH24	; Object $2D - OBJ_BIGBERTHA
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH32	; Object $2E - OBJ_INVISIBLELIFT
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $2F - OBJ_BOO
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $31 - OBJ_BOOSTRETCH
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $33 - OBJ_NIPPER
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $34 - OBJ_TOAD
	.byte OA1_PAL0 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA1_PAL2 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $3F - OBJ_DRYBONES
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH16	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OA1_PAL3 | OA1_HEIGHT16 | OA1_WIDTH48	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA1_PAL1 | OA1_HEIGHT16 | OA1_WIDTH8	; Object $45 - OBJ_HOTFOOT
	.byte OA1_PAL2 | OA1_HEIGHT32 | OA1_WIDTH16	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA1_PAL0 | OA1_HEIGHT32 | OA1_WIDTH32	; Object $47 - OBJ_GIANTBLOCKCTL

	; Object group $01 (i.e. objects starting at ID $24) second set attribute bits

	; Attribute bits for objects:
	;	Bits 0: If set, object is NOT a "shelled" enemy
	;	Bits 1: Subtly modifies Player detection response; see comments in PRG000_D205
	;	Bits 2: If set, object doesn't respond if stomped (indifferent, not same as attr 3, bit 5 which leads to hurting player)
	;	Bits 3: Object uses 16-bit X value (otherwise, Object_XHi will be zeroed)
	;	Bits 4-7: Pick root tile detection group offset (from Object_TileDetectOffsets)

	.org ObjectGroup_Attributes2	; <-- help enforce this table *here*
ObjectGroup01_Attributes2:
	.byte OA2_TDOGRP2	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA2_TDOGRP0	; Object $25
	.byte OA2_TDOGRP2	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA2_TDOGRP2	; Object $27 - OBJ_OSCILLATING_H
	.byte OA2_TDOGRP2	; Object $28 - OBJ_OSCILLATING_V
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $29 - OBJ_SPIKE
	.byte OA2_TDOGRP2	; Object $2A - OBJ_PATOOIE
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $2B - OBJ_GOOMBAINSHOE
	.byte OA2_TDOGRP2	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA2_TDOGRP0	; Object $2D - OBJ_BIGBERTHA
	.byte OA2_TDOGRP2	; Object $2E - OBJ_INVISIBLELIFT
	.byte OA2_TDOGRP1	; Object $2F - OBJ_BOO
	.byte OA2_TDOGRP0	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA2_TDOGRP1	; Object $31 - OBJ_BOOSTRETCH
	.byte OA2_TDOGRP1	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA2_TDOGRP1	; Object $33 - OBJ_NIPPER
	.byte OA2_TDOGRP2	; Object $34 - OBJ_TOAD
	.byte OA2_TDOGRP0	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA2_TDOGRP2	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA2_TDOGRP2	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA2_TDOGRP2	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA2_TDOGRP1	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA2_TDOGRP9	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA2_TDOGRP9	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA2_TDOGRP9	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA2_TDOGRP1	; Object $3F - OBJ_DRYBONES
	.byte OA2_NOSHELLORSQUASH | OA2_GNDPLAYERMOD | OA2_TDOGRP1	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA2_TDOGRP0	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OA2_NOSHELLORSQUASH | OA2_TDOGRP1	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OA2_TDOGRP9	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA2_TDOGRP0	; Object $45 - OBJ_HOTFOOT
	.byte OA2_TDOGRP2	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA2_TDOGRP1	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) third set attribute bits

	.org ObjectGroup_Attributes3	; <-- help enforce this table *here*
ObjectGroup01_Attributes3:
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $25
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $27 - OBJ_OSCILLATING_H
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $28 - OBJ_OSCILLATING_V
	.byte OA3_HALT_SPIKESPECIAL 	; Object $29 - OBJ_SPIKE
	.byte OA3_HALT_PIRANHASPECIAL 	; Object $2A - OBJ_PATOOIE
	.byte OA3_HALT_KURIBOSPECIAL 	; Object $2B - OBJ_GOOMBAINSHOE
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OA3_HALT_NORMALONLY 	; Object $2D - OBJ_BIGBERTHA
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2E - OBJ_INVISIBLELIFT
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $2F - OBJ_BOO
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $31 - OBJ_BOOSTRETCH
	.byte OA3_HALT_JUSTDRAW | OA3_TAILATKIMMUNE	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $33 - OBJ_NIPPER
	.byte OA3_HALT_JUSTDRAWTALL | OA3_TAILATKIMMUNE	; Object $34 - OBJ_TOAD
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $36 - OBJ_WOODENPLATFORM
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $37 - OBJ_OSCILLATING_HS
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $38 - OBJ_OSCILLATING_VS
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $39 - OBJ_NIPPERHOPPING
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OA3_HALT_JUSTDRAW 	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OA3_HALT_JUSTDRAW | OA3_NOTSTOMPABLE 	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OA3_HALT_NORMALONLY | OA3_NOTSTOMPABLE | OA3_TAILATKIMMUNE	; Object $3F - OBJ_DRYBONES
	.byte OA3_HALT_BUSTERSPECIAL 	; Object $40 - OBJ_BUSTERBEATLE
	.byte OA3_HALT_ENDCARDSPECIAL | OA3_TAILATKIMMUNE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OA3_HALT_JUSTDRAW 	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OA3_HALT_JUSTDRAW 	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OA3_HALT_HOTFOOTSPECIAL | OA3_TAILATKIMMUNE	; Object $45 - OBJ_HOTFOOT
	.byte OA3_HALT_PIRANHASPECIAL 	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OA3_HALT_NORMALONLY | OA3_TAILATKIMMUNE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) Pattern Table Select

	.org ObjectGroup_PatTableSel	; <-- help enforce this table *here*
ObjectGroup01_PatTableSel:
	.byte OPTS_SETPT5 | $0E	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte OPTS_NOCHANGE	; Object $25
	.byte OPTS_SETPT5 | $0E	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte OPTS_SETPT5 | $0E	; Object $27 - OBJ_OSCILLATING_H
	.byte OPTS_SETPT5 | $0E	; Object $28 - OBJ_OSCILLATING_V
	.byte OPTS_SETPT5 | $0A	; Object $29 - OBJ_SPIKE
	.byte OPTS_SETPT5 | $0A	; Object $2A - OBJ_PATOOIE
	.byte OPTS_SETPT5 | $0B	; Object $2B - OBJ_GOOMBAINSHOE
	.byte OPTS_SETPT5 | $0E	; Object $2C - OBJ_CLOUDPLATFORM
	.byte OPTS_SETPT5 | $1A	; Object $2D - OBJ_BIGBERTHA
	.byte OPTS_SETPT6 | $13	; Object $2E - OBJ_INVISIBLELIFT
	.byte OPTS_SETPT5 | $12	; Object $2F - OBJ_BOO
	.byte OPTS_SETPT5 | $12	; Object $30 - OBJ_HOTFOOT_SHY
	.byte OPTS_SETPT5 | $12	; Object $31 - OBJ_BOOSTRETCH
	.byte OPTS_SETPT5 | $12	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte OPTS_SETPT5 | $0A	; Object $33 - OBJ_NIPPER
	.byte OPTS_SETPT5 | $05	; Object $34 - OBJ_TOAD
	.byte OPTS_SETPT5 | $05	; Object $35 - OBJ_TOADHOUSEITEM
	.byte OPTS_SETPT5 | $0E	; Object $36 - OBJ_WOODENPLATFORM
	.byte OPTS_SETPT5 | $0E	; Object $37 - OBJ_OSCILLATING_HS
	.byte OPTS_SETPT5 | $0E	; Object $38 - OBJ_OSCILLATING_VS
	.byte OPTS_SETPT5 | $0A	; Object $39 - OBJ_NIPPERHOPPING
	.byte OPTS_SETPT6 | $13	; Object $3A - OBJ_FALLINGPLATFORM
	.byte OPTS_SETPT6 | $4F	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte OPTS_SETPT5 | $0E	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte OPTS_SETPT5 | $0A	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte OPTS_SETPT5 | $1A	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte OPTS_SETPT6 | $13	; Object $3F - OBJ_DRYBONES
	.byte OPTS_SETPT5 | $0A	; Object $40 - OBJ_BUSTERBEATLE
	.byte OPTS_NOCHANGE	; Object $41 - OBJ_ENDLEVELCARD
	.byte OPTS_SETPT6 | $4F	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte OPTS_SETPT6 | $4F	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte OPTS_SETPT5 | $0E	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte OPTS_SETPT5 | $12	; Object $45 - OBJ_HOTFOOT
	.byte OPTS_SETPT5 | $0A	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte OPTS_NOCHANGE	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) "Kill Action"

	.org ObjectGroup_KillAction	; <-- help enforce this table *here*
ObjectGroup01_KillAction:
	.byte KILLACT_STANDARD	; Object $24 - OBJ_CLOUDPLATFORM_FAST
	.byte KILLACT_STANDARD	; Object $25
	.byte KILLACT_STANDARD	; Object $26 - OBJ_WOODENPLAT_RIDER
	.byte KILLACT_STANDARD	; Object $27 - OBJ_OSCILLATING_H
	.byte KILLACT_STANDARD	; Object $28 - OBJ_OSCILLATING_V
	.byte KILLACT_STANDARD	; Object $29 - OBJ_SPIKE
	.byte KILLACT_NORMALANDKILLED	; Object $2A - OBJ_PATOOIE
	.byte KILLACT_STANDARD	; Object $2B - OBJ_GOOMBAINSHOE
	.byte KILLACT_STANDARD	; Object $2C - OBJ_CLOUDPLATFORM
	.byte KILLACT_NORMALSTATE	; Object $2D - OBJ_BIGBERTHA
	.byte KILLACT_STANDARD	; Object $2E - OBJ_INVISIBLELIFT
	.byte KILLACT_STANDARD	; Object $2F - OBJ_BOO
	.byte KILLACT_POOFDEATH	; Object $30 - OBJ_HOTFOOT_SHY
	.byte KILLACT_POOFDEATH	; Object $31 - OBJ_BOOSTRETCH
	.byte KILLACT_POOFDEATH	; Object $32 - OBJ_BOOSTRETCH_FLIP
	.byte KILLACT_STANDARD	; Object $33 - OBJ_NIPPER
	.byte KILLACT_STANDARD	; Object $34 - OBJ_TOAD
	.byte KILLACT_STANDARD	; Object $35 - OBJ_TOADHOUSEITEM
	.byte KILLACT_STANDARD	; Object $36 - OBJ_WOODENPLATFORM
	.byte KILLACT_STANDARD	; Object $37 - OBJ_OSCILLATING_HS
	.byte KILLACT_STANDARD	; Object $38 - OBJ_OSCILLATING_VS
	.byte KILLACT_STANDARD	; Object $39 - OBJ_NIPPERHOPPING
	.byte KILLACT_STANDARD	; Object $3A - OBJ_FALLINGPLATFORM
	.byte KILLACT_NORMALSTATE	; Object $3B - OBJ_CHARGINGCHEEPCHEEP
	.byte KILLACT_STANDARD	; Object $3C - OBJ_WOODENPLATFORMFALL
	.byte KILLACT_STANDARD	; Object $3D - OBJ_NIPPERFIREBREATHER
	.byte KILLACT_STANDARD	; Object $3E - OBJ_WOODENPLATFORMFLOAT
	.byte KILLACT_NORMALANDKILLED	; Object $3F - OBJ_DRYBONES
	.byte KILLACT_STANDARD	; Object $40 - OBJ_BUSTERBEATLE
	.byte KILLACT_STANDARD	; Object $41 - OBJ_ENDLEVELCARD
	.byte KILLACT_STANDARD	; Object $42 - OBJ_CHEEPCHEEPPOOL2POOL
	.byte KILLACT_STANDARD	; Object $43 - OBJ_CHEEPCHEEPPOOL2POOL2
	.byte KILLACT_STANDARD	; Object $44 - OBJ_WOODENPLATUNSTABLE
	.byte KILLACT_POOFDEATH	; Object $45 - OBJ_HOTFOOT
	.byte KILLACT_NORMALSTATE	; Object $46 - OBJ_PIRANHASPIKEBALL
	.byte KILLACT_STANDARD	; Object $47 - OBJ_GIANTBLOCKCTL


	; Object group $01 (i.e. objects starting at ID $24) pattern index starts
	; These are used for all states except "normal"

OG1_POff .func (\1 - ObjectGroup01_PatternSets)

	.org ObjectGroup_PatternStarts	; <-- help enforce this table *here*
ObjectGroup01_PatternStarts:
	; Index by object group relative index (ObjGroupRel_Idx)
	.byte OG1_POff(ObjP24), OG1_POff(ObjP25), OG1_POff(ObjP26), OG1_POff(ObjP27)
	.byte OG1_POff(ObjP28), OG1_POff(ObjP29), OG1_POff(ObjP2A), OG1_POff(ObjP2B)
	.byte OG1_POff(ObjP2C), OG1_POff(ObjP2D), OG1_POff(ObjP2E), OG1_POff(ObjP2F)
	.byte OG1_POff(ObjP30), OG1_POff(ObjP31), OG1_POff(ObjP32), OG1_POff(ObjP33)
	.byte OG1_POff(ObjP34), OG1_POff(ObjP35), OG1_POff(ObjP36), OG1_POff(ObjP37)
	.byte OG1_POff(ObjP38), OG1_POff(ObjP39), OG1_POff(ObjP3A), OG1_POff(ObjP3B)
	.byte OG1_POff(ObjP3C), OG1_POff(ObjP3D), OG1_POff(ObjP3E), OG1_POff(ObjP3F)
	.byte OG1_POff(ObjP40), OG1_POff(ObjP41), OG1_POff(ObjP42), OG1_POff(ObjP43)
	.byte OG1_POff(ObjP44), OG1_POff(ObjP45), OG1_POff(ObjP46), OG1_POff(ObjP47)


	; Object group $01 (i.e. objects starting at ID $24) pattern sets
	; Note that each "frame" is made up of two tile starts, so there's
	; always going to be an even amount of tiles per object.  That is,
	; for each "frame" value, it moves up two bytes to the next pair.

	; NOTE: SPECIAL EXCEPTION: If an object has Objects_IsGiant set
	; OR has its ID >= OBJ_BIGGREENTROOPA, there is an assumption
	; that the initial bytes at ObjectGroup01_PatternSets form a
	; valid JMP $xxxx instruction to go to an alternate giant shell
	; drawing routine (since otherwise default code is used)

	.org ObjectGroup_PatternSets	; <-- help enforce this table *here*
ObjectGroup01_PatternSets:
	; (End restricted alignment space)

ObjP25:
ObjP2F:
ObjP35:
ObjP47:
	.byte $95, $97, $B9, $BF
ObjP30:
ObjP45:
	.byte $85, $87, $89, $8B, $81, $83
ObjP31:
ObjP32:
	.byte $A1, $A3, $A5, $A7, $A9, $AB, $AD, $AF, $71, $71
ObjP26:
ObjP27:
ObjP28:
ObjP36:
ObjP37:
ObjP38:
ObjP3C:
ObjP3E:
ObjP44:
	.byte $8F, $9D, $9D, $9D, $9D, $9F
ObjP2B:
	.byte $A9, $AB, $A9, $AD
ObjP33:
ObjP39:
	.byte $A1, $A3, $AD, $AF, $A5, $A7, $A9, $AB
ObjP34:
	.byte $B9, $BB, $BD, $BF
ObjP3D:
	.byte $A1, $A3, $A5, $A7, $A9, $AB
ObjP2D:
	.byte $81, $83, $85, $8D, $A1, $8B, $81, $83, $85, $87, $89, $8B, $81, $83, $85, $87, $89, $91, $81, $83, $85, $8D, $A1, $8B, $81, $83, $85, $8D, $A1, $91, $71, $A3, $A5, $71, $71, $71, $71, $99, $9B, $71, $71, $71
ObjP24:
ObjP2C:
	.byte $81, $83, $83, $83, $85, $87
ObjP3F:
	.byte $C1, $C3, $C5, $C7, $C9, $CB, $CD, $CF, $D1, $D3, $D5, $F9, $DD, $DF
	
	; Spike's / Patooie's spike ball patterns are actually here
SpikeBall_Patterns:
	.byte $95, $95, $D9, $DB
ObjP29:
	.byte $81, $83, $85, $87, $89, $8B, $8D, $8F, $97, $99
ObjP2A:
ObjP46:
	.byte $E5, $E5, $E1, $E1, $E1, $E1, $BD, $BF, $E3, $E3
ObjP3B:
ObjP42:
ObjP43:
	.byte $E7, $E9, $E7, $EF, $E7, $EF
ObjP3A:
	.byte $71, $E1, $E3, $E1, $E3, $71
ObjP2E:
	.byte $E1, $E3, $E1, $E3
ObjP41:
	.byte $51, $51, $53, $53, $55, $55, $F7, $F7, $F9, $F9, $FB, $FB, $E3, $E3, $E5, $E5, $F5, $F5, $FD, $FD, $FD, $FD, $FD, $FD, $E3, $E3, $E5, $E5, $F5, $F5, $D1, $D3, $D5, $D7
ObjP40:
	.byte $B1, $B3, $B5, $B7, $B9, $BB, $75, $75

GiantBlockCtl_BlkBump:	.byte CHNGTILE_GIANTBRICKFIX, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBLOCKHIT, CHNGTILE_GIANTBRICKBUST
GiantBlockCtl_BlockStarts:	.byte TILE11_BRICK_UL, TILE11_QBLOCKC_UL, TILE11_QBLOCKP_UL
GiantBlockCtl_Frames:	.byte $00, $08, $08

	.byte $00

PRG002_A27B:
	.byte $00, $00, $50, $40, $30, $20, $00, $E0, $D0, $C0, $B0

ObjNorm_GiantBlockCtl:
	LDA Objects_Timer,X
	BNE PRG002_A2CD	 ; If timer not expired, jump to PRG002_A2CD

	LDA Objects_Var2,X
	PHA		 ; Save Var2

	; Clear Var2
	LDA #$00
	STA Objects_Var2,X

	PLA
	STA <Temp_Var11	 ; Restore Var2 -> Temp_Var11
	BNE PRG002_A2A1	 ; If non-zero, jump to PRG002_A2A1

	LDA Player_HitCeiling
	BEQ PRG002_A2CC	 ; If Player did not just hit off ceiling, jump to PRG002_A2CC

	LDA Level_Tile_GndR

PRG002_A2A1:
	STA <Temp_Var1	 ; Var2 or Player detected tile -> Temp_Var1

	LDY #$02	 ; Y = 2
PRG002_A2A5:

	; Determine what kind of giant block was just hit
	LDA <Temp_Var1
	SUB GiantBlockCtl_BlockStarts,Y

	CMP #$04	 
	BGE PRG002_A2C9	 ; If result >= 4 (out of range block type), jump to PRG002_A2C9

	; result < 4 ...

	; Set frame by index
	LDA GiantBlockCtl_Frames,Y
	STA Objects_Frame,X

	TYA		; Y = frame

	BNE PRG002_A2C2	 ; If frame = 0, jump to PRG002_A2C2

	LDA <Temp_Var11
	BNE PRG002_A2C0	 ; If Temp_Var11 (previous Var2) <> 0, jump to PRG002_A2C0

	LDA <Player_Suit
	BEQ PRG002_A2C2	 ; If Player is small, jump to PRG002_A2C2

PRG002_A2C0:
	LDY #$03	 ; Y = 3

PRG002_A2C2:
	TYA		 ; A = frame or 3
	STA Objects_Var1,X	 ; -> Var1

	JMP PRG002_A325	 ; Jump to PRG002_A325

PRG002_A2C9:
	DEY		; Y--
	BPL PRG002_A2A5	; While Y >= 0, loop!

PRG002_A2CC:
	RTS		 ; Return

PRG002_A2CD:

	; Timer not expired...

	CMP #$01
	BNE PRG002_A2DB	 ; If timer is at 1, jump to PRG002_A2DB

	; Timer not expired, > 1

	LDY Objects_Var1,X	 ; Y = Var1

	; Triggers a block bump removal
	LDA GiantBlockCtl_BlkBump,Y
	STA Level_BlkBump+2

	RTS		 ; Return

PRG002_A2DB:
	JSR PRG002_A450

	LDA <Player_HaltGame
	BEQ PRG002_A2E3	 ; If gameplay halted, jump to PRG002_A2E3

	RTS		 ; Return

PRG002_A2E3:
	LDA Objects_Timer,X
	CMP #$0a
	BNE PRG002_A30C	 ; If timer <> $0A, jump to PRG002_A30C

	; Timer = $0A...

	PHA		 ; Save timer value

	; Object Y Hi -> Temp_Var13
	LDA <Objects_YHi,X
	STA <Temp_Var13	

	; Object Y -> Temp_Var14
	LDA <Objects_Y,X
	STA <Temp_Var14	

	; Object X Hi -> Temp_Var15
	LDA <Objects_XHi,X
	STA <Temp_Var15	

	; Object X -> Temp_Var16
	LDA <Objects_X,X
	PHA		 ; Save Object X
	STA <Temp_Var16

	; Clear this tile
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore 'X'
	ORA #$10	 ; Intended as next tile to the right I think
	STA <Temp_Var16	 ; -> Temp_Var16

	; Clear this tile too
	LDA #TILEA_BLOCKBUMP_CLEAR
	JSR Level_ChangeTile_ByTempVars

	PLA		 ; Restore timer

PRG002_A30C:
	TAY		 ; current timer value -> 'Y'
	LDA PRG002_A27B,Y	
	STA <Objects_YVel,X	 ; Applies a staggering Y velocity

	JMP Object_ApplyYVel	 ; Apply Y velocity and don't come back!

GiantBlockCtl_DebrisXOff:	.byte $00, $10, $00, $10
GiantBlockCtl_DebrisYOff:	.byte $00, $00, $10, $10
GiantBlockCtl_DebrisXVel:	.byte -$10, $10, -$10, $10
GiantBlockCtl_DebrisYVel	.byte -$40, -$40, -$28, -$28

PRG002_A325:
	; Set like Player bounced up
	LDA #$01	 
	STA Player_BounceDir

	LDA <Temp_Var11	 ; A = Temp_Var11 (previous Var2)
	BNE PRG002_A35E	 ; If non-zero, jump to PRG002_A35E

	; Play "bump" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	; Set Object Y Hi = Player's Y Hi
	LDA <Player_YHi
	STA <Objects_YHi,X

	LDA <Player_Y

	LDY <Player_Suit
	BEQ PRG002_A347	 ; If Player is small, jump to PRG002_A347

	; Player is NOT small; subtract 16
	SUB #$10
	BCS PRG002_A347
	DEC <Objects_YHi,X	; Apply carry
PRG002_A347:

	AND #$f0	 ; Align to tile grid row
	ORA #$10	 ; Ensures nearest 32
	STA <Objects_Y,X ; -> Object_Y

	; Set Object X Hi = Player's X Hi
	LDA <Player_XHi	
	STA <Objects_XHi,X

	; Use Player X + 8
	LDA <Player_X
	ADD #$08	
	BCC PRG002_A35A	
	INC <Objects_XHi,X	; Apply carry
PRG002_A35A:

	AND #$e0	 ; Aligned to tile grid, left side only
	STA <Objects_X,X ; -> Object_X

PRG002_A35E:

	; Set BlkBump slot 2 coordinates to the object's position

	LDA <Objects_X,X
	STA Level_BlkBump_XLo+2

	LDA <Objects_XHi,X
	STA Level_BlkBump_XHi+2

	LDA <Objects_YHi,X
	STA Level_BlkBump_YHi+2

	LDA <Objects_Y,X
	STA Level_BlkBump_YLo+2

	LDA #CHNGTILE_GIANTBRICKBUST
	STA Level_BlkBump+2

	LDA Objects_Var1,X
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word GBCtl_BrickBump	; 0: Giant brick bump (small Player hit it)
	.word GBCtl_CoinBlock	; 1: Giant [?] block with coin
	.word GBCtl_LeafBlock	; 2: Giant [?] block with power up
	.word GBCtl_BrickBust	; 3: Giant brick bust

GBCtl_BrickBump:
	JMP PRG002_A420	; Jump to PRG002_A420

GBCtl_CoinBlock:
	INC Coins_Earned	 ; Give a coin

	LDA <Objects_Y,X
	STA <Temp_Var1		; Temp_Var1 = Object's Y

	LDA <Objects_X,X
	ORA #$0e
	STA <Temp_Var2		; Temp_Var2 = Object's X aligned evenly in column

	JSR PRG000_C49B	 ; Init for emerging coin

	JMP PRG002_A420	 ; Jump to PRG000_C49B

GBCtl_LeafBlock:
	LDA <Player_X
	AND #$10
	STA Player_MushFall ; Determine which way a powerup should fall

	LDA #$1e	; A = $1E if Player is not small (Super Leaf)

	LDY <Player_Suit
	BNE PRG002_A3AA	 ; If Player is NOT small, jump to PRG002_A3AA

	LDA #$0d	 ; Otherwise, A = $0D (Mushroom)

PRG002_A3AA:
	LDY #$05	 ; Y = 5 (altering fifth object slot)

	; Make power up appear
	STA Level_ObjectID,Y

	; Set State = 1 (Init)
	LDA #OBJSTATE_INIT
	STA Objects_State,Y

	; Set X as +8 from Object X
	LDA <Objects_X,X
	ADD #$08
	STA Objects_X,Y

	; Match other coordinates
	LDA <Objects_XHi,X
	STA Objects_XHi,Y
	LDA <Objects_Y,X
	STA Objects_Y,Y	
	LDA <Objects_YHi,X
	STA Objects_YHi,Y

	JMP PRG002_A420	 ; Jump to PRG002_A420

GBCtl_BrickBust:
	; Crumbling brick noise
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	LDX #$03	 ; X = 3 (looking for up to 4 special objects, the brick debris)
	LDY #$05	 ; Y = 5

PRG002_A3DA:
	LDA SpecialObj_ID,Y
	BEQ PRG002_A3E5	 ; If this special object slot is free, jump to PRG002_A3E5

	DEY		 ; Y--
	BPL PRG002_A3DA	 ; While Y >= 0, loop!

	; SB: There's an interesting bug here; if no free slot is found,
	; we jump to PRG002_A417, which decrements 'Y' then 'X'. It is possible
	; that there are no free "special object" slots, but we haven't decremented
	; 'X' all the way, which means that we continue to loop! So you could have
	; Y = -1, Y = -2, ... and, bingo, memory corruption!
	
	; Incidentally, this never happens in SMB3 because the Giant World levels 
	; were designed such that there was no way that all special object slots 
	; were used and you could never break more than one giant brick at once,
	; which would certainly overflow the special object slots.
	
	; If the decrement operations were reversed at PRG002_A417, this underflow
	; wouldn't happen. That's really all that's needed!

	JMP PRG002_A417	 ; Jump to PRG002_A417

PRG002_A3E5:

	; Found a free slot!

	; Brick debris
	LDA #SOBJ_BRICKDEBRIS
	STA SpecialObj_ID,Y

	; Set brick debris coordinates
	LDA GiantBlockCtl_DebrisXOff,X
	ADD Level_BlkBump_XLo+2	
	STA SpecialObj_XLo,Y	

	LDA GiantBlockCtl_DebrisYOff,X	
	ADD Level_BlkBump_YLo+2
	STA SpecialObj_YLo,Y
	LDA #$00	
	ADC Level_BlkBump_YHi+2	
	STA SpecialObj_YHi,Y	

	; Set brick debris X Velocity
	LDA GiantBlockCtl_DebrisXVel,X	
	STA SpecialObj_XVel,Y	

	; Set brick debris Y Velocity
	LDA GiantBlockCtl_DebrisYVel,X	
	STA SpecialObj_YVel,Y

	; Brick data = 0
	LDA #$00
	STA SpecialObj_Data,Y

PRG002_A417:
	DEY		 ; Y--
	DEX		 ; X--
	BPL PRG002_A3DA	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_A420	 ; Jump to PRG002_A420

PRG002_A420:
	LDA <Temp_Var11	; A = Temp_Var11 (previous Var2)
	BNE PRG002_A428	 ; If non-zero, jump to PRG002_A428

	; Otherwise, halt Player's vertical movement
	LDA #$00
	STA <Player_YVel

PRG002_A428:

	; Set timer to $0B
	LDA #$0b
	STA Objects_Timer,X

	JMP PRG002_A450	 ; Jump to PRG002_A450

GiantBlockCtl_Pats:	.byte $73, $7B, $7B, $73, $7D, $7F, $7F, $7D, $79, $7B, $7B, $79, $79, $7B, $7B, $79
GiantBlockCtl_Attrs:	.byte $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, $00, $00, SPR_HFLIP, SPR_HFLIP, SPR_VFLIP, SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, SPR_HFLIP | SPR_VFLIP

PRG002_A450:
	LDA Objects_Var1,X
	CMP #$03
	BEQ PRG002_A487	 ; If Var1 = 3, jump to PRG002_A487 (RTS)

	JSR Object_CalcSpriteXY_NoHi

	LDA <Objects_SpriteX,X
	STA <Temp_Var2		 ; Temp_Var2 = Sprite X

	PHA		 ; Save it

	DEC <Objects_SpriteY,X	 ; Sprite Y--

	LDA <Objects_SpriteY,X
	STA <Temp_Var3		 ; Temp_Var3 = Sprite Y

	PHA		 ; Save it

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset

	LDA Objects_Frame,X
	TAX		 ; X = object's frame
	JSR GiantBlockCtl_Draw
	JSR GiantBlockCtl_Draw

	PLA		 ; Restore Sprite Y
	ADD #16
	STA <Temp_Var3	 ; Temp_Var3 = Sprite Y + 16

	PLA		 ; Restore Sprite X
	STA <Temp_Var2	 ; -> Temp_Var2

	JSR GiantBlockCtl_Draw
	JSR Object_GetRandNearUnusedSpr	 ; Get random nearby unused sprite
	JSR GiantBlockCtl_Draw

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_A487:
	RTS		 ; Return

GiantBlockCtl_Draw:
	LDA Player_AboveTop
	BNE PRG002_A4B7	 ; If Player is way up high, jump to PRG002_A4B7 (RTS)

	LDA #$02
	STA <Temp_Var5	 ; Temp_Var5 = 2
PRG002_A491:
	; Store Sprite Y
	LDA <Temp_Var3
	STA Sprite_RAM+$00,Y

	; Store appropriate pattern
	LDA GiantBlockCtl_Pats,X
	STA Sprite_RAM+$01,Y

	; Set attributes
	LDA #SPR_PAL3	; Palette select 3
	ORA GiantBlockCtl_Attrs,X	; And what he's having
	STA Sprite_RAM+$02,Y

	; Store Sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	; X += 8
	ADD #$08
	STA <Temp_Var2

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	INX		 ; X++ (next pattern/attribute)

	DEC <Temp_Var5	 ; Temp_Var5--
	BNE PRG002_A491	 ; While Temp_Var5 > 0, loop!

PRG002_A4B7:
	RTS		 ; Return

	; Carry is set if gameplay not halted and object not dead
CarryClearIfAliveAndNoHalt:
	LDA Objects_State,X	  
	CMP #OBJSTATE_KILLED	; Carry is clear unless state >= OBJSTATE_KILLED
	BEQ PRG002_A4C5	 ; If object state is Dying, jump to PRG002_A4C5

	CLC		 ; Clear carry (if any state other than OBJSTATE_KILLED)

	LDA <Player_HaltGame
	BEQ PRG002_A4C5	 ; If gameplay is not halted, jump to PRG002_A4C5

	SEC		 ; Set carry

PRG002_A4C5:
	RTS		 ; Return

Buster_XVel:	.byte -$10, $10

ObjInit_BusterBeatle:
	LDY <Scroll_LastDir	; Get last scroll direction

	; Set flip bits to face Player
	LDA FacePlayer_FlipBitsStart,Y
	STA Objects_FlipBits,X

	; Set appropriate X velocity for Buster Beatle
	LDA Buster_XVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return


ObjNorm_BusterBeatle:
	JSR Object_Move	 ; Do standard object movements
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block
	JSR Object_HitFloorAlign	 ; If Buster hits floor, align him

	LDA <Objects_DetStat,X
	AND #$03
	BEQ PRG002_A535	 ; If not hit wall, jump to PRG002_A535

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A532	 ; If Buster has not hit floor, jump to PRG002_A532

	LDA <Objects_SpriteX,X
	CMP #$04
	BLT PRG002_A532	 ; If Buster is near left edge of screen, jump to PRG002_A532

	CMP #232
	BCS PRG002_A532	 ; If Buster is near right edge of screen, jump to PRG002_A532

	JSR Object_AnySprOffscreen
	BNE PRG002_A532	 ; If any of Buster's sprite are off-screen, jump to PRG002_A532

	LDY #$01	; Y = 1 (Buster's got brick!)

	LDA Object_TileWall2

	CMP #TILEA_ICEBRICK
	BEQ PRG002_A508	 ; If Buster's touching an ice brick, jump to PRG002_A508

	; ?? This might be lost functionality?
	; Tile $F4 is Jelectro in most sets... Buster will pick up and toss this
	; tile like an Ice Brick, but it's ... never an Ice Brick.  
	; Maybe he'd toss Jelectros at you??
	CMP #$f4
	BNE PRG002_A532

	INY		 ; Y = 2

PRG002_A508:
	STY <Objects_Var5,X	 ; Update Var5

	; Change tile event (to background) by ice brick
	LDA #CHNGTILE_DELETETOBG
	STA Level_ChgTileEvent

	; Set all of the block change coordinates to remove the ice brick
	LDA ObjTile_DetYHi
	STA Level_BlockChgYHi

	LDA ObjTile_DetYLo
	AND #$f0
	STA Level_BlockChgYLo

	LDA ObjTile_DetXHi
	STA Level_BlockChgXHi

	LDA ObjTile_DetXLo
	AND #$f0
	STA Level_BlockChgXLo

	; Set Buster's timer 2 to $0F
	LDA #$0f
	STA Objects_Timer2,X

	BNE PRG002_A535	 ; Jump (technically always) to PRG002_A535

PRG002_A532:
	JSR Object_AboutFace	 ; Buster turns around

PRG002_A535:
	LDA Objects_Timer,X
	BNE PRG002_A542	 ; If timer not expired, jump to PRG002_A542

	LDA Objects_Timer2,X 
	BEQ PRG002_A542	 ; If timer 2 expired, jump to PRG002_A542

	; Timer 2 not expired...
	ADD #29	 ; Add to timer 2 value

PRG002_A542:
	LSR A		 
	STA <Objects_Var4,X	 ; Var4 = timer2 / 2

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Buster_DrawHoldingIceBrick	 ; Draw Buster with his ice brick if he has it

	LDA <Objects_Var5,X
	ORA Objects_Timer,X
	BNE PRG002_A568	 	; If Buster is holding a brick or his timer is not expired, jump to PRG002_A568

	LDY #$10	 ; Y = $10 (Run right)

	LDA Objects_FlipBits,X
	ASL A
	BMI PRG002_A55C	 ; If horizontally flipped, jump to PRG002_A55C

	LDY #-$10	 ; Y = -$10 (Run left)

PRG002_A55C:
	STY <Objects_XVel,X	 ; Set Buster's X Velocity

	; Buster's little frame toggle
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A568:

	; Buster with brick or timer not expired

	; Halt Buster's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	LDA Objects_Timer2,X
	BEQ PRG002_A57B	 ; If Timer 2 expired, jump to PRG002_A57B

	; Timer 2 not expired...

	AND #%00011000
	BNE PRG002_A5A1	 ; Timing jump to PRG002_A5A1 (RTS)
 
	; Buster's frame = 2 
	LDA #$02
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A57B:
	LDA Objects_Timer,X
	BEQ PRG002_A587	 ; If timer expired, jump to PRG002_A587

	CMP #$11
	BNE PRG002_A5A1	 ; If timer <> $11, jump to PRG002_A5A1 (RTS)
	JMP PRG002_A5A2	 ; Otherwise, jump to PRG002_A5A2

PRG002_A587:
	LDA <Counter_1
	AND #$07
	BNE PRG002_A5A1	 ; 1:8 ticks continue, otherwise jump to PRG002_A5A1 (RTS)

	; Set Buster's flip to face towards Player
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	CMP #$0c
	BGE PRG002_A5A1	 ; If Player is too far away, jump to PRG002_A5A1 (RTS)

	; "Stay close for $1B and I'll getcha..."
	LDA #$1b
	STA Objects_Timer,X

PRG002_A5A1:
	RTS		 ; Return

PRG002_A5A2:
	LDX #$04	 ; X = 4

PRG002_A5A4:
	LDA Objects_State,X
	BEQ PRG002_A5AE	 ; If this object slot's state is Dead/Empty, jump to PRG002_A5AE

	DEX		 ; X--
	BPL PRG002_A5A4	 ; While X >= 0, loop!
	BMI PRG002_A5F8	 ; Otherwise, jump to PRG002_A5F8

PRG002_A5AE:
	JSR Level_PrepareNewObject	; Generate new object for tossed ice block

	LDY <SlotIndexBackup	 ; Y = Buster's slot index

	; Var5 and Frame = 0
	LDA #$00
	STA Objects_Var5,Y
	STA Objects_Frame,Y

	; Set Ice Block to state Kicked
	LDA #OBJSTATE_KICKED
	STA Objects_State,X

	; It's an Ice Blocj
	LDA #OBJ_ICEBLOCK
	STA Level_ObjectID,X

	; Set Frame = 2
	LDA #$02
	STA Objects_Frame,X

	; Set expiration timer
	LDA #$ff
	STA Objects_Timer3,X

	; Set X
	LDA Objects_X,Y
	STA <Objects_X,X

	; Set X Hi
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	; Set Y/Hi
	LDA Objects_Y,Y
	SUB #16
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	LDA Objects_FlipBits,Y

	LDY #$30	 ; Y = $30
	ASL A
	BMI PRG002_A5F2	 ; If Buster's turned around, jump to PRG002_A5F2
	LDY #-$30	 ; Otherwise, Y = -$30
PRG002_A5F2:
	STY <Objects_XVel,X

	; Set Y velocity
	LDA #-$30
	STA <Objects_YVel,X

PRG002_A5F8:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Buster_BlockLiftXOff:
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $02, $03, $02, $01, $00
	.byte $01, $03, $05, $07, $08, $09, $0A, $0A

Buster_BlockLiftYOff:
	.byte -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0E, -$0D
	.byte -$0C, -$0D, -$0E, -$0E, -$0F, -$0E, -$0D, -$0B, -$09, -$06, -$03, $00 

Buster_DrawHoldingIceBrick:
	JSR Object_ShakeAndCalcSprite	 

	LDA <Temp_Var3
	BPL PRG002_A641	 ; If object is not vertically flipped, jump to PRG002_A641

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var4,X
	TAX		 	; X = Var4 (lift offset index)

	; Offset sprite Y by the index given in Var4
	LDA <Temp_Var1
	ADD Buster_BlockLiftYOff,X
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = Var6

PRG002_A641:
	JSR Object_Draw16x16Sprite	 ; Draw Buster

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var5,X
	BEQ PRG002_A68B	 	; If Var5 = 0 (not holding brick), jump to PRG002_A68B (RTS)

	; Var5 not zero...

	PHA		 	; Save Var5

	LDA <Objects_SpriteY,X

	LDY <Objects_Var4,X	 ; Y = Var4

	BIT <Temp_Var3
	BMI PRG002_A657	 	; If vertically flipped, jump to PRG002_A657

	; Adds an offset in case Buster's holding a block... but since it's
	; applied all the time, it just looks odd otherwise...
	ADD Buster_BlockLiftYOff,Y

PRG002_A657:
	STA <Temp_Var1		 ; Update Sprite Y

	LDA Buster_BlockLiftXOff,Y
	BIT <Temp_Var3
	BVS PRG002_A663	 ; If Buster is horizontally flipped, jump to PRG002_A663

	JSR Negate	 ; Negate the X offset if he's flipped around

PRG002_A663:
	ADD <Temp_Var2	; Apply X offset
	STA <Temp_Var2	; Update Sprte X

	LDA Level_NoStopCnt
	AND #$03	; Palette select 0-3
	STA <Temp_Var4	; Custom color cycling on the ice brick he's holding

	PLA		 ; Restore Var5
	TAY		 ; -> 'Y'

	LDX #$BE	 ; X = $BE (Ice Brick tile)

	LDA <Temp_Var7
	ADD #$08	
	TAY		 ; Y = Sprite_RAM + 8

	JSR Object_Draw16x16Sprite

	; Draw Ice Brick
	LDA Sprite_RAM+$02,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$02,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_A68B:
	RTS		 ; Return

ObjInit_PipewayCtlr:
	; Changes Objects_Y into a grid row position (including the high) rather than a pixel position
	; Used as index (see ObjNorm_PipewayCtlr)
	LSR <Objects_YHi,X
	LDA <Objects_Y,X
	ROR A	; Carries in the high bit, first division
	LSR A
	LSR A
	LSR A	; Completes divide-by-16 (makes grid row position)
	STA <Objects_Y,X

	; Flag we were just in a Pipeway
	INC Map_WasInPipeway

	RTS		 ; Return

	; Sets the "Map_Entered_XHi" value based on whether you're coming or going
	; That means the Player's X Hi position on the map (not screen scroll position!)
	; Almost the same as PipewayCtlr_MapScrlXHi without the centering bit.
PipewayCtlr_MapXHi:
	.byte $10	; 0
	.byte $00	; 1
	.byte $00	; 2
	.byte $11	; 3
	.byte $00	; 4
	.byte $00	; 5
	.byte $00	; 6
	.byte $01	; 7
	.byte $01	; 8
	.byte $01	; 9
	.byte $11	; 10
	.byte $11	; 11
	.byte $01	; 12
	.byte $12	; 13
	.byte $23	; 14
	.byte $01	; 15
	.byte $12	; 16
	.byte $22	; 17
	.byte $00	; 18
	.byte $01	; 19
	.byte $12	; 20
	.byte $01	; 21
	.byte $01	; 22
	.byte $00	; 23


	; This contains two values for Map X (*16) whether you're coming or going.
	; That means the Player's X Lo position on the map (not screen scroll position!)
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
PipewayCtlr_MapX:
	.byte $8C	; 0
	.byte $8E	; 1
	.byte $4E	; 2
	.byte $06	; 3
	.byte $43	; 4
	.byte $6D	; 5
	.byte $59	; 6
	.byte $50	; 7
	.byte $81	; 8
	.byte $B6	; 9
	.byte $2D	; 10
	.byte $3A	; 11
	.byte $8C	; 12
	.byte $22	; 13
	.byte $62	; 14
	.byte $6A	; 15
	.byte $8C	; 16
	.byte $4C	; 17
	.byte $4A	; 18
	.byte $A6	; 19
	.byte $4D	; 20
	.byte $4A	; 21
	.byte $22	; 22
	.byte $46	; 23

	; This contains two values for Map Y (*16) whether you're coming or going.
	; That means the Player's Y position on the map
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
PipewayCtlr_MapY:
	.byte $44	; 0
	.byte $86	; 1
	.byte $84	; 2
	.byte $62	; 3
	.byte $57	; 4
	.byte $53	; 5
	.byte $73	; 6
	.byte $99	; 7
	.byte $95	; 8
	.byte $57	; 9
	.byte $74	; 10
	.byte $53	; 11
	.byte $37	; 12
	.byte $55	; 13
	.byte $57	; 14
	.byte $53	; 15
	.byte $57	; 16
	.byte $99	; 17
	.byte $A8	; 18
	.byte $A6	; 19
	.byte $68	; 20
	.byte $48	; 21
	.byte $84	; 22
	.byte $44	; 23

	; This is for the horizontal scroll position of the map.
	; The lower bits of each nibble specify the hard screen position 
	; (i.e. scroll X Hi) and if the highest bit is set means to use
	; the center $80 position instead of the $00 position.
	; The upper nibble ("left") cooresponds to the pipe on the left side
	; The lower nibble ("right") cooresponds to the pipe on the right side
PipewayCtlr_MapScrlXHi:
	.byte $10	; 0
	.byte $08	; 1
	.byte $08	; 2
	.byte $81	; 3
	.byte $00	; 4
	.byte $08	; 5
	.byte $00	; 6
	.byte $08	; 7
	.byte $08	; 8
	.byte $01	; 9
	.byte $81	; 10
	.byte $81	; 11
	.byte $01	; 12
	.byte $12	; 13
	.byte $23	; 14
	.byte $01	; 15
	.byte $12	; 16
	.byte $22	; 17
	.byte $00	; 18
	.byte $01	; 19
	.byte $12	; 20
	.byte $01	; 21
	.byte $08	; 22
	.byte $00	; 23

ObjNorm_PipewayCtlr:
	JSR PipewyCtl_SetCarryByPPos	 ; Carry = 1 if Player is on lower part of level OR if Player is on right half of screen

	LDA #$00
	ROR A
	STA <Temp_Var1	 ; Temp_Var1 = $00 or $80 based on above

	LDY <Objects_Y,X	; Y = object's Y position	

	LDX Player_Current ; X = Current Player

	LDA PipewayCtlr_MapXHi,Y	; Get appropriate Map X Hi value

	BIT <Temp_Var1
	BMI PRG002_A712	 ; If Temp_Var1 = $80, jump to PRG002_A712

	; Otherwise, shift retrieved value down by 4 bits (get secondary value)
	LSR A	
	LSR A	
	LSR A	
	LSR A	

PRG002_A712:
	AND #%00001111	; Keep only one of the values

	STA Map_Entered_XHi,X	 ; Set as Map X High

	; Set Map X
	LDA PipewayCtlr_MapX,Y
	JSR PipewyCtl_GetUpperValue
	STA Map_Entered_X,X

	; Set Map Y
	LDA PipewayCtlr_MapY,Y
	JSR PipewyCtl_GetUpperValue
	STA Map_Entered_Y,X

	LDA PipewayCtlr_MapScrlXHi,Y
	JSR PipewyCtl_GetUpperValue
	TAY		 ; -> 'Y'

	; Set X Offset as appropriate by coordinate (i.e. map at left alignment or halfway-center alignment)
	AND #$80
	STA Map_Prev_XOff,X

	; Basically takes a 3-bit value packed in the upper nibble
	; and moves it to the bottom; the lower nibble is zeroed
	; out thanks to PipewyCtl_GetUpperValue so it has no effect.
	TYA	;   xwyz 0000
	ASL A	; x wyz0 0000
	ASL A	; w yz00 0000
	ROL A	; y z000 000w
	ROL A	; z 0000 00wy 
	ROL A	; 0 0000 0wyz
	STA Map_Prev_XHi,X	 ; Store as Map X Hi

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return


PipewyCtl_SetCarryByPPos:
	LDY <Objects_YHi,X	 
	BNE PRG002_A749	 ; If Player is on lower part of level, jump to PRG002_A749

	; Player is on upper part of level...

	LDA <Player_SpriteX
	ASL A		 ; Set carry by Player's sprite X bit 7 (i.e. Player on right half of screen sets carry = 1)
	RTS		 ; Return

PRG002_A749:

	; Player is on lower part of level...

	LDA <Player_YHi	
	LSR A		 ; Set carry = 1
	RTS		 ; Return


PipewyCtl_GetUpperValue:
	BIT <Temp_Var1
	BPL PRG002_A755	 ; If , jump to PRG002_A755

	; Shift value into upper 4 bits
	ASL A
	ASL A
	ASL A
	ASL A

PRG002_A755:
	AND #%11110000	; Keep only upper 4 bits
	RTS		 ; Return

ObjInit_CheepCheepP2P2:
	LDA #$04
	STA <Objects_Var4,X	 ; Var4 = 4

ObjInit_CheepCheepP2P:

	; Timer = $40
	LDA #$40
	STA Objects_Timer,X

	; Set attribute $20 (sprite priority)
	LSR A
	STA Objects_FlipBits,X

	RTS		 ; Return

CheepP2P_XVel:	.byte -$10, -$10, $10, $10, -$10, $10
CheepP2P_YVel:	.byte -$36, -$36, -$47, -$47, -$3F, -$3F

PRG002_A772:	.byte $20, $20, -$20, -$20, $00, $00
	
ObjNorm_CheepCheepP2P:
	LDA Objects_Timer,X
	BEQ PRG002_A793	 ; If timer expired, jump to PRG002_A793

	; Timer not expired...

	LSR A
	BNE PRG002_A7E0	 ; If timer > 1, jump to PRG002_A7E0

	; Timer = 1...

	; Loop Var4 3-0
	LDY <Objects_Var4,X	; Y = Var4
	DEY		 	; Y--
	BPL PRG002_A787	 	; If Y >= 0, jump to PRG002_A787
	LDY #$03	 	; Otherwise, Y = 3
PRG002_A787:
	STY <Objects_Var4,X	; Update Var4

	; Set Cheep Cheep's Y Velocity
	LDA CheepP2P_YVel,Y
	STA <Objects_YVel,X

	; Set Cheep Cheep's X velocity
	LDA CheepP2P_XVel,Y
	STA <Objects_XVel,X

PRG002_A793:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Player_HitEnemy	 ; Standard Enemy Collision routine

	LDY <Objects_YVel,X	; Y = Cheep Cheep's Y velocity

	; Y += 2 (gravity)
	INY
	INY

	TYA		 
	PHA		 ; Save velocity

	JSR Object_GetAttrAndMoveTiles	 ; Most importantly checking for water

	PLA		 ; Restore velocity
	STA <Objects_YVel,X	 ; Set it (ignore the water velocity)

	; NOTE: This only works on a limited range of velocities (not a problem here)
	; but it should have been a right shift for a more general implementation.
	LDA <Objects_XVel,X
	ASL A
	AND #SPR_HFLIP
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Set facing by velocity

	LDY <Objects_Var4,X	 ; Y = Var4

	LDA <Objects_Var5,X
	ADD Object_VelCarry
	CMP PRG002_A772,Y
	BLS PRG002_A7D4	 ; If Var5 < limit value, jump to PRG002_A7D4

	; Limit value hit...

	LDY <Objects_YVel,X
	BMI PRG002_A7D4	 ; If Cheep Cheep is moving upward, jump to PRG002_A7D4

	; Align to tile X
	LDA <Objects_X,X
	AND #$f0
	STA <Objects_X,X

	; Align to tile Y
	LDA <Objects_Y,X
	AND #$f0
	STA <Objects_Y,X

	JSR ObjInit_CheepCheepP2P	 ; Re-initialize!

	LDA #$00	 ; Reset Var5

PRG002_A7D4:
	STA <Objects_Var5,X	 ; Update Var5

	; Toggle Cheep Cheep's frame
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

PRG002_A7E0:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JMP Object_ShakeAndDraw	 ; Draw Cheep Cheep and don't come back!

ObjNorm_CheepCheepP2P2:

	; Alternate pool-to-pool Cheep Cheep is pretty much the same,
	; and reuses most of the code, just inverts the movements...

	LDA Objects_Timer,X
	BEQ PRG002_A793	 ; If timer not expired, jump to PRG002_A793

	LSR A
	BNE PRG002_A7E0	 ; If timer > 1, jump to PRG002_A7E0

	LDA <Objects_Var4,X
	EOR #$01	 ; Invert Var4
	TAY		 ; -> Y
	BPL PRG002_A787	 ; Jump (technically always) to PRG002_A787

	; Different "entropy" values by the object's slot -- keeps things random looking
Entropy_BySlot:	.byte $13, $D7, $F9, $36, $7F

ObjInit_HotFoot:
	LDA Entropy_BySlot,X
	STA <Objects_Var5,X

ObjInit_HotFootShy:

	; Center Hot Foot
	LDA <Objects_X,X
	ORA #$04
	STA <Objects_X,X

	RTS		 ; Return

ObjNorm_HotfootShy:
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; Hotfoot's gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	JSR Object_WorldDetectN1
	LDA <Objects_DetStat,X
	AND #$03
	BNE PRG002_A81B	 ; If Hotfoot hit a wall, jump to PRG002_A81B

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG002_A81B:
	JSR Object_HitFloorAlign	 ; If HotFoot hits the floor, align him to it
	JSR Boo_CheckPlayerSight	 ; Uses Boo's check-facing logic

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot has NOT hit floor, jump to PRG002_A846

	LDA #$00	; Don't move (if not chasing Player)

	BCC PRG002_A844	 ; (From Boo_CheckPlayerSight) if not chasing Player, jump to PRG002_A844

	; Hotfoot is chasing Player...

	; Face same way as Player
	LDA <Player_FlipBits
	STA Objects_FlipBits,X

PRG002_A832:
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02
	TAY		 ; Y = 0 or 2

	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA #$08	; Walk right

	BCS PRG002_A844	; If horizontally flipped, jump to PRG002_A844

	LDA #-$08	; Walk left

PRG002_A844:
	STA <Objects_XVel,X	 ; Set X velocity appropriately

PRG002_A846:
	TYA		 ; A = 0 or 2
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_A850:
	LSR Objects_Frame,X	 ; Frame becomes 0 or 1 (to be ROLled back)

	LDA <Counter_1
	LSR A	
	ROL Objects_Frame,X	 ; Frame is now 0/1 or 2/3, depending on counter LSb (flickering effect) 

Bank2_HotFootHaltAction:
	JSR Object_AnySprOffscreen
	BNE PRG002_A888	 ; If any of Hotfoot's sprites are off-screen, jump to PRG002_A888 (RTS)

	JSR Object_CalcSpriteXY_NoHi	; Calculate Hotfoot's sprites
	LDY ObjGroupRel_Idx	 	; Y = Object's group relative index
	LDA ObjectGroup_PatternStarts,Y	; Get Hotfoot's starting pattern index
	ADD Objects_Frame,X	 	; Offset by frame
	TAY		 		; -> 'Y'
	LDA ObjectGroup_PatternSets,Y	; Get appropriate sprite pattern for this frame

	; Store pattern into sprite RAM
	LDY Object_SprRAM,X
	STA Sprite_RAM+$01,Y

	; Store Y coordinate
	LDA <Objects_SpriteY,X
	STA Sprite_RAM+$00,Y

	; Store attributes
	LDA Objects_SprAttr,X
	ORA Objects_FlipBits,X
	STA Sprite_RAM+$02,Y

	; Store X coordinate
	LDA <Objects_SpriteX,X
	STA Sprite_RAM+$03,Y	

PRG002_A888: 
	RTS		 ; Return


ObjNorm_Hotfoot:

	; Mostly reuses the "shy" Hotfoot's code

	JSR CarryClearIfAliveAndNoHalt
	BCS PRG002_A850	 ; If Hotfoot is not alive or gameplay is halted, jump to PRG002_A850

	; Hotfoot alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDY #$04	 ; Y = 4

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_A846	 ; If Hotfoot hasn't hit floor, jump to PRG002_A846

	INC <Objects_Var5,X	 ; Var5++
	LDA <Objects_Var5,X	
	AND #$a0
	BEQ PRG002_A844	 ; If Var5 = $A0, jump to PRG002_A844

	ASL A

	LDA <Objects_Var5,X
	TAY		 ; Y = Var5
	AND #%01011111
	BNE PRG002_A8B6	 ; Most of the time, jump to PRG002_A8B6

	BCC PRG002_A8B3	 ; If Var5 bit 7 not set, jump to PRG002_A8B3

	JSR Object_CalcCoarseXDiff
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Store flip towards Player

PRG002_A8B3:
	JSR Object_FlipFace	 ; Turn around

PRG002_A8B6:
	JMP PRG002_A832	 ; Jump to PRG002_A832

Boo_CheckPlayerSight:
	LDY <Objects_Var5,X

	JSR Object_CalcCoarseXDiff
	EOR <Player_FlipBits	 ; Check flip direction against Player; if Player and Boo are facing eachother, result is non-zero
	ASL A		 ; Push up result so it is $00 or $80
	BPL PRG002_A8C5	 ; If Player is not facing Boo, jump to PRG002_A8C5

	LDY #$00	 ; Otherwise, Y = 0

PRG002_A8C5:
	CPY #$14
	BGE PRG002_A8CC	 ; If Var5 >= $14 (Time to start chasing!), jump to PRG002_A8CC

	INY		 ; Y++ (Delaying before starting chase)

	STY <Objects_Var5,X	; Update Var5

PRG002_A8CC:
	RTS		 ; Return

Boo_VelAccel:	.byte $01, -$01
Boo_VelLimit:	.byte $10, -$10

ObjNorm_Boo:
	JSR Boo_CheckPlayerSight
	BCS PRG002_A8DE	 ; If carry set, it's time to start chasing Player!  Jump to PRG002_A8DE

	; Otherwise, Boo just sits still
	LDA #$00
	STA <Objects_XVel,X
	STA <Objects_YVel,X

	BEQ PRG002_A916	 ; Jump (technically always) to PRG002_A916

PRG002_A8DE:
	JSR Level_ObjCalcXDiffs

	LDA <Objects_XVel,X
	CMP Boo_VelLimit,Y	
	BEQ PRG002_A8EE	 ; If Boo is at his acceleration limit, jump to PRG002_A8EE

	ADD Boo_VelAccel,Y	 ; Boo accelerates!
	STA <Objects_XVel,X	 ; Update Boo's X velocity

PRG002_A8EE:

	; Set flip bit as appropriate
	LDA FacePlayer_FlipBitsStart+1,Y
	STA Objects_FlipBits,X	

	JSR Object_CalcCoarseYDiff

	LDY #$00	 ; Y = 0 (Player is lower, move down!)

	LDA <Temp_Var15
	SUB #$04
	BMI PRG002_A901

	INY		 ; Y = 1 (Player is higher, move up!)

PRG002_A901:
	LDA <Objects_YVel,X
	CMP Boo_VelLimit,Y
	BEQ PRG002_A90E	 ; If Boo is at his acceleration limit, jump to PRG002_A90E

	ADD Boo_VelAccel,Y	 ; Boo accelerates!
	STA <Objects_YVel,X	 ; Update Boo's Y velocity

PRG002_A90E:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	LDA #$01	 ; A = 1 (frame 1, chase!)

PRG002_A916:
	STA Objects_Frame,X	 ; Update Boo's frame

	JSR Object_HitTestRespond	; Do collision test with Player and respond
	JSR Fish_FixedYIfAppro	 	; Fix Boo Y for raster area

Object_DeleteOrDraw:
	JSR Object_DeleteOffScreen	; Delete object if it falls off-screen
	JMP Object_ShakeAndDraw	 	; Draw and don't come back!

Stretch_XVelStart:	.byte -$10, $10
FacePlayer_FlipBitsStart:	.byte $00, SPR_HFLIP, $00	; Boo uses an off-by-1 index here, hence the other $00

ObjInit_Stretch:

	; Stretch starts 4 pixels lower than his placement
	LDA <Objects_Y,X
	ADD #$04
	STA <Objects_Y,X
	BCC PRG002_A935
	INC <Objects_YHi,X
PRG002_A935:

	; Determine which direction Player was moving when Stretch appeared
	LDY <Scroll_LastDir	

	; Set Stretch's flip to be towards Player
	LDA FacePlayer_FlipBitsStart,Y
	STA Objects_FlipBits,X	

	; Set Stretch's X velocity to be towards Player
	LDA Stretch_XVelStart,Y	
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_StretchFlip:
	JSR PRG002_A935	 ; Do most of what the un-flipped Stretch does

	; Flipped Stretch's Y velocity = -$80 (Ram into nearest ceiling)
	LDA #-$80
	STA <Objects_YVel,X

	; Set vertical flip
	ORA Objects_FlipBits,X
	STA Objects_FlipBits,X

	; Set Stretch at 6 pixels above his placement position
	LDA <Objects_Y,X
	SUB #$06
	STA <Objects_Y,X
	BCS PRG002_A95B
	DEC <Objects_YHi,X
PRG002_A95B:

	RTS		 ; Return

	; Stretch timer reset values by internal state (Var5)
Stretch_TimerByIntState:
	.byte $7F, $1F, $1F, $17

ObjNorm_Stretch:
	LDY <Objects_Var5,X	 ; Y = Var5 (internal state)

	LDA Objects_Timer,X
	BNE PRG002_A974	 ; If timer not expired, jump to PRG002_A974

	DEY		 ; Y--
	BPL PRG002_A96C	 ; If Y >= 0, jump to PRG002_A96C

	LDY #$03	 ; Otherwise, Y = 3

PRG002_A96C:
	STY <Objects_Var5,X	 ; Var5 = 0 to 3

	; Set timer based on Var5
	LDA Stretch_TimerByIntState,Y
	STA Objects_Timer,X

PRG002_A974:
	TYA
	LSR A
	PHP		 ; Save CPU state (most importantly, zero flag)
	BCS PRG002_A9A0	 ; If in internal state 1 or 3, jump to PRG002_A9A0

	JSR Object_ApplyXVel	 ; Apply X velocity
	LDY ObjGroupRel_Idx	 ; Y = Object's group relative index

	LDA ObjectGroup01_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_TDOGRPMASK		; Mask out the root tile detection group offset
	LSR A		 	; Correct the index
	TAY		 	; -> 'Y'

	LDA <Objects_YVel,X
	BPL PRG002_A98C	 ; If Stretch is on top, jump to PRG002_A98C

	; Otherwise, Y += 2 (Different detection offset)
	INY
	INY

PRG002_A98C:
	JSR Object_DetectTile
	CMP #TILE2_GHOSTM
	BEQ PRG002_A996	 ; If Stretch is gliding along a non-edge "Ghost tile", jump to PRG002_A996

	JSR Object_AboutFace	 ; Otherwise, turn around!

PRG002_A996:

	; FYI: You don't come here in internal state 1 or 3; those are explicitly handled by PRG002_A9A0

	LDA #$02	 ; A = 2
	PLP		 ; Restore CPU state (most importantly, zero flag, which means internal state 0 or 1)
	BEQ PRG002_A9AD	 ; If in internal state 0, jump to PRG002_A9AD

	; Use frame 4 if in internal state 2 
	ASL A
	STA Objects_Frame,X

	RTS		 ; Return

PRG002_A9A0:

	; Internal state 1 or 3 ONLY (Stretch rising or Stretch receding)

	LDA Objects_Timer,X
	LSR A
	LSR A
	LSR A
	AND #$03	 ; A = 0 to 3, by timer

	PLP		 ; Restore CPU state (most importantly, zero flag, which means internal state 0 or 1)
	BNE PRG002_A9AD	 ; If in internal state 3, jump to PRG002_A9AD

	EOR #$03	 ; In state 1, invert the value

PRG002_A9AD:
	STA Objects_Frame,X	 ; Store the frame
	JSR Object_DeleteOrDraw	 ; Delete Stretch if he falls off-screen, or draw him
	JMP Object_HitTestRespond	 ; Do collision test and respond, and don't come back!

ObjInit_InvisibleLift:

	; Object appears 11 pixels below placement
	LDA <Objects_Y,X
	ADD #11
	STA <Objects_Y,X
	BCC PRG002_A9C1	
	INC <Objects_YHi,X
PRG002_A9C1:

	RTS		 ; Return

ObjNorm_InvisibleLift:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the Sprite X and Sprite Y

	LDA <Objects_Var5,X
	BNE PRG002_A9D2	 ; If Var5 <> 0 (Lift activated), jump to PRG002_A9D2

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)
	BEQ PRG002_A9F5	 ; Otherwise, jump to PRG002_A9F5

PRG002_A9D2:

	; Lift activated...

	JSR InvisiLift_Draw	 ; Draw the lift

	LDA <Player_HaltGame
	BNE PRG002_A9C1	 ; If gameplay is halted, jump to PRG002_A9C1 (RTS)

	; Lift accelerates to -$20
	LDA <Objects_YVel,X
	SUB #$04
	CMP #-$20
	BGE PRG002_A9E4
	LDA #-$20
PRG002_A9E4:

	LDY <Objects_YHi,X
	BNE PRG002_A9F0	 ; If lift is on lower part of screen, jump to PRG002_A9F0

	; Lift is on higher part of screen...

	LDY <Objects_Y,X
	CPY #64
	BGE PRG002_A9F0	 ; If lift's Y >= 64, jump to PRG002_A9F0

	LDA #$00	 ; Otherwise, halt!

PRG002_A9F0:
	STA <Objects_YVel,X	 ; Update Y Velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity

PRG002_A9F5:

	; Don't worry about carry since this platform doesn't move horizontally
	LDA #$00
	STA Object_VelCarry

	JSR PlayerPlatform_Collide
	BCC PRG002_AA03	 ; If Player is not being carried by lift, jump to PRG002_AA03 (RTS)

	; Otherwise, Var5 = 1 (lift activated)
	LDA #$01
	STA <Objects_Var5,X

PRG002_AA03:
	RTS		 ; Return


InvisiLift_Draw:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	; Strip any horizontal or vertical flips from flip bits
	LDA <Temp_Var3
	AND #%00111111
	STA <Temp_Var3

	LDA <Counter_1
	LSR A	

	PHP		 ; Save CPU state
	BCC PRG002_AA17	 ; Every other tick, jump to PRG002_AA17

	; Otherwise, use Sprite_RAM offset +8
	TYA
	ADC #$07
	TAY

PRG002_AA17:
	JSR Object_Draw16x16Sprite	; Draw the first half of lift

	LDA <Temp_Var7
	PLP		 ; Restore CPU state
	BCS PRG002_AA21	 ; Every other opposite tick, jump to PRG002_AA21

	; Otherwise, use Sprite_RAM offset +8
	ADC #$08

PRG002_AA21:
	TAY		 ; Sprite_RAM offset -> 'Y'

	; X += 2 (starting sprite tile)
	INX
	INX

	; +16 for second part of lift
	LDA #16
	ADD <Temp_Var2
	STA <Temp_Var2

	; Use latter horizontal visibility bits
	ASL <Temp_Var8
	ASL <Temp_Var8
	JSR Object_Draw16x16Sprite	 ; Draw the second half of lift

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ObjInit_CloudPlatFast:

	; Set X velocity to -$0A
	LDA #-$0A

PRG002_AA37:
	STA <Objects_XVel,X

ObjInit_WoodenPlat:

	; Platform starts one pixel higher than its placement
	LDA <Objects_Y,X
	BNE PRG002_AA3F
	DEC <Objects_YHi,X
PRG002_AA3F:
	DEC <Objects_Y,X

PRG002_AA41:
	RTS		 ; Return


ObjInit_CloudPlatform:
	LDA #-$06	 ; X velocity = -$06
	BNE PRG002_AA37	 ; Jump (technically always) to PRG002_AA37

ObjInit_WoodenPlatform:
	LDA #-$08	 ; X velocity = -$08
	BNE PRG002_AA37	 ; Jump (technically always) to PRG002_AA37

ObjInit_OscillatingShort:
	INC <Objects_Var4,X	; Objects_Var4 = 1 (selects the short timer, less distance)
	BNE ObjInit_WoodenPlat	 ; Jump (technically always) to ObjInit_WoodenPlat


ObjNorm_CloudPlat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AA41	 ; If gameplay halted, jump to PRG002_AA41 (RTS)

	JSR Object_ApplyXVel	 	; Apply object's X velocity
	JMP Object_HitTestRespond	; Do hit test and respond, and don't come back!


ObjHit_CloudPlat:
	LDA <Temp_Var12
	LSR A
	BCC PRG002_AA85	 ; If not hit by Player jumping on top, jump to PRG002_AA85 (RTS)

	LDA <Player_YVel
	BMI PRG002_AA85	 ; If Player is moving upward, jump to PRG002_AA85 (RTS)

Player_StandOnPlatform:
	; Set Player to object's Y - 31
	LDA <Objects_Y,X	 
	SUB #31
	STA <Player_Y
	LDA <Objects_YHi,X
	SBC #$00
	STA <Player_YHi

	; Flag Player as NOT mid-air
	LDY #$00
	STY <Player_InAir

	LDA Object_VelCarry
	BPL PRG002_AA7B	

	DEY		 ; Y = -1 (provides a sort of carry if Player's X Velocity caused one)

PRG002_AA7B:
	; Add to Player_X, with carry
	ADD <Player_X
	STA <Player_X
	TYA
	ADC <Player_XHi
	STA <Player_XHi

PRG002_AA85:
	RTS		 ; Return

ObjNorm_WoodenPlatRider:

	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AAA6	 ; If gameplay is halted, jump to PRG002_AAA6 (RTS)

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Collide and ride

	LDA <Objects_XVel,X
	BNE PRG002_AA9A	 ; If platform is moving horizontally, jump to PRG002_AA9A

	; Platform not moving horizontally...
	BCS PRG002_AAA4	 ; If carry-collision occurred with platform, jump to PRG002_AAA4

	RTS		 ; Return


PRG002_AA9A:

	; Platform rider picks up speed until X Vel = $10

	CMP #$10
	BEQ PRG002_AAA6	 ; If Platform's X velocity = $10, jump to PRG002_AAA6 (RTS)

	LDA Level_NoStopCnt
	LSR A	
	BCS PRG002_AAA6	 ; Every other tick, jump to PRG002_AAA6 (RTS)

PRG002_AAA4:
	INC <Objects_XVel,X	 ; Increase platform's speed to the right

PRG002_AAA6:
	RTS		 ; Return


Enemy_CollideWithWorld:
	JSR Object_Move	 ; Do standard object movements

	LDA <Objects_DetStat,X
	AND #$08
	BEQ PRG002_AAB2	 ; If enemy has NOT hit ceiling, jump to PRG002_AAB2

	; Otherwise, hit off ceiling
	STA <Objects_YVel,X

PRG002_AAB2:
	LDA <Objects_DetStat,X
	AND #$03
	BEQ Object_HitFloorAlign	 ; If enemy has NOT hit walls, jump to Object_HitFloorAlign

	LDA <Objects_XVel,X
	BEQ Object_HitFloorAlign	 ; If object is not moving horizontally, jump to Object_HitFloorAlign

	JSR Object_AboutFace	 ; Otherwise, turn around

Object_HitFloorAlign:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AAA6	 ; If object has NOT hit ground, jump to PRG002_AAA6 (RTS)
	JMP Object_HitGround	 ; Otherwise, align to ground and don't come back!

	; Oscillating platform velocity and limits by direction
OscXVelLimit:	.byte -$10, $10
OscXVel:	.byte -$01, $01

ObjNorm_OscillatingH:
	LDA <Player_HaltGame
	BNE DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	JSR Platform_Oscillate	 ; Do platform oscillation
	JSR Object_ApplyXVel	 ; Apply X velocity
	JMP PlayerPlatform_Collide	 ; Do platform-player collision tests and don't come back!

	; Timers set per direction (long and short, respectively)
OscTimerSets:	.byte $41, $23	; longer timer means longer travel

Platform_Oscillate:
	LDA Objects_Timer,X	 
	BNE DeleteIfOffAndDrawWide	 ; If timer not expired, Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA Level_NoStopCnt
	LSR A
	BCS DeleteIfOffAndDrawWide	 ; Every other tick, Delete if off-screen, otherwise draw wide 48x16 sprite

	LDY <Objects_Var5,X	 ; Y = Objects_Var5 (direction of oscillation)

	; 
	LDA <Objects_XVel,X
	ADC OscXVel,Y
	STA <Objects_XVel,X

	CMP OscXVelLimit,Y
	BNE DeleteIfOffAndDrawWide	 ; If platform not hit the velocity limit, Delete if off-screen, otherwise draw wide 48x16 sprite

	; Change direction!
	TYA
	EOR #$01
	STA <Objects_Var5,X

	LDY <Objects_Var4,X	; Y = Var4 (specifies length)

	; Reset timer
	LDA OscTimerSets,Y
	STA Objects_Timer,X

DeleteIfOffAndDrawWide:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JMP LogPlat_Draw	 ; Jump to LogPlat_Draw

ObjNorm_OscillatingV:
	LDA <Player_HaltGame
	BNE DeleteIfOffAndDrawWide	 ; If gameplay halted, Delete if off-screen, otherwise draw wide 48x16 sprite

	; Vertical oscillating platform reuses the horizontal's code,
	; so the YVel is set equal to the XVel
	LDA <Objects_YVel,X
	STA <Objects_XVel,X

	JSR Platform_Oscillate	 ; Do platform oscillation

	; Same deal, Platform_Oscillate is working with the XVel, 
	; so transfer is into the YVel..
	LDA <Objects_XVel,X
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; Clear X velocity remainders
	LDA #$00
	STA Object_VelCarry

	JMP PlayerPlatform_Collide	; Do Player-platform collision and don't come back!

ObjInit_FloatWoodenPlat:
	LDA Level_AScrlConfig
	BEQ PRG002_AB35	 ; If no raster, jump to PRG002_AB35 (RTS)

	; If raster active (assuming a level with constant water level)...

	; Set fixed position at water level (vertical scroll +148)
	LDA Level_VertScroll
	ADD #148
	STA <Objects_Y,X
	LDA Level_VertScrollH
	ADC #$00		; Apply carry
	STA <Objects_YHi,X

PRG002_AB35:
	RTS		 ; Return

Float_YVelAdj:	.byte $02, $06, $0A
Float_YAccel:	.byte $02, -$01, -$04

ObjNorm_WoodenPlatFloat:
	JSR Fish_FixedYIfAppro	 	; Fixes 'Y' coordinate for platform that floats in fixed water
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_AB35	 ; If gameplay is halted, jump to PRG002_AB35 (RTS)

	LDY <Objects_Var4,X	 ; Y = Var4

	STA <Objects_Var4,X	 ; Clear Var4

	LDA Float_YVelAdj,Y

	LDY #$00	 ; Y = 0

	SUB <Objects_Var5,X
	BPL PRG002_AB5E	 

	INY		 ; Y = 1

	CMP #-$02	 
	BGE PRG002_AB5E	 

	LDA <Objects_YVel,X
	BMI PRG002_AB5E	 ; If platform is floating upward, jump to PRG002_AB5E

	INY		 ; Y = 2

PRG002_AB5E:
	; Y acceleration of floating platform
	LDA <Objects_YVel,X
	ADD Float_YAccel,Y
	STA <Objects_YVel,X

	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; 
	LDA <Objects_Var5,X
	ADD Object_VelCarry
	STA <Objects_Var5,X

	; Clear Object_VelCarry
	LDA #$00
	STA Object_VelCarry

	JSR PlayerPlatform_Collide	; Do Player-platform collision
	BCC PRG002_AB8F	 		; If Player did not collide with Platform, jump to PRG002_AB8F

	; Player collided with floater

	ROL Player_NoSlopeStick	 	; Set Player_NoSlopeStick

	LDA <Player_YVel
	BEQ PRG002_AB86	 	; If Player is not moving vertically, jump to PRG002_AB86

	LSR A
	LSR A
	STA <Objects_YVel,X	 ; Set floater's Y Velocity to Player's Y velocity / 4

PRG002_AB86:
	LDY <Player_Suit
	BEQ PRG002_AB8C	 ; If Player is small, jump to PRG002_AB8C

	LDY #$01	 ; Y = 1

PRG002_AB8C:
	INY		 ; Y = 1 (if small) or 2 (otherwise)

	STY <Objects_Var4,X	 ; Var4 = 1 or 2

PRG002_AB8F:
	RTS		 ; Return

ObjNorm_WoodenPlatform:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABAA	 	; If gameplay halted, jump to PRG002_ABAA (RTS)

	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Player collision with platform

	LDA <Objects_YVel,X
	BNE PRG002_ABA8	 ; If Platform is moving vertically, jump to PRG002_ABA8

	BCC PRG002_ABAA	 ; If Player did not collide with platform, jump to PRG002_ABAA (RTS)

	STA <Objects_XVel,X	 ; Otherwise, X Vel = Y Vel

PRG002_ABA8:
	INC <Objects_YVel,X	 ; Platform descends

PRG002_ABAA:
	RTS		 ; Return

ObjInit_WoodenFallingPlat:
	INC <Objects_Var4,X	 ; Var4 = 1

ObjInit_FallingPlatform:

	; Center the platform
	LDA <Objects_X,X
	ORA #$08
	STA <Objects_X,X

	LDA <Objects_Y,X
	ORA #$06
	STA <Objects_Y,X

PRG002_ABB9:
	RTS		 ; Return

	; Index offsets looking for next path element
WoodenPlat_ScanIndices:
	.byte -$06, $06, -$05, $05, -$04, $04, -$03, $03, -$02, $02, -$01, $01, $00
WoodenPlat_ScanIndices_End:


	; All of the following WoodenPlat_* are parallel arrays 

	; Determines which direction the platform should seek for its next path tile
WoodenPlat_NextTileIdx:
	.byte $03, $02, $02, $02
	.byte $02, $00, $00, $00
	.byte $01, $01, $01, $01
	.byte $03, $03, $03, $03

	; The different path tiles the platform may encounter (Typical Set)
WoodenPlat_PathTiles:
	.byte TILEA_PATH_VERT, TILEA_PATH_625B2T_L, TILEA_PATH_625B2T_U, TILEA_PATH_45B2T
	.byte TILEA_PATH_HORZ, TILEA_PATH_45T2B, TILEA_PATH_625T2B_L, TILEA_PATH_625T2B_U
	.byte TILEA_PATH_VERT, TILEA_PATH_625B2T_U, TILEA_PATH_625B2T_L, TILEA_PATH_45B2T
	.byte TILEA_PATH_HORZ, TILEA_PATH_45T2B, TILEA_PATH_625T2B_U, TILEA_PATH_625T2B_L

	; Same setup as WoodenPlat_PathTiles, but for Tileset 2 (Fortress Style)
WoodenPlat_PathTilesAlt:
	.byte TILE2_PATH_VERT, TILE2_PATH_625B2T_L, TILE2_PATH_625B2T_U, TILE2_PATH_45B2T
	.byte TILE2_PATH_HORZ, TILE2_PATH_45T2B, TILE2_PATH_625T2B_L, TILE2_PATH_625T2B_U
	.byte TILE2_PATH_VERT, TILE2_PATH_625B2T_U, TILE2_PATH_625B2T_L, TILE2_PATH_45B2T
	.byte TILE2_PATH_HORZ, TILE2_PATH_45T2B, TILE2_PATH_625T2B_U, TILE2_PATH_625T2B_L

	; Y velocities appropriate to path tile hit
WoodenPlat_YVel:
	.byte -$10, -$10, -$10, -$10	; forward
	.byte  $00,  $10,  $10,  $10
	.byte  $10,  $10,  $10,  $10	; reverse
	.byte  $00, -$10, -$10, -$10
	.byte  $00	; Stop

	; X velocities appropriate to path tile hit
WoodenPlat_XVel:
	.byte  $00,  $08,  $08,  $10	; forward
	.byte  $10,  $10,  $08,  $08
	.byte  $00, -$08, -$08, -$10	; reverse
	.byte -$10, -$10, -$08, -$08
	.byte  $00	; Stop


ObjNorm_PathFollowPlat:
	JSR DeleteIfOffAndDrawWide	 ; Delete if off-screen, otherwise draw wide 48x16 sprite

	LDA <Player_HaltGame
	BNE PRG002_ABB9	 ; If gameplay is halted, jump to PRG002_ABB9 (RTS)

	LDA <Objects_Var4,X
	BEQ PRG002_AC29	 ; If Var4 = 0, jump to PRG002_AC29

	LSR A
	BEQ PRG002_AC2C	 ; If Var4 < 2, jump to PRG002_AC2C

	; Var4 >= 2...

	INC <Objects_YVel,X	 ; Increase platform's fall rate

PRG002_AC29:
	JMP PRG002_ACAB	 ; Jump to PRG002_ACAB

PRG002_AC2C:

	; Var4 = 1...

	LDA <Objects_YVel,X
	BEQ PRG002_AC3A	 ; If platform is not vertically moving, jump to PRG002_AC3A

	; Platform is vertically moving...

	LDA <Objects_Y,X
	AND #$0f	; Consider platform vertical relative to current grid row only
	CMP #$06
	BNE PRG002_ACAB	 ; If platform is NOT about halfway down this grid row, jump to PRG002_ACAB
	BEQ PRG002_AC42	 ; Otherwise, jump to PRG002_AC42

PRG002_AC3A:

	; Platform is about halfway down current grid row

	LDA <Objects_X,X
	AND #$0f	 ; Consider platform horizontal relative to current grid column only
	CMP #$08	 
	BNE PRG002_ACAB	 ; If platform is NOT about halfway across current grid row, jump to PRG002_ACAB

PRG002_AC42:

	; Platform is about centered

	; Going to detect the four tiles this Platform may be touching	

	LDA #$03
	STA <Temp_Var13		 ; Update Temp_Var13

	LDY ObjGroupRel_Idx	 ; Y = Object's group relative index
	LDA ObjectGroup01_Attributes2,Y	 ; Get attributes set 2
	AND #OA2_TDOGRPMASK		; Mask out the root tile detection group offset
	LSR A		 	; Correct the index
	TAY		 	; -> 'Y'
PRG002_AC50:
	STY <Temp_Var14		 ; Update Temp_Var14

	JSR Object_DetectTile	 ; Detect tile platform is seeing

	LDY <Temp_Var13		 ; Y = Temp_Var13
	STA Temp_Var9,Y	 ; Store detected tile -> Temp_Var[9...12]

	LDY <Temp_Var14		; Y = Temp_Var14

	; Y += 2 (next DetectTile offset pair)
	INY
	INY

	DEC <Temp_Var13		 ; Temp_Var13--
	BPL PRG002_AC50	 	; While Temp_Var13 >= 0, loop!

	; Temp_Var13 = 12
	LDA #(WoodenPlat_ScanIndices_End - WoodenPlat_ScanIndices - 1)
	STA <Temp_Var13

	; Temp_Var14 = Var5 (travel direction, offset of 0 or 8)
	LDA <Objects_Var5,X
	STA <Temp_Var14

PRG002_AC6A:
	LDY <Temp_Var13		; Y = Temp_Var13

	LDA WoodenPlat_ScanIndices,Y
	ADD <Temp_Var14		; Travel direction offset
	AND #$0f		; Mod 16
	TAY			; -> 'Y' 

	LDX WoodenPlat_NextTileIdx,Y	 ; X = which of the four tiles that should be checked next

	LDA <Temp_Var9,X	 ; Get this tile
	CMP WoodenPlat_PathTiles,Y	 
	BEQ PRG002_AC9C	 	; If it's one of the path tiles (Typical set), jump to PRG002_AC9C

	CMP WoodenPlat_PathTilesAlt,Y
	BEQ PRG002_AC9C	 	; If it's one of the path tiles (Fortress set), jump to PRG002_AC9C

	CPY <Temp_Var14	
	BNE PRG002_AC92	 ; If Temp_Var14 <> 0, jump to PRG002_AC92 (stop platform)

	CMP #TILE4_PLATFORMPULLER
	BNE PRG002_AC92	 ; If tile is NOT the "Platform Puller" twirly thing, jump to PRG002_AC92 (stop platform)

	; Temp_Var14 = 0 and platform hit a path ending "platform puller" twirly thing

	; Change direction!
	TYA
	EOR #$08
	TAY	

	BPL PRG002_AC9C	 ; Jump (technically always) to PRG002_AC9C

PRG002_AC92:
	DEC <Temp_Var13	 ; Temp_Var13--
	BPL PRG002_AC6A	 ; While Temp_Var13 >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index

	INC <Objects_Var4,X	 ; Objects_Var4 = 1 (platform stop)

	LDY #16	; Y = 16 (uses stop velocities)

PRG002_AC9C:

	; Hit a path tile...

	LDX <SlotIndexBackup		 ; X = object slot index

	TYA
	STA <Objects_Var5,X	 ; Store the directional offset (0 or 8)

	; Set Platform X Velocity appropriate for path tile
	LDA WoodenPlat_XVel,Y
	STA <Objects_XVel,X

	; Set Platform Y Velocity appropriate for path tile
	LDA WoodenPlat_YVel,Y
	STA <Objects_YVel,X

PRG002_ACAB:
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR PlayerPlatform_Collide	 ; Do Player-to-platform collision
	BCC PRG002_ACBC	 ; If Player did not collide with platform, jump to PRG002_ACBC (RTS)

	; Mark Player standing on platform
	LDA <Objects_Var4,X
	ORA #$01
	STA <Objects_Var4,X

PRG002_ACBC:
	RTS		 ; Return

EnemyEnterFlip:	.byte  $00, SPR_HFLIP
EnemyEnterXVel:	.byte -$08, $08

ObjInit_TowardsPlayer:

	; Get last scroll direction so we know which way to face
	LDY Scroll_LastDir

	; Enemy faces Player relative to which direction he's headed
	LDA EnemyEnterFlip,Y
	STA Objects_FlipBits,X

	; Enemy charges at Player the same
	LDA EnemyEnterXVel,Y
	STA <Objects_XVel,X

	RTS		 ; Return

Spike_Frames:
	.byte $04, $04, $04, $04, $04, $02, $02, $03, $03, $03, $03, $02, $02, $02, $02

Spike_XOff:
	.byte $00
	.byte $02, $03, $02, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

Spike_YOff:
	.byte $00, $F4, $F4
	.byte $F4, $F4, $F4, $F4, $F2, $F0, $EF, $EE, $EE, $EF, $F0, $F2, $F4, $F6, $F9, $FC
	.byte $FF, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


ObjNorm_Spike:
	LDA Objects_Timer,X
	LSR A
	STA <Objects_Var4,X	 ; Var4 = timer / 2

	ROL A		; Puts bit 0 back
	BEQ PRG002_AD3F	 ; If timer expired, jump to PRG002_AD3F

	LSR A
	BNE PRG002_AD31	 ; If timer > 2, jump to PRG002_AD31

	JSR Spike_TossSpikeBall	 ; Cough up a spike ball!

	LDA <Objects_Var5,X
	BEQ PRG002_AD31	 	; ?? I think this was meant to check that no sprites are off-screen, but most likely you'll make this jump

	INC Objects_Timer,X	 ; Timer++ (delay decrementing it)

PRG002_AD31:
	LDA Objects_Timer,X
	LSR A
	LSR A
	TAY		 ; Y = timer / 4

	; Set Spike's frame
	LDA Spike_Frames,Y
	STA Objects_Frame,X
	BPL PRG002_AD95	 ; If positive, jump to PRG002_AD95

PRG002_AD3F:
	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AD80	 ; If Spike has not touched the ground, jump to PRG002_AD80

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Set Spike's frame alternating 0/1 (walking)

	; This keeps Spike interesting
	LDA <Counter_1
	ADC Entropy_BySlot,X	; Add an arbitrary value based on which slot this Spike is in
	BMI PRG002_AD95	 ; If the result has bit 7 set, jump to PRG002_AD95

	JSR Object_CalcCoarseXDiff
	EOR Objects_FlipBits,X
	ASL A
	BPL PRG002_AD6E	 ; If the signs aren't different, Spike doesn't change direction; jump to PRG002_AD6E

	; Spike needs to change direction

	LDA <Counter_1
	AND #$07	
	BNE PRG002_AD80	 ; But only a 1:7 chance, otherwise jump to PRG002_AD80

	JSR Object_FlipFace	 ; Turn around
	JMP PRG002_AD80	 	; Jump to PRG002_AD80

PRG002_AD6E:

	; This gets a little tricky to follow...

	LDA <Temp_Var15	
	ADD #$20
	CMP #$40
	BGE PRG002_AD80	 ; Player out of X range

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	CMP #$08	
	BCC PRG002_AD84	 ; Player out of Y range

PRG002_AD80:
	LDA #$00
	BEQ PRG002_AD88	 

PRG002_AD84:
	LDA <Objects_Var5,X	
	ADC #$10

PRG002_AD88:
	STA <Objects_Var5,X	 
	BPL PRG002_AD95

	; Timer = $3A
	LDA #$3a
	STA Objects_Timer,X

	; Halt Spike's horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG002_AD95:
	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_SpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDA <Temp_Var3
	BPL PRG002_ADB4	 ; If Spike is not flipped, jump to PRG002_ADB4

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Objects_Var4,X
	TAX		 ; X = Var4

	; Add to Sprite Y by Var4 index
	LDA <Temp_Var1	
	ADD Spike_YOff,X
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = object's starting tiles index

PRG002_ADB4:
	JSR Object_Draw16x16Sprite	 ; Draw Spike

	LDX <SlotIndexBackup		 ; X = object slot index

	LDY <Objects_Var4,X	 ; Y = Var4

	LDA <Objects_SpriteY,X
	BIT <Temp_Var3		
	BMI PRG002_ADC5	 ; If Spike is vertically flipped, jump to PRG002_ADC5

	ADD Spike_YOff,Y	 ; Otherwise, add appropriate offset

PRG002_ADC5:
	STA <Temp_Var1		 ; -> Temp_Var1
 
	LDA Spike_XOff,Y

	BIT <Temp_Var3
	BVC PRG002_ADD1	 ; If Spike is NOT horizontally flipped, jump to PRG002_ADD1

	JSR Negate	; Negate the X Offset

PRG002_ADD1:
	ADD <Temp_Var2		 ; Offset by Spike's X
	STA <Temp_Var2		 ; -> Temp_Var2

	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball

	; Draw Spike's pre-thrown spike ball sprite at +8 to Spike's assigned Sprite_RAM offset
	LDA <Temp_Var7
	ADD #$08	
	TAY		
	JSR Object_Draw16x16Sprite

	; Set Spike's spike ball attributes
	LDA #$02
	STA Sprite_RAM+$02,Y
	ORA #$c0
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Spike_TossSpikeBall:
	JSR SpecialObj_FindEmptyAbort	; Find an empty special object slot if on-screen (or don't come back!)	 
	STA <Objects_Var5,X	 ; Objects_Var5 = 0 (because we wouldn't be here otherwise)

	; Spike's spike ball
	LDA #SOBJ_SPIKEBALL	 
	STA SpecialObj_ID,Y

	; Set Spike's ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike's ball Y
	LDA <Objects_Y,X
	SUB #14
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	JSR Object_SetXVelByFacingDir	 ; Set Spike's X velocity by his facing direction
	ASL A	
	ASL A		; Multiply result by 4
	STA SpecialObj_XVel,Y	 ; Set as Spike's ball X velocity

	; Spike's ball Y velocity and Data = 0
	LDA #$00
	STA SpecialObj_YVel,Y
	STA SpecialObj_Data,Y

	RTS		 ; Return


	; Sets X velocity by facing flip direction
Object_SetXVelByFacingDir:
	LDA Objects_FlipBits,X
	ASL A
	ASL A	; If HFlip is set, pushed into carry

	LDA #$08
	BCS PRG002_AE28
	LDA #-$08
PRG002_AE28:
	STA <Objects_XVel,X

	RTS		 ; Return

ObjInit_PiranhaSpikeBall:
	; Center piranha
	LDA <Objects_X,X
	ORA #$08
	STA <Objects_X,X

	; Set Objects_Var5 = $10
	LDA #$10
	BNE PRG002_AE3A	 ; Jump (technically always) to PRG002_AE3A

ObjInit_Patooie:
	JSR ObjInit_TowardsPlayer	; Have enemy facing/moving towards Player

	; Set Objects_Var5 = $0C 
	LDA #$0c
PRG002_AE3A:
	STA <Objects_Var5,X

	RTS		 ; Return

ObjNorm_PiranhaSpikeBall:

	; Mostly reuses Patooie's code

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_AE47	 ; If piranha is dead, jump to PRG002_AE47

	JMP PRG002_AEE1	 ; Otherwise, jump to PRG002_AEE1

PRG002_AE47:

	; Use "poof" death
	LDA #OBJSTATE_POOFDEATH
	STA Objects_State,X

	; Set timer to $1F (poof death timer)
	LDA #$1f
	STA Objects_Timer,X

PRG002_AE51:
	INC Objects_HitCount,X	 ; Increase hit count (??)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Patooie's Spike ball
	LDA #SOBJ_SPIKEBALL
	STA SpecialObj_ID,Y

	; Set Spike ball X
	LDA <Objects_X,X
	STA SpecialObj_XLo,Y

	; Set Spike ball Y -- Objects_Var5 is used as the height of the spiked ball Patooie is blowing
	LDA <Objects_Y,X
	SUB <Objects_Var5,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	SBC #$00
	STA SpecialObj_YHi,Y

	; Spike ball data
	LDA #$01
	STA SpecialObj_Data,Y

	LSR A	
	STA SpecialObj_XVel,Y	 ; X Vel = 0

	LDA Objects_Var6,X
	AND #%01111100	; Masking the lower bits not strictly necessary...
	LSR A	
	LSR A	
	TAX	; X = value 0 to 31

	; Set the Patooie ball Y velocity
	LDA Patooie_BallYDelta,X
	JSR Negate
	ASL A	
	ASL A	
	ASL A	
	ASL A	
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index
	JMP PRG002_AF30	 ; Jump to PRG002_AF30

Patooie_BallYDelta:
	.byte $00, -$01, -$02, -$03, -$03, -$03, -$02, -$01, $00,  $01, $02, $03, $03, $03, $02, $01
	.byte $00, -$01, -$01, -$01,  $00,  $01,  $01,  $01

	; Jiggles the spike ball a bit
Patooie_BallXJiggle:
	.byte $00, -$01, $00, $01


ObjNorm_Patooie:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_AEBE	 ; If Patooie's state is not Killed, jump to PRG002_AEBE

	; Patooie is killed...

	LDA Objects_HitCount,X
	BEQ PRG002_AE51	 ; If object hasn't been hit by Player weapon, jump to PRG002_AE51

	JMP PRG002_AF30	 ; Jump to PRG002_AF30

PRG002_AEBE:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_AEE1	 ; If object did not hit floor, jump to PRG002_AEE1

	LDA <Counter_1
	ADC Entropy_BySlot,X	 ; Add an arbitrary value by this object's slot index
	AND #%10011111
	BNE PRG002_AED7	 	; Semi-randomly jump to PRG002_AED7

	; Sometimes, reverse direction
	LDA <Objects_XVel,X
	JSR Negate	
	STA <Objects_XVel,X

PRG002_AED7:
	; Flip sprite back and forth to simulate walking
	LDA <Counter_1
	ASL A		
	ASL A		
	ASL A		
	AND #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_AEE1:
	LDA Objects_Var6,X
	BEQ PRG002_AEEF	 ; If Var6 = 0, jump to PRG002_AEEF

	LDA Level_NoStopCnt
	LSR A
	BCC PRG002_AEEF	 ; Every other tick, jump to PRG002_AEEF

	DEC Objects_Var6,X	 ; Otherwise, Var6--

PRG002_AEEF:
	LDY #$00	 ; Y = 0 (Mouth closed)

	LDA Objects_Var6,X
	PHA		 ; Save Var6

	AND #%11000000
	LSR A
	LSR A
	STA <Temp_Var1	 ; Temp_Var1 = $00, $10, $20, or $30

	PLA		 ; Restore Var6

	; Times the mouth animation to be similar to the spike ball's ascend/descend
	ASL A
	EOR Objects_Var6,X
	AND <Temp_Var1	
	BEQ PRG002_AF05

	INY		 ; Y = 1 (Mouth open)

PRG002_AF05:
	TYA
	STA Objects_Frame,X	 ; Set frame 0 or 1

	LDA Objects_Var6,X
	AND #$3f
	BNE PRG002_AF1D	 ; Only continue 1:64 ticks, otherwise jump to PRG002_AF1D

	LDY #$bf	 ; Y = $BF (BIG Blow)

	LDA Level_NoStopCnt
	BPL PRG002_AF19	 ; If the counter is not negative, jump to PRG002_AF19

	LDY #$5f	 ; Otherwise, Y = $5F (SHORT blow)

PRG002_AF19:
	TYA
	STA Objects_Var6,X	 ; Var6 = $5F or $BF

PRG002_AF1D:
	LDA Objects_Var6,X
	AND #%01111100
	LSR A
	LSR A
	TAY		 ; Y = 0 to 31

	; Adjusts height of spike ball
	LDA <Objects_Var5,X
	ADD Patooie_BallYDelta,Y
	STA <Objects_Var5,X

	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

PRG002_AF30:
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

Bank2_PiranhaSpikeHaltAction:
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X
	CMP #OBJ_PIRANHASPIKEBALL
	BEQ PRG002_AF46	 ; If this is just the piranha with the spike ball rather than a true Patooie, jump to PRG002_AF46

	; Temp_Var1 += 6
	LDA <Temp_Var1
	ADD #$06
	STA <Temp_Var1

PRG002_AF46:
	LDX <Temp_Var6	 ; X = object's starting tiles

	LDA <Temp_Var3
	BPL PRG002_AF4F	 ; If object is not vertically flipped, jump to PRG002_AF4F

	JSR PatooiePiranha_StartTileX	 ; Get correct starting sprite tile

PRG002_AF4F:
	JSR Object_Draw16x16Sprite	 ; Draw sprite

	LSR <Temp_Var5	; Shifting out next vertical visibility bit

	; Sprite Y += 16 for lower half
	LDA <Temp_Var1
	ADD #16
	STA <Temp_Var1

	; 'Y' += 8 (two sprite index over)
	TYA
	ADD #$08
	TAY

	LDX <Temp_Var6	 ; X = starting tiles index

	LDA <Temp_Var3
	BMI PRG002_AF69	 ; If vertically flipped, jump to PRG002_AF69
	JSR PatooiePiranha_StartTileX	 ; Otherwise, get correct starting tile again
PRG002_AF69:
	JSR Object_Draw16x16Sprite	 ; Draw lower half

	LDA <Temp_Var3
	BMI PRG002_AF72	 ; If vertically flipped, jump to PRG002_AF72

	LDY <Temp_Var7		 ; Y = original Sprite_RAM offset

PRG002_AF72:
	; Sets attributes and mirrors piranha sprites
	LDA <Temp_Var3	; Get object attributes
	AND #~(SPR_HFLIP | $03)	 ; Keep everything except the horizontal flip and the palette select
	ORA #SPR_PAL1	 ; Force palette select 1
	STA Sprite_RAM+$02,Y	 ; Set attributes
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y	 ; Set other half of piranha

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	
	CMP #OBJ_PIRANHASPIKEBALL
	BNE PRG002_AF96	 ; If this is Patooie, jump to PRG002_AF96

	; Piranha needs his body mirrored
	LDA Sprite_RAM+$0A,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$0A,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$0E,Y

PRG002_AF96:
	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B01A	 ; If this piranha/Patooie state is Killed, jump to PRG002_B01A

	LDA <Objects_YHi,X
	PHA		 ; Save Y Hi

	LDA <Objects_Y,X
	PHA		 ; Save Y

	; Temporarily using object's Y/HI to calculate the spike ball's position
	SUB <Objects_Var5,X
	STA <Objects_Y,X
	LDA <Objects_YHi,X
	SBC #$00
	STA <Objects_YHi,X

	LDY #$00	 ; Y = 0 (height of 16)
	JSR Object_DetermineVertVisY	 ; Determine visibility of spike ball sprites
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data for spike ball

	LDA Level_NoStopCnt
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3, based on timer

	; Cause the spike ball to jiggle slightly (Temp_Var2 is X)
	LDA <Temp_Var2
	ADD Patooie_BallXJiggle,X
	STA <Temp_Var2

	; Jump Sprite_RAM offset ahead 16 (four sprites, get passed Patooie/Piranha)
	TYA	
	ADD #16	
	TAY	

	; Draw sprite
	LDX #(SpikeBall_Patterns - ObjectGroup01_PatternSets)	 ; Offset to patterns for spike ball
	JSR Object_Draw16x16Sprite

	; Set spike ball vertical flip periodically
	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP	; Toggled vertical flip
	ORA #SPR_PAL2	; Set palette select 2
	STA Sprite_RAM+$02,Y
	EOR #$c0	; Invert vertical flip and apply horizontal flip
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BEQ PRG002_B00E	 ; If Patooie/Piranha's state is Killed, jump to PRG002_B00E

	LDA <Player_HaltGame
	BNE PRG002_B00E	 ; If gameplay is halted, jump to PRG002_B00E

	JSR Object_AnySprOffscreen
	BNE PRG002_B00E	 ; If any sprites of the spike ball are off-screen, jump to PRG002_B00E

	LDA Level_ObjectID,X
	PHA		 ; Save piranha/Patooie iID

	; Temporarily switch and masquerade as a OBJ_CHEEPCHEEPPOOL2POOL
	; NOTE: This really just needs to be a 16x16 sized object so we
	; can "cheat" and use Object_HitTest on a "special object"
	LDA #OBJ_CHEEPCHEEPPOOL2POOL
	STA Level_ObjectID,X

	JSR Object_HitTest
	BCC PRG002_B00A	 ; If Player did NOT hit spike ball, jump to PRG002_B00A

	LDA Player_StarInv
	BNE PRG002_B00A	 ; If Player is Starman invincible, jump to PRG002_B00A

	JSR Object_DoCollision ; Do the collision routine

PRG002_B00A:
	; Restore the object ID
	PLA
	STA Level_ObjectID,X

PRG002_B00E:
	; Restore the Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis	 ; Restore true vertical visibility for this Patooie/piranha
	JSR Object_CalcSpriteXY_NoHi	 ; Calculate the true sprite positions

PRG002_B01A:
	JMP PRG002_B196		; Jump to PRG002_B196 (set pattern bank $4F)

	; Get the correct starting sprite tile based on whether this is
	; a true Patooie or just the piranha pretending to be one
PatooiePiranha_StartTileX:
	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Level_ObjectID,X	 ; Get object ID

	LDX #(ObjP2A - ObjectGroup01_PatternSets + $06)	 ; If Patooie
	CMP #OBJ_PATOOIE
	BEQ PRG002_B02A	 ; If this is Patooie, jump to PRG002_B02A (RTS)
	LDX #(ObjP46 - ObjectGroup01_PatternSets + $08)	 ; If the piranha with spike ball
PRG002_B02A:
	RTS		 ; Return


ObjNorm_GoombaInShoe:

	; Force sixth bank select $4F
	LDA #$4f
	STA PatTable_BankSel+5

	JSR Enemy_CollideWithWorld	 ; Collide with world

	; Set Object frame (crank turning)
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen

	JSR Shoe_DrawGoomba	 ; Draw the Goomba within the shoe

	; Backup Player's invincibility into Shoe's Var1
	LDA Player_StarInv
	STA Objects_Var1,X

	; Clear Player's invincibility
	LDA #$00
	STA Player_StarInv

	JSR Object_HitTestRespond ; Do hit test and response without concerning Player's Star Man invincibility

	; Restore Player's invincibility
	LDA Objects_Var1,X
	STA Player_StarInv

	LDA Object_TileFeet2
	CMP #TILEA_BLOCKBUMP_CLEAR
	BNE PRG002_B06A	 ; If shoe has not been bumped underneath, jump to PRG002_B06A

	LDA <Objects_Var4,X
	BNE PRG002_B066	 ; If Var4 <> 0, jump to PRG002_B066

	; Otherwise, Var5 = $0E
	LDA #$0e
	STA <Objects_Var5,X

PRG002_B066:
	; Bounce
	LDA #-$38
	STA <Objects_YVel,X

PRG002_B06A:
	LDA <Objects_Var4,X
	BEQ PRG002_B076	 ; If Var4 <> 0, jump to PRG002_B076

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B0B4	 ; If Shoe has not touched ground, jump to PRG002_B0B4 (RTS)
	BNE PRG002_B0B0	 ; Otherwise, stop horizontal movement

PRG002_B076:
	LDY <Objects_Var5,X
	BEQ PRG002_B0A6	 ; If Var5 <> 0, jump to PRG002_B0A6

	LDA <Counter_1
	AND #$03
	BNE PRG002_B0B4	 ; 1:4 chance we won't jump to PRG002_B0B4

	DEY		 ; (Var5) Y-- 
	BNE PRG002_B098	 ; If Var5 did not decrement to zero, jump to PRG002_B098

	; Flip to face Player
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	LDY #$10	 ; Y = $10 (hop to right)

	ASL A
	BMI PRG002_B090	 ; If horizontally flipped, jump to PRG002_B090

	LDY #-$10	 ; Y = -$10 (hop to left)

PRG002_B090:
	STY <Objects_XVel,X	 ; Set proper X velocity

	; Hop!
	LDA #-$50
	STA <Objects_YVel,X
	BNE PRG002_B0A1	 ; Jump (technically always) to PRG002_B0A1

PRG002_B098:
	CPY #$0b
	BNE PRG002_B0A3	 ; If Var5 <> $0B, jump to PRG002_B0A3

	JSR Shoe_EjectGoomba	 ; Eject the occupant of the Shoe
	INC <Objects_Var4,X	 ; Var4++

PRG002_B0A1:
	LDY #$00	 ; Y = 0 (reset Var5)

PRG002_B0A3:
	STY <Objects_Var5,X	 ; Update Var5

	RTS		 ; Return

PRG002_B0A6:
	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B0B4	 ; If Shoe hasn't hit ground, jump to PRG002_B0B4 (RTS)

	; Var5 = $0B
	LDA #$0b
	STA <Objects_Var5,X

PRG002_B0B0: 

	; Stop horizontal movement
	LDA #$00
	STA <Objects_XVel,X

PRG002_B0B4:
	RTS		 ; Return


Shoe_EjectGoomba:
	LDX #$04	 
PRG002_B0B7:
	LDA Objects_State,X
	BEQ PRG002_B0C1	 ; If this object slot is dead/empty, jump to PRG002_B0C1
	DEX		 ; X--
	BPL PRG002_B0B7	 ; While X >= 0, loop!

	BMI PRG002_B0FB	 ; If no object slots are available, jump to PRG002_B0FB

PRG002_B0C1:
	JSR Level_PrepareNewObject	 ; Prepare new object (the Goomba which is knocked out)

	; Start Goomba off in "Killed" state
	LDA #OBJSTATE_KILLED
	STA Objects_State,X

	; It's a Goomba
	LDA #OBJ_GOOMBA
	STA Level_ObjectID,X

	; Palette select 3
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	LDY <SlotIndexBackup	 ; Y = dead Goomba's object slot index

	; Set equal to Shoe's X
	LDA Objects_X,Y
	STA <Objects_X,X

	; Set Goomba's X Hi to Shoe's X Hi
	LDA Objects_XHi,Y
	STA <Objects_XHi,X

	; Set Goomba's Y 16 pixels higher than shoe
	LDA Objects_Y,Y
	SUB #16
	STA <Objects_Y,X
	LDA Objects_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; If negative X velocity, flip Goomba
	LDA Objects_XVel,Y
	LSR A	
	AND #SPR_HFLIP
	STA Objects_FlipBits,X

	; Goomba bump Y velocity
	LDA #-$30
	STA <Objects_YVel,X

PRG002_B0FB:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return


ObjHit_GoombaInShoe:
	LDA <Objects_Var4,X
	BEQ PRG002_B119	 ; If Var4 = 0, jump to PRG002_B119

	; Goomba not in shoe...

	LDA Player_Statue
	BNE PRG002_B118	 ; If Player is a statue, jump to PRG002_B118

	; Shoe pickup sound!
	LDA Sound_QPlayer
	ORA #SND_PLAYERSWIM
	STA Sound_QPlayer

	; Queue Kuribo's shoe!
	LDA #$80
	STA Player_QueueSuit

	; Set shoe state to 0 (dead/empty)
	ASL A
	STA Objects_State,X

PRG002_B118:
	RTS		 ; Return

PRG002_B119:

	; Goomba's still in there...

	LDA Objects_Var1,X
	BNE PRG002_B126	 ; If Var1 <> 0, jump to PRG002_B126

	LDA <Temp_Var12
	LSR A
	BCS PRG002_B126	 ; If hit by Player jumping on top, jump to PRG002_B126

	JMP Player_GetHurt ; Hurt Player and don't come back!

PRG002_B126:
	JMP PRG000_D2B4	 ; Jump to PRG000_D2B4 (hijacks the kill routine)

	; The Y offset for the Goomba riding in the shoe
Shoe_GoombaYOff:
	.byte $00, -$02, -$04, -$06, -$08, -$08, -$08, -$08, -$08, -$06, -$04, -$02, $F4, -$08, -$04
	
Shoe_DrawGoomba:
	JSR Object_ShakeAndCalcSprite
	LDA <Temp_Var3		 
	BPL PRG002_B14E	 ; If object is not vertically flipped, jump to PRG002_B14E

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var5,X
	TAX		 ; X = Var5

	LDA <Temp_Var1
	ADD Shoe_GoombaYOff,X	
	STA <Temp_Var1	

	LDX <Temp_Var6		 ; X = starting sprite tile

PRG002_B14E:
	JSR Object_Draw16x16Sprite	 ; Draw the shoe

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA <Objects_SpriteY,X	; Get sprite Y for object

	BIT <Temp_Var3
	BMI PRG002_B15F	 ; If shoe is vertically flipped, jump to PRG002_B15F

	; Shoe is not vertically flipped...

	; Add offset for Goomba inside shoe
	LDY <Objects_Var5,X
	ADD Shoe_GoombaYOff,Y

PRG002_B15F:
	STA <Temp_Var1	 ; -> Temp_Var1

	BIT <Temp_Var3
	BVS PRG002_B16C	 ; If shoe is horizontally flipped, jump to PRG002_B16C

	; If not horizontally flipped, +1 to X
	LDA <Temp_Var2
	ADD #$01
	STA <Temp_Var2

PRG002_B16C:
	LDA #SPR_PAL3
	STA <Temp_Var4	 ; Set Goomba attributes to just palette select 3
	LDX #$70	 ; X = $70 (Goomba's starting pattern)

	LDA <Temp_Var7
	ADD #$08
	TAY		 ; Y = Sprite_RAM offset +8 (passed the shoe, for the Goomba)

	JSR Object_Draw16x16Sprite	 ; Draw Goomba

	; Mirror Goomba's halves
	LDA Sprite_RAM+$02,Y
	AND #~SPR_HFLIP
	STA Sprite_RAM+$02,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$06,Y	 ; Whoops?

	; Goomba X - 1
	LDA Sprite_RAM+$07,Y
	SUB #$01
	STA Sprite_RAM+$07,Y

	LDX <SlotIndexBackup	 ; X = object slot index


PRG002_B196:
	; Set pattern sixth bank to $4F
	LDA #$4f	  
	STA PatTable_BankSel+5
	RTS		 ; Return

ObjInit_NipperHopping:
	INC <Objects_Var4,X	 ; Var4 = 1
	RTS		 ; Return


ObjNorm_Nipper:
	JSR Enemy_CollideWithWorld	 ; Collide with world

	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$02	 
	TAY		 ; Y = 0 or 2

	JSR Object_CalcCoarseXDiff	 ; Get X difference between Nipper and Player
	STA <Temp_Var14		 ; Store flip direction -> Temp_Var14

	LDA <Temp_Var15	
	ADD #$03
	CMP #$06
	BGE PRG002_B1CD	 ; If Player is horizontally too far away from Nipper, jump to PRG002_B1CD

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	BMI PRG002_B1CD	 ; If Player is below Nipper, jump to PRG002_B1CD

	INY		 ; Y = 1 or 3

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B1CD	 ; If Nipper has not touched ground, jump to PRG002_B1CD

	; Nipper plant don't move horizontally!
	LDA #$00
	STA <Objects_XVel,X

	; Jump little Nipper!
	LDA #-$30
	STA <Objects_YVel,X

PRG002_B1CD:
	TYA	
	STA Objects_Frame,X	 ; Set frame

	JSR Object_DeleteOrDraw	 ; Delete if falls off-screen, otherwise draw
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

	LDA <Objects_Var4,X
	BNE PRG002_B1E1	 ; If Var4 <> 0, jump to PRG002_B1E1

	; Set the flip bits
	LDA <Temp_Var14
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B1E1:
	LDA Objects_Timer,X
	BEQ PRG002_B1EC	 ; If timer expired, jump to PRG002_B1EC

	LSR A
	BNE PRG002_B20F	 ; If timer > 1, jump to PRG002_B20F (RTS)

	JSR Object_FlipFace	 ; Otherwise, turn around

PRG002_B1EC:

	; Timer expired...

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B20F	 ; If Nipper has not touched ground, jump to PRG002_B20F (RTS)

	LDA <Objects_YVel,X
	BMI PRG002_B20F	 ; If Nipper is moving upward, jump to PRG002_B20F (RTS)

	DEC <Objects_Var5,X	; Var5--
	BPL PRG002_B208	 ; If Var5 >= 0, jump to PRG002_B208

	; Reset Var5 = 8
	LDA #$08
	STA <Objects_Var5,X

	; Reset timer to $20
	LDA #$20
	STA Objects_Timer,X

	; Halt horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	RTS		 ; Return

PRG002_B208:
	JSR Object_SetXVelByFacingDir	; Face travel direction 

	; Hop hop hop
	LDA #-$10
	STA <Objects_YVel,X

PRG002_B20F:
	RTS		 ; Return

ObjInit_Toad:
	LDY <Objects_YHi,X
	BEQ PRG002_B21A	 ; If Toad is high up, jump to PRG002_B21A

	; If you came via a Map Entry override, we assume it's a white toad house!
	LDA Map_EnterViaID
	BEQ PRG002_B21A		; If not an override, jump to PRG002_B21A

	INY		 ; Otherwise, Y = 1 

PRG002_B21A:
	STY <Objects_Var5,X	 ; -> Objects_Var5 (which message Toad gives)

	; Toad is always on the lower screen space
	LDA #$01
	STA <Objects_YHi,X

	; Stop the timer
	STA Level_TimerEn

	; Halt the Player
	LDA #$ff
	STA Player_HaltTick

	LDA #$00
	STA <Map_UseItem	; Clear item usage flag
	STA Player_Behind	; Player is not behind anything
	STA ToadTalk_CPos	; Clear the Toad character position counter

	; Set the starting VRAM addresses
	LDA #$28
	STA ToadTalk_VH
	LDA #$c8
	STA ToadTalk_VL

	RTS		 ; Return

PRG002_B23D:
	.byte $08, $04, $02, $01

ObjNorm_Toad:

	; Always turn to face Player
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	; Do Toad's dialog message
	JSR Toad_Speak

	LDA Player_HaltTick
	ORA InvFlip_Counter
	BNE PRG002_B261	 ; If Player is still halted or inventory is open, jump to PRG002_B261

	LDA <Pad_Input
	AND #$10
	BEQ PRG002_B261	 ; If Player is NOT pressing START, jump to PRG002_B261

	; Flip open inventory
	LDA #$01
	STA Inventory_Open

	; Start on first inventory item
	LSR A	; A = 0
	STA InvStart_Item

PRG002_B261:
	LDA InvFlip_Counter
	CMP #$04
	BNE PRG002_B272	 ; If Inventory is fully open, jump to PRG002_B272

	LDA <Pad_Input
	AND #%11110011
	BEQ PRG002_B272	 ; If Player is not pressing anything (besides up/down), jump to PRG002_B272

	; Force like Player pressed 'B' (close inventory)
	LDA #$40
	STA <Pad_Input

PRG002_B272:
	JMP Object_Draw16x32Sprite	 ; Draw Toad's sprite and don't come back!


Toad_Speak:
	LDA <Objects_Var4,X	 ; Get current dialog state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word Toad_DrawDiagBox
	.word Toad_DoToadText
	.word PRG002_B4B1	; Does nothing

TDiagBox_R1:	.byte $94, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $96
TDiagBox_R2:	.byte $92, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $93
TDiagBox_R3:	.byte $95, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $91, $97

TDiagBox_RowOffs:
	.byte (TDiagBox_R1 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1)
	.byte (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R2 - TDiagBox_R1), (TDiagBox_R3 - TDiagBox_R1)
TDiagBox_RowOffs_End

Toad_DrawDiagBox:
	LDX Graphics_BufCnt	 ; X = current graphics buffer counter

	; Store the current VRAM address into the buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,X
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,X

	; Store the next row address (+32 bytes to next row)
	ADD #$20	; 32 bytes to next row
	STA ToadTalk_VL
	BCC PRG002_B2D5
	INC ToadTalk_VH	 ; Apply carry
PRG002_B2D5:

	LDA #(TDiagBox_R2 - TDiagBox_R1)	; run count per row
	STA Graphics_Buffer+2,X
	STA <Temp_Var1		 ; -> Temp_Var1

	LDY ToadTalk_CPos	 ; Y = current dialog box row
	LDA TDiagBox_RowOffs,Y
	TAY		 	; Y = offset to this row index

PRG002_B2E3:
	; Store next pattern in dialog box
	LDA TDiagBox_R1,Y
	STA Graphics_Buffer+3,X

	INY		 ; Y++ (next pattern for dialog box)
	INX		 ; X++ (next index in graphics buffer)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG002_B2E3	 ; While Temp_Var1 > 0, loop!

	; Insert terminator
	LDA #$00
	STA Graphics_Buffer+3,X

	; X += 3
	INX
	INX
	INX
	STX Graphics_BufCnt

	LDX <SlotIndexBackup	 ; X = object slot index

	INC ToadTalk_CPos	 ; Next row

	LDA ToadTalk_CPos
	CMP #(TDiagBox_RowOffs_End - TDiagBox_RowOffs)
	BLT PRG002_B325	 ; If row count < 8, jump to PRG002_B325 (RTS)

	; Dialog box is complete

	LDY <Objects_Var5,X	 ; Y = Objects_Var5

	; Toad's Var1 and Var2 store the current pointer to the text he's reciting
	LDA ToadMsg_Low,Y
	STA Objects_Var1,X
	LDA ToadMsg_High,Y
	STA Objects_Var2,X

	; Reset the VRAM address for the dialog text
	LDA #$28
	STA ToadTalk_VH
	LDA #$e9
	STA ToadTalk_VL

	; Toad's timer = $10
	LDA #$10
	STA Objects_Timer,X

	INC <Objects_Var4,X	 ; Objects_Var4 = 1 (next dialog state)

PRG002_B325:
	RTS		 ; Return

	; English: "Pick a box." / "Its contents" / "will help you" / "on your way"
ToadMsg_Standard:
	;            P    i    c    k         a         b    o    x    .
	.byte $FE, $BF, $D8, $D2, $DA, $FE, $D0, $FE, $D1, $DE, $88, $E9, $FE, $FE, $FE

	;            I    t    s         c    o    n    t    e    n    t    s
	.byte $FE, $B8, $CD, $CC, $FE, $D2, $DE, $DD, $CD, $D4, $DD, $CD, $CC, $FE, $FE

	;            w    i    l    l         h    e    l    p         y    o    u
	.byte $FE, $81, $D8, $DB, $DB, $FE, $D7, $D4, $DB, $DF, $FE, $8C, $DE, $CE, $FE

	;            o    n         y    o    u    r         w    a    y    .
	.byte $FE, $DE, $DD, $FE, $8C, $DE, $CE, $CB, $FE, $81, $D0, $8C, $E9, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	; English: "One toot on" / "this whistle" / "will send you" / "to a far away" / "land!"
ToadMsg_WarpWhistle:
	;       O    n    e         t    o    o    t         o    n
	.byte $BE, $DD, $D4, $FE, $CD, $DE, $DE, $CD, $FE, $DE, $DD, $FE, $FE, $FE, $FE

	;       t    h    i    s         w    h    i    s    t    l    e
	.byte $CD, $D7, $D8, $CC, $FE, $81, $D7, $D8, $CC, $CD, $DB, $D4, $FE, $FE, $FE

	;       w    i    l    l         s    e    n    d         y    o    u
	.byte $81, $D8, $DB, $DB, $FE, $CC, $D4, $DD, $D3, $FE, $8C, $DE, $CE, $FE, $FE

	;       t    o         a         f    a    r         a    w    a    y
	.byte $CD, $DE, $FE, $D0, $FE, $D5, $D0, $CB, $E5, $D0, $81, $D0, $8C, $FE, $FE

	;       l    a    n    d    !
	.byte $DB, $D0, $DD, $D3, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	; English: "Hello! You" / "found my shop" / "of strange and" / "wonderful" / "things!"
ToadMsg_AnchorPWing:
	;            H    e    l    l    o    !         Y    o    u
	.byte $FE, $B7, $D4, $DB, $DB, $DE, $EA, $FE, $C8, $DE, $CE, $FE, $FE, $FE, $FE

	;            f    o    u    n    d         m    y         s    h    o    p
	.byte $FE, $D5, $DE, $CE, $DD, $D3, $FE, $DC, $8C, $FE, $CC, $D7, $DE, $DF, $FE

	;            o    f         s    t    r    a    n    g    e         a    n    d
	.byte $FE, $DE, $D5, $FE, $CC, $CD, $CB, $D0, $DD, $D6, $D4, $FE, $D0, $DD, $D3

	;            w    o    n    d    e    r    f    u    l
	.byte $FE, $81, $DE, $DD, $D3, $D4, $CB, $D5, $CE, $DB, $FE, $FE, $FE, $FE, $FE

	;            t    h    i    n    g    s    !
	.byte $FE, $CD, $D7, $D8, $DD, $D6, $CC, $EA, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	;
	.byte $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE, $FE

	; Pointer table to Toad's three messages
	; Warp Whistle
	; Standard
	; Anchor/P-Wing
ToadMsg_Low:	.byte LOW(ToadMsg_WarpWhistle), LOW(ToadMsg_Standard), LOW(ToadMsg_AnchorPWing)
ToadMsg_High:	.byte HIGH(ToadMsg_WarpWhistle), HIGH(ToadMsg_Standard), HIGH(ToadMsg_AnchorPWing)


Toad_DoToadText:
	LDA Objects_Timer,X
	BNE PRG002_B4B1	 ; If timer not expired, jump to PRG002_B4B1

	; Store address of text -> Temp_Var1/2
	LDA Objects_Var1,X
	STA <Temp_Var1
	LDA Objects_Var2,X
	STA <Temp_Var2

	INC Objects_Var1,X	; Next character
	BNE PRG002_B451
	INC Objects_Var2,X	; Apply carry
PRG002_B451:

	LDY #$00	 	; Y = 0
	LDA [Temp_Var1],Y	; Get character here
	TAY		 	; -> 'Y'
	CPY #$FE
	BEQ PRG002_B468	 	; If this is a "space", jump to PRG002_B468

	; Play "blip" sound every other letter
	LDA ToadTalk_VL
	LSR A
	BCC PRG002_B468

	; Play text "blip" sound
	LDA Sound_QLevel1
	ORA #SND_LEVELBLIP
	STA Sound_QLevel1

PRG002_B468:
	TYA

	LDY Graphics_BufCnt	 ; Y = graphics buffer counter
	STA Graphics_Buffer+3,Y	 ; Store into buffer

	; Insert one character into graphics buffer
	LDA ToadTalk_VH
	STA Graphics_Buffer,Y	; address high
	LDA #$01	 
	STA Graphics_Buffer+2,Y	; run length
	LSR A
	STA Graphics_Buffer+4,Y	; terminator
	TYA
	ADD #$04
	STA Graphics_BufCnt	; count
	LDA ToadTalk_VL
	STA Graphics_Buffer+1,Y	; address low

	INC ToadTalk_VL	 ; Next VRAM byte
	AND #$1f	 	; Get current column
	CMP #$17
	BNE PRG002_B4AC	 	; If we're not in column 23, jump to PRG024_A25B

	; Line break!

	LDA ToadTalk_VL
	ADC #$10		; Add enough bytes to get to next row
	STA ToadTalk_VL
	BCC PRG002_B4A1
	INC ToadTalk_VH	; Apply carry
PRG002_B4A1:

	CMP #$a9
	BNE PRG002_B4AC	 ; If we haven't reached the last character, jump to PRG002_B4AC

	INC <Objects_Var4,X	 ; Objects_Var4 = 2 (next dialog state)

	LDA #$00
	STA ToadTalk_CPos

PRG002_B4AC:

	; Set timer to $04
	LDA #$04
	STA Objects_Timer,X

PRG002_B4B1:
	RTS		 ; Return

	; Pattern for left half of sprite for Toad House item
ToadItem_PatternLeft:
	.byte $85	; Mushroom
	.byte $87	; Fire flower
	.byte $9D	; Leaf
	.byte $81	; Frog Suit
	.byte $83	; Tanooki Suit
	.byte $8B	; Hammer Suit
	.byte $B5	; Judgems
	.byte $91	; P-Wing
	.byte $A9	; Star
	.byte $95	; Anchor
	.byte $99	; Hammer
	.byte $A1	; Whistle
	.byte $89	; Music box

	; Pattern for right half of sprite for Toad House item
ToadItem_PatternRight:
	.byte $85	; Mushroom
	.byte $87	; Fire flower
	.byte $9F	; Leaf
	.byte $81	; Frog Suit
	.byte $83	; Tanooki Suit
	.byte $8B	; Hammer Suit
	.byte $B7	; Judgems
	.byte $93	; P-Wing
	.byte $A9	; Star
	.byte $97	; Anchor
	.byte $9B	; Hammer
	.byte $A3	; Whistle 
	.byte $8D	; Music box

	; Attributes applied to right sprite of item
ToadItem_AttrRight:
	.byte $43	; Mushroom
	.byte $43	; Fire flower
	.byte $03	; Leaf
	.byte $43	; Frog Suit
	.byte $43	; Tanooki Suit
	.byte $43	; Hammer Suit
	.byte $03	; Judgems
	.byte $03	; P-Wing
	.byte $43	; Star
	.byte $03	; Anchor
	.byte $03	; Hammer
	.byte $03	; Whistle
	.byte $03	; Music Box

ObjNorm_ToadHouseItem:
	LDA <Objects_Var4,X
	ORA InvFlip_Counter
	BNE PRG002_B523	 ; If Var4 <> 0 OR Inventory is open, jump to PRG002_B523

	; Var4 = 0, or inventor not open

	; Set "starting" inventory item in open inventory
	LDA Objects_Var2,X
	STA InvStart_Item

	; Begin opening inventory
	LDA #$01
	STA Inventory_Open
	STA InvFlip_Counter
	LSR A
	STA InvFlip_Frame

	; HACKish: Setting inventory flip "High" address
	LDA #$2b
	STA InvFlip_VAddrHi

	LDY Objects_Frame,X	 ; Y = object frame (item you're getting)

	LDA ToadItem_PalPerItem,Y

	LDY Graphics_BufCnt
	STA Graphics_Buffer+3,Y	 ; Store color change into buffer

	; Store color change into palette
	STA Pal_Data+$1E	
	STA Palette_Buffer+$1E	

	; Store palette address into buffer
	LDA #$3f
	STA Graphics_Buffer,Y
	LDA #$1e
	STA Graphics_Buffer+1,Y

	; Run length of 1
	LDA #$01
	STA Graphics_Buffer+2,Y

	; Terminator
	LSR A
	STA Graphics_Buffer+4,Y

	; Y += 4 (4 new bytes in buffer)
	INY
	INY
	INY
	INY
	STY Graphics_BufCnt	 ; Set corrected buffer count

PRG002_B523:
	LDA #$00
	STA <Objects_Var4,X	 ; Var4 = 0
	STA <Pad_Input		 ; Ignore Player input

	LDA Objects_Timer,X
	BNE PRG002_B534	 ; If timer not expired, jump to PRG002_B534

	; Timer expired!  Returning to map

	STA Map_ReturnStatus	 ; Clear level
	INC Level_ExitToMap	 ; Exit to map

PRG002_B534:
	LDA InvFlip_Counter
	CMP #$04
	BNE PRG002_B5A9	 ; If inventory is not fully open, jump to PRG002_B5A9 (RTS)

	LDA <Objects_Y,X
	CMP #200
	BEQ PRG002_B56A	 ; If item's Y = 200, jump to PRG002_B56A

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	; "Gravity" of item
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDY #$00	 ; Y = 0

	LDA <Objects_Y,X
	CMP #200
	BLT PRG002_B572	 ; If item's Y < 200, jump to PRG002_B572

	; Prevent object from falling lower than 200
	LDA #200
	STA <Objects_Y,X

	LDY Objects_Var1,X	; Y = Inventory_Items offset

	; Store object into Player's inventory
	LDA Objects_Frame,X
	STA Inventory_Items,Y

	; Force redraw of Inventory items
	LDA #$03
	STA InvFlip_Counter
	LDA #$0c
	STA InvFlip_Frame

PRG002_B56A:
	LDA <Counter_1
	AND #%0011000
	BEQ PRG002_B5A9	 ; Flashing display; jump on and off to PRG002_B5A9

	LDY #$18	 ; Y = $18

PRG002_B572:

	; Display cycle...

	; Set Sprite Y of both halves
	LDA <Objects_Y,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA Objects_Frame,X
	TAX		 ; Frame -> 'X' 

	; Due to logic about the item ('0' meant Player didn't open box yet back in PRG029), the frame is off-by-one

	; Store left pattern
	LDA ToadItem_PatternLeft-1,X	 
	STA Sprite_RAM+$01,Y	 

	; Store right pattern
	LDA ToadItem_PatternRight-1,X
	STA Sprite_RAM+$05,Y	

	; Palette select 3 for left half
	LDA #SPR_PAL3
	STA Sprite_RAM+$02,Y

	; Whatever appropriate attribute for right half
	LDA ToadItem_AttrRight-1,X
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	; Store item sprite Xs
	LDA <Objects_X,X
	STA Sprite_RAM+$03,Y	; Left half
	ADD #$08		; +8
	STA Sprite_RAM+$07,Y	; Right half

	; Y -= 8
	TYA
	SUB #$08
	TAY

	BPL PRG002_B572	 ; While Y >= 0, loop

PRG002_B5A9:
	RTS		 ; Return

LogPlat_Draw:
	JSR Object_ShakeAndCalcSprite

	; Do not preserve the H/V flip bits
	LDA <Temp_Var3
	AND #%00111111
	STA <Temp_Var3

	LDA <Counter_1
	LSR A
	PHP		 ; Save CPU state (most importantly the carry flag)
	BCC PRG002_B5BD	 ; Every other tick, jump to PRG002_B5BD

	; Y += (11 + C = 12) -- Every other tick, offset Sprite_RAM
	TYA
	ADC #$0b
	TAY

PRG002_B5BD:
	JSR Object_Draw24x16Sprite	 ; Draw wide sprite

	LDA <Temp_Var7	 ; Get Sprite_RAM offset (as determined by Object_ShakeAndCalcSprite)
	PLP		 ; Restore CPU state
	BCS PRG002_B5C7	 ; Every other opposite tick, jump to PRG002_B5C7

	; Otherwise, add +12 to Sprite_RAM offset
	ADC #$0c

PRG002_B5C7:
	TAY		 ; Sprite_RAM offset -> 'Y'

	INX
	INX
	INX	; X += 3 (starting tiles index)

	; Temp_Var2 (Sprite X) += 24
	LDA #24
	ADD <Temp_Var2
	STA <Temp_Var2

	; Alters horizontal visibility ??
	ASL <Temp_Var8
	ASL <Temp_Var8
	ASL <Temp_Var8

	JSR Object_Draw24x16Sprite	 ; Draw wide sprite

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

ObjNorm_NipperFireBreathe:
	JSR Enemy_CollideWithWorld	; Collide with world
	JSR Object_DeleteOrDraw	 	; Delete if Nipper off-screen or draw it
	JSR Object_HitTestRespond	; Do collision test with Player and respond

	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X	 ; Set flip towards Player
 
	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X	 ; Nipper just smacks his lips

	JSR Object_AnySprOffscreen
	BNE PRG002_B65A	 ; If any of Nipper's sprites are not visible, jump to PRG002_B65A (RTS)

	LDA <Counter_1
	AND #$a0
	BNE PRG002_B65A	; Fire breather only does things in a limited window; otherwise, jump to PRG002_B65A (RTS)

	; Fire breather frame!
	LDA #$02
	STA Objects_Frame,X

	LDA <Counter_1
	AND #$07
	BNE PRG002_B65A	 ; Only do anything 1:8 ticks, otherwise jump to PRG002_B65A (RTS)

	; Set 'Y' to $10 or -$10 based on which side Player is on
	LDA <Temp_Var15
	TAY	
	ADD #$10
	CMP #$20
	BLT PRG002_B61F

	LDY #$10	 ; Y = $10

	LDA <Temp_Var15
	BPL PRG002_B61F

	LDY #-$10	 ; Y = -$10

PRG002_B61F:
	STY <Temp_Var1		 ; Temp_Var1 = $10 or -$10, based on which side Player is on

	JSR Object_CalcCoarseYDiff

	LDA <Temp_Var15
	ADD #$20
	CMP #$40
	BGE PRG002_B65A	 	; If Player is too high above Nipper, jump to PRG002_B65A (RTS)

	JSR SpecialObj_FindEmptyAbort	 ; Find an empty special object slot if on-screen (or don't come back!)

	; Nipper fireball ID
	LDA #SOBJ_NIPPERFIREBALL
	STA SpecialObj_ID,Y

	; Nipper fireball X
	LDA <Objects_X,X
	ADD #$04
	STA SpecialObj_XLo,Y

	; Nipper fireball Y
	LDA <Objects_Y,X
	STA SpecialObj_YLo,Y
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,Y

	; Nipper fireball X velocity
	LDA <Temp_Var1
	ASL A		
	JSR Negate	
	STA SpecialObj_XVel,Y

	; Nipper fireball Y velocity
	LDA #-$40
	SUB <Temp_Var15
	STA SpecialObj_YVel,Y

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_B65A:
	RTS		 ; Return

DryBones_XVelConveyor:	.byte $08, $08, $0A	; Dry Bones' X Velocities with conveyor handling 
DryBones_AnimCntrMask:	.byte $04, $08, $08	; These values mask against the counter (Dry Bones animates faster walking against conveyor)

	; While Dry Bones is reassembling, provides frame and timer values
DryBones_ReassembleFrames:	.byte $01, $02, $03, $03, $03, $03, $03, $02
DryBones_ReassembleTimers:	.byte $10, $0A, $06, $06, $06, $06, $FF, $0A
	
ObjNorm_DryBones:
	JSR CarryClearIfAliveAndNoHalt
	BCS DryBones_Draw	 ; If Dry Bones is Dying or gameplay halted, jump to DryBones_Draw

	; Dry Bones is alive and gameplay not halted...

	JSR Enemy_CollideWithWorld	 ; Collide with world
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JSR DryBones_Draw		 ; Draw Dry Bones
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond
	JSR DryBones_BumpOffOthers	 ; Bump off other objects

	LDA <Objects_Var5,X
	BNE PRG002_B6B2	 ; If Var5 <> 0 (Dry Bones is crumpled), jump to PRG002_B6B2

	JSR Object_HandleConveyorBounceVel	; Sets LRBounce_Vel which way Dry Bones will need to be effected by conveyor
	LDY LRBounce_Vel
	INY		 ; Y++ (index into DryBones_XVelConveyor)

	; Set carry if horizontally flipped
	LDA Objects_FlipBits,X
	ASL A
	ASL A

	LDA DryBones_XVelConveyor,Y	 ; Get velocity appropriate to Dry Bones' predicament
	BCS PRG002_B69D	 ; If horizontally flipped, jump to PRG002_B69D
	JSR Negate	 ; Otherwise, negate
PRG002_B69D:
	STA <Objects_XVel,X	 ; Set Dry Bones' X velocity

	LDA <Objects_DetStat,X
	AND #$04
	BEQ PRG002_B6B1	 ; If Dry Bones is NOT on the ground, jump to PRG002_B6B1

	; Toggle Dry Bones' walking frames by counter and whether he's running against a conveyor 
	LDA <Counter_1
	AND DryBones_AnimCntrMask,Y
	BEQ PRG002_B6AE	 
	LDA #$01
PRG002_B6AE:
	STA Objects_Frame,X

PRG002_B6B1:
	RTS		 ; Return

PRG002_B6B2:

	; Crumpled Dry Bones...

	LDA Objects_Timer,X
	BNE PRG002_B6D0	 ; If timer not expired, jump to PRG002_B6D0 (RTS)

	DEC <Objects_Var5,X	 ; Var5--
	BNE PRG002_B6C2	 ; If Var5 <> 0 (still reassembling), jump to PRG002_B6C2

	; Dry Bones gets back up and faces Player!
	JSR Object_CalcCoarseXDiff
	STA Objects_FlipBits,X

	RTS		 ; Return

PRG002_B6C2:

	; Reassembling Dry Bones

	LDY <Objects_Var5,X	; Y = Var5 (0 = fully reassembled, hence -1 used below)

	LDA DryBones_ReassembleFrames-1,Y
	STA Objects_Frame,X

	LDA DryBones_ReassembleTimers-1,Y
	STA Objects_Timer,X

PRG002_B6D0:
	RTS		 ; Return

	; Patterns used when Dry Bones is crumbling
DryBones_CrumblePats:	.byte (ObjP3F - ObjectGroup01_PatternSets + $08), (ObjP3F - ObjectGroup01_PatternSets + $0B)
	; Little head bounce when crumbled
DryBones_HeadYOff:	.byte 0, 0, 0, -1, -2, -1, 0, 0, 0

DryBones_Draw:
	LDA Objects_Frame,X
	CMP #$02
	BGE PRG002_B706	 ; If Dry Bones' frame >= 2 (crumbling), jump to PRG002_B706

	; Frame 0 or 1

	; Save Dry Bones' Y/Hi
	LDA <Objects_YHi,X
	PHA		
	LDA <Objects_Y,X
	PHA		

	; Subtract 16 from Dry Bones' Y position
	SUB #16
	STA <Objects_Y,X
	BCS PRG002_B6F2
	DEC <Objects_YHi,X
PRG002_B6F2:

	; Draw Dry Bones
	LDY #$01	 ; 32 pixels height for Object_DetermineVertVisY
	JSR Object_DetermineVertVisY
	JSR Object_Draw16x32Sprite

	; Restore Dry Bones' Y/Hi
	PLA
	STA <Objects_Y,X
	PLA
	STA <Objects_YHi,X

	JSR Object_DetermineVertVis
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate sprite X/Y and don't come back!

PRG002_B706:

	; Frame >= 2 (crumbling)...

	LDA Objects_FlipBits,X
	ASL A
	ASL A	; Sets carry if horizontally flipped

	; Save Dry Bones' X/Hi
	LDA <Objects_XHi,X
	PHA
	LDA <Objects_X,X
	PHA

	BCS PRG002_B71C	 ; If Dry Bones is horizontally flipped, jump to PRG002_B71C

	; Subtract 8 from Dry Bones' X position
	SUB #$08
	STA <Objects_X,X
	BCS PRG002_B71C
	DEC <Objects_XHi,X
PRG002_B71C:

	LDY #$02	 ; Select width = 24 for Object_DetermineHorzVisY
	JSR Object_DetermineHorzVisY	 ; Determine horizontal visibility
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite X/Y

	LDX <SlotIndexBackup	 	 ; X = object slot index
	LDY Objects_Frame,X	 	 ; Y = Dry Bones' frame

	LDX DryBones_CrumblePats-2,Y	 ; X = pattern start for this frame of Dry Bones (-2 because we start crumbling at frame 2)
	LDY <Temp_Var7			 ; Y = Sprite_RAM offset
	JSR Object_Draw24x16Sprite	 ; Draw wide sprite (crumbled Dry Bones)

	LDX <SlotIndexBackup		 ; X = object slot index
	BIT <Temp_Var3
	BVC PRG002_B73C	 	; If Dry Bones is not horizontally flipped, jump to PRG002_B73C

	; Otherwise, 'Y' += 8 (two sprites over)
	TYA
	ADD #$08
	TAY

PRG002_B73C:
	LDA <Objects_Var5,X
	TAX		 ; X = Var5 (head bounce index)

	; Apply bounce to his head after crumbling
	LDA Sprite_RAM+$00,Y
	ADD DryBones_HeadYOff,X	
	STA Sprite_RAM+$00,Y

	LDX <SlotIndexBackup		 ; X = object slot index

	; Restore Dry Bones' X/Hi
	PLA
	STA <Objects_X,X
	PLA
	STA <Objects_XHi,X

	JSR Object_DetermineHorzVis	 ; Determine horizontal visibility of Dry Bones' sprites
	JMP Object_CalcSpriteXY_NoHi	 ; Calculate Sprite X/Y and don't come back!


ObjHit_DryBones:
	LDA <Objects_Var5,X
	BNE PRG002_B77D	 ; If head bouncing, jump to PRG002_B77D (RTS)

	; Head not bouncing yet

	LDA <Temp_Var12
	LSR A
	BCC PRG002_B77E	 ; If not hit by Player jumping on head, jump to PRG002_B77E (Player_GetHurt)

	; Var5 = 9
	LDA #$09
	STA <Objects_Var5,X

	; Dry Bones stop horizontal movement
	LDA #$00
	STA <Objects_XVel,X

	; Bounce Player
	LDA #-$40
	STA <Player_YVel

	; Crumble sound
	LDA Sound_QLevel2
	ORA #SND_LEVELCRUMBLE
	STA Sound_QLevel2

	; Tally kill
	LDA Kill_Tally
	JSR Score_Get100PlusPts
	INC Kill_Tally

PRG002_B77D:
	RTS		 ; Return

PRG002_B77E:
	JMP Player_GetHurt	 ; Hurt Player and don't come back!


	; Essentially an implementation of Object_BumpOffOthers tailored
	; for Dry Bones, handling one or the other being crumpled
DryBones_BumpOffOthers:
	TXA		  
	ADD <Counter_1
	LSR A		
	BCS PRG002_B789	 ; Semi-randomly jump to PRG002_B789

PRG002_B788:
	RTS		 ; Return

PRG002_B789:
	LDA Objects_SprVVis,X
	BNE PRG002_B77D	 ; If any sprite of Dry Bones is vertically off-screen, jump to PRG002_B77D (RTS)

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B77D	 ; If some of Dry Bones is horizontally off-screen, jump to PRG002_B77D (RTS)

	JSR Object_CalcBoundBox2
	TXA	
	BEQ PRG002_B788	 ; If this Dry Bones is in object slot 0, jump to PRG002_B788

	DEX		 ; X-- (consider the previous object)
PRG002_B79E:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BEQ PRG002_B7A9	 ; If previous object state is Normal, jump to PRG002_B7A9

	CMP #OBJSTATE_SHELLED
	BNE PRG002_B815	 ; If previous object state is not Shelled, jump to PRG002_B815

PRG002_B7A9:
	LDY Level_ObjectID,X	 ; Y = object's ID

	LDA Object_AttrFlags,Y
	AND #OAT_BOUNCEOFFOTHERS
	BEQ PRG002_B815	 ; If OAT_BOUNCEOFFOTHERS is NOT set, jump to PRG002_B815

	LDA Objects_SprVVis,X
	BNE PRG002_B815	 ; If any sprite is vertically off-screen, jump to PRG002_B815

	LDA Objects_SprHVis,X
	AND #$c0
	CMP #$c0
	BEQ PRG002_B815	 ; If previous object has sprites horizontally off-screen, jump to PRG002_B815

	JSR Object_CalcBoundBox 
	JSR ObjectObject_Intersect 
	BCC PRG002_B815	 ; If object did not intersect with prior object, jump to PRG002_B815

	LDY <SlotIndexBackup	 ; Y = object slot index

	LDA <Objects_X,X
	SUB Objects_X,Y
	PHA		 ; Save the difference between the two objects' Xs

	LDA <Objects_XHi,X
	SBC Objects_XHi,Y
	STA <Temp_Var1	 ; Temp_Var1 = the difference between the two objects' X His

	; Determine which way this object should face relative to its position
	ROL <Temp_Var2
	PLA	
	ADC #$80
	LDA <Temp_Var1
	ADC #$00	
	BNE PRG002_B815	 

	LSR <Temp_Var2	
	LDY #$00	 ; Y = $00 (face one way)
	BCS PRG002_B7EC	

	LDY #SPR_HFLIP	 ; Y = SPR_HFLIP (face the other)

PRG002_B7EC:
	TYA		 
	STA <Temp_Var1	 ; Temp_Var1

	LDY <SlotIndexBackup	 ; Y = The Dry Bones who started this

	LDA Objects_Var5,Y
	BNE PRG002_B7FB	 ; If Var5 <> 0, jump to PRG002_B7FB (crumbled Dry Bones need not turn around)

	; I'm not crumbled, I get to turn...
	LDA <Temp_Var1
	STA Objects_FlipBits,Y

PRG002_B7FB:
	LDA Objects_State,X
	CMP #OBJSTATE_NORMAL
	BNE PRG002_B815	 ; If bumped-into object's state is not Normal, jump to PRG002_B815

	LDA Level_ObjectID,X
	CMP #OBJ_DRYBONES
	BNE PRG002_B80E	 ; If Dry Bones bumped into something that's not a Dry Bones, jump to PRG002_B80E

	LDA Objects_Var5,X
	BNE PRG002_B815	 ; If Dry Bones bumped into a crumpled Dry Bones, jump to PRG002_B815

PRG002_B80E:
	; Dry Bones "bumps" into a non-crumpled Dry Bones or something not a Dry Bones, turn around
	LDA <Temp_Var1
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X

PRG002_B815:
	DEX		 ; X--
	BPL PRG002_B79E	 ; While X >= 0, loop!

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

Respawn_XLo:	.byte $40, -$40
Respawn_XHi:	.byte $00, $FF

Fish_Repawn:
	LDY <Scroll_LastDir	 ; Y = last scroll direction value

	; Respawn near Player depending on direction he last moved
	LDA <Player_X
	ADD Respawn_XLo,Y
	STA <Objects_X,X
	LDA <Player_XHi
	ADC Respawn_XHi,Y
	STA <Objects_XHi,X

	TYA
	STA <Objects_Var5,X	 ; Objects_Var5 = entrance direction

ObjInit_ChasingFish:

	; Chasing fish always appear at the current vertical scroll + 160
	LDA Level_VertScroll
	ADD #160
	STA <Objects_Y,X
	LDA Level_VertScrollH
	ADC #$00
	STA <Objects_YHi,X

	; Come in hopping!
	LDA #-$08
	STA <Objects_YVel,X

	; Frame -1??
	LDA #-1
	STA Objects_Frame,X

	RTS		 ; Return

BigBertha_ProxLimit:	.byte $08, -$09	; How close (in coarse units) Big Bertha must be to Player to lunge
BigBertha_XVelLimit:	.byte $30, $50	; Limit on X Velocity (relative, used in addition)
BigBertha_Accel:	.byte -$04, $04	; X Velocity acceleration for each direction
BigBertha_XCoarseLimit:	.byte $10, $70	; How far away Big Bertha can be before turning around
BigBertha_EatLimit:	.byte $01, $03	; In coarse units (relative, used in addition), when Player is close enough to be eaten

ObjNorm_BigBertha:
	JSR Fish_FixedYIfAppro	 ; Fixes 'Y' coordinate for Big Bertha that swims in fixed water
	JSR BigBertha_Draw	 ; Draw Big Bertha

	LDA <Player_HaltGame
	BNE PRG002_B896	 ; If gameplay is halted, jump to PRG002_B896

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_B897	 ; If Big Bertha's state is not Dying, jump to PRG002_B897

PRG002_B867:
	; Big Bertha is dying...

	LDA Objects_Timer,X
	BEQ PRG002_B87A	 ; If timer expired, jump to PRG002_B87A

	LSR A	
	BNE PRG002_B896	 ; If timer >= 2, jump to PRG002_B896 (RTS)

	; Timer tick 1...

	; Big Bertha recreates self!
	JSR Level_PrepareNewObject

	; Set back to state 2 (Normal operation)
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X
	JMP Fish_Repawn	 ; Jump to Fish_Repawn

PRG002_B87A:

	; Timer expired on dying Big Bertha...

	; Fix the flip bits
	ASL Objects_FlipBits,X
	SEC
	ROR Objects_FlipBits,X

	LDA Objects_Var7,X
	BEQ PRG002_B889	 ; If Var7 = 0 (Mario not devoured), jump to PRG002_B889
	JMP PRG002_B981	 ; Jump to PRG002_B981

PRG002_B889:
	JSR Object_Move	 ; Do standard object movements

	LDA Objects_SprVVis,X
	BEQ PRG002_B896	 ; If no sprites are vertically off-screen, jump to PRG002_B896

	; Otherwise, set Big Bertha's timer to $FF (time until Big Bertha respawns!)
	LDA #$ff
	STA Objects_Timer,X

PRG002_B896:
	RTS		 ; Return


PRG002_B897:
	LDY Objects_Var7,X
	BEQ PRG002_B8A0	 ; If Mario not devoured, jump to PRG002_B8A0

	INY
	STY Player_HaltTick	; Player is halted until Big Bertha drowns him!

PRG002_B8A0:
	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond

	LDA Objects_Frame,X
	BPL PRG002_B900	 ; If frame = 0, jump to PRG002_B900

	LDA <Objects_SpriteY,X
	CMP #154
	BGE PRG002_B8B8	 ; If Big Bertha's SpriteY >= 154, jump to PRG002_B8B8

	; Otherwise, halt vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG002_B8B8:
	LDY <Objects_Var5,X	 ; Y = Var5 (current direction)

	LDA <Objects_XVel,X
	ADD BigBertha_XVelLimit,Y
	BMI PRG002_B8CA		; If negative result, jump to PRG002_B8CA

	; Apply acceleration
	LDA <Objects_XVel,X
	ADD BigBertha_Accel,Y
	STA <Objects_XVel,X

PRG002_B8CA:
	LDA <Objects_XVel,X
	LSR A		; Shift right 1
	AND #SPR_HFLIP	; Mask if it was negative
	EOR #SPR_HFLIP	; Flip it
	STA Objects_FlipBits,X	 ; Store horizontal flip bit

	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15		 ; Get coarse X diff
	ADD BigBertha_XCoarseLimit,Y
	BPL PRG002_B8E4	 ; If limit not reached, jump to PRG002_B8E4

	; Turn Big Bertha around
	TYA		
	EOR #$01	
	STA <Objects_Var5,X	 ; Store reversed direction flag

PRG002_B8E4:
	LDA <Temp_Var15		
	CMP BigBertha_ProxLimit,Y
	BNE PRG002_B896	 ; If not hit limit, jump to PRG002_B896 (RTS)

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	CMP #$10
	BGE PRG002_B896	 ; If Big Bertha is vertically too far from Player, jump to PRG002_B896

	; Does ... nothing to X Velocity?
	LDA <Objects_XVel,X
	ASL A			; Bit 7 shifted into carry
	ROR <Objects_XVel,X	; Carry shifted back into Bit 7

	; Big Bertha jumps!
	LDA #-$28
	STA <Objects_YVel,X

	; Gaping mouth
	INC Objects_Frame,X

PRG002_B900:

	; Big Bertha's gravity, Y Vel += 2
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDA <Objects_SpriteY,X

	; NOTE: Big Bertha is clearly abusing the purpose of Objects_Frame

	LDY Objects_Frame,X
	CPY #$05
	BGE PRG002_B978	 ; If frame >= 5, jump to PRG002_B978

	CPY #$04
	BLT PRG002_B919	 ; If frame < 4, jump to PRG002_B919

	CMP #148
	BLT PRG002_B896	 ; If SpriteY < 148, jump to PRG002_B896 (RTS)

	LDA #$05
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (sets Objects_Frame)

PRG002_B919:
	LDA <Counter_1
	AND #$07
	BNE PRG002_B925	 ; Only 1:8 ticks we don't jump to PRG002_B925

	; Reverse frame
	TYA
	EOR #$01
	STA Objects_Frame,X

PRG002_B925:
	CPY #$02
	BGE PRG002_B95C	 ; If frame >= 2, jump to PRG002_B95C

	JSR Object_CalcCoarseXDiff
	LDY <Objects_Var5,X	; get direction flag
	LDA <Temp_Var15
	ADD BigBertha_EatLimit,Y
	CMP #$02
	BGE PRG002_B95C	 ; If Player is horizontally too far away to be eaten, jump to PRG002_B95C

	; Player might get eaten!

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15
	ADD #$08
	CMP #$0a
	BGE PRG002_B95C	 ; If Player is vertically too far away to be eaten, jump to PRG002_B95C

	LDA Player_StarInv
	ORA <Player_IsDying
	ORA Player_Behind_En
	BNE PRG002_B95C	 ; If Player is invincible by Starman, dying, or "behind the scenes", jump to PRG002_B95C

	; Player gets eaten!

	INC Objects_Var7,X ; Flag Player as devoured

	LDA #$08
	STA <Player_YHi		; Set Player impossibly low
	STA Player_OffScreen	; Flag Player as off-screen

	LDA #$02
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (set frame)

PRG002_B95C:
	LDA <Objects_YVel,X
	BMI PRG002_B996	 ; If Big Bertha is moving upward, jump to PRG002_B996 (RTS)

	; Big Bertha is falling...
	
	LDA <Objects_SpriteY,X
	CMP #160
	BLT PRG002_B996	 ; If SpriteY < 160, jump to PRG002_B996 (RTS)

	JSR BigBertha_Splash	 ; Splash!

	; Big Bertha Y -= 24
	LDA <Objects_Y,X
	SUB #24
	STA <Objects_Y,X
	BCS PRG002_B974
	DEC <Objects_YHi,X	 ; Apply carry
PRG002_B974:

	LDA #$04
	BNE PRG002_B993	 ; Jump (technically always) to PRG002_B993 (set frame)

PRG002_B978:
	CMP #160
	BLT PRG002_B996	 ; If Big Bertha's Y < 160, jump to PRG002_B996

	LDA Objects_Var7,X
	BEQ PRG002_B98D	 ; If Player is not devoured, jump to PRG002_B98D

PRG002_B981:
	LDA #$00
	STA Player_HaltTick	; Player not halted
	STA Player_AboveTop	; Player not above top of screen

	; Hold Player really low
	LDA #196
	STA <Player_SpriteY

PRG002_B98D:
	; Big Bertha Y Vel = -$08
	LDA #-$08
	STA <Objects_YVel,X

	; Sprite frame = -1 (??)
	LDA #$ff

PRG002_B993:
	STA Objects_Frame,X

PRG002_B996:
	RTS		 ; Return

PRG002_B997:
	.byte $FE, $02, $05, $FB, $01, $02, $03, $00

BigBertha_Splash:
	LDY #$02	 ; Y = 2 (use splash slot 2)

	LDA Splash_Counter,Y
	BEQ PRG002_B9A7	 ; If this slot is free, jump to PRG002_B9A7

	DEY		 ; Otherwise, try slot 1

PRG002_B9A7:

	; Initialize splash
	LDA #$01
	STA Splash_Counter,Y
	STA Splash_NoScrollY,Y

	; Set Splash Y
	LDA #147
	STA Splash_Y,Y

	; Set Splash X
	LDA <Objects_X,X
	STA Splash_X,Y
	RTS		 ; Return

BigBertha_Draw:
	LDA Objects_Var7,X	 
	BNE PRG002_B9CB	 ; If there's fractional X, jump to PRG002_B9CB

	LDY Objects_State,X
	CPY #OBJSTATE_KILLED
	BNE PRG002_B9CB	 ; If Big Bertha's state is not Killed, jump to PRG002_B9CB

	; Big Bertha's frame set to 1 if Dying
	LDA #$01
	STA Objects_Frame,X

PRG002_B9CB:
	INC Objects_Frame,X	 ; Big Bertha's frame++
	JSR Object_ShakeAndCalcSprite	 ; Calculate sprite data

	LDX <SlotIndexBackup		 ; X = object slot index

	LDA Objects_Frame,X
	DEC Objects_Frame,X	 ; Big Bertha's frame--
	ASL A	
	ASL A			; Multiply by 4
	ADD <Temp_Var6		 ; Add to starting tile
	STA <Temp_Var6		 ; Set as starting tile
	TAX		 ; Starting tile -> 'X'

	LDA <Temp_Var3
	BPL PRG002_B9E8	 ; If Big Bertha is not vertically flipped, jump to PRG002_B9E8

	; Otherwise, starting tile += 3
	INX
	INX
	INX

PRG002_B9E8:
	JSR Object_Draw24x16Sprite ; Draw upper half of Big Bertha

	LSR <Temp_Var5	; Shift the vertical visibility bits

	; Sprite_RAM offset += 12 (3 sprites ahead)
	TYA
	ADD #$0c
	TAY

	LDX <Temp_Var6	 ; X = starting tile

	LDA <Temp_Var3	
	BMI PRG002_B9FB	 ; If Big Bertha is vertically flipped, jump to PRG002_B9FB

	; Otherwise, starting tile += 3
	INX
	INX
	INX

PRG002_B9FB:
	; Sprite Y += 16 (lower half of Big Bertha)
	LDA #16
	ADD <Temp_Var1
	STA <Temp_Var1
	JSR Object_Draw24x16Sprite ; Draw lower half of Big Bertha

	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

CheepCheepCharge_ProxLimit:	.byte $06, -$06	; How close (in coarse units) Cheep Cheep must be to Player to lunge
CheepCheepCharge_XVelLimit:	.byte $20, $60	; Limit on X Velocity (relative, used in addition)
CheepCheepCharge_Accel:		.byte -$01, $01	; X Velocity acceleration for each direction
CheepCheepCharge_XCoarseLimit:	.byte $10, $70	; How far away Cheep Cheep can be before turning around


ObjNorm_CharginCheepCheep:
	JSR Fish_FixedYIfAppro	 ; Fixes 'Y' coordinate for Cheep Cheep that swims in fixed water
	JSR Object_ShakeAndDraw	 ; Draw Cheep Cheep

	LDA Objects_State,X
	CMP #OBJSTATE_KILLED
	BNE PRG002_BA20	 ; If Cheep Cheep's state is not Killed, jump to PRG002_BA20

	JMP PRG002_B867	 ; Jump to PRG002_B867 (use Big Bertha style respawn routine)

PRG002_BA20:

	; Cheep Cheep is not dying...

	; Toggle Cheep Cheep's frame
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$01
	STA Objects_Frame,X

	JSR Object_ApplyXVel	 ; Apply X velocity
	JSR Object_ApplyYVel	 ; Apply Y Velocity
	JSR Object_HandleBumpUnderneath	 ; Get killed if hit underneath by block

	LDA <Objects_Var4,X
	BNE PRG002_BA96	 ; If Var4 <> 0 (Cheep Cheep is lunging), jump to PRG002_BA96

	LDA <Objects_SpriteY,X
	CMP #156
	BGE PRG002_BA40	 ; If Cheep Cheep's SpriteY >= 156, jump to PRG002_BA40

	; Stop Cheep Cheep's vertical movement
	LDA #$00
	STA <Objects_YVel,X

PRG002_BA40:
	LDY <Objects_Var5,X	 ; Y = Var5

	LDA <Objects_XVel,X
	ADD CheepCheepCharge_XVelLimit,Y
	BMI PRG002_BA52	 ; If Cheep Cheep has hit velocity limit, jump to PRG002_BA52

	; Cheep Cheep accelerate!
	LDA <Objects_XVel,X
	ADD CheepCheepCharge_Accel,Y
	STA <Objects_XVel,X	

PRG002_BA52:

	LDA <Objects_XVel,X
	LSR A
	AND #SPR_HFLIP
	EOR #SPR_HFLIP
	STA Objects_FlipBits,X	 ; Store flip bit by X velocity

	JSR Object_CalcCoarseXDiff
	LDA <Temp_Var15	
	ADD #$40
	CMP #$80
	BLT PRG002_BA6B		; If Cheep Cheep isn't too far away, jump to PRG002_BA6B

	JMP Fish_Repawn	 	; Cheep Cheep went too far, restart

PRG002_BA6B:
	LDA <Temp_Var15
	ADD CheepCheepCharge_XCoarseLimit,Y
	BPL PRG002_BA78	 ; If Cheep Cheep hasn't gotten too close to Player, jump to PRG002_BA78

	; Reverse direction
	TYA	
	EOR #$01
	STA <Objects_Var5,X

PRG002_BA78:
	LDA <Temp_Var15	
	CMP CheepCheepCharge_ProxLimit,Y
	BNE PRG002_BAA6	 ; If not hit limit, jump to PRG002_BAA6 (RTS)

	JSR Object_CalcCoarseYDiff
	LDA <Temp_Var15	
	SUB #$05
	CMP #$18
	BGE PRG002_BAA6	 ; If Cheep Cheep is vertically too far from Player, jump to PRG002_BAA6 (RTS)

	; Big Bertha jumps!
	LDA #-$28
	STA <Objects_YVel,X

	; Does ... nothing to X Velocity?
	LDA <Objects_XVel,X
	ASL A			; Bit 7 shifted into carry
	ROR <Objects_XVel,X	; Carry shifted back into Bit 7

	INC <Objects_Var4,X	 ; Var4 = 1 (Cheep Cheep lunge)

PRG002_BA96:

	; Cheep Cheep's gravity
	INC <Objects_YVel,X
	INC <Objects_YVel,X

	LDA <Objects_SpriteY,X
	CMP #168
	BLT PRG002_BAA6	 ; If Cheep Cheep Y < 168, jump to PRG002_BAA6 (RTS)

	; Stop Cheep Cheep from falling too far; bounce back up
	LDA #-$08
	STA <Objects_YVel,X

	DEC <Objects_Var4,X	 ; Var4 = 0 (Cheep Cheep done lunging)

PRG002_BAA6:
	RTS		 ; Return


	; Performs collision tests against platform and enables Player
	; to stand on the platform, hit head off platform, etc.
	; Carry set if carrying collision occurred
PlayerPlatform_Collide:
	JSR Object_HitTest	 ; Test if Player is touching object
	BCC PRG002_BAEE	 	; If not, jump to PRG002_BAEE (RTS)

	; Test if Player is standing on top of platform

	LDA <Player_SpriteY
	ADD #24
	CMP <Objects_SpriteY,X
	BGE PRG002_BABE	 ; If Player's bottom is beneath object's top, jump to PRG002_BABE

	LDA <Player_YVel
	BMI PRG002_BABD	 ; If Player is moving upward, jump to PRG002_BABD

	JSR Player_StandOnPlatform	 ; Stand on platform
	SEC		 ; Set carry (collided)

PRG002_BABD:
	RTS		 ; Return

PRG002_BABE:

	; Check if Player is hitting off bottom of platform

	LDA #-$08	; A = -8 unless small or ducking

	LDY <Player_Suit
	BEQ PRG002_BAC9	 ; If Player is small, jump to PRG002_BAC9

	LDY Player_IsDucking
	BEQ PRG002_BACB	 ; If Player is NOT ducking, jump to PRG002_BACB

PRG002_BAC9:
	LDA #$08	 ; A = 8 if small or ducking

PRG002_BACB:
	ADD <Player_SpriteY
	CMP <Objects_SpriteY,X
	BLT PRG002_BADC	 ; If Player's Sprite top is near object's top, jump to PRG002_BADC

	LDA <Player_YVel
	BPL PRG002_BADA	 ; If Player is falling, jump to PRG002_BADA

	; Player hits head off platform
	LDA #$10
	STA <Player_YVel

PRG002_BADA:
	CLC		 ; Clear carry (no collision)
	RTS		 ; Return

PRG002_BADC:
	LDA <Objects_XVel,X
	BEQ PRG002_BAF4	 ; If platform is not moving horizontally, jump to PRG002_BAF4

	; Platform is moving horizontally...

	LDA <Player_X
	SUB <Objects_X,X	; Difference between Player and Platform X
	EOR <Objects_XVel,X	; Most importantly, check if sign differs from velocity

	CLC		 ; Clear carry (no collision)
	BMI PRG002_BAEF	 ; If signs differ, jump to PRG002_BAEF

	; Otherwise, set Player's X velocity to platform's X velocity
	LDA <Objects_XVel,X
	STA <Player_XVel

PRG002_BAEE:
	RTS		 ; Return


PRG002_BAEF:

	; Halt Player's movement
	LDA #$00
	STA <Player_XVel

	RTS		 ; Return

PRG002_BAF4:

	; Platform is not moving horizontally... 

	JSR Level_ObjCalcXDiffs

	INY		 ; Y = 1 or 2, depending on Player's relative position

	LDA <Pad_Holding
	AND #(PAD_LEFT | PAD_RIGHT)
	STA <Temp_Var1	 ; Temp_Var1 is non-zero if Player is pressing left/right

	CPY <Temp_Var1	 ; Check if Player is pressing a direction favorable to his position

	CLC		 ; Clear carry (no collision)

	BNE PRG002_BAEF	 ; If Player is pressing against it, jump to PRG002_BAEF (halt Player's movement)

	; Player pushing with platform
	LDA PlayerPushWithPlatform_XVel-1,Y
	STA <Player_XVel

	RTS		 ; Return

PlayerPushWithPlatform_XVel:	.byte $04, -$04

	; Attribute by frame
EndLevelCard_AttributeByFrame:
	.byte $01, $02, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01

EndLevelCard_AsTwinkleFrames:
	.byte $0F, $0F, $0F, $10, $0F, $10, $10, $10

	; Offset to the start of the cards
EndLevelCard_CardBackOffset:
	.byte (EndLevelCard_CardBackUpper - EndLevelCard_CardBackUpper)
	.byte (EndLevelCard_CardBackLower - EndLevelCard_CardBackUpper)
	.byte (EndLevelCard_CardEnd - EndLevelCard_CardBackUpper)	; Just used as an end count

	; The background for the card that appears in the air for a triple card match
EndLevelCard_CardBackUpper:
	; Upper card
	vaddr $22D7
	.byte $02, $FE, $FE
	vaddr $22F7
	.byte $02, $FE, $FE
	.byte $00

	; The background for the card that appears with less than three cards or mismatched cards
EndLevelCard_CardBackLower:
	; Lower card
	vaddr $28F7
	.byte $02, $FE, $FE
	vaddr $2917
	.byte $02, $FE, $FE
	.byte $00
EndLevelCard_CardEnd

ObjNorm_EndLevelCard:
	LDA <Objects_DetStat,X	 ; Mis-used as tracking for the current internal state
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word EndLevelCard_Untouched		; 0: Initial state before Player touches card

	; Triple card match
	.word EndLevelCard_InitForFanfare	; 1: Halts Player, sets palette, draws card
	.word EndLevelCard_Appear		; 2: The giant shape in the sky appears
	.word EndLevelCard_3CMMsg2XUP		; 3: Draws the "YOU GOT A CARD" message and inits for extra lives (triple card match)

	; Not Triple card match
	.word EndLevelCard_WaitFlyAway		; 4: Starts Player running off, spins card away until off-screen
	.word EndLevelCard_MsgAndCard		; 5: Draws the messages "COURSE CLEAR!"/"YOU GOT A CARD" and the cards (two places)

	; Extra lives
	.word EndLevelCard_DoXUPs		; 6 - Give lives until done
	.word EndLevelCard_Exit			; 7: Exit


EndLevelCard_Untouched:
	LDA <Counter_1		 
	AND #$07
	BNE PRG002_BB65	 ; 1:8 ticks continue, otherwise jump to PRG002_BB65

	; Run through frames 0-2
	INC Objects_Frame,X
	LDA Objects_Frame,X
	CMP #$03
	BLT PRG002_BB65

	; Restart animation loop
	LDA #$00
	STA Objects_Frame,X

PRG002_BB65:
	JSR Object_HitTestRespond	 ; Do collision test with Player and respond
	JSR Object_DeleteOffScreen	 ; Delete object if it falls off-screen
	JMP EndLevelCard_Draw	 	; Jump off to draw End Level card


EndLevelCard_InitForFanfare:

	; Halt Player
	LDA #$ff	 
	STA Player_HaltTick

	LDA Objects_Timer,X
	BEQ PRG002_BBB0	 ; If timer expired, jump to PRG002_BBB0

	LSR A
	TAY		 ; Y = timer / 2
	BNE PRG002_BBA2	 ; If timer > 1, jump to PRG002_BBA2

	INC <Objects_DetStat,X	 ; Go to internal state 2

	; Setup palette
	LDY #$02	 ; Y = 2
PRG002_BB80:
	LDA EndLevelCard_PalData,Y
	STA Pal_Data+5,Y
	STA Palette_Buffer+5,Y

	LDA EndLevelCard_PalData+6,Y
	STA Pal_Data+9,Y	
	STA Palette_Buffer+9,Y	

	LDA #$0f
	STA Pal_Data+$D,Y
	STA Palette_Buffer+$D,Y

	DEY		 ; Y--
	BNE PRG002_BB80	; While Y > 0, loop!

	; Var1 = $25
	LDA #$25
	STA Objects_Var1,X

PRG002_BBA2:
	; Set current frame for "twinkle" as card disappears during the beginning of triple card match
	LDA EndLevelCard_AsTwinkleFrames,Y
	STA Objects_Frame,X

	; Load graphics for the "twinkle" of the disappearing end card
	LDA #$06
	STA PatTable_BankSel+5

	JMP EndLevelCard_Draw	 ; Draw the card and don't come back

PRG002_BBB0:
	LDA <Objects_X,X
	AND #$0f
	CMP #$07
	BEQ PRG002_BBBB	; If card has aligned to nearest 8 pixel, jump to PRG002_BBBB

	JSR Object_ApplyXVel	 ; Apply X velocity

PRG002_BBBB:
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	LDA <Objects_YHi,X
	BEQ PRG002_BBC8	 ; If card is up high, jump to PRG002_BBC8

	; Card is not up high yet...

	LDA <Objects_Y,X
	CMP #16
	BGE PRG002_BBE0	 ; If the object Y >= 16 (away from top of the screen), jump to PRG002_BBE0

PRG002_BBC8:
	; When card is high enough, begin scrolling upward
	LDA <Vert_Scroll
	SUB #$03
	STA <Vert_Scroll

	STA Level_VertScroll

	CMP #17
	BGE PRG002_BBE0	 ; If vertical scroll >= 17, jump to PRG002_BBE0

	; Timer = $10
	LDA #$10
	STA Objects_Timer,X

	; Load the font
	LDA #$5e
	STA PatTable_BankSel

PRG002_BBE0:
	LDA <Counter_1
	AND #$03
	BNE EndLevelCard_AnimateSpinAway ; Only proceed every 1:4 ticks, otherwise jump to EndLevelCard_AnimateSpinAway

	LDA Objects_Var1,X
	CMP #$12
	BLT EndLevelCard_AnimateSpinAway ; If Var1 < $12, jump to EndLevelCard_AnimateSpinAway

	; Var1 > $12...

	CMP #$24
	BLT PRG002_BBF7	 ; If Var1 < $24, jump to PRG002_BBF7

	LDY #$24
	STY <Graphics_Queue	; Graphics_Queue = $24
	BGE PRG002_BC12	 ; If Var1 >= $24, jump to PRG002_BC12

PRG002_BBF7:

	; Var1 < $24...

	CMP #$15
	BGE PRG002_BC10	 ; If Var1 >= $15, jump to PRG002_BC10 (push out another fifth of the giant mushroom/flower/star)

	; Var1 < $15...

	LDA <Vert_Scroll
	CMP #192
	BGE EndLevelCard_AnimateSpinAway	 ; If Vert_Scroll >= 192, jump to EndLevelCard_AnimateSpinAway

	LDY #$02	 ; Y = 2
	LDA #$0f	 ; A = $F
PRG002_BC05:
	STA Pal_Data+$D,Y
	STA Palette_Buffer+$D,Y
	DEY		 ; Y--
	BPL PRG002_BC05	 ; While Y >= 0, loop!

	LDA #$14	 ; A = $14 (blacks out a bit of the palette)

PRG002_BC10:
	STA <Graphics_Queue	 ; Set five times to execute each of Video_Upd_Table Video_3CM*

PRG002_BC12:
	SUB #$03
	STA Objects_Var1,X	 ; Var1 -= 3 (separation between drawing segments, see Video_Upd_Table Video_3CM*)

EndLevelCard_AnimateSpinAway:
	; Spinning away card graphics
	LDA #$07
	STA PatTable_BankSel+5

	LDA <Counter_1
	AND #$03
	BNE PRG002_BC32	 ; Only proceed 1:4 ticks, otherwise jump to PRG002_BC32

	; Loop frame 3,6,9,12 / 4,7,10,13 / 5,8,11,14 (Mushroom, Flower, Star)
	LDA Objects_Frame,X
	SUB #$03
	CMP #$03
	BGE PRG002_BC2F	 ; If not underflowed, jump to PRG002_BC2F
	ADC #12		; Reset animation by adding 12
PRG002_BC2F:
	STA Objects_Frame,X	 ; Set frame

PRG002_BC32:
	JMP EndLevelCard_Draw	 ; Draw the card and don't come back!


EndLevelCard_Appear:

	; Var1 starts at $25 here

	LDA <Counter_1		  
	AND #$03
	BNE PRG002_BC51	 ; Only do anything 1:4 ticks, otherwise jump to PRG002_BC51

	; Set the proper graphics queue event
	LDA Objects_Var1,X
	STA <Graphics_Queue

	INC Objects_Var1,X	 ; Var1++

	CMP #$2a
	BNE PRG002_BC51	 ; If Var1 <> $2A, jump to PRG002_BC51 (RTS)

	; Var1 = $2A; we're done!

	INC <Objects_DetStat,X	 ; Go to internal state 3

	; Set Timer to $80
	LDA #$80
	STA Objects_Timer,X

	JSR EndLevelCard_SetFrameToCard	 ; Set frame to the newest card's frame

PRG002_BC51:
	RTS		 ; Return

EndLevelCard_3CMMsg2XUP:

	; Keep Player halted
	LDA #$ff
	STA Player_HaltTick

	LDA Objects_Timer,X
	CMP #$50
	BLT PRG002_BC6C	 ; If timer < $50, jump to PRG002_BC6C
	BNE PRG002_BC6F	 ; If timer <> $50, jump to PRG002_BC6F

	; When timer = $50...

	LDA #$2c	 ; Y = $2C ("YOU GOT A CARD" [and card space])
	STA <Graphics_Queue


EndLevelCard_DrawCardT2:
	; Set timer 2 to $30
	LDA #$30	 
	STA Objects_Timer2,X
	JMP EndLevelCard_DrawCard	 ; Push the proper card into the Graphics Buffer and don't come back


PRG002_BC6C:
	JSR EndLevelCard_DrawFlashing	 ; Draw the flashing card after it was retrieved

PRG002_BC6F:
	JSR DoTimeBonus	 		; Turn time into score
	ORA Objects_Timer,X
	BNE PRG002_BC51	 ; If still converting time to score or timer not expired, jump to PRG002_BC51 (RTS)

	JMP EndLevelCard_SetupXUP	 ; Setup for getting 'X' number of lives!

EndLevelCard_WaitFlyAway:
	JSR Object_ApplyYVel	 ; Apply Y Velocity

	LDA Objects_SprVVis,X
	BEQ PRG002_BC8E	 ; If card is not vertically off-screen, jump to PRG002_BC8E

	; Card is vertically off-screen...

	INC <Objects_DetStat,X	 ; Go to next internal state

	; Set card's timer to $60
	LDA #$60
	STA Objects_Timer,X

	; Select bank to support "YOU GOT A CARD" font
	LDA #$5e
	STA PatTable_BankSel+1

PRG002_BC8E:
	JSR EndLevelCard_AnimateSpinAway 	; Animate the card as it spins away

EndLevelCard_PlayerRunOff:
	JSR EndLevelCard_ClearPlayerIfOff	; Clear Player's sprites as he walks off-screen

	; Always set Player facing correct direction
	LDA #$41
	STA <Player_FlipBits

	; Does the Player's "run off to the right" sequence
	LDY #$ff
	STY Player_EndLevel

	; Technically the Player runs around and loops back left
	LDA <Player_SpriteX
	LSR A		; divide by 2
	CMP #$10	; so really checking if it's around 32 or 33
	BNE PRG002_BCA7	 ; If Player's not there yet, jump to PRG002_BCA7

	STY Player_HaltTick	 ; If Player has run far enough, set halt

PRG002_BCA7:
	RTS		 ; Return

	; Number of lives you get by triple matches (Mushroom, Flower, Star, Non-Match 3  respectively)
EndLevelCard_xUpByMatch:	.byte $02, $03, $05, $01

EndLevelCard_MsgAndCard:
	JSR EndLevelCard_PlayerRunOff	 ; Keep checking for Player having run off to the right

	LDY #$2D	 ; Y = $2D ("COURSE CLEAR")

	LDA Objects_Timer,X
	CMP #$1e
	BEQ PRG002_BCC4	 ; If timer = $1E, jump to PRG002_BCC4

	CMP #$01
	BNE PRG002_BCC6	 ; If timer = 1, jump to PRG002_BCC6

	JSR EndLevelCard_DrawCardT2	 ; Draws the card (displayed against goal) and sets timer 2 = $30
	JSR EndLevelCard_SetFrameToCard	 ; Set frame to the newest card's frame

	LDY #$2E	 ; Y = $2E ("YOU GOT A CARD" [and card space])

PRG002_BCC4:
	STY <Graphics_Queue	 ; Set Graphics_Queue as appropriate

PRG002_BCC6:
	JSR DoTimeBonus	 	; Turn time into score

	ORA Objects_Timer,X
	BNE PRG002_BD02	 ; If clock not run out or timer not expired, jump to PRG002_BD02

	; All clock converted to score and timer expired...

	LDA <Player_SpriteX
	LSR A		; divide by 2
	CMP #$10	; so really checking if it's around 32 or 33
	BNE PRG002_BD02	 ; If Player's not there yet, jump to PRG002_BD02

	JSR Player_GetInventoryOffset
	LDA Inventory_Cards+2,Y
	BEQ PRG002_BCFF	 ; If Player didn't get their third card, jump to PRG002_BCFF

	; Player got their third card (not a triple match, that was checked previously)

	; Var5 = 4
	LDA #$04
	STA <Objects_Var5,X

	; Sets up the End Level Card object as the "xUP" display that occurs with three cards
EndLevelCard_SetupXUP:
	JSR Player_GetInventoryOffset
	TYA		 
	STA Objects_Var2,X	 ; Var2 = inventory offset

	LDY <Objects_Var5,X	 ; Y = Var5

	; Store the number of lives we're going to get
	LDA EndLevelCard_xUpByMatch-1,Y
	STA Objects_Var1,X

	; Go to internal state 6
	LDA #$06
	STA <Objects_DetStat,X

	; Set Objects_Y = $FF (object will become the xUP display)
	LDA #$ff
	STA <Objects_Y,X

	; Y velocity = -$40
	LDA #-$40
	STA <Objects_YVel,X

	JMP Object_ResetXToSlotIndex	 ; Set 'X' back to slot index and don't come back!

PRG002_BCFF:
	JSR PRG002_BD35	 ; Prepare for exit

PRG002_BD02:
	LDA Objects_Timer,X
	BNE PRG002_BD0A		; If timer hasn't expired, jump to PRG002_BD0A

	JSR EndLevelCard_DrawFlashing	; Draw the flashing card after it was retrieved

PRG002_BD0A:
	RTS		 ; Return


EndLevelCard_DoXUPs:
	; Keep Player halted!
	LDA #$ff
	STA Player_HaltTick
	JSR EndLevelCard_ClearPlayerIfOff	; Clear Player's sprites as he walks off-screen
	JSR EndLevelCard_Give1UpsAndCycle	; Give 1-ups and cycle cards

	LDA <Objects_Y,X
	CMP #$80
	BLT PRG002_BD24	 ; If Object Y < $80, jump to PRG002_BD24

	; Y >= $80...

	; Timer = $40
	LDA #$40
	STA Objects_Timer,X

	JMP Object_ApplyYVel	 ; Apply Y velocity and don't come back!

PRG002_BD24:
	LDA Objects_Timer,X
	BEQ PRG002_BD30	 ; If timer expired, jump to PRG002_BD30

	; xUP "bounces" after it stops
	LDA <Objects_Y,X
	EOR #$01
	STA <Objects_Y,X

	RTS		 ; Return

PRG002_BD30:
	LDA Objects_Var1,X
	BNE PRG002_BD3E	 ; If Var1 <> 0 (still have lives to give), jump to PRG002_BD3E

PRG002_BD35:
	; Go to internal state 7
	LDA #$07
	STA <Objects_DetStat,X

	; Set timer to $80
	LDA #$80
	STA Objects_Timer,X

PRG002_BD3E:
	RTS		 ; Return

XUp_Patterns:	.byte $00, $EB, $ED		; xUP (the first byte is unused since it must be supplied by how many lives)
XUp_XOff:	.byte $74, $7C, $84		; X offset
XUp_NumPats:	.byte $B3, $B5, $B7, $B1	; Pattern for 2, 3, 5, 1

EndLevelCard_Exit:
	JSR EndLevelCard_ClearPlayerIfOff	; Clear Player's sprites as he walks off-screen
	JSR Player_GetInventoryOffset

	LDA Objects_Timer,X
	BNE PRG002_BD6B	 ; If timer not expired, jump to PRG002_BD6B

	; Timer expired, and we're outta here

	STA Map_ReturnStatus	 ; Return Status = 0 (clear level)
	INC Level_ExitToMap	 ; Flag to exit to map

	LDA Inventory_Cards+2,Y
	BEQ PRG002_BD6B		; If we didn't have three cards, jump to PRG002_BD6B

	; Otherwise, clear them out!
	LDA #$00
	STA Inventory_Cards,Y
	STA Inventory_Cards+1,Y
	STA Inventory_Cards+2,Y

	RTS		 ; Return

PRG002_BD6B:
	LDA <Objects_Var5,X
	BNE EndLevelCard_Give1UpsAndCycle	 ; If Var5 > 0, jump to EndLevelCard_Give1UpsAndCycle (Give 1-ups and cycle cards)

	JMP EndLevelCard_DrawFlashing	 ; Draw the flashing card after it was retrieved

EndLevelCard_Give1UpsAndCycle:
	LDA Objects_Var1,X
	BEQ PRG002_BD91	 ; If Var1 = 0 (no more lives to give), jump to PRG002_BD91

	LDA SndCur_Level1
	AND #$40
	BNE PRG002_BD91	 ; If 1-up sound is currently playing, jump to PRG002_BD91

	; Otherwise, queue 1-up sound
	LDA Sound_QLevel1
	ORA #SND_LEVEL1UP
	STA Sound_QLevel1

	LDX Player_Current	 ; X = current player

	INC Player_Lives,X	 ; Extra life to this player!

	LDX <SlotIndexBackup	 ; X = object slot index
	DEC Objects_Var1,X	 ; Var1--

PRG002_BD91:
	; The big 1, 2, 3, 5
	LDA #$55
	STA PatTable_BankSel+4

	; provides the "UP" (from TIME UP)
	LDA #$32
	STA PatTable_BankSel+5

	; Temp_Var1 = object Y
	LDA <Objects_Y,X
	STA <Temp_Var1

	LDY Object_SprRAM,X	 ; Y = Sprite_RAM offset
	LDX #$02	 ; X = 2
PRG002_BDA4:
	; Set Sprite Y
	LDA <Temp_Var1
	STA Sprite_RAM+$00,Y

	; Set pattern to three sprites
	LDA XUp_Patterns,X
	STA Sprite_RAM+$01,Y

	; Set attributes to all sprites
	LDA #$01
	STA Sprite_RAM+$02,Y

	; Set Sprite X
	LDA XUp_XOff,X
	BIT <Vert_Scroll
	BPL PRG002_BDBE	 ; If vertical scroll is high up (Triple Card Match), jump to PRG002_BDBE
	ADD #$08	 ; Otherwise, +8
PRG002_BDBE:
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	INY
	INY
	INY
	INY		 ; Y += 4 (next sprite)

	DEX		 ; X--
	BPL PRG002_BDA4	 ; While X >= 0, loop!

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA <Objects_Var5,X
	TAX		 ; X = Var5

	; Set pattern of number of lives
	LDA XUp_NumPats-1,X
	STA Sprite_RAM-3,Y

	LDX <SlotIndexBackup	 ; X = object slot index

	LDY Objects_Var2,X	 ; Y = Var2

	LDA <Counter_1
	AND #$07
	BEQ PRG002_BDF8	 ; Only proceed 1:8 ticks, otherwise jump to PRG002_BDF8

	; This is the "cycling" effect of making all the cards appear and vanish in rotation
	LDA Inventory_Cards,Y
	PHA
	LDA #$00
	STA Inventory_Cards,Y
	JSR StatusBar_DrawCardPiece
	LDX <SlotIndexBackup		 ; X = object slot index
	LDY Objects_Var2,X	 ; Y = Var2 (which card is being vanished)
	PLA
	STA Inventory_Cards,Y

	BNE PRG002_BE11	 ; Jump (technically always) to PRG002_BE11

PRG002_BDF8:
	JSR StatusBar_DrawCardPiece

	LDX <SlotIndexBackup		 ; X = object slot index
	LDY Objects_Var2,X

	INY		 ; Y++
	CPY #$03
	BNE PRG002_BE07	 ; If Y <> 3, jump to PRG002_BE07

	LDY #$00	 ; Otherwise, Y = 0

PRG002_BE07:
	CPY #(Inventory_Cards2 - Inventory_Cards + $03)
	BNE PRG002_BE0D	 ; If Y <> Luigi's last card index, jump to PRG002_BE0D

	LDY #(Inventory_Cards2 - Inventory_Cards)
PRG002_BE0D:
	TYA
	STA Objects_Var2,X	 ; Update Var2

PRG002_BE11:
	RTS		 ; Return


EndLevelCard_DrawCard:
	LDY #$00	; Y = 0 (draw card back in the air, i.e. the triple card match)
	 
	LDA <Vert_Scroll
	BPL PRG002_BE19	 ; Dodgy check to see if we're in the air; if we are, jump to PRG002_BE19

	INY		; Y = 1 (draw card back lower on the ground)

PRG002_BE19:
	JSR EndLevelCard_DrawCardBack	 ; Draw the card back (not really seen)

	JSR EndLevelCard_SetFrameToCard	 ; Set frame to the newest card's frame
	ASL A
	ASL A
	TAY		 ; Y = current frame * 4 (in the air, i.e. the triple card match)

	LDA <Vert_Scroll
	BPL PRG002_BE27	 ; Dodgy check to see if we're in the air; if we are, jump to PRG002_BE27

	INY		 ; Y = current frame * 4 + 1 (lower on the ground)

PRG002_BE27:
	LDX Graphics_BufCnt	 ; X = current graphics buffer count

	; This replaces the contents of the graphics buffer with the proper card face

	; Temp_Var = 2
	LDA #$02
	STA <Temp_Var1
PRG002_BE2E:

	LDA EndLevelCard_CardFace-4,Y
	STA Graphics_Buffer-7,X

	LDA EndLevelCard_CardFace+8,Y
	STA Graphics_Buffer-2,X

	INY
	INY	; Y += 2 (next card sprite set)

	INX	; X++ 

	DEC <Temp_Var1	; Temp_Var1--
	BNE PRG002_BE2E	; While Temp_Var1 > 0, loop!

	JMP Object_ResetXToSlotIndex	 ; Set 'X' back to slot index and don't come back!


	; Returns 'Y' as offset to Mario's or Luigi's inventory memory
Player_GetInventoryOffset:
	LDY Player_Current
	BEQ PRG002_BE4B	
	LDY #(Inventory_Items2 - Inventory_Items)
PRG002_BE4B:
	RTS		 ; Return

	; Draws the card backs, though the backs are almost immediately
	; overwritten with the proper card face...
EndLevelCard_DrawCardBack:
	; Load the "end" index -> Temp_Var1
	LDA EndLevelCard_CardBackOffset+1,Y	  
	STA <Temp_Var1

	; Load the "start" index -> 'X'
	LDX EndLevelCard_CardBackOffset,Y

	LDY Graphics_BufCnt	 ; Y = current graphics buffer count

	; Copy directly into graphics buffer
PRG002_BE57:
	LDA EndLevelCard_CardBackUpper,X

	STA Graphics_Buffer,Y

	INY		 ; Y++ (one more byte in buffer)
	INX		 ; X++ (next index)

	CPX <Temp_Var1
	BLT PRG002_BE57	 ; If 'X' < the ending index, jump to PRG002_BE57

	DEY		 ; Y-- (one too many for the buffer)

	STY Graphics_BufCnt	 ; Update graphics buffer counter

	JMP Object_ResetXToSlotIndex	 ; Set 'X' back to slot index and don't come back!

EndLevelCard_CardFace:
	;     ATTR PAT  ATTR PAT
	.byte $60, $E0, $61, $E1	; Mushroom top
	.byte $64, $E4, $66, $E6	; Mushroom bottom

	.byte $2C, $AC, $2D, $AD	; Flower top
	.byte $62, $E2, $63, $E3	; Flower bottom

	.byte $67, $E7, $68, $E8	; Star top
	.byte $2E, $AE, $2F, $AF	; Star bottom


	; Draw the flashing card after it was retrieved
EndLevelCard_DrawFlashing:
	JSR EndLevelCard_SetFrameToCard	 ; Set frame to the newest card's frame

	; Timer 2 holds before flashing, otherwise flash regularly
	LDA <Counter_1
	AND #%00010000
	ORA Objects_Timer2,X
	BNE PRG002_BEA3	 ; Every 1:16 ticks or Timer 2 not expired, jump to PRG002_BEA3

	; Clear card
	LDA #$00
	STA Inventory_Cards,Y

	; Backup 'Y' (the card index)
	TYA
	PHA

	; Clear the card
	JSR StatusBar_DrawCardPiece

	; Restore 'Y' (the card index)
	PLA
	TAY

	LDX <SlotIndexBackup		 ; X = object slot index

	; Reset the card to what it should be
	LDA Objects_Frame,X
	STA Inventory_Cards,Y

	RTS		 ; Return

PRG002_BEA3:
	JSR StatusBar_DrawCardPiece	 ; Redraw the card

Object_ResetXToSlotIndex:
	LDX <SlotIndexBackup		 ; X = object slot index
	RTS		 ; Return

	; Gets the last card since that's the card you just picked up
EndLevelCard_SetFrameToCard:
	JSR Player_GetInventoryOffset	  
	INY
	INY	; Start at third card slot

PRG002_BEAE:
	LDA Inventory_Cards,Y
	BNE PRG002_BEB6	 ; If this card slot is occupied, jump to PRG002_BEB6

	DEY		 ; Y-- (previous card slot)
	BPL PRG002_BEAE	 ; While Y >= 0, loop

PRG002_BEB6:
	STA Objects_Frame,X	 ; Set object frame to card
 
	RTS		 ; Return

	; Clears the Player's sprites if they've gone off-screen
EndLevelCard_ClearPlayerIfOff:
	LDY Player_SprOff	 ; Y = Player's sprite offset

	; Temp_Var1 = 5 (all of the Player's potential sprites)
	LDA #$05
	STA <Temp_Var1
PRG002_BEC1:
	LDA Sprite_RAM+$03,Y
	CMP #64
	BGE PRG002_BECD	 ; If Player's Sprite X > 64, jump to PRG002_BECD

	; Otherwise, set Player's Sprite Y to really low (invisible)
	LDA #248
	STA Sprite_RAM+$00,Y

PRG002_BECD:
	INY
	INY
	INY
	INY	; Y += 4 (next sprite)

	DEC <Temp_Var1	 ; Temp_Var1--
	BPL PRG002_BEC1	 ; While Temp_Var1 >= 0, loop!

	RTS		 ; Return

	; Var1 values for Mushroom, Flower, Star
EndLevelCard_Var1:	.byte $24, $25, $26

	; Frame value for Mushroom, Flower, Star
EndLevelCard_Frame:	.byte $03, $04, $05

ObjHit_EndLevelCard:

	; Clear relevant gameplay variables
	LDA #$00
	STA Player_StarInv
	STA Kill_Tally
	STA Level_PSwitchCnt
	STA Level_AScrlConfig
	STA <Player_YVel
	STA PlayerProj_ID	
	STA PlayerProj_ID+1

	; Delete all "Special Objects" in one sweep
	LDY #$09
PRG002_BEF4:
	STA SpecialObj_ID,Y
	DEY
	BPL PRG002_BEF4

	LDX #$04	 ; X = 4
PRG002_BEFC:
	LDA Objects_State,X
	BEQ PRG002_BF4B	 ; If object slot is dead/empty, jump to PRG002_BF4B

	LDA Level_ObjectID,X
	CMP #OBJ_WARPHIDE
	BEQ PRG002_BF46	 ; If this is the World 1-3 Warp Whistle trigger object, jump to  PRG002_BF46

	; Determine if object has gone off-screen yet or not
	LDY #$00
	JSR Object_DetermineHorzVisY
	LDY #$00
	JSR Object_DetermineVertVisY
	JSR Object_AnySprOffscreen
	BNE PRG002_BF46	 ; If object is off-screen in any way, jump to PRG002_BF46

	; Object is on-screen -- turn into coin

	; Play coin sound
	LDA Sound_QLevel1
	ORA #SND_LEVELCOIN
	STA Sound_QLevel1

	; Special object: Emitted coin
	LDA #SOBJ_POPPEDOUTCOIN
	STA SpecialObj_ID,X

	; Set coin where object was
	LDA <Objects_X,X
	STA SpecialObj_XLo,X
	LDA <Objects_Y,X
	STA SpecialObj_YLo,X
	LDA <Objects_YHi,X
	STA SpecialObj_YHi,X

	; Pop out coin Y Velocity
	LDA #-$28
	STA SpecialObj_YVel,X

	; Don't move horizontally
	LDA #$00
	STA SpecialObj_XVel,X

	; Set coin timer to $1F
	LDA #$1f
	STA Objects_Timer,X

	LDA #OBJSTATE_POOFDEATH	; A = 8 ("Poof" death the object)
	BNE PRG002_BF48	 ; Jump (technically always) to PRG002_BF48

PRG002_BF46:
	LDA #$00	 ; A = 0 (just delete object)

PRG002_BF48:
	STA Objects_State,X	 ; Set object state

PRG002_BF4B:
	DEX		 ; X--
	BPL PRG002_BEFC	 ; While X >= 0, loop

	LDX <SlotIndexBackup		 ; X = object slot index

	; Stop the level clock and animations
	LDA #$81
	STA Level_TimerEn
	STA EndCard_Flag	 ; Flag end level card as grabbed

	; Card actually has a slight leftward velocity?
	LDA #-$01
	STA <Objects_XVel,X

	; Card moves upward
	LDA #-$28
	STA <Objects_YVel,X

	LDY Objects_Frame,X	 ; Y = current frame 

	; Set Var1
	LDA EndLevelCard_Var1,Y
	STA Objects_Var1,X

	; Set frame
	LDA EndLevelCard_Frame,Y
	STA Objects_Frame,X

	INY		 ; Y++ (1-3)
	TYA		 ; -> 'A'
	JSR Player_GetCard	; Give this card to the Player

	LDX <SlotIndexBackup		 ; X = object slot index

	; Jump to internal state 4 (Regular get card, no fanfare)
	LDA #$04
	STA <Objects_DetStat,X

	; Play "Got the Card" song
	LDA #MUS1_COURSECLEAR
	STA Sound_QMusic1

	JSR Player_GetInventoryOffset

	LDA Inventory_Cards+2,Y
	BEQ PRG002_BF9F	 ; If Player hasn't gotten their third card, jump to PRG002_BF9F (RTS)

	CMP Inventory_Cards,Y
	BNE PRG002_BF9F	 ; If the first card doesn't match, jump to PRG002_BF9F (RTS)

	CMP Inventory_Cards+1,Y
	BNE PRG002_BF9F	 ; If the second card doesn't match, jump to PRG002_BF9F (RTS)

	; All three cards match!

	STA <Objects_Var5,X	; Set Var5 to the card triple

	; Do internal state 1 instead (big fanfare)
	LDA #$01
	STA <Objects_DetStat,X

	; Enable level animations
	LSR Level_TimerEn

	; Play fanfare song
	LDA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

PRG002_BF9F:
	RTS		 ; Return

EndLevelCard_Draw:
	LDA Objects_Frame,X

	JSR Object_ShakeAndCalcSprite

	; Select own range of sprite area
	LDA #$05
	ADD Counter_7to0
	TAY		 ; Y = 5 to 12

	LDA SprRamOffsets,Y
	ADD #$08
	TAY		 ; -> 'Y'

	JSR Object_Draw16x16Sprite	 ; Draw the End Level card

	LDX <SlotIndexBackup	 ; X = object slot index

	LDA Objects_Frame,X
	CMP #$0f
	BGE PRG002_BFD3	 ; If frame >= $0F, jump to PRG002_BFD3 (RTS)

	TAX		 ; Frame -> 'X'

	LDA Sprite_RAM+$02,Y
	AND #~(SPR_HFLIP | $03)	 	; Keep all attributes except horizontal flip and palette select
	ORA EndLevelCard_AttributeByFrame,X	 ; Set attributes by frame
	STA Sprite_RAM+$02,Y	 ; Set attributes
	EOR #SPR_HFLIP	 ; Mirror second half
	STA Sprite_RAM+$06,Y	 ; Set attributes

	LDX <SlotIndexBackup		 ; X = object slot index

PRG002_BFD3:
	RTS		 ; Return

	; ?? Someone wanna claim this?
PRG002_BFD4:
	.byte $FC, $A9, $00, $22, $0B, $01, $A9, $22, $14, $01, $A9, $22, $29, $04, $A9, $FC
	.byte $FC, $A9, $22, $33, $04, $A9, $FC, $FC, $A9, $22, $4A, $04, $A9, $A9, $FC, $A9
	.byte $22, $52, $04, $A9, $FC, $A9, $A9, $22, $6C, $48, $A9, $00

