; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2011-11-18 21:50:33.000000000 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

Sound_Engine_Begin:
	LDA #$ff	 ; 
	STA FRAMECTR_CTL ; Resets the frame counter clock (sync sound hardware), disables IRQ generation

	LDA Sound_QPause
	BNE SndPause	 ; If a "pause/resume" was requested, jump to SndPause
	LDA SndCur_Pause
	BNE PRG028_A04F	 	; If playing the pause sound, jump to PRG028_A04F
	LDA Sound_IsPaused	
	BNE PRG028_A08F	 	; If sound is currently paused, jump to PRG028_A08F (allows processing of pause sound)

	JMP Sound_Process	; Otherwise, jump to normal sound processing routine!

SndPause:	; $A017
	STA SndCur_Pause	 ; Store it into the "hold" variable
	STA Sound_IsPaused	 ; Mark sound as paused
	CMP #$02	 ; Is the request actually to RESUME sound?
	BNE PRG028_A033	 ; If not, go to PRG028_A033

	; Want to RESUME sound, not pause!
	LDA #$00
	STA Sound_IsPaused	 ; Clear IsPaused
	STA SndCur_Pause	 ; Clear the pause sound hold
	STA PAPU_EN	 ; Disable all channels
	LDA #$0f	 ;  
	STA PAPU_EN	 ; Enable all channels
	BNE Sound_Process	 ; (Technically always) jump to Sound_Process

PRG028_A033:
	; Want to PAUSE sound
	LDA #$00
	STA PAPU_EN	; Disable all sound channels

	; Clear other sound counters
	STA SndCur_Player	; Kill player sound
	STA SndCur_Level1	; Kill level 1 sound
	STA SndCur_Level2	; Kill level 2 sound
	LDA #$0f	
	STA PAPU_EN	; Enable all sound channels
	LDA #$2a	
	STA SFX_Counter1 ; SFX_Counter1 = $2A

PRG028_A04B:
	LDA #$68	 ; Play note 104 (high bing)
	BNE PRG028_A060	 ; (Technically always) jump to PRG028_A060

PRG028_A04F:
	LDA SFX_Counter1
	CMP #$24
	BEQ PRG028_A05E	 ; If SFX_Counter1 is at $24, jump to PRG028_A05E (play a low bing)
	CMP #$1e
	BEQ PRG028_A04B	 ; If SFX_Counter1 is at $1E, jump to PRG028_A04B (play another high bing)
	CMP #$18
	BNE PRG028_A067	 ; If SFX_Counter1 is at $18, jump to PRG028_A067 (otherwise, just decrement)

PRG028_A05E:
	LDA #96		; Play note 96 (low bing)

PRG028_A060:
	LDX #$84	 ; Goes to PAPU_CTL1
	LDY #$7f	 ; Goes to PAPU_RAMP1
	JSR Sound_Sq1_NoteOn

PRG028_A067:
	DEC SFX_Counter1 ; SFX_Counter1--
	BNE PRG028_A08F	 ; If not zero yet, go to PRG028_A08F

	; Pause sound over!
	LDA #$00	 ; 
	STA PAPU_EN	 ; Disable all sound channels
	LDA #$00	 ; 
	STA SndCur_Pause	 ; Stop the pause sound hold
	BEQ PRG028_A08F	 ; (technically always) go to PRG028_A08F

Sound_Process:
	; Queue + Play all sounds in...
	JSR Sound_PlayLevel2	 ; Level 2
	JSR Sound_PlayPlayer	 ; Player
	JSR Sound_PlayLevel1	 ; Level 1
	JSR Sound_PlayMapSounds	 ; Map sounds
	JSR Sound_PlayMusic	 ; Music

	; Clear any music queues
	LDA #$00	 
	STA Sound_QMusic2
	STA Sound_QMusic1

PRG028_A08F:

	; Clear all sound queues
	LDA #$00
	STA Sound_QPlayer
	STA Sound_QLevel1
	STA Sound_QLevel2
	STA Sound_QMap
	STA Sound_QPause
	RTS		 ; Return

Sound_PlayMapSounds:
	LDA Sound_QMap
	BNE MapSound_Queued	 ; If a map sound has been queued, jump to MapSound_Queued
	LDA SndCur_Map
	BNE MapSound_Playing	 ; If a map sound is already playing, jump to MapSound_Playing

	; Nothing to do!
	RTS		 ; Return

MapSound_Queued:
	CMP #SND_MAPENTERLEVEL
	BNE PRG028_A0BD	 ; If not playing Map Entering Level sound, go to PRG028_A0BD

	; Entering level sound only:
	LDX #$00	 ; 
	STX SndCur_Music2	 ; Halt any playing BGM
	STX PAPU_EN	 ; Disable all sound channels
	LDX #$0f	 ; 
	STX PAPU_EN	 ; Enable all sound channels

PRG028_A0BD:
	STA SndCur_Map ; Lock in this sound as playing!

	; Sound_Unused7FF = 0 (but never used again...)
	LDY #$00
	STY Sound_Unused7FF

	; The map sounds are issued by bit ($01, $02, $04, $08, etc.)
	; this loop converts it to a Y value of 1-8
	; Basically you earn a prioritization system; lowest sound plays first!
PRG028_A0C5:
	INY		 ; Y++
	LSR A		 ; Sound >> 1 ... -> Carry
	BCC PRG028_A0C5	 ; Waiting for that bit...!

	LDA Sound_Map_LUT-1,Y	; Unfortunately the index is one off, so we have to access the LUT one prior
	TAY		 	; Y = first byte for this sound from LUT

	; Y is now an offset gleaned from the first 8 bytes of this table...
	LDA Sound_Map_LUT,Y	; A = Offset to sound
	STA <Sound_Map_Off	; Store offset to Sound_Map_Off

	LDA Sound_Map_LUT+1,Y	; Offset for the second track of the sound
	STA Sound_Map_Off2	; Store offset to Sound_Map_Off2

	LDA #$01	 ; 
	STA Sound_Map_Len	 ; Sound_Map_Len = 1, so it updates immediately
	STA Sound_Map_Len2	 ; Sound_Map_Len2 = 1, so it updates immediately

MapSound_Playing:
	DEC Sound_Map_Len	 ; Sound_Map_Len--
	BNE PRG028_A136	 ; If Sound_Map_Len > 0, jump to PRG028_A136

	; Sound_Map_Len = 0 ...
	LDY <Sound_Map_Off	; Y = Sound_Map_Off
	INC <Sound_Map_Off	; Sound_Map_Off++
	LDA SndMap_Data,Y 	; Get next byte of sound data

	BEQ MapSound_Stop 	; If it's $00, sound over!  Jump to MapSound_Stop
	BPL MapSound_PlayFreqL	; $00 - $7f injects a new byte into PAPU_FT1 (low byte frequency)
	BNE MapSound_SetLen	; $80 - $ff, MapSound_SetLen

MapSound_Stop:
	LDA #$08	 ; 
	STA PAPU_EN	 ; Only noise channel left enabled
	LDA #$0f	 ; 
	STA PAPU_EN	 ; All channels enabled
	LDA #$00	 ; 
	STA SndCur_Map ; Release hold, no longer playing a sound
	RTS		 ; Return

MapSound_SetLen:
	JSR AND7F	 	; Just keep the lower 7 bits
	STA Sound_Map_LHold	; Use this as the new length value for any following bytes
	LDY <Sound_Map_Off	; Y = offset into sound data
	INC <Sound_Map_Off	; Sound_Map_Off++
	LDA SndMap_Data,Y	; Get the next (presumably not rest!) byte


MapSound_PlayFreqL:
	STA PAPU_FT1	 ; Byte goes directly into frequency register
	LDA SndCur_Map ; Get the hold value
	BPL PRG028_A120	 ; If $80 not set, jump to PRG028_A120

	LDA #$0e	 ; 
	STA PAPU_CT1	 ; Fairly high frequency, short length
	LDX #%10011111	 ; Square 1's CTL settings: Max volume, envelope decay disabled, 50% duty cycle
	BNE PRG028_A127	 ; (technically always) jump to PRG028_A127

PRG028_A120:
	LDA #$08	 ; 
	STA PAPU_CT1	 ; Short length
	LDX #%10010111	 ; Square 1's CTL settings: Half volume, envelope decay disabled, 50% duty cycle

PRG028_A127:
	LDY #$7f	 ; Ramp settings: Everything except actually enabling the ramp!
	JSR Sound1_XCTL_YRAMP
 
	LDA Sound_Map_LHold	 ; Get the current length hold value
	STA Sound_Map_Len	 ; Reset the length counter with this value!
	LDA #$00	 	 ; 
	STA <Sound_Map_EntrV	 ; Start at index 0 for volume ramping (sound $04, level enter, ONLY!)

PRG028_A136:
	LDA SndCur_Map ; Get current map sound we're playing
	CMP #$04	 ; 
	BNE PRG028_A147	 ; If it's NOT $04 (entering level) jump to PRG028_A147

	; $04 (entering level) specific...
	; The volume is ramped down as the sound plays!
	INC <Sound_Map_EntrV	 ; Sound_Map_EntrV++
	LDY <Sound_Map_EntrV	 ; Y = Sound_Map_EntrV
	LDA SndMap_Entr_VolData-1,Y	 ; because they incremented the pointer FIRST, I have to subtract 1 from the LUT address!
	STA PAPU_CTL1	 ; Set the new volume!

PRG028_A147:
	; For any sound...

	LDY Sound_Map_Off2	; Y = Sound_Map_Off2
	BEQ PRG028_A19B	 	; If Sound_Map_Off2 = 0, jump to PRG028_A19B (do nothing; an offset of zero disables the track)

	DEC Sound_Map_Len2	; Sound_Map_Len2--
	BNE PRG028_A18F	 	; If not zero, jump to PRG028_A18F

	LDY Sound_Map_Off2	; Y = Sound_Map_Off2 (again)
	INC Sound_Map_Off2	; Sound_Map_Off2++

	LDA SndMap_Data,Y 	; Get this byte of sound data
	BPL MapSound_Play2FreqL	; If it is $00-$7f, jump to BPL MapSound_Play2FreqL

	; Otherwise this is a length setting
	JSR AND7F		; & $7F
	STA Sound_Map_L2Hld	; Use this as the new length for following bytes
	LDY Sound_Map_Off2	; Y = Sound_Map_Off2
	INC Sound_Map_Off2	; Sound_Map_Off2++
	LDA SndMap_Data,Y	; Get the next (presumably note!) byte 

MapSound_Play2FreqL:
	CMP #$7e	 ; 
	BNE PRG028_A176	 ; Is the next byte $7e? If not, jump to PRG028_A176
	LDA #%00010000	 ; 
	STA PAPU_CTL2	 ; Disables envelope decay, but that's it
	BNE PRG028_A185	 ; (technically always) jump to PRG028_A185

PRG028_A176:
	; Every other byte...
	STA PAPU_FT2

	LDX #$08	 ; 
	STX PAPU_CT2	 ; Short length
	LDX #%01010101	 ; Square 2's CTL settings: 33% volume, envelope decay disabled, 25% duty cycle
	LDY #$7f	 ; Ramp settings: Everything except actually enabling the ramp!
	JSR Sound2_XCTL_YRAMP

PRG028_A185:
	LDA Sound_Map_L2Hld	 ; Get the current length hold value
	STA Sound_Map_Len2	 ; Reset the length counter with this value!

	; Sound_Map_EntV2 = 0
	LDA #$00
	STA <Sound_Map_EntV2

PRG028_A18F:
	INC <Sound_Map_EntV2	 ; Sound_Map_EntV2++

	LDY <Sound_Map_EntV2	; Y = Sound_Map_EntV2

	LDA SndMap_Entr_VolData-1,Y
	ORA #$50	 ; Envelope decay disable + 25% duty cycle
	STA PAPU_CTL2	 ; Set the register

PRG028_A19B:
	RTS		 ; Return

SndMap_Entr_VolData:
	; This ramps down the volume during the "level enter" sound
	.byte $97, $96, $96, $95, $95, $95, $94, $94, $94, $93, $93, $92, $92, $91, $91, $91


AND7F:	; This seems like a ridiculous subroutine!
	AND #$7f
	RTS		 ; Return

MSHO .func \1-Sound_Map_LUT	; "Map Sound Header Offset"
Sound_Map_LUT:
	; These are offsets from here to the respective SFX data headers
	.byte MSHO(SndMapH_Entrance),	MSHO(SndMapH_Move)
	.byte MSHO(SndMapH_Enter),	MSHO(SndMapH_Flip)
	.byte MSHO(SndMapH_Bonus),	MSHO(SndMapH_Unused)
	.byte MSHO(SndMapH_Unused),	MSHO(SndMapH_Deny)


MSO .func \1-SndMap_Data
	;	Offset1, Offset2
	; Offset1 specifies a first track played on Square 1 at 50% duty cycle
	; Offset2 specifies a second track played on Square 2 at 25% duty cycle, only used by the level entry sound...
SndMapH_Entrance:	.byte MSO(SndMap_Data_WEnt),	$00 ; $01: World begin starry entrance sound
SndMapH_Move:		.byte MSO(SndMap_Data_Move),	$00 ; $02: Path move
SndMapH_Enter:		.byte MSO(SndMap_Data_Entr),	MSO(SndMap_Data_Entr2) ; $04: Enter level
SndMapH_Flip:		.byte MSO(SndMap_Data_Flip),	$00 ; $08: Flip inventory
SndMapH_Bonus:		.byte MSO(SndMap_Data_Bonus),	$00 ; $10: Bonus appears
SndMapH_Deny:		.byte MSO(SndMap_Data_Deny), 	$00 ; $80: Denied
SndMapH_Unused:		.byte MSO(SndMap_Data_Unused),	$00 ; $20/$40: ?? unused ?


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Format of Map sound data:
; $00:		Ends sound
; $01-$7F:	Sets PAPU_FT1 to this value (lower = higher pitch)
; $80-$FF:	Removing the high bit, this sets the length of following values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SndMap_Data:
SndMap_Data_WEnt:
	.byte $83, $35, $32, $2F, $2C, $2A, $28, $25, $23, $21, $1F, $1D, $1C, $1A, $18, $16
SndMap_Data_Unused: 
	.byte $00	; NOTE: This is SndMap_Data_WEnt's terminator!

	; NOTE: The SndMap_Data_Entr $04 sound is expected to be synced with volume values
	; specified in the table SndMap_Entr_VolData!
SndMap_Data_Entr:
	.byte $84, $12, $15, $19, $1F, $23, $2A, $32, $3F, $47, $54, $64, $8A, $7F, $00

	; "Second track" of entry sound, played on Square 2, only map sound to do this...
SndMap_Data_Entr2:
	.byte $82, $7E, $84, $12, $15, $19, $1F, $23, $2A, $32, $3F, $47, $54, $64, $8A, $7F, $00

SndMap_Data_Flip:
	.byte $85, $6A, $5F, $87, $47, $00

SndMap_Data_Move:
	.byte $85, $2A, $8A, $23, $00

SndMap_Data_Bonus:
	.byte $85, $54, $47, $3F, $35, $8A, $2A, $00

SndMap_Data_Deny:
	.byte $88, $14, $14, $8A, $14, $00

; End of "Map" sounds
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Bytes sent to PAPU_CTL1 for the swim sound
SwimCTL1_LUT:
	.byte $9F, $9B, $98, $96, $95, $94, $92, $90, $90, $9A, $97, $95, $93, $92


PRG028_A21D:
	; Pipe sound comes here
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$08	 
	STA SFX_Counter1 ; SFX_Counter1 = 8
	BNE PRG028_A22F	 ; (technically always) jump to PRG028_A22F

PRG028_A227:
	; SFX_Counter1 has gone to zero...
	LSR Sound_QPlayer	; Sound_QPlayer >>= 1
	BCS PRG028_A22F	 	; If another bit present (?), jump to PRG028_A22F (seems like a dumb place to go with SFX_Counter1 = 0)
	JMP PlayerSnd_Stop	 	; Otherwise, hop to PlayerSnd_Stop

PRG028_A22F:
	DEC SFX_Counter1 ; SFX_Counter1--
	LDA SFX_Counter1 ; A =  SFX_Counter1
	BEQ PRG028_A23F	 ; If SFX_Counter1 = 0, jump to PRG028_A23F
	CMP #$04	 ; 
	BNE PRG028_A24D	 ; If SFX_Counter1 <> 4, jump to PRG028_A24D (do nothing)
	LDA #110	 ; Note 110
	BNE PRG028_A246	 ; (technically always) jump to PRG028_A246

PRG028_A23F:
	; SFX_Counter1 = 8
	LDA #$08
	STA SFX_Counter1

	LDA #$72

PRG028_A246:
	LDX #%10110100	 ; PAPU_CTL1 - volume 8, envelope decay disabled, looping enable, 50% duty 
	LDY #$7f	 ; PAPU_RAMP - Everything but the ramp enable!
	JSR Sound_Sq1_NoteOn

PRG028_A24D:
	RTS		 ; Return

PlayerSnd_Frog:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #66		 ; Slightly higher note, otherwise same as PlayerSnd_Jump
	BNE PRG028_A25A	 ; Jump (technically always) to PRG028_A25A

PlayerSnd_Jump:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #52		 ; Note 52

PRG028_A25A:
	LDX #%10000010	 ; PAPU_CTL1  - 50% duty, envelope decay rate 2
	LDY #%10100111	 ; PAPU_RAMP1 - Max shift amount, rate update 2, enable sweep
	JSR Sound_Sq1_NoteOn	 ; Play sound!

	LDA #$28
	STA SFX_Counter1 ; Load SFX_Counter1 = $28; when this expires, sound ends!

PlayerSnd_FrogCont:
	LDA SFX_Counter1 ; A = SFX_Counter1
	CMP #$25	 ; 
	BNE PRG028_A273	 ; If SFX_Counter1 <> $25, go to PRG028_A273

	; When SFX_Counter1 reaches $25...
	LDX #%01011111	 ; PAPU_CTL1  - max decay rate (and disabled), 25% duty
	LDY #%11110110	 ; PAPU_RAMP1 - slower right shift, max sweep rate, and enabled
	BNE PRG028_A27B	 ; (technically always) jump to PRG028_A27B

PRG028_A273:
	; SFX_Counter1 <> $25...
	CMP #$20	 ; 
	BNE PRG028_A2A6	 ; If SFX_Counter1 <> $20, go to PRG028_A2A6

	; When SFX_Counter1 reaches $20...
	LDX #%01001000	 ; PAPU_CTL1  - volume 0, decay disabled, 25% duty
	LDY #%10111100	 ; PAPU_RAMP1 - shift amount 4, decrease wavelength, sweep update 3, sweep enable

PRG028_A27B:
	JSR Sound1_XCTL_YRAMP
	BNE PRG028_A2A6	 ; (technically always) jump to PRG028_A2A6

PlayerSnd_Fire:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #5 	 	; SFX_Counter1 will be 5
	LDY #%10011001	 ; PPU_RAMP1 - right shift minimal, decrease wavelength, sweep rate 1, enable sweep
	BNE PRG028_A290	 ; Jump (technically always) to PRG028_A290

PlayerSnd_Bump:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #10		 ; SFX_Counter1 will be 5
	LDY #%10010011	 ; PPU_RAMP1 - right shift 3, increase wavelength, sweep update 1, enable sweep

PRG028_A290:
	LDX #%10011110	 ; PAPU_CTL1 - volume 14, decay disabled, 50% duty
	STA SFX_Counter1

	LDA #38		 ; Note 38
	JSR Sound_Sq1_NoteOn	 ; Play sound!

PlayerSnd_FirBmpCont:
	LDA SFX_Counter1
	CMP #$06	
	BNE PRG028_A2A6	 ; If SFX_Counter1 <> 6, go to PRG028_A2A6

	; SFX_Counter1 = 6...
	LDA #%10111011	 ; 
	STA PAPU_RAMP1	 ; right shift 3, decrease wavelength, sweep rate 3, enable sweep

PRG028_A2A6:
	BNE PRG028_A325	 ; A <> 0, jump to PRG028_A325

PRG028_A2A8:
	; SFX_Counter1 = 0 is the only point you get down here...
	; or from Sound_QPlayer = $40 (unused)
	JMP PRG028_A227	 ; Jump to  PRG028_A227

Sound_PlayPlayer:
	LDY Sound_QPlayer ; Get sound queue for Player sounds
	BEQ PRG028_A2D0	 ; If 0, nothing's queued; go to PRG028_A2D0

	BMI PlayerSnd_Frog 	; If sound $80 frog jump, go to PlayerSnd_Frog

	; Since the input is a bit value ($01, $02, $04, ...), this will
	; decode it by continuously shifting to the right until we hit
	; a bit; this also incidentally provides a simple priority system.

	LSR Sound_QPlayer
	BCS PlayerSnd_Jump 	; If sound $01 (SND_PLAYERJUMP), go to PlayerSnd_Jump
	LSR Sound_QPlayer
	BCS PlayerSnd_Bump 	; If sound $02 (SND_PLAYERBUMP), go to PlayerSnd_Bump
	LSR Sound_QPlayer
	BCS PlayerSnd_Swim 	; If sound $04 (SND_PLAYERSWIM), go to PlayerSnd_Swim
	LSR Sound_QPlayer
	BCS PlayerSnd_Kick 	; If sound $08 (SND_PLAYERKICK), go to PlayerSnd_Kick
	LSR Sound_QPlayer
	BCS PlayerSnd_Pipe 	; If sound $10 (SND_PLAYERPIPE), go to PlayerSnd_Pipe
	LSR Sound_QPlayer
	BCS PlayerSnd_Fire 	; If sound $20 (SND_PLAYERFIRE), go to PlayerSnd_Fire

PRG028_A2D0:
	LDA SndCur_Player
	BEQ PRG028_A2E9	 ; If no sound playing, jump to PRG028_A2E9

	BMI PlayerSnd_FrogCont	 ; If sound $80 (SND_PLAYERFROG), go to PlayerSnd_FrogCont
	LSR A		 ; 
	BCS PlayerSnd_JumpCont	 ; If sound $01 (SND_PLAYERJUMP), go to PlayerSnd_JumpCont
	LSR A		 ;
	BCS PlayerSnd_FirBmpCont ; If sound $02 (SND_PLAYERBUMP), go to PlayerSnd_FirBmpCont
	LSR A		 ; 
	BCS PlayerSnd_SwimCont	 ; If sound $04 (SND_PLAYERSWIM), go to PlayerSnd_SwimCont	
	LSR A		 ; 
	BCS PlayerSnd_KickCont	 ; If sound $08 (SND_PLAYERKICK), go to PlayerSnd_KickCont
	LSR A		 ; 
	BCS PlayerSnd_PipeCont	 ; If sound $10 (SND_PLAYERPIPE), go to PlayerSnd_PipeCont
	LSR A		 ; 
	BCS PlayerSnd_FirBmpCont ; If sound $20 (SND_PLAYERFIRE), go to PlayerSnd_FirBmpCont

PRG028_A2E9:
	LDA SndCur_Player
	CMP #SND_PLAYERPOWER
	BEQ PRG028_A2A8	 	; If SndCur_Player = SND_PLAYERPOWER, go to PRG028_A2A8

	LSR Sound_QPlayer	; 
	BCS PRG028_A2FC	 	; If SND_PLAYERJUMP (??) go to PRG028_A2FC (I don't think this will ever happen)
	RTS		 ; Return

PlayerSnd_Pipe:
	JMP PlayerSnd_Pipe2

PlayerSnd_PipeCont:
	JMP PlayerSnd_PipeCont2

PRG028_A2FC:
	JMP PRG028_A21D	 ; Jump to PRG028_A21D

PlayerSnd_JumpCont:	; jump update comes here
	JMP PlayerSnd_FrogCont

PlayerSnd_Swim:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$0e	 
	STA SFX_Counter1 ; SFX_Counter1 = $0e
	LDY #$9c	 ; PAPU_RAMP1 
	LDX #$9e	 ; PAPU_CTL1
	LDA #66		 ; Note 66
	JSR Sound_Sq1_NoteOn	 

PlayerSnd_SwimCont:
	LDY SFX_Counter1 
	LDA SwimCTL1_LUT-1,Y	; SFX_Counter1 is used as an index into SwimCTL1_LUT; we subtract 1 because SFX_Counter1 must be at least 1
	STA PAPU_CTL1	 	; Store next swim CTL1 command
	CPY #$06	 ; 
	BNE PRG028_A325	 ; If SFX_Counter1 <> 6, jump to PRG028_A325
	LDA #$9e	 ;
	STA PAPU_FT1	 ; Update PAPU_FT1

PRG028_A325:
	BNE PlayerSnd_CounterUpd	 ; (technically always) jump to PlayerSnd_CounterUpd

PlayerSnd_Kick:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$0e	 ; 
	LDY #$cb	 ; PAPU_RAMP1
	LDX #$9f	 ; PAPU_CTL1
	STA SFX_Counter1 ; SFX_Counter1 = $0E
	LDA #68		 ; Note 68
	JSR Sound_Sq1_NoteOn	 ; Play sound!
	BNE PlayerSnd_CounterUpd

PlayerSnd_KickCont:
	LDY SFX_Counter1
	CPY #$08	 ; 
	BNE PRG028_A34A	 ; If SFX_Counter1 <> 8, go to PRG028_A34A
	LDA #$a0	 ; 
	STA PAPU_FT1	 ; Update register
	LDA #$9f	 ; 
	BNE PRG028_A34C	 ; (technically always) jump to PRG028_A34C

PRG028_A34A:
	LDA #$90	 

PRG028_A34C:
	STA PAPU_CTL1

PlayerSnd_CounterUpd:
	DEC SFX_Counter1 ; SFX_Counter1--
	BNE PRG028_A363	 ; If SFX_Counter1 <> 0, go to PRG028_A363 (do nothing)

	; Counter has dropped to zero!
PlayerSnd_Stop:
	LDX #$00	 	;
	STX SndCur_Player	; Clear Player sound hold
	LDX #$1e	 	; 
	STX PAPU_EN	 	; Disable square wave 1
	LDX #$0f	 	; 
	STX PAPU_EN	 	; Enable every channel

PRG028_A363:
	RTS		 ; Return

PlayerSnd_Pipe2:
	STY SndCur_Player	; Mark what Player sound we're playing
	LDA #$2f		
	STA SFX_Counter1	; SFX_Counter1 = $2F

PlayerSnd_PipeCont2:
	LDA SFX_Counter1	 
	LSR A		 ; 
	BCS PRG028_A382	 ; If SFX_Counter1 & 1, jump to PRG028_A382
	LSR A		 ; 
	BCS PRG028_A382	 ; If SFX_Counter1 & 2, jump to PRG028_A382
	AND #$02	 ; 
	BEQ PRG028_A382	 ; If !(SFX_Counter1 & 8), jump to PRG028_A382
	LDY #$91	 ; PAPU_RAMP1
	LDX #$9a	 ; PAPU_CTL1
	LDA #104	 ; Note 104
	JSR Sound_Sq1_NoteOn

PRG028_A382:
	JMP PlayerSnd_CounterUpd

	; the "1-up" sound
SndLev1_1upData:
	.byte $23, $2F, $35, $2A, $47, $54

	; the "power up" sound
SndLev1_PUpData:
	.byte $6A, $74, $6A, $64, $5C, $52, $5C, $52
	.byte $4C, $44, $66, $70, $66, $60, $58, $4E, $58, $4E, $48, $40, $56, $60, $56, $50
	.byte $48, $3E, $48, $3E, $38, $30, $30

SndLev1_PUpRiseData:
	.byte $7E, $3E, $40, $32, $7E, $40, $42, $34, $7E
	.byte $42, $44, $36, $7E, $44, $46, $38, $7E, $46, $48, $3A, $7E, $48, $4A, $3C, $7E
	.byte $4A, $4C, $3E, $7E, $4C, $4E

SndLev1_Coin2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$35	 ; SFX_Counter2 value
	LDX #$8d	 ; PAPU_CTL2
	BNE PRG028_A3D9	 ; (technically always) jump to PRG028_A3D9

SndLev1_Text2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$06	 ; SFX_Counter2 value
	LDX #$98	 ; PAPU_CTL2

PRG028_A3D9:
	STA SFX_Counter2
	LDY #$7f	 ; PAPU_RAMP2
	LDA #94		 ; Note 94
	JSR Sound_Sq2_NoteOn	 

SndLev1_Coin_Cont2:
	LDA SFX_Counter2
	CMP #$30	 
	BNE PRG028_A3EF	 ; If SFX_Counter2 <> $30, jump to PRG028_A3EF

	LDA #$54
	STA PAPU_FT2

PRG028_A3EF:
	BNE SndLev1_PUp_Cont2	 ; $A3EF 

SndLev1_Boom:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$20	  
	STA SFX_Counter2	  
	LDY #$94	  
	LDA #$1c	  
	BNE PRG028_A40C	 ; (technically always) jump to PRG028_A40C

SndLev1_Boom_Cont2:
	LDA SFX_Counter2	  
	CMP #$18	  
	BNE SndLev1_PUp_Cont2	  
	LDY #$93	  
	LDA #$34	  
	LDX #$9f	  
PRG028_A40C:
	JMP PRG028_A425	  

SndLev1_PUp:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$36	 
	STA SFX_Counter2	 ; SFX_Counter2 = $36

SndLev1_PUp_Cont:
	LDA SFX_Counter2
	LSR A		
	BCS SndLev1_PUp_Cont2	 ; If SFX_Counter2 & 1, jump to SndLev1_PUp_Cont2
	TAY		 ; Y = A
	LDA SndLev1_PUpData-1,Y	; As in other parts of sound code, -1 because SFX_Counter2 must be > 0
	LDX #$5d	 ; PAPU_CTL2
	LDY #$7f	 ; PAPU_RAMP2

PRG028_A425:
	JSR Sound_Sq2_NoteOn

SndLev1_PUp_Cont2:
	DEC SFX_Counter2
	BNE PRG028_A43C	 ; If SFX_Counter2 <> 0, jump to PRG028_A43C (RTS)

PRG028_A42D:

	; SndCur_Level1 = 0
	LDX #$00
	STX SndCur_Level1

	; Disable and re-enable square 2
	LDX #$0d
	STX PAPU_EN
	LDX #$0f
	STX PAPU_EN

PRG028_A43C:
	RTS		 ; Return

SndLev1_PUpRise:
	JMP SndLev1_PUpRise2

SndLev1_Coin:
	JMP SndLev1_Coin2

SndLev1_VineRise:
	JMP SndLev1_VineRise2

SndLev1_SuitLost:
	JMP SndLev1_SuitLost2

Sound_PlayLevel1:
	LDA SndCur_Level1
	AND #$40	 ; 
	BNE SndLev1_1upCont	 ; If currently playing level 1 sound is $40 1-up, jump to SndLev1_1up (overrides any new sounds!)

	LDY Sound_QLevel1
	BEQ PRG028_A47A	 ; If no Level 1 sound is queued, jump to PRG028_A47A

	BMI SndLev1_SuitLost	 ; If sound $80 (SND_LEVELPOOF) sound, jump to SndLev1_SuitLost

	; Since the input is a bit value ($01, $02, $04, ...), this will
	; decode it by continuously shifting to the right until we hit
	; a bit; this also incidentally provides a simple priority system.

	LSR Sound_QLevel1
	BCS SndLev1_Coin	 ; If sound $01 (SND_LEVELCOIN), jump to SndLev1_Coin
	LSR Sound_QLevel1
	BCS SndLev1_PUpRise	 ; If sound $02 (SND_LEVELRISE), jump to SndLev1_PUpRise
	LSR Sound_QLevel1
	BCS SndLev1_VineRise	 ; If sound $04 (SND_LEVELVINE), jump to SndLev1_VineRise
	LSR Sound_QLevel1
	BCS SndLev1_Boom	 ; If sound $08 (SND_LEVELBABOOM), jump to SndLev1_Boom
	LSR Sound_QLevel1
	BCS SndLev1_Text	 ; If sound $10 (SND_LEVELBLIP), jump to SndLev1_Text
	LSR Sound_QLevel1
	BCS SndLev1_PUp	 ; If sound $20 (SND_LEVELPOWER), jump to SndLev1_PUp
	LSR Sound_QLevel1
	BCS SndLev1_1up	 ; If sound $40 (SND_LEVEL1UP), jump to SndLev1_1up

PRG028_A47A:
	LDA SndCur_Level1
	BEQ PRG028_A496	 ; If no sound is playing, jump to PRG028_A496 (Do nothing)

	BMI SndLev1_SuitLost_Cont	 ; If sound (SND_LEVELPOOF) "lost suit" sound, jump to SndLev1_SuitLost_Cont
	LSR A		 
	BCS SndLev1_Coin_Cont	 ; If sound $01 (SND_LEVELCOIN), jump to SndLev1_Coin_Cont
	LSR A		
	BCS SndLev1_PUpRise_Cont	 ; If sound $02 (SND_LEVELRISE), jump to SndLev1_PUpRise_Cont
	LSR A		 
	BCS SndLev1_PUpRise_Cont	 ; If sound $04 (SND_LEVELVINE), jump to SndLev1_PUpRise_Cont
	LSR A		
	BCS SndLev1_Boom_Cont	 ; If sound $08 (SND_LEVELBABOOM), jump to SndLev1_Boom_Cont
	LSR A		
	BCS SndLev1_Text_Cont	 ; If sound $10 (SND_LEVELBLIP), jump to SndLev1_Text_Cont
	LSR A		 
	BCS SndLev1_PUp_Cont	 ; If sound $20 (SND_LEVELPOWER), jump to SndLev1_PUp_Cont
	LSR A		 
	BCS SndLev1_1upCont	 ; If sound $40 (SND_LEVEL1UP), jump to SndLev1_1upCont

PRG028_A496:
	RTS		 ; Return

SndLev1_SuitLost_Cont: 
	JMP SndLev1_SuitLost_Cont2

SndLev1_Text:
	JMP SndLev1_Text2

SndLev1_Coin_Cont:
SndLev1_Text_Cont:
	JMP SndLev1_Coin_Cont2

SndLev1_Boom_Cont:
	JMP SndLev1_Boom_Cont2

SndLev1_PUp_1up:
	JMP SndLev1_PUp_Cont2

SndLev1_1up:
	STY SndCur_Level1	 ; Store what level 1 sound we're playing
	LDA #$30
	STA SFX_Counter2	 ; SFX_Counter2 = $30

SndLev1_1upCont:
	LDA SFX_Counter2
	LDX #$03

PRG028_A4B3:	
	LSR A		 
	BCS SndLev1_PUp_1up	 ; If SFX_Counter2 & 1, jump to SndLev1_PUp_1up
	DEX		 ; X--
	BNE PRG028_A4B3	 ; If X > 0, loop

	TAY		 	; Y = A
	LDA SndLev1_1upData-1,Y	; As in other parts of sound code, -1 because SFX_Counter2 must be > 0
	STA PAPU_FT2	 	; Store this into PAPU_FT2

	LDX #$82	 	; PAPU_CTL2
	LDY #$7f	 	; PAPU_RAMP2
	JSR Sound2_XCTL_YRAMP	

	; PAPU_CT2 = 8
	LDA #$08
	STA PAPU_CT2

	JMP SndLev1_PUp_Cont2	 ; Jump to SndLev1_PUp_Cont2

SndLev1_PUpRise2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing

	LDA #$10
	BNE PRG028_A4DB	 ; Jump (technically always) to PRG028_A4DB

SndLev1_VineRise2:
	STY SndCur_Level1	 ; Mark what "level 1" sound we're playing
	LDA #$20

PRG028_A4DB:
	STA SFX_Counter2	 ; Set SFX_Counter2

	LDA #$7f
	STA PAPU_RAMP2	 ;  [NES] Audio -> Square 2

	; SFX_Counter3 = 0
	LDA #$00
	STA SFX_Counter3

SndLev1_PUpRise_Cont:
	INC SFX_Counter3 ; SFX_Counter3++

	LDA SFX_Counter3
	LSR A	
	TAY		 ; Y = SFX_Counter3 >> 1
	CPY SFX_Counter2
	BEQ PRG028_A501	 ; If SFX_Counter3 / 2 = SFX_Counter2, jump to PRG028_A501 (PRG028_A42D)

	LDA #$9d
	STA PAPU_CTL2	 ;  [NES] Audio -> Square 2

	LDA SndLev1_PUpRiseData-1,Y	 ; As in other parts of sound code, -1 because SFX_Counter2 must be > 0
	JSR Sound_Sq2_NoteOn_NoPAPURAMP

	RTS		 ; Return

PRG028_A501:
	JMP PRG028_A42D	 ; Jump to PRG028_A42D

PRG028_A504:
	JMP PRG028_A47A	 ; Jump to PRG028_A47A

SndLev1_SuitLost2:
	LDY Sound_QLevel1
	CPY #SND_LEVELPOOF
	BNE PRG028_A512	 ; If this is not the "poof" sound, jump to PRG028_A512
 
	; "Poof" sound effect
	LDA #(SndLev1_DataPoof - SndLev1_Data)
	BNE PRG028_A529	 ; Jump (technically always) to PRG028_A529

PRG028_A512:
	CPY #SND_LEVELUNK
	BNE PRG028_A51A	 ; If not unknown / lost sound, jump to PRG028_A51A

	; Unknown / lost sound
	LDA #(SndLev1_DataUnk - SndLev1_Data)
	BEQ PRG028_A529	 ; Jump (technically always) to PRG028_A529

PRG028_A51A:
	CPY #SND_LEVELSHOE
	BNE PRG028_A522	 ; If not these sounds, jump to PRG028_A522

	; Lost shoe sound
	LDA #(SndLev1_DataLostShoe - SndLev1_Data)
	BNE PRG028_A529	 ; Jump (technically always) to PRG028_A529

PRG028_A522:
	LDA SndCur_Level1
	BNE PRG028_A504	 ; If any level 1 sounds are playing, jump to PRG028_A504

	; Tail wag
	LDA #(SndLev1_DataLongWag - SndLev1_Data)

PRG028_A529:
	STA SFX_Counter2	 ; Set SFX_Counter2 appropriately

	; Filter out sound selection
	TYA
	AND #(SND_LEVELPOOF | SND_LEVELTAILWAG | SND_LEVELSHOE)
	STY SndCur_Level1

SndLev1_SuitLost_Cont2:
	INC SFX_Counter2	 ; SFX_Counter2++

	LDY SFX_Counter2	 ; Y = SFX_Counter2

	LDA SndLev1_Data,Y	 ; Get data
	BEQ PRG028_A553	 ; If data = 0, jump to PRG028_A553
	BPL PRG028_A544	 ; If data > 0, jump to PRG028_A544

	; data < 0...

	; Store value -> SFX_Counter3
	STA SFX_Counter3
	BNE SndLev1_SuitLost_Cont2	 ; Jump (technically always) to SndLev1_SuitLost_Cont2

PRG028_A544:
	LDX #$7f
	STX PAPU_RAMP2	 ;  [NES] Audio -> Square 2

	LDX SFX_Counter3
	STX PAPU_CTL2	 ;  [NES] Audio -> Square 2

	JSR Sound_Sq2_NoteOn_NoPAPURAMP

	RTS		 ; Return

PRG028_A553:
	; SFX_Counter2 = 0
	LDA #$00
	STA SFX_Counter2

	JMP PRG028_A42D	 ; Jump to PRG028_A42D


SndLev1_Data:
SndLev1_DataUnk:
	.byte $9F, $30, $34, $36, $38, $9F, $3A, $3C, $3E, $40, $9A, $3A, $3C, $3E, $40, $9C ; $A55B - $A56A
	.byte $3A, $3C, $3E, $40, $96, $3A, $3C, $3E, $40, $98, $3A, $3C, $3E, $40, $00

SndLev1_DataPoof:
	.byte $9F
	.byte $2E, $2A, $26, $22, $9D, $2E, $2A, $7E, $7E, $9F, $30, $2E, $2A, $28, $9D, $30 ; $A57B - $A58A
	.byte $2E, $7E, $7E, $9F, $38, $34, $32, $30, $9D, $38, $34, $32, $30, $9A, $38, $34 ; $A58B - $A59A
	.byte $32, $30, $9C, $38, $34, $32, $30, $97, $38, $34, $32, $30, $98, $38, $34, $32 ; $A59B - $A5AA
	.byte $30, $94, $38, $34, $32, $30, $00

SndLev1_DataLostShoe:
	.byte $9F, $42, $40, $7E, $7E, $9F, $46, $48, $7E ; $A5AB - $A5BA
	.byte $7E, $9A, $4A, $4E, $50, $52, $96, $4E, $52, $54, $56, $00

SndLev1_DataLongWag:
	.byte $90, $7E, $7E, $97 ; $A5BB - $A5CA
	.byte $4C, $4E, $90, $7E, $7E, $95, $52, $54, $56, $58, $94, $52, $54, $56, $58, $93 ; $A5CB - $A5DA
	.byte $52, $54, $56, $58, $00

SndLev2_MarchData:
	.byte $55, $81, $AA, $02, $74, $B7, $A5, $04, $92, $A9, $08 ; $A5DB - $A5EA
	.byte $69, $58, $4A

SndLev2_BoomerangData:
	.byte $11, $61, $21, $51, $81, $21, $61, $A2, $23, $64, $A5, $76

SndLev2_SkidNFreq:
	.byte $01, $0E, $0E, $0D, $0B, $06, $0C, $0F, $0A, $09, $03, $0D, $08, $0D, $06

SndLev2_SkidTFreq:
	.byte $0C, $47, $49, $42, $4A, $43, $4B

SndLev2_Skid:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = 6
	LDA #$06
	STA SFX_Counter4

SndLev2_SkidCont:
	LDA SFX_Counter4
	TAY		 ; Y = SFX_Counter4

	LDA SndLev2_SkidTFreq,Y
	STA PAPU_TFREQ1	 ; [NES] Audio -> Triangle

	LDA #$18
	STA PAPU_TCR1	 ; [NES] Audio -> Triangle
	STA PAPU_TFREQ2	 ; [NES] Audio -> Triangle
	BNE PRG028_A64C	 ; Jump (technically always) to PRG028_A64C

SndLev2_Crumble:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $20
	LDA #$20
	STA SFX_Counter4

SndLev2_CrumbleCont:
	LDA SFX_Counter4
	LSR A	
	BCC PRG028_A64C	 ; Every other tick, jump to PRG028_A64C

	TAY		 ; SFX_Counter4 / 2 -> 'Y'
	LDX SndLev2_SkidNFreq,Y	 ; Get noise frequency
	LDA SndLev2_SkidNCtl,Y	 ; Get noise CTL value

PRG028_A641:

	; Set both
	STA PAPU_NCTL1
	STX PAPU_NFREQ1

	LDA #$18
	STA PAPU_NFREQ2	 ; [NES] Audio -> Noise Frequency reg #2

PRG028_A64C:
	DEC SFX_Counter4 ; SFX_Counter4--
	BNE PRG028_A660	 ; If SFX_Counter4 <> 0, jump to PRG028_A660 (RTS)

	LDA #$f0
	STA PAPU_NCTL1	 ; [NES] Audio -> Noise control reg
	LDA #$00
	STA PAPU_TCR1	 ; [NES] Audio -> Triangle

	; SndCur_Level2 = 0
	LDA #$00
	STA SndCur_Level2

PRG028_A660:
	RTS		 ; Return

Sound_PlayLevel2: 
	LDA SndCur_Level2
	CMP #SND_LEVELAIRSHIP
	BNE PRG028_A66B	 ; If this is not the airship sound, jump to PRG028_A66B

	JMP SndLev2_AirshipCont	 ; Jump to SndLev2_AirshipCont

PRG028_A66B:

	; This is here because sounds $20 and $40 are undefined;
	; if they were to be defined, this could sit down below...
	LDA SndCur_Level2
	BMI SndLev2_SkidCont	 ; If sound $80 (SND_LEVELSKID) is currently playing, jump to SndLev2_SkidCont (overrides queue)

	LDY Sound_QLevel2
	BEQ PRG028_A690	 ; If no level 2 sound is queued, jump to PRG028_A690

	BMI SndLev2_Skid	 ; If sound $80 (SND_LEVELSKID), jump to SndLev2_Skid

	; Since the input is a bit value ($01, $02, $04, ...), this will
	; decode it by continuously shifting to the right until we hit
	; a bit; this also incidentally provides a simple priority system.

	LSR Sound_QLevel2
	BCS SndLev2_Crumble	 ; If sound $01 (SND_LEVELCRUMBLE), jump to SndLev2_Crumble
	LSR Sound_QLevel2
	BCS SndLev2_Flame	 ; If sound $02 (SND_LEVELFLAME), jump to SndLev2_Flame
	LSR Sound_QLevel2
	BCS SndLev2_Boomerang	 ; If sound $04 (SND_BOOMERANG), jump to SndLev2_Boomerang
	LSR Sound_QLevel2
	BCS SndLev2_Airship	 ; If sound $08 (SND_LEVELAIRSHIP), jump to SndLev2_Airship
	LSR Sound_QLevel2
	BCS SndLev2_March	 ; If sound $10 (SND_LEVELMARCH), jump to SndLev2_March

	; NOTE: Level 2 set sounds $20 and $40 are undefined!


PRG028_A690:

	; No sound is queued...

	LDA SndCur_Level2
	BEQ PRG028_A6A4	 ; If no sound is playing, jump to PRG028_A6A4 (RTS)
	LSR A
	BCS SndLev2_CrumbleCont	 ; If sound $01 (SND_LEVELCRUMBLE), jump to SndLev2_CrumbleCont
	LSR A
	BCS SndLev2_FlameCont	 ; If sound $02 (SND_LEVELFLAME), jump to SndLev2_FlameCont
	LSR A
	BCS SndLev2_BoomerangCont	 ; If sound $04 (SND_BOOMERANG), jump to SndLev2_BoomerangCont
	LSR A
	BCS SndLev2_AirshipCont	 ; If sound $08 (SND_LEVELAIRSHIP), jump to SndLev2_AirshipCont
	LSR A
	BCS SndLev2_MarchCont	 ; If sound $10 (SND_LEVELMARCH), jump to SndLev2_MarchCont

PRG028_A6A4:
	RTS		 ; Return

SndLev2_Flame:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $40
	LDA #$40
	STA SFX_Counter4

SndLev2_FlameCont:
	LDA SFX_Counter4
	LSR A
	TAY		 ; Y = SFX_Counter4 / 2

	LDX #$0f	 ; X = $F
	LDA PRG028_A709-1,Y

PRG028_A6B7:
	BNE PRG028_A641	 ; If data <> 0, jump to PRG028_A641

SndLev2_March:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $E
	LDA #$0e
	STA SFX_Counter4

SndLev2_MarchCont:
	LDA SFX_Counter4
	TAY		 ; Y = SFX_Counter4

	; Lower 4 bits OR'd with $10 -> 'X'
	LDA SndLev2_MarchData,Y
	AND #$0f
	ORA #$10
	TAX

	; Upper 4 bits shifted down, OR'd with $10
	LDA SndLev2_MarchData,Y
	LSR A
	LSR A
	LSR A
	LSR A
	ORA #$10

PRG028_A6D6:
	BNE PRG028_A6B7	 ; Jump (technically always) to PRG028_A6B7

SndLev2_Boomerang:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $C
	LDA #$0c
	STA SFX_Counter4

SndLev2_BoomerangCont:
	LDA SFX_Counter4
	TAY		 ; Y = SFX_Counter4

	; Lower 4 bits OR'd with $10 -> 'X'
	LDA SndLev2_BoomerangData,Y
	AND #$0f
	ORA #$10
	TAX

	; Upper 4 bits shifted down, OR'd with $10
	LDA SndLev2_BoomerangData,Y
	LSR A
	LSR A
	LSR A
	LSR A
	ORA #$10

PRG028_A6F5:
	BNE PRG028_A6D6	 ; Jump (technically always) to PRG028_A6D6

SndLev2_Airship:
	STY SndCur_Level2	 ; Mark what "level 2" sound we're playing

	; SFX_Counter4 = $40
	LDA #$40
	STA SFX_Counter4

SndLev2_AirshipCont:
	LDA SFX_Counter4
	LSR A
	LSR A
	TAX		 ; X = SFX_Counter4 >> 2

	ORA #$10	 ; Value OR'd with $10
	BNE PRG028_A6F5	 ; Jump (technically always) to PRG028_A6F5


PRG028_A709:
	.byte $15, $16, $16, $17, $17, $18, $19, $19, $1A, $1A, $1C, $1D, $1D, $1E, $1E, $1F ; $A709 - $A718
	.byte $1F, $1F, $1F, $1E, $1D, $1C, $1E, $1F, $1F, $1E, $1D, $1C, $1A, $18, $16, $14 ; $A719 - $A728

SndLev2_SkidNCtl:
	.byte $15, $16, $16, $17, $17, $18, $19, $19, $1A, $1A, $1C, $1D, $1D, $1E, $1E, $1F ; SndLev2_SkidNCtl - $A738
	.byte $A5, $8B, $C9, $03, $F0, $10, $C0


	; Each segment header is 7 bytes long:
MusSeg .macro
   .byte \1	; Music_RestH_Base value (always divisible by $10; base part of index into PRG031's Music_RestH_LUT)
   .word \2	; Address of music segment data (all tracks this segment, offsets to follow, except implied Square 2 zero)
   .byte \3	; Triangle track starting offset ($00 means disabled)
   .byte \4	; Square 1 track starting offset (cannot be disabled)
   .byte \5	; Noise track starting offset ($00 means disabled)
   .byte \6	; DCM track starting offset ($00 means disabled)
   .endm	; Square 2 cannot be disabled and always starts at offset $00

M12ASH .func \1-Music_Set1_Set2A_Headers	; "Music Set 1/2A Segment Header Offset"

Music_Set1_Set2A_IndexOffs:
	; Index 0 - 7 are Set 1 songs, accessed by bit weight
	.byte M12ASH(MS1_01SegHedr), M12ASH(MS1_02SegHedr), M12ASH(MS1_04SegHedr), M12ASH(MS1_08SegHedr)	; Index $00-$03
	.byte M12ASH(MS1_10SegHedr), M12ASH(MS1_20SegHedr), M12ASH(MS1_40SegHedr), M12ASH(MS1_80SegHedr)	; Index $04-$07

	; 8+ are Set 2A
	.byte M12ASH(MS2ASegHedr09), M12ASH(MS2ASegHedr0C), M12ASH(MS2ASegHedr07), M12ASH(MS2ASegHedr0A)	; Index $08-$0B
	.byte M12ASH(MS2ASegHedr0B), M12ASH(MS2ASegHedr05), M12ASH(MS2ASegHedr08), M12ASH(MS2ASegHedr06)	; Index $0C-$0F
	.byte M12ASH(MS2ASegHedr0F), M12ASH(MS2ASegHedr10), M12ASH(MS2ASegHedr11), M12ASH(MS2ASegHedr0E)	; Index $10-$13
	.byte M12ASH(MS2ASegHedr04), M12ASH(MS2ASegHedr12), M12ASH(MS2ASegHedr03), M12ASH(MS2ASegHedr04)	; Index $14-$17
	.byte M12ASH(MS2ASegHedr00), M12ASH(MS2ASegHedr01), M12ASH(MS2ASegHedr00), M12ASH(MS2ASegHedr02)	; Index $18-$1B
	.byte M12ASH(MS2ASegHedr1A), M12ASH(MS2ASegHedr0D), M12ASH(MS2ASegHedr1B), M12ASH(MS2ASegHedr1B)	; Index $1C-$1F
	.byte M12ASH(MS2ASegHedr1C), M12ASH(MS2ASegHedr1B), M12ASH(MS2ASegHedr1D), M12ASH(MS2ASegHedr1E)	; Index $20-$23
	.byte M12ASH(MS2ASegHedr1E), M12ASH(MS2ASegHedr1F), M12ASH(MS2ASegHedr1F), M12ASH(MS2ASegHedr20)	; Index $24-$27
	.byte M12ASH(MS2ASegHedr21), M12ASH(MS2ASegHedr22), M12ASH(MS2ASegHedr21), M12ASH(MS2ASegHedr23)	; Index $28-$2B

Music_Set1_Set2A_Headers:
MS2ASegHedr00:	MusSeg $00, M12ASegData00, $00, $13, $00, $00
MS2ASegHedr01:	MusSeg $00, M12ASegData01, $00, $0F, $00, $00
MS2ASegHedr02:	MusSeg $00, M12ASegData02, $00, $0A, $00, $00
MS2ASegHedr03: 	MusSeg $00, M12ASegData03, $00, $0B, $00, $00
MS2ASegHedr04:	MusSeg $00, M12ASegData04, $2E, $19, $00, $00
MS2ASegHedr05:	MusSeg $30, M12ASegData05, $20, $0A, $61, $65
MS2ASegHedr06:	MusSeg $30, M12ASegData06, $56, $2D, $7A, $81
MS2ASegHedr07:	MusSeg $00, M12ASegData07, $1B, $0E, $2F, $33
MS2ASegHedr08:	MusSeg $30, M12ASegData08, $00, $00, $00, $07
MS2ASegHedr09:	MusSeg $50, M12ASegData09, $7F, $31, $B5, $CE
MS2ASegHedr0A:	MusSeg $30, M12ASegData0A, $40, $37, $60, $72
MS2ASegHedr0B:	MusSeg $30, M12ASegData0B, $40, $37, $60, $85
MS2ASegHedr0C:	MusSeg $50, M12ASegData0C, $40, $1C, $5B, $84
MS2ASegHedr0D:	MusSeg $50, M12ASegData0D, $07, $04, $10, $00
MS2ASegHedr0E:	MusSeg $00, M12ASegData0E, $13, $0A, $00, $1C

	.byte $00	; Extra byte??  Probably a typo in the original source

MS2ASegHedr0F:	MusSeg $30, M12ASegData0F, $25, $12, $2A, $35
MS2ASegHedr10:	MusSeg $10, M12ASegData10, $56, $17, $64, $7D
MS2ASegHedr11:	MusSeg $10, M12ASegData11, $29, $15, $37, $50
MS2ASegHedr12:	MusSeg $80, M12ASegData12, $37, $1A, $49, $4F
MS1_40SegHedr:	MusSeg $80, M12ASegData13, $35, $18, $00, $00
MS1_01SegHedr:	MusSeg $30, M12ASegData14, $26, $11, $00, $38
MS1_04SegHedr:	MusSeg $30, M12ASegData15, $21, $11, $00, $31
MS1_20SegHedr:	MusSeg $30, M12ASegData16, $1F, $10, $2E, $3C

; MS1_80SegHedr is the "stop music" request; have to look into this
; a little bit more to figure out how it works
MS1_80SegHedr:	.byte $60
		.word M12ASegData17		; Just lands at a $00 stop
		.byte $00			; Incomplete header??

MS1_02SegHedr:	MusSeg $30, M12ASegData18, $20, $12, $00, $00
MS1_08SegHedr:	MusSeg $40, M12ASegData19, $4D, $27, $00, $73
MS2ASegHedr1A:	MusSeg $30, M12ASegData1A, $29, $14, $00, $00
MS2ASegHedr1B:	MusSeg $00, M12ASegData1B, $00, $1B, $00, $00
MS2ASegHedr1C:	MusSeg $00, M12ASegData1C, $00, $21, $00, $00
MS2ASegHedr1D:	MusSeg $30, M12ASegData1D, $23, $12, $33, $40
MS2ASegHedr1E:	MusSeg $30, M12ASegData1E, $45, $23, $65, $72
MS2ASegHedr1F:	MusSeg $30, M12ASegData1F, $1F, $10, $32, $3F
MS2ASegHedr20:	MusSeg $30, M12ASegData20, $39, $1D, $5E, $6B
MS2ASegHedr21:	MusSeg $30, M12ASegData21, $6D, $24, $A4, $B1
MS2ASegHedr22:	MusSeg $30, M12ASegData22, $24, $0C, $37, $44
MS2ASegHedr23:	MusSeg $30, M12ASegData23, $23, $0F, $3D, $4A
MS1_10SegHedr:	MusSeg $30, M12ASegData24, $6F, $4C, $00, $BA


	; Music in Set 2A is played by "index", which is a segment of music.
	; The index always advances, though what that index actually represents
	; may be a reused segment of music.

	; These three LUTs are to be read vertically for each Set 2A song to
	; be played ($1, $2, $3, ... $F), so that song $1 uses a start
	; index of $08, an end index of $09, and a loop index of $08.

Music_Set2A_Starts:
	.byte $08, $0A, $0B, $0D, $0E, $10, $11, $13, $14, $15, $16, $18, $1C, $1D, $1E

Music_Set2A_Ends:
	.byte $09, $0A, $0C, $0D, $0F, $10, $12, $13, $14, $15, $17, $1B, $1C, $1D, $2B

Music_Set2A_Loops:
	.byte $08, $0A, $0B, $0D, $0F, $10, $11, $13, $14, $15, $17, $18, $1C, $1D, $23

M12ASegData1A:
	.byte $D8, $68, $60, $60, $5A, $50, $4C, $68, $60, $60, $5A, $50, $4C, $68, $60 ; $A899 - $A8A8
	.byte $60, $5A, $50, $4C

M12ASegData17:
	.byte $00, $D4, $7E, $D8, $64, $5E, $56, $56, $48, $50, $64, $5E ; $A8A9 - $A8B8
	.byte $56, $56, $48, $50, $64, $5E, $56, $56, $48, $50, $DC, $30, $DA, $3E, $DC, $3A ; $A8B9 - $A8C8
	.byte $D8, $2A, $2E, $DC, $30, $DA, $7E

M12ASegData24:
	.byte $8E, $4C, $4A, $48, $5E, $5C, $5A, $58, $56 ; $A8C9 - $A8D8
	.byte $54, $52, $50, $4E, $4C, $4A, $48, $46, $44, $42, $40, $3E, $3C, $3A, $38, $36 ; $A8D9 - $A8E8
	.byte $34, $32, $30, $46, $44, $42, $40, $3E, $3C, $3A, $38, $36, $34, $32, $30, $2E ; $A8E9 - $A8F8
	.byte $2C, $2A, $28, $26, $24, $22, $20, $1E, $1C, $1A, $18, $2E, $2C, $2A, $28, $26 ; $A8F9 - $A908
	.byte $24, $22, $20, $1E, $1C, $1A, $18, $16, $14, $12, $10, $0E, $0C, $0A, $08, $06 ; $A909 - $A918
	.byte $88, $04, $00, $80, $4C, $4A, $48, $5E, $5C, $5A, $58, $56, $54, $52, $50, $4E ; $A919 - $A928
	.byte $4C, $4A, $48, $46, $44, $42, $40, $3E, $3C, $3A, $38, $36, $34, $32, $30, $2E ; $A929 - $A938
	.byte $2C, $2A, $28, $26, $88, $12, $8E, $4C, $4A, $48, $5E, $5C, $5A, $58, $56, $54 ; $A939 - $A948
	.byte $52, $50, $4E, $4C, $4A, $48, $46, $44, $42, $40, $3E, $3C, $3A, $38, $36, $34 ; $A949 - $A958
	.byte $32, $30, $46, $44, $42, $40, $3E, $3C, $3A, $38, $36, $34, $32, $30, $2E, $2C ; $A959 - $A968
	.byte $2A, $28, $26, $24, $22, $20, $1E, $1C, $1A, $18, $2E, $2C, $2A, $28, $26, $24 ; $A969 - $A978
	.byte $22, $20, $1E, $1C, $1A, $18, $16, $14, $12, $10, $0E, $0C, $0A, $08, $06, $88 ; $A979 - $A988
	.byte $1C, $82, $09, $09, $09, $09, $00

M12ASegData03:
	.byte $C4, $4C, $50, $C9, $64, $C0, $62, $60, $CA ; $A989 - $A998
	.byte $5E, $00, $C0, $7E, $C4, $4C, $50, $C9, $64, $C0, $62, $60, $CA, $5E

M12ASegData00:
	.byte $D8, $7E ; $A999 - $A9A8
	.byte $D4, $6E, $6C, $6A, $D8, $66, $68, $D4, $58, $5A, $D8, $60, $D4, $5A, $60, $64 ; $A9A9 - $A9B8
	.byte $00, $D9, $30, $3E, $D8, $48, $D9, $3A, $D4, $48, $D8, $48, $3A

M12ASegData01:
	.byte $D8, $7E, $D4 ; $A9B9 - $A9C8
	.byte $6E, $6C, $6A, $D8, $66, $68, $78, $D4, $78, $DA, $78, $00, $D9, $30, $38, $D4 ; $A9C9 - $A9D8
	.byte $3E, $D8, $48, $6E, $D4, $6E, $D8, $6E, $3E

M12ASegData02:
	.byte $D8, $7E, $D9, $66, $D9, $64, $DA ; $A9D9 - $A9E8
	.byte $60, $7E, $00, $D8, $30, $D9, $40, $44, $48, $D4, $3E, $D8, $3E, $30

M12ASegData16:
	.byte $94, $48 ; $A9E9 - $A9F8
	.byte $4C, $50, $98, $52, $C4, $56, $5A, $5E, $98, $60, $7E, $9A, $48, $00, $94, $42 ; $A9F9 - $AA08
	.byte $46, $48, $98, $4C, $C4, $50, $52, $56, $98, $50, $7E, $9A, $38, $94, $3A, $7E ; $AA09 - $AA18
	.byte $7E, $88, $34, $84, $34, $3E, $3E, $98, $30, $7E, $9A, $30, $94, $02, $02, $02 ; $AA19 - $AA28
	.byte $02, $01, $02, $02, $02, $98, $06, $01, $9A, $01, $94, $05, $05, $05, $05, $7E ; $AA29 - $AA38
	.byte $05, $05, $05, $9C, $05, $7E

M12ASegData04:
	.byte $C8, $3E, $CA, $56, $C8, $3E, $40, $CA, $58, $C8 ; $AA39 - $AA48
	.byte $5C, $56, $CA, $3E, $C8, $56, $52, $CA, $40, $C4, $44, $C0, $42, $40, $00, $C8 ; $AA49 - $AA58
	.byte $38, $CA, $50, $C8, $38, $3A, $CA, $52, $C8, $56, $50, $CA, $38, $C8, $50, $4A ; $AA59 - $AA68
	.byte $CA, $3A, $C8, $3A, $94, $30, $3E, $3E, $48, $48, $50, $50, $56, $32, $40, $40 ; $AA69 - $AA78
	.byte $4A, $4A, $52, $52, $58, $30, $3E, $3E, $48, $48, $50, $50, $56, $32, $40, $40 ; $AA79 - $AA88
	.byte $4A, $4A, $52, $52, $58

M12ASegData12:
	.byte $98, $48, $48, $48, $94, $7E, $48, $7E, $99, $48, $98 ; $AA89 - $AA98
	.byte $48, $48, $46, $46, $46, $94, $7E, $46, $7E, $99, $46, $98, $46, $46, $00, $98 ; $AA99 - $AAA8
	.byte $3A, $3A, $3A, $94, $34, $98, $3A, $3A, $94, $34, $3A, $34, $98, $3A, $38, $38 ; $AAA9 - $AAB8
	.byte $38, $94, $30, $98, $38, $38, $94, $30, $38, $30, $98, $38, $9A, $34, $99, $42 ; $AAB9 - $AAC8
	.byte $4C, $98, $7E, $42, $4C, $9A, $30, $99, $3E, $48, $98, $7E, $3E, $48, $98, $02 ; $AAC9 - $AAD8
	.byte $94, $02, $02, $00, $9A, $05, $99, $05, $05, $98, $7E, $05, $05, $00

M12ASegData15:
	.byte $B4, $7E ; $AAD9 - $AAE8
	.byte $B8, $7E, $B4, $48, $3E, $48, $B9, $4E, $B4, $52, $52, $52, $BC, $56, $00, $B4 ; $AAE9 - $AAF8
	.byte $7E, $B8, $7E, $B4, $38, $30, $38, $B9, $3E, $B4, $42, $42, $42, $BC, $46, $B4 ; $AAF9 - $AB08
	.byte $7E, $B8, $7E, $B4, $3E, $38, $3E, $B9, $44, $B4, $48, $48, $48, $BC, $4C, $B0 ; $AB09 - $AB18
	.byte $0F, $0F, $B8, $0F, $B8, $0E, $B4, $0E, $B8, $0E, $B4, $0E, $0E, $0E, $0E, $B0 ; $AB19 - $AB28
	.byte $0E, $0F, $0E, $0F, $0E, $0F, $0E, $0F, $0E, $0F, $B9, $0E

M12ASegData18:
	.byte $94, $50, $50, $50 ; $AB29 - $AB38
	.byte $98, $5E, $94, $5A, $54, $4C, $98, $56, $94, $7E, $32, $34, $26, $00, $94, $3E ; $AB39 - $AB48
	.byte $3E, $3E, $98, $4C, $94, $48, $42, $3C, $98, $46, $7E, $7E, $94, $42, $7E, $7E ; $AB49 - $AB58
	.byte $98, $34, $94, $34, $34, $3C, $3E, $7E, $7E, $32, $34, $26

M12ASegData13:
	.byte $B4, $38, $4C, $7E ; $AB59 - $AB68
	.byte $4C, $4C, $7E, $3A, $4E, $7E, $4E, $4E, $7E, $3C, $50, $7E, $50, $50, $7E, $52 ; $AB69 - $AB78
	.byte $7E, $BC, $52, $00, $B4, $20, $B8, $40, $B4, $40, $B8, $40, $B4, $22, $B8, $42 ; $AB79 - $AB88
	.byte $B4, $42, $B8, $42, $B4, $24, $B8, $44, $B4, $44, $B8, $44, $B4, $46, $7E, $BC ; $AB89 - $AB98
	.byte $46, $B4, $46, $5E, $7E, $5E, $5E, $7E, $48, $60, $7E, $60, $60, $7E, $4A, $62 ; $AB99 - $ABA8
	.byte $7E, $62, $62, $7E, $3E, $7E, $BC, $3E

M12ASegData14:
	.byte $B8, $7E, $98, $7E, $92, $50, $7E, $50 ; $ABA9 - $ABB8
	.byte $7E, $7E, $4C, $7E, $4C, $7E, $9B, $48, $00, $00, $9D, $44, $46, $48, $B4, $7E ; $ABB9 - $ABC8
	.byte $98, $7E, $92, $46, $7E, $46, $7E, $7E, $3A, $7E, $3A, $7E, $9B, $38, $B8, $7E ; $ABC9 - $ABD8
	.byte $82, $3E, $7E, $3E, $98, $7E, $92, $7E, $7E, $3E, $7E, $3E, $7E, $9B, $30, $7E ; $ABD9 - $ABE8
	.byte $B8, $7E, $98, $7E, $92, $05, $7E, $05, $7E, $7E, $05, $7E, $05, $7E, $98, $7E ; $ABE9 - $ABF8
	.byte $92, $7E, $7E, $08, $98, $09

M12ASegData19:
	.byte $B9, $50, $B4, $7E, $7E, $B0, $50, $50, $B4, $52 ; $ABF9 - $AC08
	.byte $50, $4C, $48, $3E, $48, $4C, $7E, $56, $B9, $56, $B4, $7E, $7E, $B0, $56, $56 ; $AC09 - $AC18
	.byte $B4, $56, $4C, $56, $58, $4E, $58, $5C, $52, $5C, $BC, $60, $00, $B9, $3E, $B4 ; $AC19 - $AC28
	.byte $7E, $7E, $B0, $3E, $3E, $B4, $42, $3E, $3A, $38, $30, $38, $3A, $7E, $46, $B9 ; $AC29 - $AC38
	.byte $46, $B4, $7E, $7E, $B0, $46, $46, $B4, $46, $3E, $46, $48, $40, $48, $4C, $44 ; $AC39 - $AC48
	.byte $4C, $BC, $50, $B9, $48, $B4, $7E, $7E, $B0, $48, $48, $B4, $48, $48, $42, $3E ; $AC49 - $AC58
	.byte $38, $3E, $42, $7E, $4C, $B9, $4C, $B4, $7E, $7E, $B0, $4C, $4C, $B4, $4C, $46 ; $AC59 - $AC68
	.byte $4C, $4E, $48, $4E, $52, $4C, $52, $BC, $56, $B9, $0E, $7E, $84, $0E, $0E, $0E ; $AC69 - $AC78
	.byte $0F, $0F, $0F, $88, $0E, $84, $0E, $80, $0E, $0E, $0E, $0E, $0E, $0E, $89, $0E ; $AC79 - $AC88
	.byte $0F, $0F, $0F, $B0, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $BA, $0F ; $AC89 - $AC98

M12ASegData05:
	.byte $9C, $7E, $7E, $7E, $7E, $7E, $7E, $7E, $7E, $00, $CA, $3E, $42, $46, $42, $4A ; $AC99 - $ACA8
	.byte $4C, $50, $4A, $4C, $5A, $56, $C8, $4C, $4E, $CB, $50, $C8, $46, $CA, $42, $40 ; $ACA9 - $ACB8
	.byte $94, $30, $48, $26, $3E, $30, $48, $26, $3E, $30, $48, $26, $3E, $30, $48, $26 ; $ACB9 - $ACC8
	.byte $3E, $34, $4C, $2A, $42, $34, $4C, $2A, $42, $34, $4C, $2A, $42, $34, $4C, $2A ; $ACC9 - $ACD8
	.byte $42, $2E, $46, $26, $3E, $2E, $46, $26, $3E, $2E, $46, $26, $3E, $2E, $46, $26 ; $ACD9 - $ACE8
	.byte $3E, $30, $48, $26, $3E, $30, $48, $26, $3E, $2E, $46, $26, $3E, $2E, $46, $26 ; $ACE9 - $ACF8
	.byte $3E, $94, $02, $06, $00, $98, $01, $02, $00

M12ASegData07:
	.byte $98, $7E, $28, $22, $7E, $98, $20 ; $ACF9 - $AD08
	.byte $94, $20, $22, $88, $7E, $7E, $00, $98, $7E, $1E, $18, $7E, $98, $16, $94, $16 ; $AD09 - $AD18
	.byte $18, $88, $7E, $7E, $A8, $3A, $84, $7E, $88, $3A, $A4, $30, $36, $38, $A8, $3A ; $AD19 - $AD28
	.byte $84, $7E, $88, $3A, $A4, $30, $36, $38, $94, $04, $02, $00, $94, $0A, $0B, $07 ; $AD29 - $AD38
	.byte $07, $00

M12ASegData06:
	.byte $B6, $7E, $B2, $7E, $86, $30, $82, $30, $B2, $7E, $7E, $18, $88, $30 ; $AD39 - $AD48
	.byte $8A, $7E, $B8, $7E, $86, $30, $82, $30, $B6, $7E, $B2, $7E, $86, $3A, $82, $3A ; $AD49 - $AD58
	.byte $B2, $7E, $7E, $22, $88, $3A, $8A, $7E, $B8, $7E, $86, $3A, $82, $3A, $00, $86 ; $AD59 - $AD68
	.byte $7E, $82, $7E, $86, $20, $82, $20, $88, $7E, $20, $8A, $7E, $88, $7E, $86, $20 ; $AD69 - $AD78
	.byte $82, $20, $86, $7E, $82, $7E, $86, $2A, $82, $2A, $82, $7E, $7E, $7E, $88, $2A ; $AD79 - $AD88
	.byte $8A, $7E, $88, $7E, $86, $2A, $82, $2A, $94, $30, $30, $30, $30, $88, $38, $3E ; $AD89 - $AD98
	.byte $98, $7E, $82, $7E, $7E, $30, $98, $38, $98, $3E, $94, $3A, $3A, $3A, $3A, $88 ; $AD99 - $ADA8
	.byte $42, $48, $98, $7E, $82, $7E, $7E, $3A, $98, $42, $98, $48, $98, $02, $92, $06 ; $ADA9 - $ADB8
	.byte $01, $02, $00, $98, $01, $03, $00

M12ASegData08:
	.byte $8D, $7E, $7E, $7E, $9A, $7E, $00, $8D, $08 ; $ADB9 - $ADC8
	.byte $08, $08, $98, $08, $08

M12ASegData0A:
	.byte $95, $7E, $8E, $7E, $8D, $4E, $84, $50, $7E, $7E, $88 ; $ADC9 - $ADD8
	.byte $50, $84, $7E, $89, $7E, $84, $50, $85, $7E, $8E, $7E, $8D, $4E, $84, $50, $7E ; $ADD9 - $ADE8
	.byte $95, $7E, $8E, $7E, $8D, $50, $84, $52, $7E, $7E, $88, $52, $84, $7E, $89, $7E ; $ADE9 - $ADF8
	.byte $84, $52, $85, $7E, $8E, $7E, $8D, $50, $84, $52, $7E, $00, $CA, $46, $42, $40 ; $ADF9 - $AE08
	.byte $42, $48, $46, $44, $46, $99, $30, $84, $26, $89, $26, $84, $30, $99, $30, $84 ; $AE09 - $AE18
	.byte $26, $89, $26, $84, $30, $99, $34, $84, $2A, $89, $2A, $84, $34, $99, $34, $84 ; $AE19 - $AE28
	.byte $2A, $89, $2A, $84, $34, $94, $02, $02, $06, $02, $02, $06, $02, $02, $06, $02 ; $AE29 - $AE38
	.byte $02, $06, $02, $02, $06, $02, $00, $98, $01, $84, $03, $01, $01, $88, $03, $84 ; $AE39 - $AE48
	.byte $01, $99, $03, $84, $03, $88, $01, $84, $03, $01, $00

M12ASegData0B:
	.byte $95, $7E, $8E, $7E, $8D ; $AE49 - $AE58
	.byte $54, $84, $56, $7E, $7E, $88, $56, $84, $7E, $89, $7E, $84, $54, $85, $7E, $8E ; $AE59 - $AE68
	.byte $7E, $8D, $52, $84, $54, $7E, $95, $7E, $8E, $7E, $8D, $50, $84, $52, $7E, $7E ; $AE69 - $AE78
	.byte $88, $52, $84, $7E, $89, $7E, $84, $52, $85, $7E, $8E, $7E, $8D, $50, $84, $52 ; $AE79 - $AE88
	.byte $7E, $00, $CA, $4C, $48, $46, $42, $48, $46, $42, $40, $99, $38, $84, $2E, $89 ; $AE89 - $AE98
	.byte $2E, $84, $38, $99, $36, $84, $2A, $89, $2A, $84, $36, $99, $34, $84, $2A, $89 ; $AE99 - $AEA8
	.byte $2A, $84, $34, $2E, $7E, $88, $2E, $7E, $84, $7E, $2E, $94, $02, $02, $06, $02 ; $AEA9 - $AEB8
	.byte $02, $06, $02, $02, $06, $02, $02, $06, $02, $02, $06, $02, $94, $02, $02, $06 ; $AEB9 - $AEC8
	.byte $02, $02, $06, $02, $02, $98, $06, $89, $06, $8D, $02, $02, $02, $88, $06, $00 ; $AEC9 - $AED8
	.byte $98, $01, $84, $03, $01, $01, $88, $03, $84, $01, $99, $03, $84, $03, $88, $01 ; $AED9 - $AEE8
	.byte $84, $03, $01, $98, $01, $84, $03, $01, $01, $88, $03, $84, $01, $98, $01, $89 ; $AEE9 - $AEF8
	.byte $7E, $84, $01, $88, $02

M12ASegData0D:
	.byte $9C, $7E, $7E, $00, $9C, $7E, $7E, $98, $30, $32, $34 ; $AEF9 - $AF08
	.byte $36, $38, $26, $2C, $2E, $98, $02, $92, $02, $01, $02, $00

M12ASegData0E:
	.byte $8A, $22, $2E, $2C ; $AF09 - $AF18
	.byte $20, $28, $34, $32, $24, $00, $8A, $18, $24, $22, $14, $1E, $2A, $28, $1A, $8A ; $AF19 - $AF28
	.byte $3A, $46, $44, $38, $40, $4C, $4A, $3C, $94, $01, $90, $01, $01, $7E, $01, $01 ; $AF29 - $AF38
	.byte $01, $00

M12ASegData09:
	.byte $98, $3E, $3E, $42, $42, $46, $92, $46, $7E, $42, $7E, $7E, $40, $98 ; $AF39 - $AF48
	.byte $42, $3E, $3E, $42, $92, $42, $7E, $46, $9C, $7E, $98, $48, $48, $4C, $4C, $50 ; $AF49 - $AF58
	.byte $92, $50, $7E, $4C, $7E, $7E, $4A, $98, $4C, $48, $48, $4C, $92, $4C, $7E, $50 ; $AF59 - $AF68
	.byte $9C, $7E, $00, $92, $38, $7E, $30, $98, $38, $92, $38, $7E, $30, $98, $38, $92 ; $AF69 - $AF78
	.byte $38, $7E, $30, $38, $7E, $38, $7E, $7E, $36, $98, $38, $92, $38, $7E, $30, $98 ; $AF79 - $AF88
	.byte $38, $92, $38, $7E, $30, $38, $7E, $38, $9C, $7E, $92, $42, $7E, $3A, $98, $42 ; $AF89 - $AF98
	.byte $92, $42, $7E, $3A, $98, $42, $92, $42, $7E, $3A, $42, $7E, $42, $7E, $7E, $40 ; $AF99 - $AFA8
	.byte $98, $42, $92, $42, $7E, $3A, $98, $42, $92, $42, $7E, $3A, $42, $7E, $42, $9C ; $AFA9 - $AFB8
	.byte $7E, $88, $30, $30, $82, $7E, $7E, $30, $2A, $7E, $30, $88, $7E, $34, $38, $7E ; $AFB9 - $AFC8
	.byte $88, $30, $30, $82, $7E, $7E, $30, $2A, $7E, $30, $8C, $7E, $88, $3A, $3A, $82 ; $AFC9 - $AFD8
	.byte $7E, $7E, $3A, $34, $7E, $3A, $88, $7E, $3E, $42, $7E, $88, $3A, $3A, $82, $7E ; $AFD9 - $AFE8
	.byte $7E, $3A, $34, $7E, $3A, $8C, $7E, $98, $02, $92, $02, $01, $02, $98, $02, $92 ; $AFE9 - $AFF8
	.byte $02, $01, $02, $98, $02, $92, $02, $01, $02, $02, $01, $06, $02, $01, $02, $00 ; $0FF9 - $1008
	.byte $8A, $01, $8D, $02, $82, $01, $8A, $01, $8D, $02, $82, $01, $8A, $01, $88, $02 ; $B009 - $B018
	.byte $86, $05, $82, $05, $8A, $01, $8D, $02, $82, $01, $00

M12ASegData0C:
	.byte $98, $3E, $3E, $42, $42 ; $B019 - $B028
	.byte $46, $92, $46, $7E, $42, $7E, $7E, $40, $98, $42, $92, $48, $7E, $48, $9A, $7E ; $B029 - $B038
	.byte $92, $48, $7E, $48, $9C, $7E, $00, $92, $38, $7E, $30, $98, $38, $92, $38, $7E ; $B039 - $B048
	.byte $30, $98, $38, $92, $38, $7E, $30, $38, $7E, $38, $7E, $7E, $36, $98, $38, $92 ; $B049 - $B058
	.byte $38, $7E, $38, $9A, $7E, $92, $38, $7E, $38, $8C, $7E, $88, $30, $30, $82, $7E ; $B059 - $B068
	.byte $7E, $30, $2A, $7E, $30, $88, $7E, $34, $38, $7E, $82, $30, $7E, $30, $8A, $7E ; $B069 - $B078
	.byte $82, $30, $7E, $30, $8C, $7E, $98, $02, $92, $02, $01, $02, $98, $02, $92, $02 ; $B079 - $B088
	.byte $01, $02, $98, $02, $92, $02, $01, $02, $02, $01, $06, $02, $01, $02, $8A, $01 ; $B089 - $B098
	.byte $86, $01, $82, $01, $06, $01, $06, $02, $01, $02, $88, $02, $8A, $06, $00, $8A ; $B099 - $B0A8
	.byte $01, $8D, $02, $82, $01, $8A, $01, $8D, $02, $82, $01, $88, $01, $86, $01, $82 ; $B0A9 - $B0B8
	.byte $01, $86, $02, $88, $01, $82, $01, $8A, $01, $86, $0A, $88, $0B, $82, $01, $00 ; $B0B9 - $B0C8

M12ASegData0F:
	.byte $D8, $6E, $5E, $66, $5E, $6E, $5E, $66, $6A, $70, $60, $68, $60, $70, $60, $68 ; $B0C9 - $B0D8
	.byte $6C, $00, $D4, $7E, $D8, $56, $56, $56, $56, $56, $56, $56, $56, $58, $58, $58 ; $B0D9 - $B0E8
	.byte $58, $58, $58, $58, $58, $9C, $7E, $7E, $7E, $7E, $9C, $01, $89, $01, $8D, $02 ; $B0E9 - $B0F8
	.byte $02, $02, $8A, $01, $00, $8A, $7E, $01, $89, $01, $8D, $03, $03, $03, $8A, $7E ; $B0F9 - $B108
	.byte $00

M12ASegData10:
	.byte $D2, $7E, $7E, $30, $36, $7E, $DB, $3A, $D2, $7E, $7E, $7E, $DD, $3A, $3C ; $B109 - $B118
	.byte $D2, $3A, $7E, $36, $30, $7E, $2C, $00, $D2, $7E, $7E, $26, $2C, $7E, $DB, $30 ; $B119 - $B128
	.byte $D2, $7E, $7E, $7E, $DD, $30, $32, $D2, $30, $7E, $2C, $26, $7E, $22

M12ASegData11:
	.byte $D2, $7E ; $B129 - $B138
	.byte $7E, $30, $36, $7E, $DB, $3A, $D2, $7E, $7E, $7E, $92, $48, $4C, $7E, $98, $4E ; $B139 - $B148
	.byte $82, $7E, $00, $D2, $7E, $7E, $26, $2C, $7E, $DB, $30, $D2, $7E, $7E, $7E, $92 ; $B149 - $B158
	.byte $3E, $42, $7E, $98, $44, $82, $7E, $D2, $7E, $7E, $30, $36, $7E, $D9, $3A, $7E ; $B159 - $B168
	.byte $D2, $7E, $8C, $7E, $7E, $88, $02, $82, $06, $01, $02, $88, $02, $82, $06, $01 ; $B169 - $B178
	.byte $02, $88, $02, $82, $06, $01, $02, $88, $02, $82, $06, $01, $02, $00, $88, $01 ; $B179 - $B188
	.byte $86, $7E, $88, $7E, $82, $7E, $88, $03, $7E, $03, $7E, $03, $00


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INSTRUMENT PATCHES
; For music playback:
; These define values for a given patch value and note length, which properly
; configure square wave generators for a given note length.  Note that the PatL
; sets are used when the current track rest rate is >= 19, otherwise the PatS
; values are used in place.  These tables just define bytes supplied to the
; respective PAPU_CTLx register to configure the waveform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PatL1:	.byte $90, $92, $94, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $96, $96, $15, $17, $58, $1A

PatS1:	.byte $90, $92, $94, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95, $95
	.byte $95, $96, $96, $15, $17, $58, $1A

PatL2:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50
	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50
	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $51, $51, $51, $51, $51, $51
	.byte $52, $52, $52, $53, $53, $53, $54, $54, $55, $55, $56, $56, $57, $58, $59, $1A

PatS2:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $51, $51, $51, $52, $52
	.byte $53, $54, $55, $56, $57, $59, $1A

PatL3:	.byte $90, $91, $91, $91, $92, $92, $92, $93, $93, $94, $94, $94, $94, $95, $95, $95
	.byte $95, $96, $96, $96, $97, $97, $97, $97, $97, $97, $97, $98, $98, $98, $98, $98
	.byte $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98, $98
	.byte $98, $98, $98, $98, $98, $98, $98, $98, $99, $99, $99, $9A, $9A, $99, $98, $97

PatS3:	.byte $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $91, $91, $91, $93, $95
	.byte $97, $98, $99, $9A, $9A, $99, $98

	.byte $97	; ?? A mistake?

PatL4:	.byte $94, $95, $95, $95, $95, $95, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96
	.byte $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96
	.byte $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $96
	.byte $96, $96, $96, $96, $96, $96, $96, $96, $96, $96, $97, $97, $97, $98, $98, $98

PatS4:	.byte $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90, $90
	.byte $90, $90, $97, $97, $98, $98, $98

PatS5:	.byte $51, $51, $52, $52, $53, $53, $53, $54, $54, $55, $56, $57, $57, $57, $57, $56
	.byte $56, $56, $55, $55, $54, $53, $53

PatL5:	.byte $51, $51, $51, $51, $51, $51, $52, $52, $52, $52, $52, $52, $52, $52, $52, $52
	.byte $52, $52, $52, $52, $52, $53, $53, $53, $53, $53, $54, $54, $54, $54, $54, $54
	.byte $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $56, $56, $56, $56, $57, $57
	.byte $57, $57, $57, $57, $57, $57, $57, $57, $56, $56, $56, $55, $55, $54, $53, $53

PatS6:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $51, $51, $52, $53
	.byte $54, $55, $56, $57, $58, $59, $5A

PatL6:	.byte $50, $50, $50, $51, $51, $51, $51, $51, $51, $51, $51, $51, $52, $52, $52, $53
	.byte $50, $50, $51, $51, $51, $51, $52, $52, $52, $52, $53, $53, $53, $54, $54, $55
	.byte $50, $51, $51, $52, $52, $52, $53, $53, $53, $54, $54, $55, $55, $56, $56, $57
	.byte $51, $52, $52, $52, $53, $53, $54, $54, $55, $55, $56, $56, $57, $58, $59, $5A


PatL8:	.byte $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50, $50 
	.byte $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51
	.byte $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51
	.byte $51, $51, $51, $51, $51, $51, $52, $53, $54, $55, $56, $57, $58, $19, $DA, $9B 

PatS8:	.byte $50, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $51, $52, $53, $54
	.byte $55, $56, $57, $58, $19, $DA, $9B

	.byte $15, $07, $C8, $E8, $E0, $03, $D0, $F4

M2BSH .func \1-Music_Set2B_Headers	; "Music Set 2B Segment Header Offset"


	; Each "index" of music is tied to a header of a "segment" of music.  Some segments are
	; reused where repetitious musical notes exist.  The segment headers are apparently not
	; stored in any particular order.  This table connects an index to a header:
Music_Set2B_IndexOffs:
	.byte M2BSH(M2BSegHedr0F), M2BSH(M2BSegHedr10), M2BSH(M2BSegHedr11), M2BSH(M2BSegHedr10)	; Index $00-$03
	.byte M2BSH(M2BSegHedr12), M2BSH(M2BSegHedr13), M2BSH(M2BSegHedr14), M2BSH(M2BSegHedr1B)	; Index $04-$07
	.byte M2BSH(M2BSegHedr0C), M2BSH(M2BSegHedr0D), M2BSH(M2BSegHedr0D), M2BSH(M2BSegHedr0E)	; Index $08-$0B
	.byte M2BSH(M2BSegHedr08), M2BSH(M2BSegHedr08), M2BSH(M2BSegHedr09), M2BSH(M2BSegHedr1C)	; Index $0C-$0F
	.byte M2BSH(M2BSegHedr1D), M2BSH(M2BSegHedr1D), M2BSH(M2BSegHedr1E), M2BSH(M2BSegHedr0A)	; Index $10-$13
	.byte M2BSH(M2BSegHedr0B), M2BSH(M2BSegHedr17), M2BSH(M2BSegHedr18), M2BSH(M2BSegHedr18)	; Index $14-$17
	.byte M2BSH(M2BSegHedr19), M2BSH(M2BSegHedr19), M2BSH(M2BSegHedr1A), M2BSH(M2BSegHedr15)	; Index $18-$1B
	.byte M2BSH(M2BSegHedr15), M2BSH(M2BSegHedr16), M2BSH(M2BSegHedr00), M2BSH(M2BSegHedr01)	; Index $1C-$1F
	.byte M2BSH(M2BSegHedr02), M2BSH(M2BSegHedr03), M2BSH(M2BSegHedr04), M2BSH(M2BSegHedr05)	; Index $20-$23
	.byte M2BSH(M2BSegHedr06), M2BSH(M2BSegHedr05), M2BSH(M2BSegHedr07), M2BSH(M2BSegHedr1F)	; Index $24-$27
	.byte M2BSH(M2BSegHedr20), M2BSH(M2BSegHedr21), M2BSH(M2BSegHedr22), M2BSH(M2BSegHedr23)	; Index $28-$2B
	.byte M2BSH(M2BSegHedr24)	; Index $2C



Music_Set2B_Headers:
	; The following is all of the segment headers for Set 2B music.
	; Tempo, Track Base Offset, Triangle offset, Square 1 offset, Noise offset, DCM offset (Square 2 is always assumed @ 0)
	; Note that Triangle, Noise, and DCM tracks are allowed to be disabled by using an offset of 0, but Squares 1/2 are not.
	; Of course, this wouldn't be hard to implement or anything, it's just the way it was coded...
M2BSegHedr00:	MusSeg $30, M2BSegData00, $21, $11, $00, $00
M2BSegHedr01:	MusSeg $30, M2BSegData01, $32, $15, $73, $83
M2BSegHedr02:	MusSeg $30, M2BSegData02, $23, $12, $32, $42
M2BSegHedr03:	MusSeg $30, M2BSegData01, $32, $29, $73, $83
M2BSegHedr04:	MusSeg $30, M2BSegData03, $52, $29, $7B, $8B
M2BSegHedr05:	MusSeg $30, M2BSegData04, $26, $15, $68, $6E
M2BSegHedr06:	MusSeg $30, M2BSegData05, $23, $13, $32, $38
M2BSegHedr07:	MusSeg $30, M2BSegData06, $36, $1C, $46, $59
M2BSegHedr08:	MusSeg $00, M2BSegData07, $1F, $10, $00, $2E
M2BSegHedr09:	MusSeg $00, M2BSegData08, $15, $0A, $00, $1E
M2BSegHedr0A:	MusSeg $00, M2BSegData09, $19, $0D, $00, $29
M2BSegHedr0B:	MusSeg $00, M2BSegData0A, $51, $29, $7D, $88
M2BSegHedr0C:	MusSeg $00, M2BSegData0B, $19, $0D, $00, $00
M2BSegHedr0D:	MusSeg $00, M2BSegData0C, $37, $1C, $B2, $B8
M2BSegHedr0E:	MusSeg $00, M2BSegData0D, $39, $1D, $5A, $60
M2BSegHedr0F:	MusSeg $30, M2BSegData0E, $29, $18, $41, $45
M2BSegHedr10:	MusSeg $30, M2BSegData0F, $54, $2C, $AF, $BE
M2BSegHedr11:	MusSeg $30, M2BSegData10, $50, $2B, $95, $A4
M2BSegHedr12:	MusSeg $30, M2BSegData11, $21, $12, $2F, $48
M2BSegHedr13:	MusSeg $30, M2BSegData12, $69, $35, $7A, $89
M2BSegHedr14:	MusSeg $30, M2BSegData13, $5F, $30, $72, $81
M2BSegHedr15:	MusSeg $00, M2BSegData14, $27, $14, $00, $70
M2BSegHedr16:	MusSeg $00, M2BSegData15, $27, $14, $00, $38
M2BSegHedr17:	MusSeg $30, M2BSegData16, $0D, $07, $00, $13
M2BSegHedr18:	MusSeg $30, M2BSegData17, $2B, $00, $3C, $42
M2BSegHedr19:	MusSeg $30, M2BSegData18, $28, $16, $39, $3F
M2BSegHedr1A:	MusSeg $30, M2BSegData19, $43, $22, $64, $85
M2BSegHedr1B:	MusSeg $50, M2BSegData1A, $4B, $00, $AE, $95
M2BSegHedr1C:	MusSeg $40, M2BSegData1B, $31, $19, $3C, $59
M2BSegHedr1D:	MusSeg $40, M2BSegData1C, $45, $23, $5C, $62
M2BSegHedr1E:	MusSeg $40, M2BSegData1D, $45, $23, $64, $6A
M2BSegHedr1F:	MusSeg $70, M2BSegData1E, $1B, $0E, $28, $00
M2BSegHedr20:	MusSeg $70, M2BSegData1F, $43, $22, $6E, $78
M2BSegHedr21:	MusSeg $70, M2BSegData1F, $48, $22, $6E, $78
M2BSegHedr22:	MusSeg $70, M2BSegData1F, $53, $22, $6E, $78
M2BSegHedr23:	MusSeg $70, M2BSegData1F, $65, $22, $6E, $78
M2BSegHedr24:	MusSeg $40, M2BSegData1B, $31, $19, $00, $00

	; Music in Set 2B is played by "index", which is a segment of music.
	; The index always advances, though what that index actually represents
	; may be a reused segment of music.

	; These three LUTs are to be read vertically for each Set 2B song to
	; be played ($10, $20, $30, ... $C0), so that song $10 uses a start
	; index of $00, an end index of $06, and a loop index of $01.
Music_Set2B_Starts:
	.byte $00, $07, $08, $0C, $0F, $13, $15, $1B, $1E, $1B, $27, $2C

Music_Set2B_Ends:
	.byte $06, $07, $0B, $0E, $12, $14, $1A, $1D, $26, $1D, $2B, $2C

Music_Set2B_Loops:
	.byte $01, $07, $09, $0C, $10, $13, $18, $1B, $1F, $1B, $28, $2C


	; These are Set 2B music segments.  Note that more exist on page 29.

M2BSegData0E:
	.byte $A2, $26, $7E, $92, $3E ; $B549 - $B558
	.byte $56, $7E, $98, $52, $92, $42, $44, $7E, $98, $46, $93, $7E, $7E, $7E, $56, $98 ; $B559 - $B568
	.byte $6E, $7E, $00, $A2, $16, $7E, $92, $2E, $46, $7E, $98, $42, $92, $30, $32, $7E ; $B569 - $B578
	.byte $98, $34, $9C, $7E, $A2, $3E, $7E, $92, $3E, $4C, $7E, $98, $48, $92, $3A, $3C ; $B579 - $B588
	.byte $7E, $98, $3E, $93, $7E, $7E, $7E, $7E, $98, $7E, $3E, $00, $98, $01, $02, $00 ; $B589 - $B598
	.byte $9A, $01, $05, $88, $05, $86, $7E, $8D, $08, $08, $98, $08, $96, $08, $92, $05 ; $B599 - $B5A8

M2BSegData0F:
	.byte $92, $7E, $7E, $50, $7E, $93, $7E, $4E, $98, $50, $92, $7E, $7E, $93, $4E, $98 ; $B5A9 - $B5B8
	.byte $50, $92, $42, $7E, $98, $48, $7E, $93, $7E, $00

M2BSegData10:
	.byte $92, $7E, $7E, $50, $7E, $93 ; $B5B9 - $B5C8
	.byte $7E, $4E, $96, $50, $50, $97, $48, $98, $4C, $9B, $7E, $00, $92, $7E, $7E, $3E ; $B5C9 - $B5D8
	.byte $7E, $93, $7E, $3E, $98, $3E, $92, $7E, $7E, $93, $3E, $98, $3E, $92, $3A, $7E ; $B5D9 - $B5E8
	.byte $98, $38, $7E, $93, $7E, $92, $7E, $7E, $3E, $7E, $93, $7E, $3E, $96, $3E, $3E ; $B5E9 - $B5F8
	.byte $97, $3E, $9C, $3A, $98, $7E, $96, $7E, $92, $30, $98, $38, $98, $3E, $98, $7E ; $B5F9 - $B608
	.byte $96, $7E, $92, $3A, $96, $2A, $92, $2A, $98, $30, $98, $7E, $96, $7E, $92, $30 ; $B609 - $B618
	.byte $98, $38, $98, $3E, $98, $7E, $96, $7E, $92, $26, $96, $2E, $92, $2E, $98, $34 ; $B619 - $B628

M2BSegData11:
	.byte $92, $7E, $7E, $50, $7E, $93, $7E, $50, $96, $50, $3E, $97, $42, $98, $48, $9B ; $B629 - $B638
	.byte $7E, $00, $92, $7E, $7E, $3E, $7E, $93, $7E, $3E, $96, $3E, $34, $97, $34, $9C ; $B639 - $B648
	.byte $38, $98, $7E, $96, $7E, $92, $30, $98, $38, $98, $26, $98, $30, $9B, $7E, $98 ; $B649 - $B658
	.byte $02, $92, $02, $01, $93, $02, $98, $01, $92, $02, $01, $93, $02, $00, $98, $7E ; $B659 - $B668
	.byte $96, $05, $92, $05, $98, $7E, $08, $00, $98, $7E, $96, $05, $92, $05, $98, $7E ; $B669 - $B678
	.byte $98, $08, $98, $7E, $96, $05, $92, $05, $92, $09, $9D, $09, $94, $09, $98, $08 ; $B679 - $B688
	.byte $00

M2BSegData12:
	.byte $92, $42, $7E, $42, $48, $7E, $48, $93, $7E, $7E, $6A, $98, $5A, $92, $3E ; $B689 - $B698
	.byte $7E, $3E, $48, $7E, $48, $93, $7E, $7E, $68, $98, $56, $92, $3A, $7E, $3A, $42 ; $B699 - $B6A8
	.byte $7E, $42, $93, $7E, $7E, $64, $98, $52, $92, $38, $7E, $38, $3E, $7E, $3E, $93 ; $B6A9 - $B6B8
	.byte $7E, $7E, $60, $98, $50, $00, $92, $3A, $7E, $3A, $42, $7E, $42, $93, $7E, $7E ; $B6B9 - $B6C8
	.byte $3A, $98, $2A, $92, $38, $7E, $38, $3E, $7E, $3E, $93, $7E, $7E, $38, $98, $26 ; $B6C9 - $B6D8
	.byte $92, $34, $7E, $34, $3A, $7E, $3A, $93, $7E, $7E, $34, $98, $22, $92, $30, $7E ; $B6D9 - $B6E8
	.byte $30, $38, $7E, $38, $93, $7E, $7E, $30, $98, $20, $98, $3A, $3A, $7E, $7E, $38 ; $B6E9 - $B6F8
	.byte $38, $7E, $7E, $34, $34, $7E, $7E, $30, $30, $7E, $7E, $98, $02, $92, $02, $01 ; $B6F9 - $B708
	.byte $93, $02, $98, $01, $92, $02, $01, $93, $02, $00, $98, $7E, $96, $05, $92, $05 ; $B709 - $B718
	.byte $98, $7E, $08, $00

M2BSegData13:
	.byte $92, $42, $7E, $42, $48, $7E, $48, $93, $7E, $7E, $6A, $98 ; $B719 - $B728
	.byte $5A, $92, $42, $7E, $42, $48, $7E, $48, $93, $7E, $7E, $6C, $98, $5A, $92, $46 ; $B729 - $B738
	.byte $7E, $46, $48, $7E, $48, $4A, $7E, $4A, $4C, $93, $7E, $4C, $7E, $7E, $56, $98 ; $B739 - $B748
	.byte $7E, $9A, $56, $00, $92, $3A, $7E, $3A, $42, $7E, $42, $93, $7E, $7E, $3A, $98 ; $B749 - $B758
	.byte $2A, $92, $3C, $7E, $3C, $42, $7E, $42, $93, $7E, $7E, $3C, $98, $2A, $92, $34 ; $B759 - $B768
	.byte $7E, $34, $38, $7E, $38, $3A, $7E, $3A, $3C, $93, $7E, $3C, $7E, $7E, $46, $98 ; $B769 - $B778
	.byte $7E, $9A, $46, $98, $3A, $3A, $9A, $7E, $98, $3C, $3C, $9A, $7E, $98, $3E, $42 ; $B779 - $B788
	.byte $44, $46, $3E, $7E, $9A, $2E, $98, $02, $92, $02, $01, $93, $02, $98, $01, $92 ; $B789 - $B798
	.byte $02, $01, $93, $02, $00, $98, $7E, $96, $05, $92, $05, $98, $7E, $08, $98, $7E ; $B799 - $B7A8
	.byte $96, $05, $92, $05, $98, $7E, $08, $98, $7E, $96, $05, $92, $05, $98, $7E, $08 ; $B7A9 - $B7B8
	.byte $98, $7E, $96, $7E, $9D, $08, $08, $98, $08, $08

M2BSegData1E:
	.byte $84, $38, $7E, $38, $38, $7E ; $B7B9 - $B7C8
	.byte $38, $38, $38, $3E, $7E, $3E, $7E, $00, $84, $2A, $7E, $2A, $2A, $7E, $2A, $2A ; $B7C9 - $B7D8
	.byte $2A, $30, $7E, $30, $7E, $84, $5E, $7E, $5E, $5E, $7E, $5E, $5E, $5E, $64, $7E ; $B7D9 - $B7E8
	.byte $64, $7E, $84, $06, $01, $04, $06, $01, $04, $04, $04, $04, $01, $04, $01

M2BSegData1F:
	.byte $84 ; $B7E9 - $B7F8
	.byte $12, $7E, $20, $2A, $7E, $20, $2A, $20, $12, $7E, $20, $2A, $7E, $20, $2A, $20 ; $B7F9 - $B808
	.byte $14, $7E, $22, $2C, $7E, $22, $2C, $22, $14, $7E, $22, $2C, $7E, $22, $2C, $22 ; $B809 - $B818
	.byte $00, $84, $12, $7E, $20, $38, $7E, $20, $38, $20, $12, $7E, $20, $38, $7E, $20 ; $B819 - $B828
	.byte $38, $20, $14, $7E, $22, $3A, $7E, $22, $3A, $22, $14, $7E, $22, $3A, $7E, $22 ; $B829 - $B838
	.byte $3A, $22, $9C, $7E, $7E, $7E, $7E, $8C, $7E, $7E, $7E, $8A, $7E, $84, $7E, $50 ; $B839 - $B848
	.byte $5A, $68, $8C, $5E, $8A, $7E, $84, $7E, $7E, $60, $64, $8C, $6E, $8A, $7E, $84 ; $B849 - $B858
	.byte $7E, $6A, $68, $64, $84, $68, $5E, $9C, $68, $7E, $7E, $8B, $7E, $94, $04, $04 ; $B859 - $B868
	.byte $06, $04, $04, $04, $04, $06, $00, $94, $06, $06, $05, $06, $06, $07, $0C, $05 ; $B869 - $B878
	.byte $00

M2BSegData16:
	.byte $88, $30, $36, $3A, $8C, $3C, $00, $88, $20, $26, $2A, $8C, $32, $88, $26 ; $B879 - $B888
	.byte $2C, $30, $8C, $3C, $9B, $7E, $90, $0E, $0F, $0E, $0F, $0E, $0F, $0E, $0F, $0E ; $B889 - $B898
	.byte $0F, $90, $0E, $0F, $0E, $0F, $0E, $0F, $0E, $0F, $0E, $0F

M2BSegData17:
	.byte $8C, $7E, $00

M2BSegData18:
	.byte $94 ; $B899 - $B8A8
	.byte $36, $38, $36, $38, $34, $30, $2A, $98, $30, $94, $30, $90, $36, $34, $98, $30 ; $B8A9 - $B8B8
	.byte $94, $2A, $98, $30, $00, $94, $2E, $30, $2E, $30, $2A, $2A, $22, $98, $20, $94 ; $B8B9 - $B8C8
	.byte $20, $94, $24, $98, $20, $99, $7E, $84, $30, $30, $36, $38, $3A, $3A, $40, $42 ; $B8C9 - $B8D8
	.byte $30, $30, $36, $38, $3A, $3A, $42, $48, $84, $02, $02, $06, $02, $00, $98, $01 ; $B8D9 - $B8E8
	.byte $94, $02, $01, $00

M2BSegData19:
	.byte $94, $3E, $3E, $42, $44, $46, $3E, $7E, $3E, $3A, $3A, $38 ; $B8E9 - $B8F8
	.byte $3A, $7E, $30, $34, $30, $36, $36, $34, $36, $34, $30, $2A, $30, $7E, $3E, $3E ; $B8F9 - $B908
	.byte $3E, $3E, $3E, $3E, $3E, $00, $94, $2E, $2E, $30, $32, $34, $2E, $7E, $2E, $2A ; $B909 - $B918
	.byte $2A, $26, $2A, $7E, $22, $22, $22, $26, $26, $26, $26, $22, $22, $22, $20, $7E ; $B919 - $B928
	.byte $2E, $2E, $2E, $30, $30, $34, $34, $84, $3E, $3E, $44, $46, $4C, $4C, $50, $56 ; $B929 - $B938
	.byte $3A, $3A, $40, $42, $48, $48, $4C, $52, $30, $30, $36, $38, $3A, $3A, $40, $42 ; $B939 - $B948
	.byte $7E, $3E, $3E, $3E, $42, $42, $46, $46, $84, $02, $02, $06, $02, $02, $02, $06 ; $B949 - $B958
	.byte $02, $02, $02, $06, $02, $02, $02, $06, $02, $02, $02, $06, $02, $02, $02, $06 ; $B959 - $B968
	.byte $02, $02, $02, $02, $02, $02, $02, $02, $02, $98, $01, $94, $02, $01, $98, $01 ; $B969 - $B978
	.byte $94, $02, $01, $98, $01, $94, $02, $01, $98, $01, $94, $02, $01, $98, $01, $94 ; $B979 - $B988
	.byte $02, $01, $98, $01, $94, $02, $01, $98, $01, $94, $02, $01, $01, $06, $88, $07 ; $B989 - $B998

M2BSegData00:
	.byte $94, $6C, $6E, $6E, $6E, $54, $56, $56, $56, $3C, $3E, $3C, $3E, $98, $3E, $26 ; $B999 - $B9A8
	.byte $00, $94, $66, $68, $68, $68, $4E, $50, $50, $50, $36, $38, $36, $38, $98, $26 ; $B9A9 - $B9B8
	.byte $0E, $9A, $7E, $7E, $7E, $98, $7E, $3E

M2BSegData01:
	.byte $94, $54, $56, $56, $54, $56, $56, $54 ; $B9B9 - $B9C8
	.byte $56, $5A, $58, $5A, $98, $5C, $FF, $5E, $94, $5A, $56, $52, $00, $94, $4E, $50 ; $B9C9 - $B9D8
	.byte $50, $4E, $50, $50, $4E, $50, $52, $50, $52, $98, $54, $FF, $56, $94, $52, $50 ; $B9D9 - $B9E8
	.byte $4C, $CA, $48, $46, $42, $3E, $48, $46, $42, $46, $94, $30, $48, $30, $48, $38 ; $B9E9 - $B9F8
	.byte $50, $38, $50, $3A, $52, $3A, $3E, $9A, $7E

M2BSegData02:
	.byte $94, $54, $56, $56, $54, $56, $56 ; $B9F9 - $BA08
	.byte $54, $56, $5A, $58, $5A, $5E, $7E, $64, $98, $6E, $00, $94, $4E, $50, $50, $4E ; $BA09 - $BA18
	.byte $50, $50, $4E, $50, $52, $50, $52, $56, $7E, $60, $98, $6C, $94, $30, $48, $30 ; $BA19 - $BA28
	.byte $48, $38, $50, $38, $50, $3A, $52, $3A, $3E, $9A, $7E, $94, $02, $02, $02, $02 ; $BA29 - $BA38
	.byte $02, $02, $02, $02, $02, $02, $02, $06, $9A, $01, $00, $94, $01, $98, $05, $05 ; $BA39 - $BA48
	.byte $05, $05, $94, $05, $05, $99, $05, $98, $05, $00

M2BSegData03:
	.byte $94, $50, $52, $56, $98, $5A ; $BA49 - $BA58
	.byte $C4, $56, $52, $50, $94, $4C, $50, $52, $98, $56, $C4, $52, $50, $4C, $94, $48 ; $BA59 - $BA68
	.byte $4C, $50, $98, $52, $C4, $50, $4C, $46, $99, $48, $98, $28, $94, $2C, $26, $48 ; $BA69 - $BA78
	.byte $46, $44, $00, $94, $48, $4C, $50, $98, $52, $C4, $50, $4C, $48, $94, $46, $48 ; $BA79 - $BA88
	.byte $4C, $98, $50, $C4, $4C, $48, $46, $94, $42, $46, $48, $98, $4C, $C4, $48, $46 ; $BA89 - $BA98
	.byte $3A, $94, $38, $7E, $7E, $98, $3A, $94, $3E, $38, $99, $7E, $94, $42, $7E, $7E ; $BA99 - $BAA8
	.byte $88, $34, $84, $34, $34, $34, $94, $3E, $7E, $7E, $88, $30, $84, $30, $30, $30 ; $BAA9 - $BAB8
	.byte $94, $3A, $7E, $7E, $88, $34, $84, $34, $3E, $3E, $94, $30, $7E, $7E, $98, $32 ; $BAB9 - $BAC8
	.byte $94, $36, $30, $99, $7E, $94, $02, $02, $02, $02, $02, $02, $02, $02, $02, $02 ; $BAC9 - $BAD8
	.byte $02, $06, $9A, $01, $00, $94, $05, $05, $05, $98, $05, $94, $05, $05, $05, $94 ; $BAD9 - $BAE8
	.byte $05, $05, $05, $98, $05, $94, $05, $05, $05, $94, $05, $05, $05, $98, $05, $94 ; $BAE9 - $BAF8
	.byte $05, $05, $05, $94, $05, $05, $99, $05, $98, $05, $00

M2BSegData04:
	.byte $C4, $42, $46, $48, $C8 ; $BAF9 - $BB08
	.byte $5A, $94, $5A, $98, $72, $C4, $3E, $42, $46, $C8, $56, $94, $56, $98, $6E, $00 ; $BB09 - $BB18
	.byte $C4, $3A, $3E, $42, $48, $46, $4C, $48, $42, $38, $3A, $3E, $46, $42, $48, $46 ; $BB19 - $BB28
	.byte $3E, $98, $3A, $84, $48, $89, $52, $88, $7E, $98, $38, $84, $48, $89, $50, $88 ; $BB29 - $BB38
	.byte $7E

M2BSegData05:
	.byte $C4, $3A, $3E, $42, $C8, $52, $94, $52, $98, $6A, $C4, $38, $36, $38, $50 ; $BB39 - $BB48
	.byte $98, $52, $56, $00, $C4, $34, $38, $3A, $42, $40, $46, $42, $3A, $30, $2E, $30 ; $BB49 - $BB58
	.byte $3E, $98, $42, $46, $98, $34, $84, $42, $89, $4C, $98, $7E, $30, $84, $3E, $48 ; $BB59 - $BB68
	.byte $C8, $34, $38, $99, $06, $06, $88, $01, $00, $99, $05, $05, $84, $05, $05, $00 ; $BB69 - $BB78

M2BSegData06:
	.byte $C4, $3A, $3E, $42, $C8, $52, $C4, $50, $52, $54, $94, $56, $3E, $3E, $3E, $3E ; $BB79 - $BB88
	.byte $26, $26, $26, $24, $26, $24, $26, $28, $2A, $2C, $2E, $00, $C4, $34, $38, $3A ; $BB89 - $BB98
	.byte $42, $40, $46, $48, $4A, $94, $4C, $34, $34, $34, $34, $1C, $1C, $1C, $1E, $20 ; $BB99 - $BBA8
	.byte $1E, $20, $22, $24, $26, $28, $98, $34, $84, $42, $89, $4C, $98, $7E, $3E, $7E ; $BBA9 - $BBB8
	.byte $26, $7E, $3E, $26, $26, $2E, $99, $06, $06, $88, $01, $98, $02, $02, $02, $02 ; $BBB9 - $BBC8
	.byte $94, $02, $02, $02, $02, $02, $02, $02, $02, $99, $05, $05, $84, $05, $05, $98 ; $BBC9 - $BBD8
	.byte $05, $05, $05, $05, $94, $05, $05, $05, $05, $05, $05, $06, $07, $00

M2BSegData0B:
	.byte $C4, $3E ; $BBD9 - $BBE8
	.byte $56, $52, $C8, $4C, $C4, $3E, $42, $44, $CC, $46, $00, $C4, $2E, $46, $42, $C8 ; $BBE9 - $BBF8
	.byte $3A, $C4, $2E, $30, $32, $CC, $34, $CC, $7E, $C8, $3E, $42, $44, $46

M2BSegData0C:
	.byte $C4, $3E ; $BBF9 - $BC08
	.byte $48, $56, $C8, $54, $5A, $C4, $54, $56, $50, $48, $C8, $3E, $42, $C4, $3C, $3E ; $BC09 - $BC18
	.byte $48, $56, $C8, $54, $5A, $C4, $54, $CC, $56, $00, $C4, $38, $3E, $50, $C8, $4E ; $BC19 - $BC28
	.byte $52, $C4, $4E, $50, $48, $3E, $C8, $38, $3C, $C4, $36, $38, $3E, $50, $C8, $4E ; $BC29 - $BC38
	.byte $52, $C4, $4E, $CC, $50, $C4, $30, $56, $60, $56, $3E, $56, $60, $56, $30, $56 ; $BC39 - $BC48
	.byte $60, $56, $3E, $56, $60, $56, $30, $56, $60, $56, $3E, $56, $60, $56, $30, $56 ; $BC49 - $BC58
	.byte $60, $56, $3E, $56, $60, $56

M2BSegData0D:
	.byte $C4, $42, $48, $5A, $C8, $58, $5E, $C4, $5A, $56 ; $BC59 - $BC68
	.byte $3E, $5A, $C8, $56, $7E, $C4, $7E, $3E, $44, $56, $C8, $52, $56, $C4, $4E, $CA ; $BC69 - $BC78
	.byte $5A, $56, $00, $C4, $3A, $42, $52, $C8, $50, $56, $C4, $52, $50, $38, $52, $C8 ; $BC79 - $BC88
	.byte $50, $7E, $C4, $7E, $36, $3E, $4E, $C8, $4C, $4E, $C4, $44, $CA, $52, $46, $C4 ; $BC89 - $BC98
	.byte $3A, $52, $60, $52, $3A, $52, $60, $52, $38, $50, $5E, $50, $38, $50, $5E, $50 ; $BC99 - $BCA8
	.byte $36, $4E, $5C, $4E, $36, $4E, $5C, $4E, $3A, $52, $60, $52, $3E, $56, $64, $56 ; $BCA9 - $BCB8
	.byte $94, $06, $02, $02, $02, $00, $94, $7E, $05, $05, $05, $00

M2BSegData1B:
	.byte $84, $42, $40, $3E ; $BCB9 - $BCC8
	.byte $8C, $3C, $84, $7E, $08, $20, $34, $20, $34, $32, $7E, $20, $30, $7E, $20, $30 ; $BCC9 - $BCD8
	.byte $7E, $2E, $30, $32, $00, $84, $30, $2E, $2C, $8C, $2A, $84, $7E, $08, $20, $2A ; $BCD9 - $BCE8
	.byte $20, $2A, $28, $7E, $20, $26, $7E, $20, $26, $7E, $24, $26, $28, $84, $3C, $3A ; $BCE9 - $BCF8
	.byte $38, $8C, $36, $84, $7E, $9C, $7E, $7E, $94, $02, $01, $02, $02, $01, $02, $02 ; $BCF9 - $BD08
	.byte $02, $02, $02, $02, $02, $02, $02, $06, $02, $02, $02, $06, $02, $02, $02, $06 ; $BD09 - $BD18
	.byte $02, $02, $02, $06, $02, $94, $01, $7E, $01, $01, $7E, $01, $01, $01, $01, $01 ; $BD19 - $BD28
	.byte $01, $01, $98, $01, $94, $02, $01, $98, $01, $94, $02, $01, $98, $08, $94, $02 ; $BD29 - $BD38
	.byte $08, $98, $01, $94, $08, $01

M2BSegData1C:
	.byte $84, $08, $20, $34, $20, $34, $32, $7E, $20, $30 ; $BD39 - $BD48
	.byte $7E, $20, $30, $7E, $2E, $30, $32, $84, $08, $20, $34, $20, $34, $32, $7E, $20 ; $BD49 - $BD58
	.byte $30, $7E, $20, $30, $7E, $2E, $30, $32, $00, $84, $08, $20, $2A, $20, $2A, $28 ; $BD59 - $BD68
	.byte $7E, $20, $26, $7E, $20, $26, $7E, $24, $26, $28, $84, $08, $20, $2A, $20, $2A ; $BD69 - $BD78
	.byte $28, $7E, $20, $26, $7E, $20, $26, $7E, $24, $26, $28, $98, $7E, $9C, $5E, $98 ; $BD79 - $BD88
	.byte $7E, $90, $5C, $5A, $94, $56, $5A, $50, $7E, $56, $7E, $4C, $7E, $46, $4C, $50 ; $BD89 - $BD98
	.byte $9C, $7E, $94, $02, $02, $06, $02, $00, $98, $01, $94, $02, $01, $00

M2BSegData1D:
	.byte $84, $0A ; $BD99 - $BDA8
	.byte $22, $36, $22, $36, $34, $7E, $22, $32, $7E, $22, $32, $7E, $30, $32, $34, $84 ; $BDA9 - $BDB8
	.byte $0A, $22, $36, $22, $36, $34, $7E, $22, $32, $7E, $22, $32, $7E, $30, $32, $34 ; $BDB9 - $BDC8
	.byte $00, $84, $0A, $22, $2C, $22, $2C, $2A, $7E, $22, $28, $7E, $22, $28, $7E, $26 ; $BDC9 - $BDD8
	.byte $28, $2A, $84, $0A, $22, $2C, $22, $2C, $2A, $7E, $22, $28, $7E, $22, $28, $7E ; $BDD9 - $BDE8
	.byte $26, $28, $2A, $98, $7E, $9C, $60, $98, $7E, $94, $7E, $5E, $60, $6A, $66, $5E ; $BDE9 - $BDF8
	.byte $5C, $58, $90, $5C, $5E, $5C, $58, $94, $5C, $52, $58, $52, $4E, $52, $7E, $7E ; $BDF9 - $BE08
	.byte $7E, $7E, $94, $02, $02, $06, $02, $00, $98, $01, $94, $02, $01, $00  ; $BE09 - $BE14


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;; BEGIN UNUSED COPY/PASTED CODE ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The following are copied fragments from PRG030 ... THEY DO NOT BELONG HERE
; They also are in the wrong address space (PRG030 is $8xxx, PRG028 is $Axxx)
; My guess... massive copy/paste error? :D


	; Set Temp_Var13/14 to point to the layout data for this Tileset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA TileLayout_ByTileset,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA TileLayout_ByTileset+1,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDY <Temp_Var11		 ; Y = tile temp		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; VScroll_TileQuads2Attrs:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDX <Temp_Var8		 ; X = Temp_Var8 (Scroll_AttrStrip offset)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Map_Tile_AddrL],Y	 ; Get the tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	DEY		 ; Y--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Map_Tile_AddrL],Y	 ; Get the tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; "Quadrant" bits (6 and 7) are pushed in as attribute bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL Scroll_AttrStrip,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; Player_GetTileV:	; $9E3C 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var13	 ; A = Temp_Var13 (Y Hi)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	PHA		 ; Save it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAY		 ; Y = Y Hi		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var14	 ; A = Temp_Var14 (Y Lo)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	PHA		 ; Save it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	JSR LevelJct_GetVScreenH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	STA <Temp_Var14	 ; Adjusted Y for vertical -> Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Select root offset into tile memory		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_AddrVL,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrL		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_AddrVH,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Combine positions into Temp_Var15 to form tile mem offset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #$f0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var15		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var16		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ORA <Temp_Var15		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	TAY		 ; Offset -> 'Y'		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	PLA		 ; Restore original value for Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var14	 ; Store it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	PLA		 ; Restore original value for Temp_Var13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var13	 ; Store it		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Map_Tile_AddrL],Y	 ; Get tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Level_Tile	 ; Store into Level_Tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; This is basically a lookup for any given "Player Y Hi" shifted up 4 bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BE6C:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $00, $10, $20, $30, $40, $50, $60, $70, $80, $90, $A0, $B0, $C0, $D0, $E0, $F0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Translates the Player position into appropriate "high" value		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; as Vertical describes it ($0(00), $0(F0), $1(E0), ...)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; LevelJct_GetVScreenH:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Y = Player_YHi		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; A = Player_Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	CPY #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLS PRG028_BE8E	 ; If Y < 0 (i.e. if the Player Y High is less than zero, which shouldn't happen!), jump to PRG028_BE8E (RTS)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	ADD PRG030_9E6C,Y	; Player_Y += Player_YHi[Y]		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BCS PRG028_BE8A	 	; If carry set (overflow occurred), jump to PRG028_BE8A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	CMP #$f0			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLT PRG028_BE8E	 	; If result is < $F0, jump to PRG028_BE8E		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BE8A:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Add $10 and roll over 'Y' (Considered in the lower vertical half)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ADD #$10		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	INY			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BE8E:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Something similar to LevelJct_GetVScreenH, but I'm 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; not quite following the purpose		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; LevelJct_GetVScreenH2:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; A = Player_Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Y = Player_YHi		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CPY #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLS PRG028_BE9A	 ; If YHi < 0 (shouldn't happen?), jump to PRG028_BE9A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	SUB PRG030_9E6C,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BCS PRG028_BE9A	 ; If carry set, jump to PRG028_BE9A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	DEY		 ; Y--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BE9A:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY


; FIXME: Anybody want to claim this??		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; $9E9B		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $F0, $20		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; Player_GetTileAndSlope_Normal:	; $9E9D		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Temp_Var13 / Temp_Var14 -- Y Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Temp_Var15 / Temp_Var16 -- X Hi and Lo		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Clear slope array		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA #$00			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes+1		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes+2		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var16		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LSR A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Level_TileOff	 ; Level_TileOff = Temp_Var16 >> 4 (current column Player is in)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var15		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #$0f			; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A				; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAX		 ; X = (Temp_Var15 & $0F) << 1 (current "high" part of Player X shifted up by 1, indexing Tile Mem)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Set Map_Tile_AddrL/H to appropriate screen based on Player's position		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_Addr,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrL		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Tile_Mem_Addr+1,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Map_Tile_AddrH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BEQ PRG028_BEC3	 ; If Temp_Var13 (Y Hi) = 0, jump to PRG028_BEC3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	INC <Map_Tile_AddrH ; Otherwise, go to second half of screen		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BEC3:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Temp_Var14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #$f0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ORA <Level_TileOff	 ; Level_TileOff gets the Player's current row in the upper 4 bits		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Level_TileOff is now Player's current offset in Tile Mem from the selected pointer		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	STA <Temp_Var12		 ; ... and copied into Temp_Var12		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	TAY		 	; Y = current offset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA [Map_Tile_AddrL],Y	; Get tile here		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Level_Tile	; Store into Level_Tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDY Level_Tileset		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CPY #3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BEQ PRG028_BEDB	 ; If Level_Tileset = 3 (Hills style), jump to PRG028_BEDB		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	CPY #14		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BNE PRG028_BF0D	 ; If Level_Tileset <> 14 (Underground), jump to PRG028_BF0D		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BEDB:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var1		 ; Temp_Var1 = 0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDY <Temp_Var12		 ; Y = current offset in Tile Mem		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA [Map_Tile_AddrL],Y	 ; Get tile here		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var2		 ; Store into Temp_Var2		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	AND #$c0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CLC		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ROL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAY		; Y = just the upper 2 bits of tile shifted right 6 (0 to 3)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA <Temp_Var2		 ; Re-get tile		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	CMP Tile_AttrTable,Y		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BLT PRG028_BF0D	 	; If it's less than the tile specified in Tile_AttrTable[Y], jump to PRG028_BF0D		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	TYA		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	ASL A		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAX		 ; X = Y (the upper 2 bits) << 1 (two byte index)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Temp_Var3/4 are loaded with address inside PRG000_C000		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Level_SlopeSetByQuad,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Level_SlopeSetByQuad+1,X		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Temp_Var4		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDX <Temp_Var1	 	; X = Temp_Var1 (0)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Temp_Var2	 	; A = Temp_Var2 (the retrieved tile)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	SUB Tile_AttrTable,Y	; Subtract the root tile value		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	TAY		 	; Y = result		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA [Temp_Var3],Y		; Get value 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA <Player_Slopes,X	; Store into Player_Slopes		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BF0D:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA <Level_Tile	; A = Level_Tile (the tile retrieved)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Probably unused space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY


; PRG030_SUB_9F40:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA #$00		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA Raster_State 	; Reset Raster_State		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDA Update_Request		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	JMP PRG031_F499		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Filler space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $ff, $ff, $ff, $ff, $ff		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Sub part of A0 mode of IRQ		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
; PRG030_SUB_9F50:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; Some kind of delay loop?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDX #$17	 ; X = $17		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BF52:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		 ; ?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	DEX		 ; X--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BPL PRG028_BF52 ; While X > 0, loop		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Latch this value, and force it into the counter!		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQLATCH		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQDISABLE		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQENABLE		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	RTS		 ; Return		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Probably unused space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; IntIRQ_32PixelPartition_Part5:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Some kind of delay loop?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDX #$13	 ; X = $13		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BF80:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		 ; ?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	DEX		 ; X--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BPL PRG028_BF80 ; While X > 0, loop		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; More NOPs		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	STA MMC3_IRQLATCH ; Latch A (last set to 27!)		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	STA MMC3_IRQENABLE ; Enable IRQ again		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	JMP PRG031_FA3C	 ; Jump to PRG031_FA3C		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Unused space		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

; IntIRQ_32PixelPartition_Part2:	; $9FA0		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	LDA Update_Request	 		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	AND #UPDATERASTER_32PIXSHOWSPR		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BNE PRG028_BFAA	 ; If UPDATERASTER_32PIXSHOWSPR is set, go to PRG028_BFAA		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; Otherwise, change loaded pattern tables to hide sprites that fall beneath the 32 pixel partition		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	JMP IntIRQ_32PixPart_HideSprites		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

PRG028_BFAA:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	; I think the following NOPs and loop are to help synchronize the IRQ		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	; routine if it didn't perform the IntIRQ_32PixPart_HideSprites step		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	LDX #$03	 ; X = 3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
PRG028_BFAF:		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	NOP		 ; ?		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	DEX		 ; X--		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY
	BPL PRG028_BFAF	 ; While X > 0, loop		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

	JMP IntIRQ_32PixelPartition_Part3		; UNUSED COPY FROM PRG030, DELETE DON'T MODIFY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;  END UNUSED COPY/PASTED CODE  ;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Remainder of ROM bank was empty

