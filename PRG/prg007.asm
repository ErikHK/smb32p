; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-02-13 22:44:39.225983982 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DoLavaDonutArrowBounce
;
; Handles the Player coming into contact with lava, donut lifts,
; or arrow platforms (supported in vertical level only)
; This also checks to see if the Player should bounce because the
; block beneath his feet bounced (by checking for the 
; TILEA_BLOCKBUMP_CLEAR tile...)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Specifies which kind of arrow lift should be created relative to which tile
	; the Player stepped on.  Note the zero near the end; if you look at tileset #8
	; the donut lift appears right between what would be the multidirectional lift.
ArrowPlat_ByTile:
	.byte OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWONE, OBJ_ARROWANY, $00, OBJ_ARROWANY

	; Sets the direction value as used by the arrow platform
ArrowPlat_DirByTile:
	.byte $00, $00, $03, $03, $01, $01, $00, $00, $00

ArrowPlat_XOff:
	.byte 0, -16, 0, -16, 0, -16, 0, 0, -16

Player_DoLavaDonutArrowBounce:
	LDA <Player_IsDying		  
	BNE PRG007_A06F	 ; If Player is dying, jump to PRG007_A06F (RTS)

	LDA Level_7Vertical
	BEQ PRG007_A027	 ; If this is NOT a vertically-oriented level, jump to PRG007_A027

	JMP PRG007_A0DE	 ; Otherwise, jump to PRG007_A0DE

PRG007_A027:

	; Not vertically oriented level...

	LDA <Player_Y	; Get Player Y
	ADD #32		; +32
	AND #$f0	; Align to tile grid
	STA <Temp_Var5	; -> Temp_Var5

	LDA <Player_YHi
	BMI PRG007_A06F	; If Player is up off the top of the screen, jump to PRG007_A06F (RTS)

	ADC #$00	; Apply carry
	AND #$01	; Only bit 0 is valid anyway in non-vertical mode
	STA <Temp_Var3	; -> Temp_Var3

	LDA <Player_X	; Get Player X
	ADD #$08	; +8
	AND #$f0	; Align to tile grid
	STA <Temp_Var4	; -> Temp_Var4

	LDA <Player_XHi
	ADC #$00	; Apply carry
	STA <Temp_Var6	; -> Temp_Var6

	CMP #16		; 16 screens are the max!!
	BCS PRG007_A06F	; If Player is really far to the right (somehow), jump to PRG007_A06F (RTS)

	ASL A		; 2 byte index for current screen
	TAY		; -> 'Y'

	; Store high byte of screen address -> Temp_Var1
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1	

	; Store low byte of screen address + Player's Y Hi -> Temp_Var2
	LDA Tile_Mem_Addr+1,Y
	ADD <Temp_Var3	
	STA <Temp_Var2

	; Calculate a proper offset into the tile memory for the X/Y position of the Player
	LDA <Temp_Var4
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var5
	TAY	; -> 'Y'

	LDA [Temp_Var1],Y	; Get the tile here

	CMP #TILEA_BLOCKBUMP_CLEAR
	BNE PRG007_A070	 ; If this is not a bumped block tile, jump to PRG007_A070

	; Otherwise, bounce Player!
	LDA #-$30
	STA <Player_YVel

PRG007_A06F:
	RTS		 ; Return


PRG007_A070:
	CMP #TILE2_LAVATOP
	BNE PRG007_A082	 ; If this is not (possibly) a lava tile, jump to PRG007_A082

	LDY Level_Tileset
	CPY #11
	BEQ PRG007_A07F	 ; If this is tileset 11 (Giant World; Interesting!  Green bubbly death here), jump to PRG007_A07F

	CPY #2
	BNE PRG007_A082	 ; If this is NOT tileset 2 (Fortress style), jump to PRG007_A082

PRG007_A07F:
	JMP PRG007_A183	 ; Jump to PRG007_A183 (Player dies!)

PRG007_A082:
	CMP #TILE2_DONUTLIFT
	BNE PRG007_A0DD	 ; If this is not (possibly) a Donut Lift, jump to PRG007_A0DD (RTS)

PRG007_A086:
	; If this is tileset 4, 8, 12, or 2 (all valid for Donut Lift), jump to PRG007_A099, otherwise jump to PRG007_A06F (RTS)
	LDY Level_Tileset
	CPY #4
	BEQ PRG007_A099

	CPY #8
	BEQ PRG007_A099

	CPY #12
	BEQ PRG007_A099

	CPY #2
	BNE PRG007_A06F

PRG007_A099:
	LDA Level_ChgTileEvent
	BNE PRG007_A06F	 ; If there's already a tile change event queued, jump to PRG007_A06F (RTS)

	JSR PrepareNewObjectOrAbort	 ; Prepare a new object or don't come back!

	; This is a falling donut lift!
	LDA #OBJ_DONUTLIFTSHAKEFALL
	STA Level_ObjectID,X

	; Set donut lift Y 
	LDA <Temp_Var5
	SUB #$01
	STA <Objects_Y,X
	LDA <Temp_Var3
	SBC #$00
	STA <Objects_YHi,X

	; Set donut lift X
	LDA <Temp_Var4
	STA <Objects_X,X
	LDA <Temp_Var6
	STA <Objects_XHi,X

	; Set donut lift object's Var5 = $20
	LDA #$20
	STA <Objects_Var5,X

	; Set sprite attribute = 3
	LDA #$03
	STA Objects_SprAttr,X

	; Do tile change event to clear the tile version of the donut lift
	LDA #$02
	STA Level_ChgTileEvent
	LDA <Temp_Var3	
	STA Level_BlockChgYHi
	LDA <Temp_Var5	
	STA Level_BlockChgYLo
	LDA <Temp_Var4	
	STA Level_BlockChgXLo
	LDA <Temp_Var6	
	STA Level_BlockChgXHi

PRG007_A0DD:
	RTS		 ; Return

PRG007_A0DE:

	; Vertically oriented level...

	LDA <Player_Y	; Get Player Y
	ADD #33		; +33
	AND #$f0	; Aligned to tile grid
	STA <Temp_Var1	; -> Temp_Var1
	STA <Temp_Var5	; -> Temp_Var5

	LDA <Player_YHi
	BMI PRG007_A0DD	 ; If Player is up off the top of the level, jump to PRG007_A0DD (RTS)

	ADC #$00	; Apply carry
	STA <Temp_Var3	; -> Temp_Var3

	; High byte of Tile_Mem -> Temp_Var2
	ORA #HIGH(Tile_Mem)
	STA <Temp_Var2

	LDA <Player_X	; Get Player X
	ADD #$08	; +8
	AND #$f0	; Aligned to tile grid
	STA <Temp_Var4	; -> Temp_Var4

	; Construct tile offset
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var1
	STA <Temp_Var1

	; Temp_Var6 = 0 (would be "X Hi", which is always zero in vertical level)
	LDY #$00
	STY <Temp_Var6

	LDA [Temp_Var1],Y	 ; Get tile here

	CMP #TILE2_DONUTLIFT
	BNE PRG007_A113	 ; If this is not donut lift tile, jump to PRG007_A113

	JMP PRG007_A086	 ; Otherwise, jump to PRG007_A086

PRG007_A113:
	LDY <Player_InAir
	BNE PRG007_A0DD	 ; If Player is mid-air, jump to PRG007_A0DD (RTS)

	LDY ArrowPlat_IsActive
	BNE PRG007_A0DD	 ; If an arrow platform is already active, jump to PRG007_A0DD (RTS)

	; If not standing on some kind of arrow platform tile, jump to PRG007_A0DD (RTS)
	CMP #TILE8_ARROWLIFT_UPL
	BLT PRG007_A0DD
	CMP #(TILE8_ARROWLIFT_RANDOMR+1)
	BGE PRG007_A0DD

	SUB #TILE8_ARROWLIFT_UPL
	TAY		 ; Y = relative index of tile for arrow platform

	; Temp_Var3 = $FF
	LDA #$ff
	STA <Temp_Var3

	LDX #$04	 ; X = 4
PRG007_A12E:
	LDA Objects_State,X
	BEQ PRG007_A144	 ; If this object slot is dead/empty, jump to PRG007_A144

	; If this object slot is not some type of arrow platform, jump to PRG007_A146
	LDA Level_ObjectID,X
	CMP #OBJ_ARROWONE
	BLT PRG007_A146
	CMP #(OBJ_ARROWANY+1)
	BGE PRG007_A146

	; There's another arrow platform already active in this slot...

	JSR Object_SetDeadEmpty	; Set this slot as dead/empty
	JMP PRG007_A144	 	; Jump to PRG007_A144

	; ^ I think the above is partially a mistake; they probably wanted to jump to something
	; that would set 'X' and exit the loop.  This logic works as-is, but it requires another
	; frame before the arrow lift will actually come into existence... unless another dead/
	; empty object appears forward of this position...

PRG007_A144:
	STX <Temp_Var3		; Temp_Var3 = index we just searched

PRG007_A146:
	DEX		 ; X--
	BPL PRG007_A12E	 ; While X >= 0, loop!

	LDX <Temp_Var3	 ; X = free object slot!
	BMI PRG007_A182	 ; If no free object slot was found, jump to PRG007_A182

	; Set this to "Normal!"
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	; Create the correct arrow platform by the tile
	LDA ArrowPlat_ByTile,Y
	STA Level_ObjectID,X

	; Set the direction value by tile
	LDA ArrowPlat_DirByTile,Y
	STA <Objects_Var4,X

	; Arrow platform Y
	LDA <Temp_Var1
	AND #$f0
	SUB #$01
	STA <Objects_Y,X
	LDA <Temp_Var2
	SBC #$00
	AND #$0f
	STA <Objects_YHi,X

	; Arrow platform X
	LDA <Temp_Var1
	ASL A
	ASL A
	ASL A
	ASL A
	ADD ArrowPlat_XOff,Y
	STA <Objects_X,X
	LDA #$00
	STA <Objects_XHi,X

	; Arrow platform's Var5 (lifespan counter) = $FF
	LDA #$ff
	STA <Objects_Var5,X

PRG007_A182:
	RTS		 ; Return

PRG007_A183:

	; Player hit death tile!

	; Zap suit
	LDA #$01
	STA Player_QueueSuit

	JMP Player_Die	 ; Player dies and don't come back!


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ColorRotation_Do
;
; Performs the palette color rotation effects per RotatingColor_Cnt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; The palette color forcefully applied in a color rotation
Rotation_Colors:
	.byte $26, $2A, $22, $36

ColorRotation_Do:
	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	LDA RotatingColor_Cnt
	BEQ PRG007_A1EA	 ; If RotatingColor_Cnt = 0 (No color rotation active), jump to PRG007_A1EA (RTS)

	PHA		 ; Save rotation value

	AND #$03
	TAY		 ; Y = 0 to 3, based on rotation value

	DEC RotatingColor_Cnt	 ; RotatingColor_Cnt--

	PLA		 ; Restore rotation value
	BPL PRG007_A1EB	 ; If bit 7 not set on rotation value, jump to PRG007_A1EB

	; Bit 7 set on RotatingColor_Cnt

	AND #%01111111	 ; Ignore bit 7
	BNE PRG007_A1A8	 ; If does not amount to zero, jump to PRG007_A1A8

	STA RotatingColor_Cnt	 ; Otherwise, clear RotatingColor_Cnt

PRG007_A1A8:

	; Address of palette to modify
	LDA #$3f
	STA Graphics_Buffer+$00,X
	LDA #$04
	STA Graphics_Buffer+$01,X

	; 8 bytes to go
	LDA #$08
	STA Graphics_Buffer+$02,X

	; Set the rotation colors into the buffer
	LDA Rotation_Colors,Y
	STA Graphics_Buffer+$04,X
	STA Graphics_Buffer+$05,X
	STA Graphics_Buffer+$06,X
	STA Graphics_Buffer+$08,X

	LDA Palette_Buffer+$4
	STA Graphics_Buffer+$03,X

	LDA Palette_Buffer+$8
	STA Graphics_Buffer+$07,X

	LDA Palette_Buffer+$A
	STA Graphics_Buffer+$09,X

	LDA Palette_Buffer+$B
	STA Graphics_Buffer+$0A,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$0B,X

	; Add to the graphics buffer counter
	TXA
	ADD #$0b
	STA Graphics_BufCnt

PRG007_A1EA:
	RTS		 ; Return


PRG007_A1EB:

	; Bit 7 not set on RotatingColor_Cnt

	LDA RotatingColor_Cnt
	BEQ PRG007_A1F5	 ; If RotatingColor_Cnt = 0, jump to PRG007_A1F5

	; Set the rotation colors into the buffer
	LDA Rotation_Colors,Y
	BNE PRG007_A1F8	 ; Jump (technically always) to PRG007_A1F8

PRG007_A1F5:
	LDA Palette_Buffer+$10

PRG007_A1F8:
	STA Graphics_Buffer+$03,X

	LDA #$10
	STA Graphics_Buffer+$01,X

	LDA Palette_Buffer+$11
	STA Graphics_Buffer+$04,X

	LDA Palette_Buffer+$12
	STA Graphics_Buffer+$05,X

	LDA Palette_Buffer+$13
	STA Graphics_Buffer+$06,X

	; Address of palette to modify
	LDA #$3f
	STA Graphics_Buffer+$00,X
	LDA #$04
	STA Graphics_Buffer+$02,X

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$07,X

	; Add to the graphics buffer counter
	TXA
	ADD #$07
	STA Graphics_BufCnt

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gameplay_UpdateAndDrawMisc
;
; Color rotation effects, lava, donut lifts, arrow platforms,
; brick busts, water/waterfall visual effects, bubbles, splashes,
; pop-up coins, Special Objects, Cannon Fires, Player Projectiles,
; and, last but not least (well, maybe least), "shell kill flashes"!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Gameplay_UpdateAndDrawMisc:
	JSR ColorRotation_Do	 	 ; Do color rotation effects, if any
	JSR Player_DoLavaDonutArrowBounce	 ; Handle Lava, Donut Lifts, and Arrow platforms
	JSR BrickBusts_DrawAndUpdate	 ; Draw and update brick bust effects
	JSR Player_WaterOrWaterfallVizFX ; Standing in a waterfall splashing or periodic bubbles underwater
	JSR Bubbles_UpdateAndDraw	 ; Update and draw underwater bubbles
	JSR Splash_UpdateAndDraw	 ; Update and draw water surface splashes
	JSR CoinPUps_DrawAndUpdate	 ; Update and draw coins that have popped out of boxes
	JSR SpecialObjs_UpdateAndDraw	 ; Update and draw Special objects
	JSR CannonFire_UpdateAndDraw	 ; Update and draw the Cannon Fires
	JSR PlayerProjs_UpdateAndDraw	 ; Update and draw Player's weapon projectiles

	LDA <Player_Suit
	CMP #PLAYERSUIT_HAMMER
	BEQ PRG007_A251	 ; If Player is wearing a Hammer Suit, jump to PRG007_A251

	CMP #PLAYERSUIT_FIRE
	BNE PRG007_A268	 ; If Player is not Fire, jump to PRG007_A268

PRG007_A251:

	; Player wearing a Hammer Suit or Fire

	LDA Player_HaltTick	; If Player is not halted ...
	ORA Player_IsDucking	; ... Player is ducking ...
	ORA Player_Kick	 	; ... Player is kicking ...
	ORA Player_InPipe	; ... Player is in a pipe ...
	ORA <Player_HaltGame	; ... gameplay is halted ...
	BNE PRG007_A268	 	; ... then jump to PRG007_A268

	BIT <Pad_Input
	BVC PRG007_A268	 ; If Player is NOT pressing B, jump to PRG007_A268

	JSR PlayerProj_ThrowWeapon	 ; Player throws weapon, whatever's appropriate

PRG007_A268:
	LDA ShellKillFlash_Cnt
	BEQ PRG007_A2AE	 ; If ShellKillFlash_Cnt = 0, jump to PRG007_A2AE (RTS)

	DEC ShellKillFlash_Cnt	 ; ShellKillFlash_Cnt--

	LDY #$00	 ; Y = 0

	; Set the shell kill flash left/right sprite Y
	LDA ShellKillFlash_Y
	SUB Level_VertScroll
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Set left sprite X
	LDA ShellKillFlash_X
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	; Set left/right sprite pattern
	LDA #$57
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Temp_Var1 = toggled vertical flip bit
	LDA <Counter_1
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP
	STA <Temp_Var1

	; OR in a palette cycle
	LDA <Counter_1
	AND #$03
	ORA <Temp_Var1

	; Set left sprite attribute
	STA Sprite_RAM+$02,Y

	; Set right sprite attribute
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y

PRG007_A2AE:
	RTS		 ; Return

PlayerProj_ThrowWeapon:
	LDX #$01	 ; X = 1
PRG007_A2B1:
	LDA PlayerProj_ID,X
	BEQ PRG007_A2BA	 ; If this Player projectile slot is free

	DEX		 ; X--
	BPL PRG007_A2B1	 ; While X >= 0, loop!

	RTS		 ; Return

PRG007_A2BA:

	; Player "fire" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERFIRE
	STA Sound_QPlayer

	; Player should use "fire" frame!
	LDA #$0b
	STA Player_FireCount

	; Set projectile X
	LDA <Player_X
	ADD #$04
	STA PlayerProj_X,X

	; Set projectile Y Hi
	LDA <Player_Y
	STA PlayerProj_Y,X
	LDA <Player_YHi
	STA PlayerProj_YHi,X

	LDA #$01	 ; A = 1

	LDY <Player_Suit
	CPY #PLAYERSUIT_HAMMER
	SEC		 ; Set carry (if NOT wearing the hammer suit)
	BNE PRG007_A2E3	 ; If Player is NOT wearing the Hammer Suit, jump to PRG007_A2E3
	ASL A		 ; Clears carry, also A = 2
PRG007_A2E3:
	STA PlayerProj_ID,X	 ; Set projectile as type 1 or 2

	; Set Player Projectile Y velocity
	LDA #$03	 ; A = $03 (Fireballs are thrown down)
	BCS PRG007_A2EC	 ; If Player is NOT wearing Hammer Suit, jump to PRG007_A2EC
	LDA #-$03	 ; A = -$03 (Hammers are thrown up)
PRG007_A2EC:
	STA PlayerProj_YVel,X

	; Temp_Var1 = 0 (no offset for fireballs)
	LDA #$00
	STA <Temp_Var1

	LDA #$03	 ; A = $03 (Fire)
	BCS PRG007_A304	 ; If Player is NOT wearing Hammer Suit, jump to PRG007_A304

	; Calculate the hammer X velocity offset
	LDA <Player_FlipBits	; Keep in mind this is generally only $00 or $40 since Player doesn't vertically flip/etc.
	ASL A			; ... so this makes a positive or negative sign
	EOR <Player_XVel	; XOR in the Player's X velocity
	BPL PRG007_A302	 	; If result is positive, jump to PRG007_A302

	; Otherwise, set Temp_Var1 = Player_XVel
	LDA <Player_XVel
	STA <Temp_Var1

PRG007_A302:
	LDA #$10	 ; A = $10 (Hammer)

PRG007_A304:
	LDY <Player_FlipBits	; Keep in mind this is generally only $00 or $40 since Player doesn't vertically flip/etc.
	BNE PRG007_A30B	 	; If Player is horizontally flipped, jump to PRG007_A30B

	JSR Negate	 ; If Player is turned around, negate value

PRG007_A30B:
	ADD <Temp_Var1	 ; Add Temp_Var1 (X Velocity offset, if applicable)
	STA PlayerProj_XVel,X	 ; Store Projectile X velocity

	; PlayerProj_Cnt = 0
	LDA #$00
	STA PlayerProj_Cnt,X

	RTS		 ; Return


PlayerFireball_Pats:		.byte $65, $67, $65, $67
PlayerFireball_FlipBits:	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1 | SPR_HFLIP | SPR_VFLIP, SPR_PAL1 | SPR_HFLIP | SPR_VFLIP

PlayerHammer_FlipBits:	.byte $00, SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, SPR_HFLIP
PlayerHammer_YOff:	.byte $00 ; NOTE: Next three values overlap into following table)
PlayerHammer_XOff:	.byte $06, $06, $00, $00

PRG007_A328:
	RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PlayerProjs_UpdateAndDraw
;
; Update and draw Player Projectiles 
; (weapons, i.e. fireballs/hammers/fireball poofs)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PlayerProjs_UpdateAndDraw:
	LDX #$01	; X = 1  
	STX <SlotIndexBackup		 ; SlotIndexBackup = 1

	JSR PlayerProj_UpdateAndDraw	 ; Update and draw this Player Projectile

	DEC <SlotIndexBackup		 ; SlotIndexBackup = 0
	DEX		 ; X = 0

PlayerProj_UpdateAndDraw:
	LDA PlayerProj_ID,X
	BEQ PRG007_A328	 ; If Player Projectile slot is empty, jump to PRG007_A328 (RTS)
 
	CMP #$03
	BLT PRG007_A33F	 ; If Player Projectile ID < 3 (not the fireball poof), jump to PRG007_A33F

	JMP PRG007_A705	 ; Jump to PRG007_A705

PRG007_A33F:

	; Hammer or Fireball...

	LDA AScrlURDiag_WrapState_Copy
	BEQ PRG007_A361	 ; If diagonal scroller is not wrapping, jump to PRG007_A361

	LDA <Player_HaltGame
	BNE PRG007_A361	 ; If gameplay is halted, jump to PRG007_A361

	; Offset Player projectile to compensate for the diagonal autoscroller's wrap
	LDA PlayerProj_X,X
	ADD AScrlURDiag_OffsetX
	STA PlayerProj_X,X
	LDA PlayerProj_Y,X
	ADD AScrlURDiag_OffsetY
	STA PlayerProj_Y,X

	BCC PRG007_A361
	INC PlayerProj_YHi,X	 ; Apply carry

PRG007_A361:
	LDY <Player_HaltGame
	BNE PRG007_A3DB	 ; If gameplay halted, jump to PRG007_A3DB

	LDA PlayerProj_YVel,X

	LDY Level_AScrlConfig
	BEQ PRG007_A371	 ; If no auto scroll effect is active, jump to PRG007_A371

	ADD Level_ScrollDiffV	 ; Add auto scroll's vertical delta to Player's Y velocity

PRG007_A371:
	PHA		 ; Save Projectile Y Velocity

	LDY #$00	 ; Y = $00 (16-bit sign extension)

	PLA		 ; Restore Projectile Y Velocity
	BPL PRG007_A378	 ; If not negative, jump to PRG007_A378

	DEY		 ; Y = $FF (16-bit sign extension)

PRG007_A378:
	ADD PlayerProj_Y,X	 ; Apply Y velocity
	STA PlayerProj_Y,X	 ; Update Y

	; Cascade into Y Hi
	TYA
	ADC PlayerProj_YHi,X
	STA PlayerProj_YHi,X

	INC PlayerProj_Cnt,X	 ; PlayerProj_Cnt++

	LDA PlayerProj_ID,X
	CMP #$02
	BNE PRG007_A3C0	 ; If this is NOT the hammer, jump to PRG007_A3C0

	; Hammer specific velocity code...

	LDA PlayerProj_XVel,X
	ASL A
	ASL A
	ASL A
	ASL A		 	; Fractional part shifted up
	ADD PlayerProj_XVelFrac,X
	STA PlayerProj_XVelFrac,X	; Add to object's X vel fractional accumulator

	PHP		 ; Save CPU status

	LDA PlayerProj_XVel,X	; Get X Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 ; Whole part shifted down (integer)
	CMP #%00001000	 ; Check the sign bit
	BLT PRG007_A3AC	 ; If the value was not negatively signed, jump to PRG007_A3AC
	ORA #%11110000	 ; Otherwise, apply a sign extension
PRG007_A3AC:
	PLP		 ; Restore CPU status

	ADC PlayerProj_X,X	 ; Apply X velocity
	STA PlayerProj_X,X	 ; Update X

	LDA PlayerProj_Cnt,X
	AND #$07
	BNE PRG007_A3BD	 ; 1:8 ticks proceed, otherwise jump to PRG007_A3BD

	INC PlayerProj_YVel,X	 ; Increase Y velocity (gravity)

PRG007_A3BD:
	JMP PRG007_A3DB	 ; Jump to PRG007_A3DB

PRG007_A3C0:

	; Fireball specific velocity code...

	; X velocity is applied as integer (no fractional accumulator)
	LDA PlayerProj_X,X
	ADD PlayerProj_XVel,X
	STA PlayerProj_X,X

	LDA PlayerProj_YVel,X
	CMP #$04
	BEQ PRG007_A3DB	 ; If fireball's Y velocity = 4, jump to PRG007_A3DB

	LDA PlayerProj_Cnt,X
	AND #$03
	BNE PRG007_A3DB	 ; 1:4 ticks proceed, otherwise jump to PRG007_A3DB

	INC PlayerProj_YVel,X	 ; Increase Y velocity (gravity)

PRG007_A3DB:

	; Fireball/Hammer common...

	; Temp_Var2 = scroll relative X
	LDA PlayerProj_X,X
	SUB <Horz_Scroll
	STA <Temp_Var2	

	ADD #11
	CMP #19
	BGE PRG007_A3F0	 ; If Player Projectile X >= 19, jump to PRG007_A3F0

PRG007_A3EA:
	; Otherwise remove it and let's get out of here!
	LDA #$00
	STA PlayerProj_ID,X

PRG007_A3EF:
	RTS		 ; Return

PRG007_A3F0:
	ADC #-$08	 ; X Relative - 8
	STA <Temp_Var14	 ; -> Temp_Var14

	LDA PlayerProj_ID,X
	CMP #$01
	BNE PRG007_A400	 ; If this is NOT the fireball, jump to PRG007_A400

	; Fireball only...

	LDA PlayerProj_YVel,X
	BMI PRG007_A40E	 ; If fireball is moving upward, jump to PRG007_A40E

PRG007_A400:
	LDA PlayerProj_Y,X
	CMP Level_VertScroll
	LDA PlayerProj_YHi,X
	SBC Level_VertScrollH
	BMI PRG007_A3EF	 ; If Player projectile is vertically off-screen, jump to PRG007_A3EF (RTS)

PRG007_A40E:
	TXA
	ASL A
	ASL A		; A = Player Projectile slot index * 4
	ADD Object_SprRAM+6	 ; Offset into high end Sprite RAM
	TAY		 ; -> 'Y'

	; Set projectile sprite X
	LDA <Temp_Var2
	STA Sprite_RAM+$03,Y

	LDA PlayerProj_Y,X
	SUB Level_VertScroll
	CMP #192
	BGE PRG007_A3EA	 ; If projectile relative Y >= 192, jump to PRG007_A3EA (too low, remove projectile)

	; Set projectile sprite Y
	STA Sprite_RAM+$00,Y

	ADC #14		; Y + 14
	STA <Temp_Var13	; -> Temp_Var13

	; Temp_Var3 = initial sprite attribute by Player's travel direction
	LDA PlayerProj_XVel,X
	LSR A		; Sign bit shifted right
	AND #SPR_HFLIP
	STA <Temp_Var3

	LDA PlayerProj_ID,X
	CMP #$02
	BNE PRG007_A471	 ; If this is NOT the hammer, jump to PRG007_A471

	; Hammer only...

	LDA <Player_Suit
	CMP #PLAYERSUIT_HAMMER
	BNE PlayerProj_ChangeToPoof	 ; If Player is NOT wearing the Hammer Suit anymore (uh oh), jump to PlayerProj_ChangeToPoof

	LDA PlayerProj_Cnt,X
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	LDA PlayerHammer_XOff,X	 ; Get X offset
	BIT <Temp_Var3	 ; Check for horizontal flip
	BVC PRG007_A453	 ; If no flip, jump to PRG007_A453

	EOR #$06	 ; Otherwise, invert X offset

PRG007_A453:
	ADD <Temp_Var2		 ; Apply X offset
	STA Sprite_RAM+$03,Y	 ; Set Hammer X

	LDA PlayerHammer_YOff,X	 ; Get Y offset
	ADD Sprite_RAM+$00,Y	 ; Add to Sprite Y
	STA Sprite_RAM+$00,Y	 ; Update Sprite Y

	; Hammer pattern
	LDA #$d7
	STA Sprite_RAM+$01,Y

	LDA <Temp_Var3		; Get horizontal flip bit
	EOR PlayerHammer_FlipBits,X	 ; XOR in the hammer flip bits

	SEC		 ; Set carry (hammer)
	JMP PRG007_A485	 ; Jump to PRG007_A485

PRG007_A471:

	; Fireball only...

	LDA Level_NoStopCnt
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	; Set fireball pattern
	LDA PlayerFireball_Pats,X
	STA Sprite_RAM+$01,Y

	; Set fireball attributes
	LDA <Temp_Var3		 ; Get horizontal flip bit
	EOR PlayerFireball_FlipBits,X	 ; XOR in the fireball flip bits

	CLC		 ; Clear carry (fireball)

PRG007_A485:
	LDX Player_Behind
	BEQ PRG007_A48C	 ; If Player is not "behind the scenes", jump to PRG007_A48C

	ORA #SPR_BEHINDBG	; Set priority

PRG007_A48C:
	STA Sprite_RAM+$02,Y	 ; Set Player Projectile attributes

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

	LDA <Player_HaltGame
	BNE PRG007_A4A2	 ; If gameplay is halted, jump to PRG007_A4A2

	; Gameplay not halted...

	BCS PRG007_A49A	 ; If this is the hammer, jump to PRG007_A49A (PlayerProj_HitEnemies)

	JSR Fireball_DetectWorld	 ; Hit tests for fireball (bounce, poof, etc.)

PRG007_A49A:
	JMP PlayerProj_HitEnemies	 ; Jump to PlayerProj_HitEnemies

PlayerProj_ChangeToPoof:

	; Change Player Projectile to "Poof"
	LDA #$03
	STA PlayerProj_ID,X

PRG007_A4A2:
	RTS		 ; Return

Fireball_DetectWorld:
	LDA Level_7Vertical
	BEQ PRG007_A4CF	 ; If this is not a vertically oriented level, jump to PRG007_A4CF

	; Vertical level...

	LDA <Temp_Var13		; Detect Y of fireball
	ADD Level_VertScroll	; Apply vertical scroll
	STA <Temp_Var6		; -> Temp_Var6

	AND #$f0		; Aligned to grid row
	STA <Temp_Var3		; -> Temp_Var3

	; Temp_Var2 = high byte of tile memory
	LDA Level_VertScrollH	; Current vertical scroll high
	ADC #HIGH(Tile_Mem)	; Add the upper byte of the Tile_Mem address
	STA <Temp_Var2		; -> Temp_Var2

	; Temp_Var14 = fireball X + 4
	LDA PlayerProj_X,X
	ADC #$04
	STA <Temp_Var14

	; Temp_Var1 = Row/Column offset value
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	STA <Temp_Var1

	LDY #$00	 ; Y = 0 (don't need additional offset)
	JMP PRG007_A52D	 ; Jump to PRG007_A52D

PRG007_A4CF:

	; Non-vertical level...

	LDA Player_PartDetEn
	BEQ PRG007_A4E7	 ; If Player_PartDetEn is not enabled, jump to PRG007_A4E7

	; When fireball Y >= 160, force detection of bottom two rows of tiles

	LDA <Temp_Var13	 ; Detect Y of fireball
	CMP #160
	BLT PRG007_A4E9	 ; If < 160, jump to PRG007_A4E9

	SBC #16		 ; Detect Y - 16
	STA <Temp_Var6	 ; -> Temp_Var6

	AND #$f0	 ; Aligned to grid row
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA #$01	 ; A = 1 (force bottom tiles)
	JMP PRG007_A4F8	 ; Jump to PRG007_A4F8

PRG007_A4E7:
	LDA <Temp_Var13	 ; Detect Y of fireball

PRG007_A4E9:
	ADD Level_VertScroll	 ; Apply vertical scroll
	STA <Temp_Var6		 ; -> Temp_Var6

	AND #$f0	 ; Aligned to grid row
	STA <Temp_Var3	 ; -> Temp_Var3

	LDA Level_VertScrollH	; Current vertical scroll high
	ADC #$00	 ; Apply carry

PRG007_A4F8
	STA <Temp_Var4	 ; -> Temp_Var4
	BEQ PRG007_A506	 ; If vertical high = 0, jump to PRG007_A506

	CMP #$02
	BGE PRG007_A557	 ; If vertical high >= 2 (way too low), jump to PRG007_A557

	LDA <Temp_Var3
	CMP #$B0
	BGE PRG007_A557	 ; If at or lower than $1B0 (too low), jump to PRG007_A557

PRG007_A506:
	LDA <Temp_Var14	 ; Fireball detect X
	ADD <Horz_Scroll ; Apply horizontal scroll
	STA <Temp_Var5	 ; -> Temp_Var5

	LDA <Horz_Scroll_Hi
	ADC #$00
	STA <Temp_Var7	 ; High value -> Temp_Var7

	ASL A		 ; Multiply by 2 for Tile_Mem_Addr index
	TAY		 ; -> 'Y'

	; Temp_Var1 = low byte of Tile_Mem_Addr
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1

	; Temp_Var2 = high byte of Tile_Mem_Addr
	LDA <Temp_Var4
	AND #$01	; Only 0 or 1 is valid in non-vertical
	ADD Tile_Mem_Addr+1,Y
	STA <Temp_Var2

	; Y = row/column offset index
	LDA <Temp_Var5
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	TAY

PRG007_A52D:
	LDA [Temp_Var1],Y	 ; Get the tile at the Player Projectile 
	JSR PSwitch_SubstTileAndAttr	 ; Handle P-Switch changed tiles
	PHA		 ; Save adjusted tile

	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; Y = quadrant of tile
	STY <Temp_Var2	 ; -> Temp_Var2

	PLA		 ; Restore adjusted tile
	STA <Temp_Var1	 ; -> Temp_Var1

	CMP Tile_AttrTable,Y
	BLT PRG007_A557	 ; If this tile is not solid on top, jump to PRG007_A557

	; Tile is solid on top...

	CMP Tile_AttrTable+4,Y
	BLT PRG007_A59F	 ; If this tile is not solid on the sides/bottom, jump to PRG007_A59F

	; Tile is solid all around

	LDY Level_TilesetIdx
	CPY #$0b
	BNE PRG007_A566	 ; If this is not an Ice level, jump to PRG007_A566

	CMP #TILE12_FROZENMUNCHER
	BNE PRG007_A55D		; If the fireball did not hit a frozen muncher, jump to PRG007_A55D

	; Fireball hit a frozen muncher!

	LDA #CHNGTILE_FROZENMUNCHER
	BNE PRG007_A563	 ; Jump (technically always) to PRG007_A563

PRG007_A557:

	; Fireball_HitChkPass = 0
	LDA #$00
	STA Fireball_HitChkPass,X

	RTS		 ; Return

PRG007_A55D:
	CMP #TILE12_FROZENCOIN
	BNE PRG007_A566	 ; If the fireball did not hit a frozen coin, jump to PRG007_A566

	; Fireball hit a frozen coin!

	LDA #CHNGTILE_FROZENCOIN

PRG007_A563:
	JSR Fireball_ThawTile	 ; Thaw the frozen tile!

PRG007_A566:
	LDA <Temp_Var1

	LDY Level_SlopeEn
	BEQ PRG007_A579	 ; If this level is NOT sloped, jump to PRG007_A579

	; If this is a slope level and fireball hit level ground, jump to PRG007_A594
	CMP #TILE14_ABOVE_MIDGROUND
	BEQ PRG007_A594
	CMP #TILE3_MIDGROUND
	BEQ PRG007_A594
	CMP #TILE3_WMIDGROUND
	BEQ PRG007_A594

PRG007_A579:
	INC Fireball_HitChkPass,X	; Fireball_HitChkPass++

	LDA Fireball_HitChkPass,X
	CMP #$02
	BNE PRG007_A586	 ; If Fireball_HitChkPass <> 2, jump to PRG007_A586

	; Fireball has been through hit check too many times, it's obviously done

	JMP PRG007_A637	 ; Jump to PRG007_A637 ("Poof" away, fireball..)

PRG007_A586:

	; Fireball Y -= 2
	LDA PlayerProj_Y,X
	SUB #$02
	STA PlayerProj_Y,X
	BCS PRG007_A594
	DEC PlayerProj_YHi,X	 ; Apply carry
PRG007_A594:

	; Bounce fireball!
	LDA #-$03

PRG007_A596:
	STA PlayerProj_YVel,X

	; Reset counter to 3
	LDA #$03
	STA PlayerProj_Cnt,X

	RTS		 ; Return

PRG007_A59F:

	; Tile not solid on sides/bottom...

	LDA Level_SlopeEn
	BNE PRG007_A5DC		; If this is a sloped level, jump to PRG007_A5DC

	; Not a sloped level...

	LDA <Temp_Var6	; Relative Y of fireball
	AND #$0f	; Within tile
	CMP #$05	
	BLT PRG007_A594	; If fireball is high enough on the top-solid-only tile, then bounce! (Jump to PRG007_A594)

	RTS		 ; Return


Fireball_ThawTile:
	STA Level_ChgTileEvent	 ; Queue tile change event!

	JSR BrickBust_MoveOver	 ; Open up a brick bust

	; Brick bust "poof" style (over top of the changing tile)
	LDA #$01
	STA BrickBust_En

	; Set block change Y 
	LDA <Temp_Var3
	STA Level_BlockChgYLo

	; Set poof Y
	SBC Level_VertScroll
	STA BrickBust_YUpr

	; Set block change Y Hi
	LDA <Temp_Var4
	STA Level_BlockChgYHi

	; Set block change X
	LDA <Temp_Var5
	AND #$f0
	STA Level_BlockChgXLo

	; Set poof X
	SBC <Horz_Scroll
	STA BrickBust_X	

	; Set block change X Hi
	LDA <Temp_Var7
	STA Level_BlockChgXHi

	JMP PlayerProj_ChangeToPoof	 ; Change the projectile itself into a poof


PRG007_A5DC:

	; Temp_Var6 will remain as "Y offset within tile"
	LDA <Temp_Var6
	AND #$0f
	STA <Temp_Var6

	; Temp_Var5 will remain as "X offset within tile"
	LDA <Temp_Var5
	AND #$0f
	STA <Temp_Var5

	LDY <Temp_Var2	 ; Y = tile quadrant
	TYA
	ASL A
	TAX		 ; X = tile quadrant * 2 (2 byte index into Level_SlopeSetByQuad)

	; Temp_Var3/4 pointer into appropriate Level_SlopeSetByQuad
	LDA Level_SlopeSetByQuad,X
	STA <Temp_Var3
	LDA Level_SlopeSetByQuad+1,X
	STA <Temp_Var4

	LDX <SlotIndexBackup	 ; X = Player Projectile index

	LDA <Temp_Var1
	SUB Tile_AttrTable,Y
	TAY		 ; Y = tile made relative to solid set

	LDA [Temp_Var3],Y
	TAY		 ; Y = slope offset for this tile

	LDA Slope_ObjectVel_Effect,Y
	CMP #$80
	BEQ PRG007_A637	 ; If this tile has no effect, jump to PRG007_A637 ("Poof" away, fireball..)

	STA <Temp_Var7	 ; Effect value -> Temp_Var7

	TYA
	ASL A
	ASL A
	ASL A
	ASL A		; Multiply relative tile index by 16 (because 16 slope values exist across each 16x16 tile)
	ADD <Temp_Var5	; Add specific offset across tile
	TAY		; -> 'Y'

	; Lower 4 bits of Slope_LUT (the "sloped floor height" component) -> Temp_Var2
	LDA Slope_LUT,Y
	AND #$0f
	STA <Temp_Var2

	LDA <Temp_Var6
	CMP #12
	BGE PRG007_A626	 ; If fireball is deeper than 12 pixels into the tile, jump to PRG007_A626

	CMP <Temp_Var2
	BLT PRG007_A645	 ; If fireball is higher than the slope height, jump to PRG007_A645 (RTS)

PRG007_A626:
	LDA <Temp_Var7
	BEQ PRG007_A642	 ; If effect value = 0, jump to PRG007_A642

	LDY #-$05	 ; Y = -$05 (high bounce velocity)
	EOR PlayerProj_XVel,X
	BMI PRG007_A633
	LDY #-$02	 ; Y = -$02 (low bounce velocity)
PRG007_A633:
	TYA
	JMP PRG007_A596	 ; Jump to PRG007_A596

PRG007_A637:

	; "Bump" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	JMP PlayerProj_ChangeToPoof	; Turn into a "poof" and don't come back!

PRG007_A642:
	JMP PRG007_A594	 ; Jump to PRG007_A594 (another pass through the hit routines, should cause it to "poof" out)

PRG007_A645:
	RTS		 ; Return

PlayerProj_HitEnemies:

	; Fireball/hammer common...

	LDY #$04	 ; Y = 4 (enemies only exist in the lower slots)
PRG007_A648:
	LDA Objects_SprHVis,Y
	ORA Objects_SprVVis,Y
	BNE PRG007_A667	 ; If object has sprites horizontally or vertically off-screen, jump to PRG007_A667 (Forget it!)

	LDX Objects_State,Y	; X = object's state
	LDA Obj2Obj_EnByState,X
	BNE PRG007_A667	 ; If this state does not support object-to-object (object-to-Projectile), jump to PRG007_A667 (Forget it!)

	LDX Level_ObjectID,Y	; X = object's ID
	LDA Object_AttrFlags,X	
	STA <Temp_Var1		; Object attribute flags -> Temp_Var1

	AND #OAT_WEAPONIMMUNITY
	BNE PRG007_A667	 ; If object is immune to Player weapons, jump to PRG007_A667

	JSR PlayerProj_HitObject	 ; See if Player Project hit an object and respond!

PRG007_A667:
	DEY		 ; Y--
	BPL PRG007_A648	; While Y >= 0, loop

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

PRG007_A66C:
	RTS		 ; Return

	; A Y range per bounding box index
Projectile_BBoxY:	.byte $18, $18, $28, $18, $18, $18, $18, $18, $18, $18, $20, $18, $18, $28, $18, $18

	; An X range per bounding box index
Projectile_BBoxX:	.byte $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $10, $18, $10, $10


PlayerProj_HitObject:
	LDA <Temp_Var1		 
	AND #OAT_BOUNDBOXMASK
	TAX		 ; X = Object's bounding box index
	STX <Temp_Var2	 ; -> Temp_var2

	LDA <Temp_Var13	 	; Detect Y of projectile
	SUB Objects_SpriteY,Y	; Difference against this object's Sprite Y
	CMP Projectile_BBoxY,X
	LDX <SlotIndexBackup	; X = Player Projectile slot index
	BGE PRG007_A66C	 	; If projectile is out of range vertically, jump to PRG007_A66C (RTS)

	LDA <Temp_Var14		; Detect X of projectile
	SUB Objects_SpriteX,Y	; Difference against this object's Sprite X
	LDX <Temp_Var2		; X = bounding box index
	CMP Projectile_BBoxX,X
	LDX <SlotIndexBackup	; X = Player Projectile slot index
	BGE PRG007_A6FD	 	; If projectile is out of range horizontally, jump to PRG007_A6FD (RTS)

	LDA PlayerProj_ID,X
	CMP #$02
	BEQ PRG007_A6BD	 ; If this is a hammer, jump to PRG007_A6BD

	JSR PlayerProj_ChangeToPoof	 ; "Poof" goes the fireball
	JMP PRG007_A6C3	 ; Jump to PRG007_A6C3

PRG007_A6BD:

	; Hammer hit...

	LDA <Temp_Var1	; Object's attributes
	BMI PRG007_A6FD	 ; If OAT_HITNOTKILL is set, jump to PRG007_A6FD (RTS)
	BPL PRG007_A6C9	 ; Otherwise, jump to PRG007_A6C9

PRG007_A6C3:

	; Fireball only...

	LDA <Temp_Var1
	AND #OAT_FIREIMMUNITY
	BNE PRG007_A6FE	 ; If object is immune to fire, jump to PRG007_A6FE

PRG007_A6C9:

	; Weapon successfully hit!

	; Play "kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	LDA Objects_HitCount,Y
	BEQ PRG007_A6DD	 ; If enemy has no hits left, jump to PRG007_A6DD

	; Otherwise, just remove a hit...
	SUB #$01
	STA Objects_HitCount,Y

	RTS		 ; Return


PRG007_A6DD:

	; Enemy bounces upward a bit
	LDA #-$34
	STA Objects_YVel,Y

	; Set object's velocity based on Player's velocity (sort of works)
	LDA PlayerProj_XVel,X
	ASL A
	LDA #$0C
	BCC PRG007_A6EC	 ; If Player's X Velocity is negative, jump to PRG007_A6EC
	LDA #-$0C
PRG007_A6EC:
	STA Objects_XVel,Y

	TYA
	TAX	; object index -> 'X'

	; 100 pts!
	LDA #$05
	JSR Score_PopUp

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

	; But the enemy is killed...
	LDA #OBJSTATE_KILLED
	STA Objects_State,Y

PRG007_A6FD:
	RTS		 ; Return

PRG007_A6FE:
	JMP PRG007_A637	 ; Jump to PRG007_A637

Fireball_PoofPattern:	.byte $45, $41, $43, $47

PRG007_A705:

	; Fireball poof!

	LDY <Player_HaltGame
	BNE PRG007_A719	 ; If gameplay halted, jump to PRG007_A719

	; PlayerProj_ID is now the fireball poof counter for the remainder

	INC PlayerProj_ID,X	 ; PlayerProj_ID++

	LDA PlayerProj_ID,X
	CMP #$10
	BNE PRG007_A719	 ; If PlayerProj_ID <> $10, jump to PRG007_A719

PRG007_A713:
	; Poof is over; clear it!
	LDA #$00
	STA PlayerProj_ID,X

	RTS		 ; Return

PRG007_A719:
	TXA
	ADD <Counter_1
	AND #$01	; A = 0 or 1
	ASL A
	ASL A
	ASL A		; A = 0 or 8
	ADC #$18	; A = $18 or $20
	TAY		; -> 'Y'

	; Set poof left sprite X
	LDA PlayerProj_X,X
	SBC #$04
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	; Set poof right sprite X
	ADD #$08
	STA Sprite_RAM+$07,Y

	LDA PlayerProj_Y,X
	SUB Level_VertScroll
	CMP #208
	BGE PRG007_A713	 ; If poof has fallen too low, jump to PRG007_A713 (remove it)

	; Set left and right "poof" sprite Ys
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA PlayerProj_ID,X
	LSR A
	LSR A
	TAX		 ; X = index into Fireball_PoofPattern
	LDA Fireball_PoofPattern,X	 ; Get proper poof pattern

	; Set left and right "poof" sprite pattern
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDA #SPR_PAL1

	LDX Player_Behind
	BEQ PRG007_A75F	 ; If Player is not behind the scenes, jump to PRG007_A75F

	ORA #SPR_BEHINDBG

PRG007_A75F:
	STA Sprite_RAM+$02,Y	; Set left sprite attributes
	ORA #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y	 ; Set right sprite attributes

	LDX <SlotIndexBackup	 ; X = Player Projectile slot index

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_WaterOrWaterfallVizFX
;
; Visual effects for standing in a waterfall (splashing on head)
; or the periodic bubbles underwater...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Y offsets for periodic bubble generated by the Player while underwater
SwimBubble_YOff:
	.byte $04, $04	; Not a frog swimming frame
	.byte $08, $08	; Idle or left/right frog swimming
	.byte $0D, $0D	; Down frog swim
	.byte $00, $00	; Up frog swim

	; X offsets for periodic bubble generated by the Player while underwater (left is not horizontally flipped, right is h-flipped)
SwimBubble_XOff:
	.byte $00, $0B	; Not a frog swimming frame
	.byte $00, $0B	; Idle or left/right frog swimming
	.byte $05, $05	; Down frog swim
	.byte $05, $05	; Up frog swim

Player_WaterOrWaterfallVizFX:
	LDY Player_FlyTime
	INY
	BNE PRG007_A783	 ; (Will be zero if Player_FlyTime = $FF, i.e. P-Wing) If not using P-Wing, jump to PRG007_A783

	; Otherwise, clear kill tally (P-Wing does not net you 1-ups)
	STY Kill_Tally

PRG007_A783:
	LDY <Player_HaltGame
	BNE PRG007_A7F0	 ; If gameplay halted, jump to PRG007_A7F0 (RTS)

	LDA Player_InWater
	BEQ PRG007_A7F0	 ; If Player is not underwater, jump to PRG007_A7F0 (RTS)

	; Otherwise, clear kill tally (Being underwater also resets your chain stomping)
	STY Kill_Tally

	CMP #$01
	BEQ PRG007_A7F1	 ; If Player_InWater = 1 (water, not waterfall), jump to PRG007_A7F1

	; Player's in a waterfall!

	LDA <Player_YVel
	CMP #$3c
	BGS PRG007_A7A2	 ; If Player's Y velocity >= $3C, jump to PRG007_A7A2

	INC <Player_YVel ; Player_YVel++

	LDA <Counter_1
	LSR A	
	BCC PRG007_A7A2	 ; Every other tick, jump to PRG007_A7A2

	INC <Player_YVel ; Player_YVel++

PRG007_A7A2:
	JSR Object_GetRandNearUnusedSpr
	BEQ PRG007_A7F0	 ; If no free sprite, jump to PRG007_A7F0 (RTS)

	LDA Player_OffScreen
	BNE PRG007_A7F0	 ; If Player is off-screen, jump to PRG007_A7F0 (RTS)

	; Patterns for "splashing" effect seen above Player's head
	LDA #$47
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDA <Counter_1
	LSR A
	AND #$03
	ADD #$05	; Value of 5 to 8

	LDX Player_IsDucking
	BNE PRG007_A7C6	 ; If Player is ducking, jump to PRG007_A7C6

	LDX Player_Suit
	BNE PRG007_A7C9	 ; If Player is not small, jump to PRG007_A7C9

PRG007_A7C6:
	ADD #10		 ; Small or ducking, +10 (15 to 18)

PRG007_A7C9:
	STA <Temp_Var1	 ; -> Temp_Var1

	LDX <SlotIndexBackup	 ; Restore 'X' as slot index

	; Sprite "splashing" effect Y
	LDA <Player_SpriteY
	ADD <Temp_Var1
	SUB #10
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Sprite "splashing" effect X
	LDA <Player_SpriteX
	STA Sprite_RAM+$03,Y
	ADD #$08
	STA Sprite_RAM+$07,Y

	LDA <Counter_1
	AND #$03
	SUB #$02	 ; A = -2 to 1 (spread value)

	JSR Draw_SpreadAndColorful	 ; Spreads out the two sprites and rotates the color palette

PRG007_A7F0:
	RTS		 ; Return


PRG007_A7F1:

	; Player's in regular old water

	LDY #$7f	 ; Y = $7F ("slow" mask value for idle underwater player)

	LDA <Pad_Holding
	AND #(PAD_A | PAD_LEFT | PAD_RIGHT)
	BEQ PRG007_A7FB	 ; If Player is not pressing A, LEFT, or RIGHT (swim controls), jump to PRG007_A7FB

	LDY #$3f	 ; Y = $3F ("fast" mask value for idle underwater player)

PRG007_A7FB:
	TYA		 ; Mask -> 'Y'
	AND <Counter_1
	BNE PRG007_A80C	 ; Periodically jump to PRG007_A80C (RTS)

	; SlotIndexBackup = 2
	LDX #$02
PRG007_A802:
	STX <SlotIndexBackup

	LDA Bubble_Cnt,X
	BEQ PRG007_A80D	 ; If this bubble slot is empty, jump to PRG007_A80D

	DEX		 ; X--
	BPL PRG007_A802	 ; While X >= 0, loop!

PRG007_A80C:
	RTS		 ; Return


PRG007_A80D:
	LDA RandomN
	ORA #$10
	STA Bubble_Cnt,X ; Set random value -> Bubble_Cnt

	LDY #$00	 ; Y = 0

	LDA <Player_Frame
	CMP #PF_FROGSWIM_UPBASE
	BLT PRG007_A835	 ; If Player is not within the low end range of frog suit swim frames, jump to PRG007_A835

	LDY #$03	 ; Otherwise, Y = 3 (pending this might be the "up" frame)

	CMP #PF_FROGHOP_BASE
	BLT PRG007_A835	 ; If frame < PF_FROGHOP_BASE (if true, then absolutely the "up" swim frame), jump to PRG007_A835

	LDY #$00	 ; Otherwise, Y = 0

	CMP #PF_FROGSWIM_IDLEBASE
	BLT PRG007_A835	 ; If not possibly just the "idling" frog frames, jump to PRG007_A835

	INY		 ; Otherwise, Y = 1 (idle or left/right frog swim)

	CMP #PF_FROGSWIM_LRBASE+2
	BLT PRG007_A835	 ; Not a down swimming frame, jump to PRG007_A835

	INY		 ; Otherwise, Y = 2 (down frog swim)

	CMP #(PF_FROGSWIM_DOWNBASE+3)	; This is actually 1 passed the end of frog suit swim frames
	BLT PRG007_A835	 ; If within range of the last frog suit swim frame, jump to PRG007_A835

	LDY #$00	 ; Otherwise, Y = 0

PRG007_A835:

	; Y *= 2
	TYA
	ASL A
	TAY

	BIT <Player_FlipBits
	BVC PRG007_A83D	 ; If Player is not horizontally flipped, jump to PRG007_A83D

	INY		 ; Otherwise, Y++

PRG007_A83D:
	LDA #$00	; A = 0

	LDX <Player_Suit
	BNE PRG007_A845	 ; If Player is not small, jump to PRG007_A845
 
	LDA #$08	 ; Otherwise, A = 8

PRG007_A845:
	LDX <SlotIndexBackup	 ; X = slot backup

	; Set Bubble Y
	ADD <Player_Y
	ADC SwimBubble_YOff,Y
	STA Bubble_Y,X
	LDA <Player_YHi
	ADC #$00
	STA Bubble_YHi,X

	; Set Bubble X
	LDA <Player_X
	ADD SwimBubble_XOff,Y
	STA Bubble_X,X
	LDA <Player_XHi
	ADC #$00
	STA Bubble_XHi,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bubbles_UpdateAndDraw
;
; Update and draw bubbles that appear underwater
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Bubbles_UpdateAndDraw:
	LDX #$03	 ; X = 3
PRG007_A86A:
	STX <SlotIndexBackup	 ; -> Slot index backup

	LDA Bubble_Cnt,X
	BEQ PRG007_A874	 ; If this bubble slot is not in use, jump to PRG007_A874

	JSR Bubble_UpdateAndDraw	 ; Update and draw this bubble

PRG007_A874:
	DEX		; X--
	BPL PRG007_A86A	; While X >= 0, loop!

	RTS		 ; Return


Bubble_UpdateAndDraw:
	LDA <Player_HaltGame		 
	BEQ PRG007_A87F	 ; If gameplay is not halted, juimp to PRG007_A89A

	JMP PRG007_A89A	 ; Otherwise, jump to PRG007_A89A

PRG007_A87F:
	INC Bubble_Cnt,X ; Bubble counter increment

	; Fix bit 7 on bubble counter
	LDA Bubble_Cnt,X
	ORA #$80
	STA Bubble_Cnt,X

	AND #%00110000
	BEQ PRG007_A89A	 ; Periodically jump to PRG007_A89A

	DEC Bubble_Y,X	 ; Bubble Y --

	LDY Bubble_Y,X
	INY	
	BNE PRG007_A89A	 ; If no carry, jump to PRG007_A89A
	DEC Bubble_YHi,X ; Apply carry

PRG007_A89A:
	LDA Level_7Vertical
	BEQ PRG007_A8BF	 ; If this level is not vertical, jump to PRG007_A8F0

	; Vertical level...

	LDA Bubble_Y,X
	ADD #10		; Bubble Y + 10
	AND #$f0
	STA <Temp_Var3	; Temp_Var3 = bubble row (offset into tile memory)

	LDA Bubble_YHi,X
	ADC #HIGH(Tile_Mem)
	STA <Temp_Var2	; Temp_Var2 = bubble high offset into tile memory

	; Create row/column offset into tile memory for current screen of bubble -> Temp_var1
	LDA Bubble_X,X
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	STA <Temp_Var1

	LDY #$00	 ; Y = 0 (not using the offset like non-vertical does)
	BEQ PRG007_A8F0	 ; Jump (technically always) to PRG007_A8F0

PRG007_A8BF:
	LDA Bubble_Y,X
	ADD #10		 ; Bubble Y + 10
	AND #$f0
	STA <Temp_Var3	 ; Temp_Var3 = bubble row (offset into tile memory)

	LDA Bubble_YHi,X
	ADC #$00	 ; Apply carry
	PHA		 ; Save it

	; Temp_Var5 = bubble X
	LDA Bubble_X,X
	STA <Temp_Var5

	LDA Bubble_XHi,X
	ASL A		 ; 2 bytes per screen
	TAY		 ; Y = offset into Tile_Mem_Addr

	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1	 ; Temp_Var1 = low byte of this screen's tile memory address

	PLA		 ; Restore Bubble's Y Hi
	AND #$01	 ; Only 0/1 valid for non-vertical
	ADD Tile_Mem_Addr+1,Y	 ; Add to high byte of address
	STA <Temp_Var2	 ; -> Temp_Var2

	; Create row/column offset -> Temp_Var3
	LDA <Temp_Var5
	LSR A	
	LSR A	
	LSR A	
	LSR A	
	ORA <Temp_Var3

	TAY		 ; Y = this offset

PRG007_A8F0:
	LDA [Temp_Var1],Y ; Get the tile the bubble detects

	PHA		 ; Save it

	; Get tile "quadrant" -> Temp_Var1
	ASL A
	ROL A
	ROL A
	AND #$03
	STA <Temp_Var1

	PLA		 ; Restore specific tile
	STA <Temp_Var2	 ; -> Temp_Var2

	LDY <Temp_Var1	 ; Y = tile quadrant
	CMP Tile_AttrTable,Y
	BGE PRG007_A91E	 ; If this tile is solid, jump to PRG007_A91E (destroy bubble)

	LDA Level_TilesetIdx
	ASL A
	ASL A		; Tileset index * 4
	ADD <Temp_Var1	; + quadrant
	TAY	; -> 'Y' (offset into Level_MinTileUWByQuad)

	LDA <Temp_Var2
	CMP #TILE1_WFALLTOP
	BEQ PRG007_A91E	 ; If this is the top of a waterfall, jump to PRG007_A915 (indirect to PRG007_A91E)

	CMP #TILE1_WFALLMID

PRG007_A915:
	BEQ PRG007_A91E	 ; If this is the top or middle of a waterfall, jump to PRG007_A91E

	LDA Level_MinTileUWByQuad,Y
	CMP <Temp_Var2
	BLT Bubble_Draw	 ; If this tile is still considered underwater, jump to Bubble_Draw 

PRG007_A91E:

	; Remove this bubble
	LDA #$00
	STA Bubble_Cnt,X

	RTS		 ; Return

Bubble_XOff:		.byte $00, $01, $00, -$01
Bubble_SprRAMOff:	.byte $10, $14, $0C, $FF, $10, $14, $0C

Bubble_Draw:
	LDA Level_NoStopCnt
	AND #%00001100
	LSR A	
	LSR A	
	TAY		 ; Y = 0 to 3

	; Temp_Var1 = bubble's X offset
	LDA Bubble_XOff,Y
	STA <Temp_Var1

	LDA <Counter_1
	AND #%00000011
	ADC <SlotIndexBackup 	
	TAY		 ; Y = (0 to 3) + bubble's index

	LDA Bubble_SprRAMOff,Y
	BMI PRG007_A978	 ; If we hit the $FF value in Bubble_SprRAMOff, jump to PRG007_A978 (RTS)

	TAY		 ; -> 'Y'

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BNE PRG007_A978	 ; If this sprite is not free, jump to PRG007_A978 (RTS)

	; Bubble Y
	LDA Bubble_Y,X
	SUB Level_VertScroll
	STA Sprite_RAM+$00,Y

	CMP #200
	BGE PRG007_A91E	 ; If this bubble's sprite Y >= 200, jump to PRG007_A91E (destroy bubble)

	; Bubble X
	LDA Bubble_X,X
	ADD <Temp_Var1
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	CMP #248
	BCS PRG007_A91E	 ; If this bubble's X >= 248, jump  to PRG007_A91E (destroy bubble)

	; Bubble's pattern
	LDA #$17
	STA Sprite_RAM+$01,Y

	; Bubble's attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

PRG007_A978:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Splash_UpdateAndDraw
;
; Update and draw water surface splashes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Splash_UpdateAndDraw:
	LDX #$02	 ; X = 2
PRG007_A97B:
	STX <SlotIndexBackup	 ; -> Slot Index backup

	LDA Splash_Counter,X
	BEQ PRG007_A9A0	 ; If no splash is active here, jump to PRG007_A9A0

	LDA <Player_HaltGame

	; This probably used to skip something if gameplay was halted, i.e. (BNE xxxx)
	NOP
	NOP

	INC Splash_Counter,X	 ; Splash counter++

	LDA <Counter_1
	LSR A
	BCC PRG007_A991	 ; Every other tick, jump to PRG007_A991

	INC Splash_Counter,X	 ; Splash counter++

PRG007_A991:
	LDA Splash_Counter,X
	CMP #$30
	BLT PRG007_A99D	 ; If splash counter < $30, jump to PRG007_A99D

	JSR Splash_Remove ; Remove this splash
	BEQ PRG007_A9A0	 ; Jump (technically always) to PRG007_A9A0

PRG007_A99D:
	JSR Splash_Draw	 ; Draw this splash

PRG007_A9A0:
	DEX		 ; X--
	BPL PRG007_A97B	 ; While X >= 0, loop!

	RTS		 ; Return

Splash_Patterns:
	.byte $11, $13, $15, $47, $47, $47

Splash_Remove:

	; Remove this splash
	LDA #$00	 
	STA Splash_Counter,X

PRG007_A9AF:
	RTS		 ; Return

Splash_Draw:
	JSR Object_GetRandNearUnusedSpr	 
	BEQ PRG007_A9AF	 ; If no sprite available, jump to PRG007_A9AF (RTS)

	STY <Temp_Var1	 ; Sprite RAM offset -> Temp_Var1

	LDA Splash_X,X
	SUB <Horz_Scroll	; Make scroll relative X for splash

	CMP #240
	BGE Splash_Remove	; If splash X >= 240, jump to Splash_Remove

	STA Sprite_RAM+$03,Y	 ; Set left splash sprite X

	ADC #$08	 ; +8
	STA Sprite_RAM+$07,Y	; Set right splash sprite X

	LDA Splash_Y,X		; Get splash Y

	LDY Splash_NoScrollY,X
	BNE PRG007_A9D5	 	; If Splash_NoScrollY is set, do not make splash Y scroll relative

	SUB Level_VertScroll	 ; Make scroll relative Y for splash

PRG007_A9D5:
	LDY <Temp_Var1		 ; Y = sprite RAM offset

	CMP #$ae
	BGE Splash_Remove	 ; If splash sprite RAM offset >= $AE (?), jump to Splash_Remove (remove it!)

	; Set splash sprites Y
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Set left splash sprite attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	; Set right splash sprite attributes
	LDA #(SPR_PAL1 | SPR_HFLIP)
	STA Sprite_RAM+$06,Y

	LDA Splash_Counter,X
	LSR A
	LSR A
	LSR A
	TAX		; X = splash counter / 8
	STX <Temp_Var1	; -> Temp_Var1

	; Set splash sprite patterns
	LDA Splash_Patterns,X
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDX <SlotIndexBackup	 ; X = splash index

	LDA <Temp_Var1
	CMP #$03
	BLT PRG007_AA4C	 ; If (splash counter / 8) < 3, jump to PRG007_AA4C (RTS)

	LDA <Counter_1
	AND #$01
	ORA <Player_HaltGame
	BNE PRG007_AA10	 ; Every other tick or gameplay halted, jump to 

	INC Splash_Y,X	 ; Splash_Y++

PRG007_AA10:
	LDA Splash_Counter,X
	SUB #24
	LSR A	
	LSR A	
	LSR A	
	AND #$03	 ; A = (splash counter - 24) / 8

Draw_SpreadAndColorful:
	STA <Temp_Var1		 

	; Subtract from sprite X
	LDA Sprite_RAM+$03,Y
	SUB <Temp_Var1	
	STA Sprite_RAM+$03,Y

	; Add to other sprite X
	LDA Sprite_RAM+$07,Y
	ADD <Temp_Var1
	STA Sprite_RAM+$07,Y

	; Set attributes of two sprites
	LDA #SPR_PAL1
	STA Sprite_RAM+$06,Y

	ORA #SPR_HFLIP
	STA Sprite_RAM+$02,Y

	LDA Level_NoStopCnt
	AND #$02
	BNE PRG007_AA4C	 ; 2 ticks on, 2 ticks off; jump to PRG007_AA4C (RTS)

	; Mess with attributes for a little sparkly fun
	LDA <Temp_Var1
	ORA #SPR_VFLIP
	STA Sprite_RAM+$02,Y

	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

PRG007_AA4C:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Scores_GiveAndDraw
;
; Gives awarded points and draws score sprites.  Also caps 
; the Kill_Tally variable at a maximum value of 8.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; Patterns for the left and right sprites of the score sprite ($FF means "don't display")
	;		       10   20   40   80  100  200  400  800 1000 2000 4000 8000 1-up
Score_PatternLeft:	.byte $FF, $FF, $FF, $FF, $5B, $63, $6B, $6D, $5B, $63, $6B, $6D, $61
Score_PatternRight:	.byte $5B, $63, $6B, $6D, $69, $69, $69, $69, $59, $59, $59, $59, $6F

	; Score to add (low byte)
ScoreAdd_L:
	.byte LOW(  1)	;   10 points
	.byte LOW(  2)	;   20 points
	.byte LOW(  4)	;   40 points
	.byte LOW(  8)	;   80 points
	.byte LOW( 10)	;  100 points
	.byte LOW( 20)	;  200 points
	.byte LOW( 40)	;  400 points
	.byte LOW( 80)	;  800 points
	.byte LOW(100)	; 1000 points
	.byte LOW(200)	; 2000 points
	.byte LOW(400)	; 4000 points
	.byte LOW(800)	; 8000 points
	.byte $00	; 1-up (no score value)

	; Score to add (high byte)
ScoreAdd_H:
	.byte HIGH(  1)	;   10 points
	.byte HIGH(  2)	;   20 points
	.byte HIGH(  4)	;   40 points
	.byte HIGH(  8)	;   80 points
	.byte HIGH( 10)	;  100 points
	.byte HIGH( 20)	;  200 points
	.byte HIGH( 40)	;  400 points
	.byte HIGH( 80)	;  800 points
	.byte HIGH(100)	; 1000 points
	.byte HIGH(200)	; 2000 points
	.byte HIGH(400)	; 4000 points
	.byte HIGH(800)	; 8000 points
	.byte $00	; 1-up (no score value)


Scores_GiveAndDraw:
	LDA Kill_Tally	  
	CMP #$08
	BLT PRG007_AA8D	 ; If Kill_Tally < 8, jump to PRG007_AA8D

	; Max Kill_Tally at 8
	LDA #$08
	STA Kill_Tally

PRG007_AA8D:
	LDX #$04	; X = 4 (all five on-screen "scores")
PRG007_AA8F:
	STX <SlotIndexBackup	 ; Update SlotIndexBackup

	LDA Scores_Value,X
	AND #$7f	 ; Keep only lower 7 bits
	BEQ PRG007_AAAD	 ; If this score's value is $00 or $80, jump to PRG007_AAAD

	CMP #$0D
	BLT PRG007_AAA8	 ; If score value < $0D (1-up), jump to PRG007_AAA8

	LDA Scores_Value,X
	AND #$80	; Keep bit 7
	ORA #$0d	; Cap at 1-up ($0D) regardless of value
	STA Scores_Value,X	 ; Update value

	AND #$7f	 ; Keep only lower 7 bits

PRG007_AAA8:
	STA <Temp_Var1	 	; Score value -> Temp_Var1
	JSR Score_GiveAndDraw	; Give awarded points and draw score sprites

PRG007_AAAD:
	DEX		 ; X--
	BPL PRG007_AA8F	 ; While X >= 0, loop!
	RTS		 ; Return

Score_GiveAndDraw:
	LDA Player_Grow	  	; If Player is growing up...
	ORA Player_StarOff	; ... is losing invincibility (?) ...
	ORA Player_SuitLost	; ... or has lost their power-up ...
	BNE PRG007_AAC0	 	; ... then jump to PRG007_AAC0

	LDA <Player_HaltGame
	BNE PRG007_AB1D	 	; If gameplay is halted, jump to PRG007_AB1D

PRG007_AAC0:
	LDA Scores_Counter,X
	BNE PRG007_AACF	 ; If this score counter hasn't expired, jump to PRG007_AACF

PRG007_AAC5:
	; Otherwise, this score is finished; clear it out!
	LDA #$00
	STA Scores_Value,X

	RTS		 ; Return

	; Mask values that control how quickly the score rises
Score_RiseCounterMask:	.byte $03, $01, $00, $00

PRG007_AACF:
	DEC Scores_Counter,X	 ; Decrement the score counter

	CMP #$2a
	BNE PRG007_AB04	 ; If score counter <> $2A, jump to PRG007_AB04

	; Score counter = $2A...

	LDY <Temp_Var1	 ; Y = score value

	; Add Score's value to Score_Earned
	LDA Score_Earned
	ADD ScoreAdd_L-1,Y	; -1 because a score value of zero is "empty"
	STA Score_Earned
	LDA Score_Earned+1
	ADC ScoreAdd_H-1,Y
	STA Score_Earned+1

	CPY #$0d
	BNE PRG007_AB02	 ; If this is not 1-up level score, jump to PRG007_AB02

	; Play 1-up sound!
	LDA Sound_QLevel1
	ORA #SND_LEVEL1UP
	STA Sound_QLevel1

	LDX Player_Current	 ; X = current Player

	LDA Player_Lives,X
	BMI PRG007_AB02	 	; If this Player is dead (and how could we be here, hmm?), jump to PRG007_AB02

	INC Player_Lives,X	; Otherwise, give them the extra life!

PRG007_AB02:
	LDX <SlotIndexBackup	; X = score slot index

PRG007_AB04:
	LDA Scores_Counter,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = score counter / 16

	LDA <Counter_1
	AND Score_RiseCounterMask,Y
	BNE PRG007_AB1D	 ; Periodically jump to PRG007_AB1D

	LDA Scores_Y,X
	CMP #$04
	BLT PRG007_AB1D	 ; If this score's Y < 4, jump to PRG007_AB1D

	DEC Scores_Y,X	 ; Otherwise, rise up!

PRG007_AB1D:

	; Scroll score horizontally with screen
	LDA Scores_X,X
	SUB Level_ScrollDiffH
	STA Scores_X,X

	CMP #248
	BGE PRG007_AAC5	 ; If score's X >= 248, jump to PRG007_AAC5 (get rid of it!)

	; Scroll score vertically with screen
	LDA Scores_Y,X
	SUB Level_ScrollDiffV
	STA Scores_Y,X

	CMP #248
	BGE PRG007_AAC5	 ; If score's Y >= 248, jump to PRG007_AAC5 (get rid of it!)

	LDA Scores_Value,X
	BMI PRG007_AB53		; If score value has bit 7 set, jump to PRG007_AB53

	; Otherwise...

	; This just takes from object sprite RAM
	LDA Object_SprRAM,X
	ADD #16		; +16 (4 sprites over)
	TAY		 ; Y = Sprite RAM offset
	STY <Temp_Var5	 ; -> Temp_Var5

	ADD #$04	 ; +4 (1 sprite over)
	STA <Temp_Var6	 ; -> Temp_Var6

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BEQ PRG007_AB76	 ; If this sprite is free, jump to PRG007_AB76

PRG007_AB53:
	JSR Object_GetRandNearUnusedSpr		; Sprite is not free; get a nearby one

	STY <Temp_Var5	 ; -> Temp_Var5
	BNE PRG007_AB70	 ; As long as result wasn't zero, jump to PRG007_AB70

	; No sprites available...

	; Temp_Var6 = $FF
	LDA #$ff
	STA <Temp_Var6

	LDA <Counter_1
	LSR A
	BCC PRG007_AB6D	 ; Every other tick, jump to PRG007_AB6D

	; Basically only one or the other half of the score will actually display
	LDA <Temp_Var5
	PHA
	LDA <Temp_Var6
	STA <Temp_Var5
	PLA
	STA <Temp_Var6

PRG007_AB6D:
	JMP PRG007_AB76	 ; Jump to PRG007_AB76

PRG007_AB70:
	; New sprite RAM offset selected...
	TYA		 ; -> Y
	ADD #$04	 ; +4 (next sprite over)
	STA <Temp_Var6	 ; -> Temp_Var6

PRG007_AB76: 
	LDY <Temp_Var5
	CPY #$ff
	BEQ PRG007_AB99	 ; If this sprite RAM offset is invalid, jump to PRG007_AB99

	LDX <Temp_Var1	 ; X = score value

	LDA Score_PatternLeft-1,X	 ; -1 because a score value of zero is "empty"

	LDX <SlotIndexBackup	 ; X = score slot index

	CMP #$ff
	BEQ PRG007_AB99	 ; If this is the "don't display" marker, jump to PRG007_AB99

	; Otherwise, set the pattern
	STA Sprite_RAM+$01,Y

	; Score Sprite Y
	LDA Scores_Y,X
	STA Sprite_RAM+$00,Y

	; Score Sprite X
	LDA Scores_X,X
	STA Sprite_RAM+$03,Y

	JSR Score_SetAttribute

PRG007_AB99:
	LDY <Temp_Var6	 ; Y = second sprite offset
	CPY #$ff
	BEQ PRG007_ABC4	 ; If this sprite is marked as "don't display", jump to PRG007_ABC4

	; Score Sprite Y
	LDA Scores_Y,X
	STA Sprite_RAM+$00,Y

	; Score Sprite X
	LDA Scores_X,X
	ADD #$08
	STA Sprite_RAM+$03,Y

	LDX <Temp_Var1	 ; X = score value

	; Score Sprite pattern
	LDA Score_PatternRight-1,X
	STA Sprite_RAM+$01,Y

Score_SetAttribute:
	LDA <Temp_Var1	 ; Get score value
	CMP #$0d
	LDA #$01	 ; A = 1
	BGE PRG007_ABBF	 ; If this is the 1-up, jump to PRG007_ABBF

	NOP		 ; Otherwise, do ... nothing!

PRG007_ABBF:
	; Set attribute
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup	 ; X = score slot index

PRG007_ABC4:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BrickBusts_DrawAndUpdate
;
; Draws and updates the brick bust debris/poof effects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BrickBusts_DrawAndUpdate:
	LDX #$01	 ; X = 1
PRG007_ABC7:
	STX <SlotIndexBackup	; -> SlotIndexBackup

	JSR BrickBust_DrawAndUpdate	 ; Draw and update this brick bust

	DEX		 ; X--
	BPL PRG007_ABC7	 ; While X >= 0, loop

PRG007_ABCF:
	RTS		 ; Return

BrickBust_SprRAMOff:	.byte $08, $18	; Four sprites required here
BrickPoof_SprRAMOff:	.byte $08, $10	; Only two sprites required here

	; Draw and update the specific brick bust
BrickBust_DrawAndUpdate:
	LDA BrickBust_En,X
	BEQ PRG007_ABCF	 ; If this brick bust slot is not active, jump to PRG007_ABCF

	CMP #$02
	BEQ PRG007_ABE0	 ; If the bust type is 2 (typical), jump to PRG007_ABE0

	JMP PRG007_AD27	 ; Otherwise, jump to PRG007_AD27

PRG007_ABE0:
	LDA <Player_HaltGame
	BNE PRG007_ABED	 ; If gameplay halted, jump to PRG007_ABED

	LDA <Counter_1
	AND #$03
	BNE PRG007_ABED	 ; 1:4 proceed, otherwise jump to PRG007_ABED

	INC BrickBust_YVel,X	 ; BrickBust_YVel++ (gravity)

PRG007_ABED:
	LDA BrickBust_YUpr,X
	PHA		 ; Save upper chunk Y

	CLC		 ; Clear carry (no point?)
	SUB Level_ScrollDiffV	 ; Adjust Y based on vertical screen scroll

	LDY <Player_HaltGame
	BNE PRG007_ABFE	 ; If gameplay is halted, jump to PRG007_ABFE

	ADD BrickBust_YVel,X	 ; Apply brick bust Y velocity

PRG007_ABFE:
	STA BrickBust_YUpr,X	 ; -> upper chunk Y

	PLA		 ; Restore original Y
	EOR BrickBust_YUpr,X
	BPL PRG007_AC1F	 ; If the sign hasn't changed, jump to PRG007_AC1F

	; Sign changed; need to make sure the block bust debris didn't wrap

	LDA Level_ScrollDiffV

	LDY <Player_HaltGame
	BNE PRG007_AC12	 ; If gameplay halted, jump to PRG007_AC12

	SUB BrickBust_YVel,X	 ; Apply velocity in reverse

PRG007_AC12:
	EOR BrickBust_YUpr,X
	BPL PRG007_AC1F	 ; If the sign didn't change, jump to PRG007_AC1F

	; Otherwise, toggle the upper chunk disable
	LDA BrickBust_HEn,X
	EOR #$08
	STA BrickBust_HEn,X

PRG007_AC1F:
	LDA BrickBust_YLwr,X
	PHA		 ; Save lower chunk Y

	CLC		 ; Clear carry (no point?)
	SUB Level_ScrollDiffV	 ; Adjust Y based on vertical screens croll

	LDY <Player_HaltGame
	BNE PRG007_AC36	 ; If gameplay is halted, jump to PRG007_AC36

	INC BrickBust_XDist,X	 ; Increase the chunk separation

	ADD BrickBust_YVel,X	 ; Apply Y velocity

	ADD #$02		; More impact on lower chunk
PRG007_AC36:
	STA BrickBust_YLwr,X

	PLA		 ; Restore lower chunk Y

	EOR BrickBust_YLwr,X
	BPL PRG007_AC5A	 ; If the sign hasn't changed, jump to PRG007_AC5A

	; Sign changed; need to make sure the block bust debris didn't wrap

	LDA Level_ScrollDiffV

	LDY <Player_HaltGame
	BNE PRG007_AC4D	 ; If gameplay halted, jump to PRG007_AC4D

	SUB BrickBust_YVel,X	 ; Apply velocity in reverse
	SUB #$02	 ; With the greater impact

PRG007_AC4D:
	EOR BrickBust_YLwr,X
	BPL PRG007_AC5A	 ; If sign didn't change, jump to PRG007_AC5A

	; Otherwise, toggle the lower chunk disable
	LDA BrickBust_HEn,X
	EOR #$04
	STA BrickBust_HEn,X

PRG007_AC5A:

	; Scroll brick bust debris horizontally with screen
	LDA BrickBust_X,X
	SUB Level_ScrollDiffH
	STA BrickBust_X,X

	TXA		 ; Keeps things interesting
	EOR <Counter_1
	AND #$01
	TAY		 ; Y = 0 or 1

	LDA BrickBust_SprRAMOff,Y
	TAY		 ; Y = sprite RAM offset
	CPY #$08	 
	BNE PRG007_AC7A	 ; If NOT using the offset $08, jump to PRG007_AC7A

	LDA Sprite_RAM+$08
	CMP #$f8
	BEQ PRG007_AC7A	 ; If this sprite is not in use, jump to PRG007_AC7A

	RTS		 ; Return

PRG007_AC7A:
	LDA BrickBust_HEn,X
	STA <Temp_Var4	 ; Horizontal enable flag -> Var4

	CMP #$0c
	BLT PRG007_AC91	 ; If at least one of upper or lower are enabled, jump to PRG007_AC91

	; Upper and lower are both disabled!

	LDA <Player_HaltGame
	BNE PRG007_AC8E	 ; If gameplay halted, jump to PRG007_AC8E

	LDA BrickBust_YVel,X
	CMP #$08
	BLS PRG007_AC91	 ; If brick bust Y velocity < $08, jump to PRG007_AC91

PRG007_AC8E:
	JMP PRG007_AD21	 ; Otherwise, jump to PRG007_AD21 (disable this brick bust)

PRG007_AC91:
	LDA <Temp_Var4
	AND #$08
	BNE PRG007_ACA0	 ; If upper bust chunks are disabled, jump to PRG007_ACA0

	; Otherwise set sprite Y for left and right uppers
	LDA BrickBust_YUpr,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

PRG007_ACA0:
	LDA <Temp_Var4
	AND #$04
	BNE PRG007_ACAF	 ; If lower bust chunks are disabled, jump to PRG007_ACAF

	; Otherwise set sprite Y for left and right lowers
	LDA BrickBust_YLwr,X
	STA Sprite_RAM+$08,Y
	STA Sprite_RAM+$0C,Y

PRG007_ACAF:
	LSR <Temp_Var4
	BCC PRG007_ACBB	 ; If right bust chunks are NOT disabled, jump to PRG007_ACBB

	; Hide right-hand bust chunks
	LDA #$f8
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$08,Y

PRG007_ACBB:
	LSR <Temp_Var4
	BCC PRG007_ACC7	 ; If left bust chunks are NOT disabled, jump to PRG007_ACC7

	; Hide left-hand bust chunks
	LDA #$f8
	STA Sprite_RAM+$04,Y
	STA Sprite_RAM+$0C,Y

PRG007_ACC7:

	; Pattern for bust chunks
	LDA #$4b
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y
	STA Sprite_RAM+$09,Y
	STA Sprite_RAM+$0D,Y

	LDA BrickBust_X,X
	PHA		 ; Save chunk X
	ADD BrickBust_XDist,X	; Add the distance
	ADD #$08	 	; +8
	STA Sprite_RAM+$03,Y	; Set right upper chunk X
	STA Sprite_RAM+$0B,Y	; Set right lower chunk X

	CMP #248
	BLT PRG007_ACF2	 ; If bust chunk X < 248, jump to PRG007_ACF2

	; Otherwise, disable right chunks
	LDA BrickBust_HEn,X
	ORA #$01
	STA BrickBust_HEn,X

PRG007_ACF2:
	PLA		 ; Restore chunk X
	SUB BrickBust_XDist,X	 ; Subtract the distance
	STA Sprite_RAM+$07,Y	 ; Set left upper chunk X
	STA Sprite_RAM+$0F,Y	 ; Set left lower chunk X

	; Seems like this should be a >= 8 check??
	CMP #244
	BLT PRG007_AD09	 ; If bust chunk X < 244 (??), jump to PRG007_AD09

	; Otherwise, disable left chunks
	LDA BrickBust_HEn,X
	ORA #$02
	STA BrickBust_HEn,X

PRG007_AD09:

	; Rotate the horizontal / vertical flips
	LDA Level_NoStopCnt
	AND #$06
	LSR A
	LSR A
	ROR A
	ROR A
	ORA #SPR_PAL3
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y
	STA Sprite_RAM+$0A,Y
	STA Sprite_RAM+$0E,Y

	RTS		 ; Return

PRG007_AD21:

	; Disable this brick bust
	LDA #$00
	STA BrickBust_En,X

	RTS		 ; Return

PRG007_AD27:

	; Brick bust type non-2 ("poof" away the tile)

	LDA BrickBust_HEn,X
	BEQ PRG007_AD21	 ; If BrickBust_HEn = 0 (poof expired), jump to PRG007_AD21 (disable this brick bust)

	LDA <Player_HaltGame
	BNE PRG007_AD33	 ; If gameplay is halted, jump to PRG007_AD33

	DEC BrickBust_HEn,X	 ; BrickBust_HEn-- (used as a counter here)

PRG007_AD33:
	LDA BrickBust_YUpr,X

	LDY Level_AScrlConfig
	BNE PRG007_AD42	 ; If raster enabled, jump to PRG007_AD42

	; Otherwise, just be screen-scroll relative
	SUB Level_ScrollDiffV
	STA BrickBust_YUpr,X

PRG007_AD42:
	CMP #208
	BGE PRG007_AD21	 ; If the poof effect Y >= 208 (too low), jump to PRG007_AD21 (disable this brick bust)

	CPY #$00
	BNE PRG007_AD54	 ; If raster effects enabled, jump to PRG007_AD54

	; Scroll poof horizontally
	LDA BrickBust_X,X
	SUB Level_ScrollDiffH
	STA BrickBust_X,X

PRG007_AD54:
	CMP #240
	BGE PRG007_AD21	 ; If the poof effect X >= 24, jump to PRG007_AD21 (disable this brick bust)

	TXA		 ; Keep it interesting
	EOR <Counter_1	 
	AND #$01	 
	TAY		 ; Y = 0 or 1

	LDA BrickPoof_SprRAMOff,Y
	TAY		 ; Y = Sprite RAM offset

	LDA Sprite_RAM+$00,Y
	CMP #$f8
	BNE PRG007_ADA7	 ; If this sprite is not free, jump to PRG007_ADA7 (RTS)

	; Set left sprite X
	LDA BrickBust_X,X
	STA Sprite_RAM+$03,Y

	; Set right sprite X
	ADD #$08	 ; +8
	STA Sprite_RAM+$07,Y

	; Set left/right sprite Y
	LDA BrickBust_YUpr,X
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP
	STA <Temp_Var1	 ; Periodically vertically flip

	; Form attribute with sprite palette 1 for left half
	LDA #SPR_PAL1
	ORA <Temp_Var1
	STA Sprite_RAM+$02,Y

	; Right half uses opposite flips
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y

	LDA BrickBust_HEn,X
	LSR A
	LSR A
	LSR A
	TAX	; X = 0 to 3

	LDA Poof_Patterns,X	 ; Get appropriate "poof" pattern
	STA Sprite_RAM+$01,Y	 ; Left
	STA Sprite_RAM+$05,Y	 ; Right

	LDX <SlotIndexBackup	 ; X = restore slot index

PRG007_ADA7:
	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CoinPUp_DrawAndUpdate
;
; Draws and updates the coins which have popped out of blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CoinPUp_Patterns:	.byte $49, $4F, $4D, $4F
CoinPUp_Attributes:	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP, SPR_PAL3, SPR_PAL3

CoinPUps_DrawAndUpdate:
	LDX #$03	 ; X = 3 (all "power up" coin slots)
PRG007_ADB2: 
	STX <SlotIndexBackup	 ; -> slot index backup

	LDA CoinPUp_State,X
	BEQ PRG007_ADBC	 ; If there's no active "powerup coin" here, jump to PRG007_ADBC

	JSR CoinPUp_UpdateAndDraw	 ; Update and draw powerup coin

PRG007_ADBC:
	DEX		 ; X--
	BPL PRG007_ADB2	 ; While X >= 0, loop!

	RTS		 ; Return

CoinPUp_UpdateAndDraw:
	LDA <Player_HaltGame		 
	BNE PRG007_ADF0	 ; If gameplay is halted, jump to PRG007_ADF0

	INC CoinPUp_Counter,X	 ; counter++

	; Apply coin's Y velocity
	LDA CoinPUp_Y,X
	ADD CoinPUp_YVel,X
	STA CoinPUp_Y,X

	LDA CoinPUp_Counter,X
	AND #$03
	BNE PRG007_ADE2	 ; 1:4 ticks proceed, otherwise jump to PRG007_ADE2

	INC CoinPUp_YVel,X	 ; coin YVel ++

	LDA CoinPUp_YVel,X
	CMP #$05
	BEQ PRG007_AE28	 ; If coin's Y velocity = 5, jump to PRG007_AE28

PRG007_ADE2:
	LDA CoinPUp_X,X
	SUB Level_ScrollDiffH	; Make relative coin X

	CMP #248
	BGE PRG007_AE4A	 ; If coin X >= 248, jump to PRG007_AE4A (remove coin)

	STA CoinPUp_X,X	 ; Update coin X

PRG007_ADF0:
	LDA <Player_HaltGame
	BEQ PRG007_AE02	 ; If gameplay is not halted, jump to PRG007_AE02

	; Move coin Y with vertical scroll
	LDA CoinPUp_Y,X	 
	SUB Level_ScrollDiffV
	STA CoinPUp_Y,X	 

	CMP #197
	BGE PRG007_AE4A	 ; If coin Y >= 197, jump to PRG007_AE4A (remove coin)

PRG007_AE02:
	JSR Object_GetRandNearUnusedSpr

	; Set coin Y
	LDA CoinPUp_Y,X
	STA Sprite_RAM+$00,Y

	; Set coin X
	LDA CoinPUp_X,X
	STA Sprite_RAM+$03,Y

	LDA CoinPUp_Counter,X
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3 by coin counter

	; Set pattern
	LDA CoinPUp_Patterns,X
	STA Sprite_RAM+$01,Y

	; Set attribute
	LDA CoinPUp_Attributes,X
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup	; X = power up coin slot index

	RTS		 ; Return

PRG007_AE28:
	JSR Score_FindFreeSlot

	; Get 100 pts
	LDA #$85
	STA Scores_Value,Y

	LDA #$30
	STA Scores_Counter,Y

	LDA CoinPUp_Y,X
	CMP #192
	BLT PRG007_AE3E	 ; If the coin is not too low, jump to PRG007_AE3E

	LDA #$05	 ; Otherwise use top of screen

PRG007_AE3E:
	STA Scores_Y,Y	 ; -> Scores_Y

	; Center score above coin
	LDA CoinPUp_X,X
	SUB #$04
	STA Scores_X,Y

PRG007_AE4A:

	; Remove coin
	LDA #$00
	STA CoinPUp_State,X

	RTS		 ; Return


	; Sets carry if solid was hit
SObj_CheckHitSolid:

	; Flag Blooper Kid as out of water until determined otherwise
	LDA #$01	 
	STA SObjBlooperKid_OutOfWater,X

	; Temp_Var6 = special object Y + 12
	LDA SpecialObj_YLo,X
	ADD #12
	STA <Temp_Var6

	; Aligned to grid -> Temp_Var3
	AND #$f0
	STA <Temp_Var3

	LDA SpecialObj_YHi,X
	ADC #$00	 ; Apply carry
	PHA		 ; Save Y Hi

	; Special object X + 4 -> Temp_Var5
	LDA SpecialObj_XLo,X
	ADD #$04
	SUB <Horz_Scroll	; -
	ADD <Horz_Scroll	; + ??
	STA <Temp_Var5

	LDA <Horz_Scroll_Hi
	ADC #$00	 ; Apply carry
	ASL A		 ; 2 bytes per screen (for Tile_Mem_Addr)
	TAY		 ; -> 'Y'

	; Low byte of Tile_Mem_Addr -> Temp_Var1
	LDA Tile_Mem_Addr,Y
	STA <Temp_Var1

	PLA		 ; Restore Y Hi

	AND #$01	 ; Only use 0 or 1 (only valid Y His in a non-vertical level)
	ADD Tile_Mem_Addr+1,Y	 ; Add to the high byte of Tile_Mem_Addr
	STA <Temp_Var2		 ; -> Temp_Var2

	; Form a row/column offset -> 'Y'
	LDA <Temp_Var5
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var3
	TAY

	LDA [Temp_Var1],Y ; Get the tile here
	PHA		 ; Save it

	ASL A
	ROL A
	ROL A
	AND #$03
	TAY		 ; Y = tile quadrant
	STY <Temp_Var2	 ; -> Temp_Var2

	PLA		 ; Restore the tile value
	STA <Temp_Var1	 ; -> Temp_Var1

	CMP Tile_AttrTable,Y
	BLT PRG007_AEE0	 ; If this tile is not solid on top, jump to PRG007_AEE0

	CMP Tile_AttrTable+4,Y
	BLT PRG007_AECF	 ; If this tile is not solid on the sides/bottom, jump to PRG007_AECF

	; Tile is solid all around

	LDA SpecialObj_ID,X
	CMP #SOBJ_FIREBROFIREBALL
	BEQ PRG007_AEB3	 ; If this a Fire Bro's fireball (the only one that bounces on the floor), jump to PRG007_AEB3

	SEC		 ; Set carry

	RTS		 ; Return

PRG007_AEB3:
	INC SpecialObj_Data,X	 ; SpecialObj_Data++

	LDA SpecialObj_Data,X
	CMP #$02
	BNE PRG007_AEC0	 ; If SpecialObj_Data <> 2, jump to PRG007_AEC0

	JMP PRG007_AF02	 ; Jump to PRG007_AF02

PRG007_AEC0:
	; Fireball's Y -= 3
	DEC SpecialObj_YLo,X
	DEC SpecialObj_YLo,X
	DEC SpecialObj_YLo,X

PRG007_AEC9:
	; Bounce fireball!
	LDA #-$2C
	STA SpecialObj_YVel,X

PRG007_AECE:
	RTS		 ; Return

PRG007_AECF:

	; Tile solid only on top

	LDA SpecialObj_ID,X
	CMP #SOBJ_FIREBROFIREBALL

	CLC		 ; Clear carry

	BNE PRG007_AECE	 ; If this is not the Fire Bro's fireball, jump to PRG007_AECE

	LDA <Temp_Var6
	AND #$0f	 ; Find Y relative to the tile
	CMP #$05
	BLT PRG007_AEC9	 ; If it's less than 5 pixels from the top, count as hit the floor, and bounce!

	RTS		 ; Return

PRG007_AEE0:

	; Tile not solid on top (literally, but likely assumes not solid on the side/bottom either)

	LDA SpecialObj_ID,X
	CMP #SOBJ_BLOOPERKID

	CLC		 ; Clear carry

	BNE PRG007_AEFC	 ; If this is not a Blooper Kid, jump to PRG007_AEFC

	; Blooper kid only...

	LDA Level_TilesetIdx
	ASL A
	ASL A	; TilesetIdx * 4
	ADD <Temp_Var2	; Add the quadrant
	TAY	; Y = offset into Level_MinTileUWByQuad

	LDA Level_MinTileUWByQuad,Y
	CMP <Temp_Var1
	BLT PRG007_AEFB	 ; If this tile is not considered underwater, jump to PRG007_AEFB (RTS)

	DEC SObjBlooperKid_OutOfWater,X	 ; Otherwise, SObjBlooperKid_OutOfWater = 0 (Blooper Kid is still in water!)

PRG007_AEFB:
	RTS		 ; Return

PRG007_AEFC:

	; SpecialObj_Data = 0
	LDA #$00
	STA SpecialObj_Data,X

	RTS		 ; Return


PRG007_AF02:

	; impact sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERBUMP
	STA Sound_QPlayer

	; Something removed here...
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

	JMP PRG007_B84C	 ; Jump to PRG007_B84C ("Poof" away the fireball)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SpecialObjs_UpdateAndDraw
;
; Updates Special Objects and they draw as they will
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SpecialObjs_UpdateAndDraw:

	; No Microgoomba stuck to Player until we say so...
	LDA #$00	 
	STA Player_Microgoomba

	LDX #$07	 ; X = 7
PRG007_AF1B:
	STX <SlotIndexBackup ; Store current checked index -> SlotIndexBackup

	JSR SpecialObj_UpdateAndDraw	 ; Does the update and draw routines of Special OBjects

	DEX		 ; X--
	BPL PRG007_AF1B	 ; While X >= 0, loop!

SObj_DoNothing:
PRG007_AF23:
	RTS		 ; Return

SpecialObj_UpdateAndDraw:
	LDA SpecialObj_ID,X	 
	BEQ PRG007_AF23	 ; If this special object slot is not in use, jump to PRG007_AF23 (RTS)

	LDA AScrlURDiag_WrapState_Copy
	BEQ PRG007_AF4B	 ; If diagonal scroller is not wrapping, jump to PRG007_AF4B

	LDA <Player_HaltGame
	BNE PRG007_AF4B	 ; If gameplay is halted, jump to PRG007_AF4B

	; Offset special object to compensate for the diagonal autoscroller's wrap
	LDA SpecialObj_XLo,X
	ADD AScrlURDiag_OffsetX
	STA SpecialObj_XLo,X
	LDA SpecialObj_YLo,X
	ADD AScrlURDiag_OffsetY
	STA SpecialObj_YLo,X

	BCC PRG007_AF4B	 ; If no carry, jump to PRG007_AF4B
	INC SpecialObj_YHi,X	 ; Apply carry
PRG007_AF4B:

	LDY <Player_HaltGame
	BNE PRG007_AF57	 ; If gameplay halted, jump to PRG007_AF57

	LDY SpecialObj_Timer,X
	BEQ PRG007_AF57	 ; If SpecialObj_Timer = 0, jump to PRG007_AF57
	DEC SpecialObj_Timer,X	 ; SpecialObj_Timer--
PRG007_AF57:


	LDA SpecialObj_XLo,X
	SUB <Horz_Scroll
	CMP #248
	BGE SpecialObj_RemoveInd ; If special object X >= 248, jump to SpecialObj_RemoveInd (remove special object)

	LDA SpecialObj_YLo,X
	ADD #16
	PHA		 ; Save Special object Y + 16

	LDA SpecialObj_YHi,X
	ADC #$00	 ; Apply carry
	STA <Temp_Var1	 ; -> Temp_Var1

	PLA		 ; Restore special object Y + 16

	CMP Level_VertScroll

	LDA <Temp_Var1
	SBC Level_VertScrollH
	STA <Temp_Var14	; Temp_Var14 = 0 if special object is on same screen...

	BEQ PRG007_AF9E	 ; If Temp_Var14 = 0 (special object on same screen), jump to PRG007_AF9E

	; A few select special objects can deal with existing on a different screen,
	; otherwise the object will be deleted immediately
	LDA SpecialObj_ID,X

	CMP #SOBJ_BUBBLE
	BEQ PRG007_AF97

	CMP #SOBJ_MICROGOOMBA
	BEQ PRG007_AF97

	CMP #SOBJ_RECOVEREDWAND
	BEQ PRG007_AF97	

	CMP #SOBJ_BRICKDEBRIS
	BEQ PRG007_AF97

	CMP #SOBJ_SPIKEBALL
	BEQ PRG007_AF97

	CMP #SOBJ_HAMMER
	BNE SpecialObj_RemoveInd

PRG007_AF97:
	LDA <Temp_Var14
	BMI PRG007_AF9E	 ; If this select special object is above, keep it alive, jump to PRG007_AF9E

SpecialObj_RemoveInd:
	JMP SpecialObj_Remove	 ; Jump to SpecialObj_Remove

PRG007_AF9E:	
	LDA SpecialObj_ID,X

	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word SObj_DoNothing	; 00: EMPTY / NOT USED (should never get here anyway)
	.word SObj_Hammer	; 01: Hammer Bro hammer
	.word SObj_Boomerang	; 02: Boomerangs
	.word SObj_UNKNOWN	; 03: 
	.word SObj_Fireball	; 04: Nipper fireball
	.word SObj_Fireball	; 05: Piranha fireball
	.word SObj_Microgoomba	; 06: Micro goombas
	.word SObj_Spikeball	; 07: Spike/Patooie's spike ball
	.word SObj_WandBlast	; 08: Koopaling wand blast
	.word SObj_KuriboShoe	; 09: Lost Kuribo shoe
	.word SObj_Wrench	; 0A: Rocky's Wrench
	.word SObj_Cannonball	; 0B: Cannonball
	.word SObj_Fireball	; 0C: Fire bro bouncing fireball
	.word SObj_ExplodeStar	; 0D: Explosion star
	.word SObj_Bubble	; 0E: Bubble
	.word SObj_LavaLotusFire; 0F: Lava Lotus fire
	.word SObj_Wand		; 10: Recovered wand
	.word SObj_CoinOrDebris	; 11: Popped out coin
	.word SObj_Fireball	; 12: Fire Chomp's fire
	.word SObj_CoinOrDebris	; 13: Brick debris (e.g. from Piledriver Microgoomba)
	.word SObj_BlooperKid	; 14: Blooper kid
	.word SObj_Laser	; 15: Laser
	.word SObj_Poof		; 16: Poof

PUpCoin_Patterns:	.byte $49, $4F, $4D, $4F
PUpCoin_Attributes:	.byte SPR_PAL3, SPR_PAL3 | SPR_HFLIP, SPR_PAL3, SPR_PAL3

SObj_Laser:

	; Load patterns for laser
	LDA #$12
	STA PatTable_BankSel+4

	JSR Laser_PrepSpritesAndHit	 ; Prepare the laser sprites and hurt Player

	LDA <Player_HaltGame
	BNE PRG007_B01F	 ; If gameplay is halted, jump to PRG007_B01F (RTS)

	; Y += 8
	LDA SpecialObj_YLo,X
	ADD #$08
	STA SpecialObj_YLo,X

	; X += 8
	LDA SpecialObj_XLo,X
	SUB #$08
	STA SpecialObj_XLo,X

	JSR SObj_CheckHitSolid
	BCC PRG007_B01F	 ; If laser didn't hit solid, jump to PRG007_B01F (RTS)

	; Laser hit floor!

	; Align Y
	LDA SpecialObj_YLo,X
	AND #$f0
	ADD #$05
	STA SpecialObj_YLo,X

	; Align X
	LDA SpecialObj_XLo,X
	AND #$f0
	ADC #$0b
	STA SpecialObj_XLo,X

	JSR SpecialObj_Remove	 ; Remove laser

	; Generate puff via "brick bust" puff (atypical, but whatever)
	LDY #$01	 ; Y = 1
PRG007_B017:
	LDA BrickBust_En,Y
	BEQ PRG007_B020	 ; If this brick bust slot is free, jump to PRG007_B020

	DEY		 ; Y--
	BPL PRG007_B017	 ; While Y >= 0, loop!

PRG007_B01F:
	RTS		 ; Return


PRG007_B020:

	; Enable this brick bust slot (poof style)
	LDA #$01
	STA BrickBust_En,Y

	; Brick bust (poof) X
	LDA SpecialObj_XLo,X
	SUB #$08
	SUB <Horz_Scroll
	STA BrickBust_X,Y

	; Brick bust (poof) Y
	LDA SpecialObj_YLo,X
	ADD #$04
	SBC Level_VertScroll
	STA BrickBust_YUpr,Y

	; Poof counter
	LDA #$17
	STA BrickBust_HEn,Y

	RTS		 ; Return


Laser_PrepSpritesAndHit:
	JSR SObj_GetSprRAMOffChkVScreen	 
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Set laser pattern
	LDA #$b7
	STA Sprite_RAM+$01,Y

	; Use rotating color attributes
	LDA <Counter_1
	LSR A	
	LSR A	
	AND #$03
	STA Sprite_RAM+$02,Y

	JMP SObj_PlayerCollide	 ; Do Player to laser collision and don't come back!

PRG007_B058:
	RTS		 ; Return

BlooperKid_VelAccel:	.byte $01, -$01
BlooperKid_VelLimit:	.byte $10, -$10
BlooperKid_SpriteYOff:	.byte $00, $01, $02, $03, $04, $05, $06, $07, $08, $07, $06, $05, $04, $03, $02, $01

SObj_BlooperKid:
	LDA <Player_HaltGame
	BNE PRG007_B0BC	 ; If gameplay halted, jump to PRG007_B0BC

	LDA <Counter_1
	AND #$07
	BNE PRG007_B0A9	 ; 1:8 ticks proceed, otherwise jump to PRG007_B0A9

	LDA SpecialObj_Data,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate Blooper Kid Y
	LDA SpecialObj_YVel,X
	ADD BlooperKid_VelAccel,Y
	STA SpecialObj_YVel,X

	CMP BlooperKid_VelLimit,Y
	BNE PRG007_B091	 ; If Blooper Kid has not hit Y velocity limit, jump to PRG007_B091

	INC SpecialObj_Data,X	 ; Otherwise change direction

PRG007_B091:
	LDA SpecialObj_Var1,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate Blooper Kid X
	LDA SpecialObj_XVel,X
	ADD BlooperKid_VelAccel,Y
	STA SpecialObj_XVel,X

	CMP BlooperKid_VelLimit,Y
	BNE PRG007_B0A9	 ; If Blooper Kid has not hit X velocity limit, jump to PRG007_B0A9

	INC SpecialObj_Var1,X	 ; Otherwise change direction

PRG007_B0A9:
	JSR SObj_AddXVelFrac	 ; Apply X Velocity

	LDA SpecialObj_YVel,X
	BPL PRG007_B0B9	 ; If Blooper Kid is moving downward, jump to PRG007_B0B9

	JSR SObj_CheckHitSolid	 ; Check if hit solid

	LDA SObjBlooperKid_OutOfWater,X
	BEQ PRG007_B0BC	 ; If Blooper Kid is still in water, jump to PRG007_B0BC

PRG007_B0B9:
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

PRG007_B0BC:
	LDA SpecialObj_Timer,X
	BEQ PRG007_B0F7	 ; If timer expired, jump to PRG007_B0F7

	CMP #$30
	BGE PRG007_B0C9	 ; If timer >= $30, jump to PRG007_B0C9

	; Blooper Kid flickering away..
	AND #$02
	BNE PRG007_B0F6	 ; 2 ticks on, 2 ticks off; jump to PRG007_B0F6 (RTS)

PRG007_B0C9:
	JSR SObj_GetSprRAMOffChkVScreen

	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	LDA Level_NoStopCnt
	LSR A
	AND #$0f
	TAX		 ; X = 0 to 15

	; Set Sprite Y
	LDA Sprite_RAM+$00,Y
	ADD BlooperKid_SpriteYOff,X
	STA Sprite_RAM+$00,Y

	TXA

	LDX <SlotIndexBackup	; X = special object slot index

	CMP #$08
	LDA #$b5	 ; A = $B5
	BLT PRG007_B0EB	 ; If only halfway through the animation cycle, jump to PRG007_B0EB

	LDA #$b7	 ; A = $B7

PRG007_B0EB:

	; Set Blooper Kid pattern
	STA Sprite_RAM+$01,Y

	; Set Blooper Kid attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	JMP SObj_PlayerCollide	 ; Do Player to Blooper Kid collision and don't come back!

PRG007_B0F6:
	RTS		 ; Return

PRG007_B0F7:
	JMP SpecialObj_Remove	 ; Remove Blooper kid

SObj_CoinOrDebris:
	LDA <Player_HaltGame
	BNE PRG007_B11F	 ; If gameplay halted, jump to PRG007_B11F

	INC SpecialObj_Var1,X	 ; Var1++

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity

	LDA SpecialObj_ID,X
	CMP #SOBJ_BRICKDEBRIS
	BNE PRG007_B11F	 ; If this is not brick debris, jump to PRG007_B11F

	; Brick debris only...

	LDA SpecialObj_YVel,X
	BMI PRG007_B114	 ; If brick debris is moving upward, jump to PRG007_B114

	CMP #$70
	BGE PRG007_B11F	 ; If brick debris is falling >= $70, jump to PRG007_B11F

PRG007_B114:
	LDA SpecialObj_Data,X
	BNE PRG007_B11C	 ; If data <> 0, jump to PRG007_B11C (fall slower)

	INC SpecialObj_YVel,X	 ; YVel++

PRG007_B11C:
	INC SpecialObj_YVel,X	 ; YVel++

PRG007_B11F:
	JSR SObj_GetSprRAMOffChkVScreen

	LDA SpecialObj_ID,X
	CMP #SOBJ_BRICKDEBRIS
	BNE PRG007_B169	 ; If this is not brick debris, jump to PRG007_B169

	; Brick debris only...

	LDA SpecialObj_Data,X
	BEQ PRG007_B153	 ; If data = 0 (full giant world style brick rather than chunks), jump to PRG007_B153

	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Brick debris chunk pattern
	LDA #$4b
	STA Sprite_RAM+$01,Y

	; Temp_Var1 = SPR_PAL3
	LDA #SPR_PAL3
	STA <Temp_Var1

	LDA SpecialObj_Timer,X
	BEQ PRG007_B144	 ; If timer expired, jump to PRG007_B144

	; Rotating colors for Ice Brick debris
	LSR A
	AND #$03
	STA <Temp_Var1

PRG007_B144:

	; Rotating effect
	LDA Level_NoStopCnt
	ASL A
	ASL A
	ASL A
	ASL A
	AND #(SPR_HFLIP | SPR_VFLIP)

	; Set attributes
	ORA <Temp_Var1		 ; OR'd with palette
	STA Sprite_RAM+$02,Y

	RTS		 ; Return

PRG007_B153:
	JSR SObj_Draw16x16	 ; Draw full brick

	; Set petterns
	LDA #$75
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Set attributes on left sprite
	LDA #SPR_PAL3
	STA Sprite_RAM+$02,Y

	; Set attributes on right sprite
	LDA #(SPR_PAL3 | SPR_HFLIP)
	STA Sprite_RAM+$06,Y

	RTS		 ; Return

PRG007_B169:

	; Popped out coin only

	LDA SpecialObj_YVel,X
	CMP #$20
	BMI PRG007_B17E	 ; If Y Velocity < $20, jump to PRG007_B17E

	; Coin fell far enough..

	JSR SpecialObj_Remove	 ; Remove it
	INC Coins_Earned	 ; You get a coin

	JSR Score_FindFreeSlot
	LDA #$89	; Get 1000 pts; $80 just mixes up what sprite it uses
	JMP PRG007_B44B	 ; Jump to PRG007_B44B

PRG007_B17E:
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Set coin sprite Y
	LDA Sprite_RAM+$03,Y
	ADD #$04
	STA Sprite_RAM+$03,Y

	LDA SpecialObj_Var1,X
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	; Set pattern
	LDA PUpCoin_Patterns,X
	STA Sprite_RAM+$01,Y	

	; Set attributes
	LDA PUpCoin_Attributes,X
	STA Sprite_RAM+$02,Y	

	LDX <SlotIndexBackup	 ; X = special object slot index

	RTS		 ; Return

	; Velocity gets applied at different rates (slower as timer decreases)
ExplodeStar_VelMask:
	.byte $07, $03, $01, $00


SObj_ExplodeStar:
	LDA SpecialObj_Data,X
	BNE PRG007_B1DD	 ; If star's data <> 0, jump to PRG007_B1DD (RTS)

	LDA SpecialObj_Timer,X
	BEQ PRG007_B1DE	 ; If timer expired, jump to PRG007_B1DE (RTS)

	LSR A
	LSR A
	LSR A
	LSR A
	AND #$03
	TAY		 ; Y = 0 to 3, by timer

	; Apply velocities at lower rates as timer decreases
	LDA <Counter_1
	AND ExplodeStar_VelMask,Y
	BNE PRG007_B1C3

	JSR SObj_AddXVelFrac	 ; Apply X velocity
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

PRG007_B1C3:
	JSR SObj_GetSprRAMOffChkVScreen
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Set Explosion Star pattern
	LDA #$73
	STA Sprite_RAM+$01,Y

	; Apply cycling palette attribute
	LDA Level_NoStopCnt
	LSR A
	LSR A
	NOP
	ADD <SlotIndexBackup
	AND #$03	 ; A = 0 to 3 (palette select)
	STA Sprite_RAM+$02,Y

	RTS		 ; Return


PRG007_B1DD:
	RTS		 ; Return

PRG007_B1DE:
	JMP SpecialObj_Remove	 ; Remove special object and don't come back!

Wand_Pattern1:		.byte $99, $B9, $BD, $B9, $99, $BB, $BF, $BB
Wand_Pattern2:		.byte $99, $BB, $BB, $BB, $99, $B9, $BD, $B9
Wand_Attributes:	.byte SPR_PAL2, SPR_PAL2, SPR_PAL2, SPR_PAL2 | SPR_VFLIP, SPR_PAL2 | SPR_VFLIP, SPR_PAL2 | SPR_VFLIP, SPR_PAL2, SPR_PAL2

SObj_Wand:

	; Load wand graphics
	LDA #$48
	STA PatTable_BankSel+4

	LDA <Player_HaltGame
	BNE PRG007_B254	 ; If gameplay is halted, jump to PRG007_B254

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity

	DEC SpecialObj_YVel,X

	; Wand_FrameCnt += Var1 (spin rate)
	LDA Wand_FrameCnt
	ADD SpecialObj_Var1,X
	STA Wand_FrameCnt
	BCC PRG007_B217	 ; If no carry, jump to PRG007_B217

	INC Wand_Frame	 ; Next wand frame

PRG007_B217:

	JSR SObj_CheckHitSolid
	BCC PRG007_B254	 ; If wand has not hit solid surface, jump to PRG007_B254

	LDA SpecialObj_YVel,X
	BMI PRG007_B254	 ; If wand is moving upward, jump to PRG007_B254

	CMP #$20
	BLT PRG007_B241	 ; If wand Y Vel < $20, jump to PRG007_B241

	; Wand bounces!
	LSR A		; Divide by 2
	JSR Negate	; Negate
	STA SpecialObj_YVel,X

	; Wand Y -= 2
	DEC SpecialObj_YLo,X
	DEC SpecialObj_YLo,X

	INC Wand_BounceFlag	 ; Wand_BounceFlag++

	; Var1 += $80 (rapid spin rate!)
	LDA SpecialObj_Var1,X
	ADD #$80
	STA SpecialObj_Var1,X

	JMP PRG007_B254	 ; Jump to PRG007_B254

PRG007_B241:

	; Wand has landed!
	LDA #$00
	STA SpecialObj_YVel,X
	STA Wand_Frame	 ; Wand_Frame = 0

	; Align wand Y to grid + 5
	LDA SpecialObj_YLo,X
	AND #$f0
	ADD #$05
	STA SpecialObj_YLo,X

PRG007_B254:
	JSR SObj_GetSprRAMOffChkVScreen
	BNE PRG007_B291	 ; If wand is not on vertical screen, jump to PRG007_B291 (RTS)

	JSR SObj_Draw16x16	 ; Prepare wand sprite

	; Subtract 4 from sprite Ys
	LDA Sprite_RAM+$00,Y
	SBC #$04
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	LDA Wand_BounceFlag
	LSR A		; Sets carry on odd bounces

	LDA Wand_Frame
	AND #$07	; A = 0 to 7 by Wand_Frame

	BCC PRG007_B274	 ; If wand is not on an odd bounce, jump to PRG007_B274

	EOR #$07	 ; Invert result (wand spin)

PRG007_B274:
	TAX		 ; Frame -> 'X'

	; Set wand sprites patterns
	LDA Wand_Pattern1,X
	STA Sprite_RAM+$01,Y
	LDA Wand_Pattern2,X
	STA Sprite_RAM+$05,Y

	; Set wand sprite attributes
	LDA Wand_Attributes,X
	STA Sprite_RAM+$02,Y
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

	LDX <SlotIndexBackup	 ; X = special object slot index
	JMP SObj_PlayerCollide	 ; Do Player-to-wand collision and don't come back!

PRG007_B291:
	RTS		 ; Return

SObj_LavaLotusFire:

	; Load Lava Lotus fire patterns
	LDA #$1b
	STA PatTable_BankSel+5

	LDA <Player_HaltGame
	BNE PRG007_B2EE	 ; If gameplay halted, jump to PRG007_B2EE

	LDA SpecialObj_Var2,X
	BEQ PRG007_B2A8	 ; If Var2 (Lava Lotus fire "life" counter) = 0, jump to PRG007_B2A8

	LDA <Counter_1
	LSR A	
	BCC PRG007_B2A8	 ; Every other tick, jump to PRG007_B2A8

	DEC SpecialObj_Var2,X	 ; Var2--

PRG007_B2A8:
	LDA SpecialObj_Data,X
	BEQ PRG007_B2E2	 ; If SpecialObj_Data = 0, jump to PRG007_B2E2

	LDY SpecialObj_Var1,X	 ; Y = Var1 (the parent Lava Lotus index)

	LDA Objects_State,Y
	CMP #OBJSTATE_NORMAL
	BNE PRG007_B2D8	 ; If Lava Lotus is no longer in normal state, jump to PRG007_B2D8

	LDA Level_ObjectID,Y
	CMP #OBJ_LAVALOTUS
	BNE PRG007_B2D8	 ; If this is no longer a Lava Lotus, jump to PRG007_B2D8

	LDA Objects_Var5,Y
	CMP #$4f
	BLT PRG007_B2D8	 ; If Lava Lotus' Var5 < $4F, jump to PRG007_B2D8

	LDA Level_NoStopCnt

	INC SpecialObj_XLo,X	 ; X++
	AND #$02
	BNE PRG007_B2D5	 ; 2 ticks on, 2 ticks off; jump to PRG007_B2D5

	; X -= 2
	DEC SpecialObj_XLo,X
	DEC SpecialObj_XLo,X

PRG007_B2D5:
	JMP PRG007_B2EE	 ; Jump to PRG007_B2EE

PRG007_B2D8:

	; SpecialObj_Data = 0
	LDA #$00
	STA SpecialObj_Data,X

	; Var2 = $C0
	LDA #$c0
	STA SpecialObj_Var2,X

PRG007_B2E2:
	LDA <Counter_1
	AND #$03
	BNE PRG007_B2EE	 ; 1:4 ticks proceed, otherwise jump to PRG007_B2EE

	JSR SObj_AddXVelFrac	 ; Apply X Velocity
	JSR SObj_AddYVelFrac	 ; Apply Y Velocity

PRG007_B2EE:
	LDA SpecialObj_Var2,X
	BNE PRG007_B2F6	 ; If Var2 <> 0 (fire still has life), jump to PRG007_B2F6

	JMP SpecialObj_Remove	 ; Otherwise, remove it and don't come back!

PRG007_B2F6:
	CMP #$30
	BGE PRG007_B303	 ; If Var2 >= 30, jump to PRG007_B303

	TXA		; A = special object slot index
	ASL A		; * 2
	ADC SpecialObj_Var2,X	; Add life counter
	AND #$02		; 0 or 2
	BNE PRG007_B320	 ; 2 ticks on, 2 ticks off; jump to PRG007_B320 (fire flickers away) (RTS)

PRG007_B303:
	JSR SObj_GetSprRAMOffChkVScreen	

	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A	; 8 ticks on/off

	LDA #$d9	 ; A = $D9
	BCC PRG007_B315	 ; 8 ticks on, 8 ticks off; jump to PRG007_B315
	LDA #$db	 ; A = $DB
PRG007_B315:

	; Store pattern
	STA Sprite_RAM+$01,Y

	; Set attribute
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	JMP SObj_PlayerCollide	 ; Do Player-to-fire collision and don't come back!

PRG007_B320:
	RTS		 ; Return

SObj_Bubble:
	LDA <Player_HaltGame
	BNE PRG007_B364	 ; If gameplay is halted, jump to PRG007_B364

	LDA SpecialObj_Timer,X
	BNE PRG007_B32D	 ; If timer not expired, jump to PRG007_B32D

	JMP SpecialObj_Remove	 ; Otherwise, remove the bubble

PRG007_B32D
	LDA SpecialObj_Data,X
	BNE PRG007_B352	 ; If data <> 0, jump to PRG007_B352

	JSR SObj_AddYVelFrac	 ; Apply Y velocity

	LDA SpecialObj_YVel,X
	BMI PRG007_B344	 ; If bubble is moving upward, jump to  PRG007_B344

	SUB #$07	; Slow down (downward bubble)
	STA SpecialObj_YVel,X
	BPL PRG007_B34F	 ; If bubble is still moving downward, jump to PRG007_B34F
	BMI PRG007_B34C	 ; Otherwise, jump to PRG007_B34C

PRG007_B344:
	ADD #$07	 ; Slow down (upward bubble)
	STA SpecialObj_YVel,X
	BMI PRG007_B34F	 ; If bubble is still moving upward, jump to PRG007_B34F

PRG007_B34C:
	INC SpecialObj_Data,X	 ; Otherwise, set SpecialObj_Data

PRG007_B34F:
	JMP PRG007_B364	 ; Jump to PRG007_B364

PRG007_B352:
	INC SpecialObj_Var1,X	 ; SpecialObj_Var1++

	LDA SpecialObj_Var1,X
	AND #%00110000
	BEQ PRG007_B364	 ; 48 ticks on, 48 ticks off; jump to PRG007_B364

	DEC SpecialObj_YLo,X	 ; Bubble Y --
	BNE PRG007_B364
	DEC SpecialObj_YHi,X	 ; Apply carry
PRG007_B364:

	LDA Level_NoStopCnt
	AND #%00001100
	LSR A
	LSR A
	TAY		 ; Y = 0 or 3

	; Bubble_XOff -> Temp_Var1
	LDA Bubble_XOff,Y
	STA <Temp_Var1

	JSR SObj_GetSprRAMOffChkVScreen
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Set bubble X
	LDA SpecialObj_XLo,X
	ADD <Temp_Var1	
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	; Set bubble pattern
	LDA #$17
	STA Sprite_RAM+$01,Y

	; Set bubble attributes
	LDA #SPR_PAL1
	STA Sprite_RAM+$02,Y

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_ApplyXYVelsWithGravity
;
; Apply the special object X and Y velocity with gravity
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_ApplyXYVelsWithGravity:
	JSR SObj_AddXVelFrac	 ; Apply X velocity
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

	LDA SpecialObj_YVel,X
	BMI PRG007_B39D	 ; If special object is moving upward, jump to PRG007_B39D

	CMP #$6e
	BGE PRG007_B3A3	 ; If special object Y velocity >= $6E, jump to PRG007_B3A3 (RTS)

PRG007_B39D:

	; Apply gravity
	INC SpecialObj_YVel,X
	INC SpecialObj_YVel,X

PRG007_B3A3:
	RTS		 ; Return

Cannonball_YOffset:	.byte 16, $00
Cannonball_YDiffLimit:	.byte 16, 32

SObj_Cannonball:

	; Load cannonball graphics
	LDA #$36
	STA PatTable_BankSel+4

	LDA <Player_HaltGame
	BNE PRG007_B3C2	 ; If gameplay halted, jump to PRG007_B3C2

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity
	JSR SObj_OffsetYForRaster	 ; Offset the Y by raster effects, if any

	LDA SpecialObj_Data,X
	BNE PRG007_B3C2	 ; If data <> 0 (cannonball is stomped), jump to PRG007_B3C2

	; Otherwise, Y Vel -= 2 (??)
	DEC SpecialObj_YVel,X
	DEC SpecialObj_YVel,X

PRG007_B3C2:
	JSR SObj_GetSprRAMOffChkVScreen
	BNE PRG007_B3A3	 ; If cannonball is vertically off-screen, jump to PRG007_B3A3 (RTS)

	JSR SObj_Draw16x16	; Prep cannonball sprites

	; Set cannon ball sprite attributes
	LDA #SPR_PAL3
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	; Set left and right cannonball patterns
	LDA #$af
	STA Sprite_RAM+$05,Y
	LDA #$ad
	STA Sprite_RAM+$01,Y

	LDA SpecialObj_Data,X
	ORA Player_IsDying
	ORA Player_OffScreen
	BNE PRG007_B445	 ; If cannonon ball is already stomped, Player is dying, or Player is off-screen, jump to PRG007_B445 (RTS)

	LDY #$00	 ; Y = 0 (Player is small or ducking)

	LDA <Player_Suit
	BEQ PRG007_B3F3		; If Player is small, jump to PRG007_B3F3

	LDA Player_IsDucking
	BNE PRG007_B3F3		; If Player is ducking, jump to PRG007_B3F3

	INY		 ; Y = 1 (Player not small/ducking)

PRG007_B3F3:
	LDA SpecialObj_YLo,X	; Cannonball Y
	SUB <Player_Y		; Player Y
	SUB Cannonball_YOffset,Y	; Offset
	CMP Cannonball_YDiffLimit,Y
	BGE PRG007_B445	 ; If Player is not close enough to top of cannonball, jump to PRG007_B445 (RTS)

	LDA SpecialObj_XLo,X
	ADD #$08	 ; Cannonball X + 8
	SUB <Player_X	 ; Diff against Player X
	CMP #20
	BGE PRG007_B445	 ; If Player is not close enough horizontally to cannonball, jump to PRG007_B445 (RTS)

	LDA Player_StarInv
	BNE PRG007_B426	 ; If Player is invincible by Star Man, jump to PRG007_B426

	LDA <Player_YVel
	BMI PRG007_B442	 ; If Player is moving upward, jump to PRG007_B442

	LDA SpecialObj_YLo,X
	SUB Level_VertScroll
	SUB #19
	CMP <Player_SpriteY
	BLT PRG007_B442	 ; If Player is close enough to bottom of cannonball, jump to PRG007_B442

PRG007_B426:

	; Flag cannonball as stomped!
	LDA #$01
	STA SpecialObj_Data,X

	; Halt its movements
	LDA #$00
	STA SpecialObj_XVel,X
	STA SpecialObj_YVel,X

	; Player bounces off cannonball
	LDA #-$30
	STA <Player_YVel

	; Cannonball kick sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

	JMP PRG007_B446	 ; Jump to PRG007_B446

PRG007_B442:
	JMP PRG007_B805	 ; Jump to PRG007_B805 (remainder of Player hit checks)

PRG007_B445:
	RTS		 ; Return


PRG007_B446:
	JSR Score_FindFreeSlot

	; Set base score and add Kill_Tally
	LDA #$85		; Base 100 points; $80 just mixes up what sprite it uses

PRG007_B44B:
	ADD Kill_Tally
	STA Scores_Value,Y

	INC Kill_Tally	 ; Kill_Tally++

	; Set the score counter
	LDA #$30
	STA Scores_Counter,Y

	LDA SpecialObj_YLo,X
	SUB Level_VertScroll
	SBC #$06
	CMP #192
	BLT PRG007_B469	 ; If score Y < 192, jump to PRG007_B469

	LDA #$05	 ; Otherwise, use Y = 5

PRG007_B469:
	STA Scores_Y,Y	 ; Set score Y

	; Set score X
	LDA SpecialObj_XLo,X
	SUB <Horz_Scroll
	STA Scores_X,Y

	RTS		 ; Return


SObj_OffsetYForRaster:
	LDA Level_AScrlConfig
	BEQ PRG007_B491	 ; If there's no raster effect going on, jump to PRG007_B491 (RTS)

	LDY #$00	 ; Y = $00 (16-bit sign extension)

	LDA Level_ScrollDiffV
	BPL PRG007_B483	 ; If vertical scroll difference is not negative, jump to PRG007_B483

	DEY		 ; Otherwise, Y = $FF (16-bit sign extension)

PRG007_B483:
	ADD SpecialObj_YLo,X
	STA SpecialObj_YLo,X	; Apply raster offset to Special Object Y

	TYA

	ADC SpecialObj_YHi,X
	STA SpecialObj_YHi,X	; Apply sign extension/carry

PRG007_B491:
	RTS		 ; Return

Wrench_Patterns:	.byte $A1, $95, $9F, $95
Wrench_Attributes:	.byte SPR_PAL2, SPR_PAL2 | SPR_VFLIP, SPR_PAL2, SPR_PAL2
	
SObj_Wrench:
	LDA <Player_HaltGame		 
	BNE PRG007_B4AF	 ; If gameplay halted, jump to PRG007_B4AF

	JSR SObj_OffsetYForRaster	; Offset Y with raster effects (if any)
	JSR SObj_AddXVelFrac	 	; Apply X velocity

	LDA SpecialObj_YVel,X
	BEQ PRG007_B4AC	 ; If wrench Y velocity = 0, jump to PRG007_B4AC

	INC SpecialObj_YVel,X	 ; Otherwise, Y Vel++ (fall?)

PRG007_B4AC:
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

PRG007_B4AF:
	JSR SObj_PlayerCollide	 ; Do Player-to-wrench collision

	JSR SObj_GetSprRAMOffChkVScreen
	BNE PRG007_B4EB	 ; If wrench is not vertically on-screen, jump to PRG007_B4EB (RTS)

	; Set Temp_Var1 = $00 or $80, depending on sign bit of X velocity
	LDA SpecialObj_XVel,X
	AND #$80
	STA <Temp_Var1

	LDA Level_NoStopCnt
	LSR A
	ADD <SlotIndexBackup
	AND #$03
	TAX		 ; X = 0 to 3

	; Set wrench pattern
	LDA Wrench_Patterns,X
	STA Sprite_RAM+$01,Y

	; Set wrench attributes
	LDA Wrench_Attributes,X
	EOR <Temp_Var1	
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup	; X = special object slot index

SObj_SetSpriteXYRelative:
	LDA SpecialObj_YLo,X
	SUB Level_VertScroll
	STA Sprite_RAM+$00,Y

	LDA SpecialObj_XLo,X
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

PRG007_B4EB:
	RTS		 ; Return


	; In the Japanese original, there were other power ups that "flew off"
	; when you lost them, and those are the additional values.  None of
	; them display correctly anymore, however, because:
	;
	; The graphics for the fly-off sprite only exist with small Mario, 
	; meaning when they added the "American" rule of returning to "super"
	; state, it didn't have the suit sprite graphics available!

LostShoe_Pattern:	.byte $A9, $AB	; 0
			.byte $39, $39	; 1
			.byte $3B, $3B	; 2
			.byte $3D, $3D	; 3
LostShoe_Attribute:	.byte $02, $01, $01, $01
	
SObj_WandBlast:
	LDA <Player_HaltGame
	BNE PRG007_B502	 ; If gameplay is halted, jump to PRG007_B502

	JSR SObj_AddXVelFrac	 ; Apply X Velocity
	JSR SObj_AddYVelFrac	 ; Apply Y Velocity

PRG007_B502:
	JSR SObj_GetSprRAMOffChkVScreen

	LDA SpecialObj_Timer,X
	TAX	; Timer -> 'X'

	; Select which pattern to use by timer
	LDA #$fd	 ; A = $FD

	CPX #$e0
	BGE PRG007_B517	 ; If timer >= $E0, jump to PRG007_B517

	LDA #$f9	 ; A = $F9

	CPX #$c0
	BGE PRG007_B517	 ; If timer >= $C0, jump to PRG007_B517

	LDA #$fb	 ; A = $FB

PRG007_B517:
	; Set the wand blast pattern
	STA Sprite_RAM+$01,Y

	LDX <SlotIndexBackup		 ; X = special object slot index

	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	TXA		; Special object slot index -> 'A'
	LSR A		; Shift bit 0 into carry
	ROR A		; Rotate it around to bit 7
	AND #SPR_VFLIP
	STA <Temp_Var1	; Temp_Var1 = VFlip attribute or not

	LDA <Counter_1
	LSR A	
	LSR A	
	LSR A	
	ROR A	
	AND #SPR_VFLIP
	ORA #SPR_PAL1
	EOR <Temp_Var1	 ; Invert VFlip by Temp_Var1

	; Set wand blast attribute
	STA Sprite_RAM+$02,Y

	JMP SObj_PlayerCollide	 ; Do Player-to-wand blast collision and don't come back!

	RTS		 ; Return

SObj_KuriboShoe:
	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity

	JSR SObj_GetSprRAMOffChkVScreen

	LDA SpecialObj_Data,X
	TAX		 ; SpecialObj_Data -> 'X' (NOTE: Will always be zero in US version, see notes at LostShoe_Pattern)

	; Set left sprite attribute
	LDA LostShoe_Attribute,X
	STA Sprite_RAM+$02,Y

	CPX #$00
	BEQ PRG007_B54F	 ; For the lost Kuribo's shoe only: Do not mirror sprite, jump to PRG007_B54F

	ORA #SPR_HFLIP	 ; Mirror sprite (NOTE: Used only in Japanese version for the "fly off" super suits!)

PRG007_B54F:
	STA Sprite_RAM+$06,Y	 ; Set attributes on right sprite

	; X *= 2 (two patterns per suit, again generally unused in US version)
	TXA
	ASL A
	TAX

	; Pattern for left fly off sprite
	LDA LostShoe_Pattern,X
	STA Sprite_RAM+$01,Y

	; Pattern for right fly off sprite
	LDA LostShoe_Pattern+1,X
	STA Sprite_RAM+$05,Y

	LDX <SlotIndexBackup	; X = special object slot index

SObj_Draw16x16:
	JSR SObj_SetSpriteXYRelative	 

	; Copy sprite Y into right sprite
	LDA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Right sprite is X + 8
	LDA Sprite_RAM+$03,Y
	ADD #$08
	STA Sprite_RAM+$07,Y

	RTS		 ; Return


SObj_Spikeball:
	LDA <Player_HaltGame
	BNE PRG007_B588	 ; If gameplay is halted, jump to PRG007_B588

	LDA SpecialObj_Data,X
	BEQ PRG007_B585	 ; If SpecialObj_Data = 0 (no gravity version, specifically Spike's spike ball), jump to PRG007_B585

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity
	JMP PRG007_B588	 ; Jump to PRG007_B588

PRG007_B585:
	JSR SObj_AddXVelFrac	 ; Apply X velocity only

PRG007_B588:
	JSR SObj_GetSprRAMOffChkVScreen

	; Spike ball pattern
	LDA #$95
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	JSR SObj_Draw16x16	 ; Draw spike ball

	; Set spike ball left attributes
	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP	; Toggles which side is going to be vertically flipped
	ORA #SPR_PAL2
	STA Sprite_RAM+$02,Y

	; Set opposite flips on right sprite
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y

	LDA SpecialObj_Data,X
	BNE PRG007_B5B1	 ; If SpecialObj_Data <> 0 (Gravity version, specifically Patooie's spike ball), jump to PRG007_B5B1 (RTS)

	JMP SObj_PlayerCollide	 ; Do Player to spike ball collision and don't come back!

PRG007_B5B1:
	RTS		 ; Return

Microgoomba_XAccel:	.byte $01, -$01
Microgoomba_XLimit:	.byte $10, -$10

Microgoomba_SprRAMAlt:	.byte $00, $04, $08, $0C, $10, $14, $18, $1C, $20, $24

SObj_Microgoomba:

	; Load Microgoomba's graphics
	LDA #$4f
	STA PatTable_BankSel+5

	LDA <Player_HaltGame
	BEQ PRG007_B5CC	 ; If gameplay is not halted, jump to PRG007_B5CC

	JMP Microgoomba_Draw	 ; Draw Microgoomba and don't come back!

PRG007_B5CC:
	LDA SpecialObj_Data,X
	BNE PRG007_B5D4	 ; If SpecialObj_Data <> 0, jump to PRG007_B5D4

	JMP PRG007_B660	 ; Otherwise, jump to PRG007_B660

PRG007_B5D4:
	BPL PRG007_B5DC	 ; If SpecialObj_Data > 0, jump to PRG007_B5DC

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity
	JMP Microgoomba_Draw	 ; Draw Microgoomba and don't come back

PRG007_B5DC:
	LDY Player_StarInv
	BNE PRG007_B601		; If Player is invincible by Star Man, jump to PRG007_B601

	LDY Player_InWater
	BNE PRG007_B601	 ; If Player is in water, jump to PRG007_B601

	INC Player_UphillSpeedIdx	 ; Player_UphillSpeedIdx = 1 (Microgoomba stuck to Player)

	CMP #$05
	BGE PRG007_B5F6	 ; If Microgoomba is already at his maximum stickiness, jump to PRG007_B5F6

	; Player is trying to shake him...

	LDA <Counter_1
	AND #$0f
	BNE PRG007_B5F6	 ; 1:16 ticks proceed, otherwise, jump to PRG007_B5F6

	INC SpecialObj_Data,X	 ; SpecialObj_Data++ (Increase "stickiness", up to 5)

PRG007_B5F6:
	LDA <Pad_Input
	AND #$ff	 ; This probably was intended to be a specific button rather than "everything"
	BEQ PRG007_B617	 ; If Player is not pressing anything, jump to PRG007_B617

	DEC SpecialObj_Data,X	 ; SpecialObj_Data--
	BNE PRG007_B617	 	; If SpecialObj_Data > 0, jump to PRG007_B617

PRG007_B601:

	; Otherwise, SpecialObj_Data = $FF (Microgoomba's "death" value)
	LDA #$ff
	STA SpecialObj_Data,X

	; Microgoomba flops off
	LDA #-$20
	STA SpecialObj_YVel,X

	LDA #$08	 ; A = $08

	LDY RandomN,X
	BPL PRG007_B614	 ; 50/50 chance we jump to PRG007_B614

	LDA #-$08	 ; A = -$08

PRG007_B614:
	STA SpecialObj_XVel,X	 ; Random X velocity

PRG007_B617:
	INC SpecialObj_Var1,X	 ; SpecialObj_Var1++

	; Set Microgoomba's Y...
	LDA SpecialObj_Var1,X
	LSR A
	LSR A
	AND #%00011111
	CMP #%00010000
	AND #%00001111
	BCC PRG007_B62B	 ; 16 ticks on, 16 ticks off; jump to PRG007_B62B

	EOR #%00001111
	ADC #$00

PRG007_B62B:
	CLC		 ; Clear carry

	LDY Player_IsDucking
	BNE PRG007_B635	 ; If Player is ducking, jump to PRG007_B635

	LDY <Player_Suit
	BNE PRG007_B639	 ; If Player is small, jump to PRG007_B639

PRG007_B635:
	LSR A
	ADD #$08

PRG007_B639:
	ADC <Player_Y
	STA SpecialObj_YLo,X
	LDA <Player_YHi
	ADC #$00
	STA SpecialObj_YHi,X


	; Set Microgoomba's X...
	LDA SpecialObj_Var1,X
	AND #%00011111
	CMP #%00010000
	AND #%00001111
	BLT PRG007_B654	 ; 16 ticks on, 16 ticks off; jump to PRG007_B62B

	EOR #%00001111
	ADC #$00

PRG007_B654:
	SUB #$03
	ADD <Player_X
	STA SpecialObj_XLo,X

	JMP Microgoomba_Draw	 ; Draw Microgoomba and don't come back

PRG007_B660:

	; SpecialObj_Data = 0...

	JSR SObj_AddXVelFrac	 ; Apply X Velocity
	JSR SObj_AddYVelFrac	 ; Apply Y Velocity

	LDA SpecialObj_YVel,X
	CMP #$10
	BGS PRG007_B670	 ; If Microgoomba's Y velocity >= 16, jump to PRG007_B670

	INC SpecialObj_YVel,X	 ; Otherwise, Y Vel++

PRG007_B670:
	LDA <Counter_1
	AND #$00
	BNE Microgoomba_Draw	 ; Technically NEVER jump to Microgoomba_Draw (??)

	LDA SpecialObj_Var1,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate Microgoomba
	LDA SpecialObj_XVel,X
	ADD Microgoomba_XAccel,Y
	STA SpecialObj_XVel,X

	CMP Microgoomba_XLimit,Y
	BNE Microgoomba_Draw	 ; If Microgoomba hasn't his X velocity limit, jump to Microgoomba_Draw

	INC SpecialObj_Var1,X	 ; Otherwise, SpecialObj_Var1++ (switch direction)

Microgoomba_Draw:
	JSR SObj_GetSprRAMOffChkVScreen
	BNE PRG007_B6CE	 ; If Microgoomba is not on this vertical screen, jump to PRG007_B6CE (RTS)

	LDA SpecialObj_Data,X
	BEQ PRG007_B6A9
	BMI PRG007_B6A9	 ; If SpecialObj_Data <= 0, jump to PRG007_B6A9

	TXA
	ASL A
	ASL A
	ASL A
	ASL A
	EOR SpecialObj_Var1,X
	AND #%00010000
	BEQ PRG007_B6A9	 ; Every 2 direction changes, jump to PRG007_B6A9

	; Use alternate Sprite RAM offset periodically
	LDY Microgoomba_SprRAMAlt,X	 ; Y = Microgoomba sprite RAM offset

PRG007_B6A9:
	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	; Microgoomba pattern
	LDA #$ff
	STA Sprite_RAM+$01,Y

	LDX #SPR_PAL3

	LDA Level_NoStopCnt
	AND #$08
	BEQ PRG007_B6BC	 ; 8 ticks on, 8 ticks off; jump to PRG007_B6BC

	LDX #(SPR_PAL3 | SPR_HFLIP)

PRG007_B6BC:

	; Store selected attributes
	TXA
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup	 ; X = special object slot

	LDA SpecialObj_Data,X
	BEQ PRG007_B6CF	 ; If SpecialObj_Data = 0, jump to PRG007_B6CF (Player to Microgoomba collision)
	BPL PRG007_B6CE	 ; If SpecialObj_Data > 0 (Microgoomba still alive), jump to PRG007_B6CE (RTS)

	; Microgoomba is dead; vertically flip
	LDA #(SPR_PAL3 | SPR_VFLIP)
	STA Sprite_RAM+$02,Y

PRG007_B6CE:
	RTS		 ; Return

PRG007_B6CF:
	JMP SObj_PlayerCollide	 ; Handle Player to Microgoomba collision and don't come back!

	; The hammer starting X is offset
Hammer_XOff:
	;  Not-HF HF  (HF = Horizontally flipped)
	.byte  8, -8	; Non-Heavy Hammer hold offset
	.byte  8, -8	; Non-Heavy Boomerang hold offset
	.byte 16, -8	; Heavy Bro hold offset

	; The hammer starting Y is offset
Hammer_YOff:
	;  Not-HF HF  (HF = Horizontally flipped)
	.byte  3,  3	; Non-Heavy Hammer hold offset
	.byte  3,  3	; Non-Heavy Boomerang hold offset
	.byte -6, -6	; Heavy Bro hold offset

SObjYOff_PlayerSize:	.byte 18, 10	; Small vs not small
SObj_VLimit:	.byte $10, $16
PRG007_B6E2:	.byte $00, $10

SObj_Hammer:
	LDA <Player_HaltGame
	BEQ PRG007_B6EB	 ; If gameplay is not halted, jump to PRG007_B6EB

	JMP PRG007_B773	 ; Otherwise, jump to PRG007_B773

PRG007_B6EB:

	; SpecialObj_Data special purposes:
	; Bits 0-3: Decrement to zero
	; Bits 4-7: While lower 4 bits not zero, references an object which, if not in normal state or off-screen, destroys this object

	LDA SpecialObj_Data,X
	AND #%00001111	 ; Consider lowest 4 bits of SpecialObj_Data
	BEQ PRG007_B76D	 ; If zero, jump to PRG007_B76D

PRG007_B6F2:
	; Lowest 4 bits of SpecialObj_Data is non-zero

	DEC SpecialObj_Data,X	 ; SpecialObj_Data-- (mainly to effect the lowest 4 bits)

	LDA SpecialObj_Data,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = the upper 4 bits (an object slot index)
	STY <Temp_Var2	 ; -> Temp_Var2

	LDA Objects_State,Y
	CMP #OBJSTATE_NORMAL
	BNE PRG007_B70D	 ; If this object is not in normal state, jump to PRG007_B70D

	LDA Objects_SprHVis,Y
	AND #%11000000
	BEQ PRG007_B710	 ; If this sprite does not have its two left sprites off-screen, jump to PRG007_B710

PRG007_B70D:

	; Referenced object is not in normal state or it is off-screen; destroy special object
	JMP SpecialObj_Remove

PRG007_B710:
	LDA Objects_FlipBits,Y
	AND #SPR_HFLIP
	STA <Temp_Var3	 ; Catch the horizontal flip bit of the referenced object -> Temp_Var3

	; Temp_Var1 = 0 to 1, based on whether object is horizontally flipped
	ASL A
	ASL A
	ROL A
	AND #$01
	STA <Temp_Var1

	LDA SpecialObj_ID,X
	CMP #SOBJ_HAMMER
	BEQ PRG007_B729	 ; If this is a hammer, jump to PRG007_B729

	; Otherwise, Temp_Var1 += 2
	INC <Temp_Var1
	INC <Temp_Var1

PRG007_B729:
	LDA Level_ObjectID,Y
	CMP #OBJ_HEAVYBRO
	BNE PRG007_B737	 ; If this not a Heavy Bro, jump to PRG007_B737

	; Otherwise, Temp_Var1 += 4
	LDA <Temp_Var1
	ADD #$04
	STA <Temp_Var1

PRG007_B737:

	; Set hammer starting X
	LDA Objects_X,Y
	LDY <Temp_Var1	
	ADD Hammer_XOff,Y
	STA SpecialObj_XLo,X

	LDY <Temp_Var2		 ; Y = referenced object slot index

	; Set hammer starting Y
	LDA Objects_Y,Y
	CLC
	LDY <Temp_Var1
	ADC Hammer_YOff,Y
	STA SpecialObj_YLo,X

	LDA #$00	; A = 0

	LDY SpecialObj_XVel,X
	BMI PRG007_B75A	 ; If hammer is traveling to the left, jump to PRG007_B75A

	LDA #SPR_HFLIP	; A = SPR_HFLIP

PRG007_B75A:
	CMP <Temp_Var3
	BEQ PRG007_B76A	 ; If hammer is flipped the same way as object, jump to PRG007_B76A

	; Reverse X velocity
	LDA SpecialObj_XVel,X
	JSR Negate
	STA SpecialObj_XVel,X

	INC SpecialObj_Var2,X

PRG007_B76A:
	JMP PRG007_B773	 ; Jump to PRG007_B773

PRG007_B76D:
	INC SpecialObj_Var1,X	; SpecialObj_Var1++

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity

PRG007_B773:
	JSR SObj_GetSprRAMOffChkVScreen	 ; Get a sprite RAM offset
	BEQ PRG007_B779	 ; If object is on the same vertical screen (see Temp_Var14 calculation), jump to PRG007_B779

	RTS		 ; Return

PRG007_B779:
	STY <Temp_Var2	 ; Sprite RAM offset -> 'Y'

	LDA SpecialObj_XVel,X

	LDY SpecialObj_ID,X
	CPY #SOBJ_HAMMER
	BEQ PRG007_B787	 ; If this is a hammer, jump to PRG007_B787

	EOR #$80	 ; Invert sign on X velocity

PRG007_B787:
	LSR A		 ; Shift down the bit
	AND #SPR_HFLIP	 ; Horizontal flip bit
	STA <Temp_Var1	 ; -> Temp_Var1

	CPY #SOBJ_HAMMER
	BNE PRG007_B798	 ; If this is not a hammer, jump to PRG007_B798

	LDY <Temp_Var2	 ; Y = Sprite RAM Offset

	JSR Hammer_Draw	 ; Draw hammer
	JMP PRG007_B7C5	 ; Jump to PRG007_B7C5

PRG007_B798:
	LDY <Temp_Var2	 ; Y = Sprite RAM Offset

	LDA SpecialObj_Var1,X
	AND #%00001100
	LSR A
	LSR A
	TAX		 ; X = 0 to 3

	; Set boomerang sprites attributes
	LDA <Temp_Var1
	EOR Boomerang_Attributes,X
	ORA #SPR_PAL1
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	LDA <Temp_Var1
	BEQ PRG007_B7B5	 ; If Temp_Var1 = 0, jump to PRG007_B7B5

	INX
	INX

PRG007_B7B5:
	TXA
	AND #$03
	TAX

	; Set boomerang sprites patterns
	LDA Boomerang_Patterns,X
	STA Sprite_RAM+$01,Y
	LDA Boomerang_Patterns+2,X
	STA Sprite_RAM+$05,Y

PRG007_B7C5:
	LDX <SlotIndexBackup	 ; X = special object slot index

	JSR SObj_Draw16x16	 ; Draw Boomerang

	LDA SpecialObj_Data,X
	AND #%00001111
	BNE PRG007_B826	 ; If lower 4 bits are not zero, jump to PRG007_B826 (RTS)

SObj_PlayerCollide:

	; Player to Special Object collision logic...

	TXA		 ; object slot index -> 'A'
	ADD <Counter_1	 ; Keep it interesting
	LSR A
	BCC PRG007_B826	 ; Every other tick, jump to PRG007_B826 (RTS)

	LDY #$00	 ; Y = 0 (small/ducking)

	LDA <Player_Suit
	BEQ PRG007_B7E4	 ; If Player is small, jump to PRG007_B7E4

	LDA Player_IsDucking
	BNE PRG007_B7E4	 ; If Player is ducking, jump to PRG007_B7E4

	INY		 ; Y = 1 (otherwise)

PRG007_B7E4:
	LDA SpecialObj_YLo,X		; Special object Y
	ADD #$08			; +8
	SUB <Player_Y			; Subtract Player Y
	SUB SObjYOff_PlayerSize,Y	; Subtract Player height offset
	CMP SObj_VLimit,Y
	BGE PRG007_B843	 	; If result >= SObj_VLimit, jump to PRG007_B843 (RTS)

	LDA SpecialObj_XLo,X		; Special object X
	ADD #$06			; +6
	SUB <Player_X			; Subtract Player X
	SBC #$00			; Carry?
	CMP #16
	BGE PRG007_B843	 	; If result >= 16, jump to PRG007_B843 (RTS)

PRG007_B805:
	LDA Player_FlashInv	; If Player is flashing from being hit ...
	ORA Player_Statue	; ... if Player is a statue ...
	ORA <Player_HaltGame	; ... if gameplay is halted ...
	ORA Player_IsDying	; ... Player is dying ...
	ORA Player_OffScreen	; ... Player is off-screen ...
	ORA Player_Behind_En	; ... Player is legitimately hidden behind the scenes ...
	ORA <Temp_Var14		; ... or special object is not vertically on-screen ...
	BNE PRG007_B843	 	; ... jump to Player_Behind_En (RTS)

	LDA SpecialObj_ID,X
	CMP #SOBJ_MICROGOOMBA
	BNE PRG007_B827	 ; If this is not a microgoomba, jump to PRG007_B827

	; Microgooma sets to 5
	LDA #$05
	STA SpecialObj_Data,X

PRG007_B826:
	RTS		 ; Return


PRG007_B827:
	CMP #$10
	BNE PRG007_B836	 ; If this is not the recovered wand, jump to PRG007_B836

	; Wand grabbed!

	INC Level_GetWandState	 ; Level_GetWandState++

	; Play victory music!
	LDA #MUS1_BOSSVICTORY
	STA Sound_QMusic1

	JMP SpecialObj_Remove	 ; Remove the wand and don't come back!

PRG007_B836:
	LDA Player_StarInv
	BNE PRG007_B844	 ; If Player is Star Man invincible, jump to PRG007_B844

	JMP Player_GetHurt	 ; Hurt Player and don't come back!

SpecialObj_Remove:

	; Remove special object
	LDA #$00
	STA SpecialObj_ID,X

PRG007_B843:
	RTS		 ; Return

PRG007_B844:

	; Player is invincible; destroy the special object!

	; Play "kick" sound
	LDA Sound_QPlayer
	ORA #SND_PLAYERKICK
	STA Sound_QPlayer

PRG007_B84C:
	; Change to a "poof"
	LDA #SOBJ_POOF
	STA SpecialObj_ID,X

	; SpecialObj_Data = $1F
	LDA #$1f
	STA SpecialObj_Data,X

	RTS		 ; Return

Hammer_Attributes:	.byte $00, SPR_HFLIP, SPR_HFLIP, SPR_HFLIP | SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, SPR_VFLIP, SPR_VFLIP, $00

Hammer_Patterns:
	.byte $A1, $A3, $B9, $B9, $A3, $A1
	.byte $AF, $AF, $A1, $A3, $B9, $B9

Hammer_Draw:
	LDA SpecialObj_Var1,X
	AND #%00011100
	LSR A
	LSR A
	TAX		 ; X = 0 to 7 (hammer's current frame)

	; Set upper and lower sprite attributes
	LDA <Temp_Var1
	EOR Hammer_Attributes,X
	ORA #SPR_PAL1
	STA Sprite_RAM+$02,Y
	STA Sprite_RAM+$06,Y

	LDA <Temp_Var1
	BEQ PRG007_B888	 ; If no flip, jump to PRG007_B888

	; Otherwise, X += 4 (4 "frames" ahead on the hammer for the flip)
	INX
	INX
	INX
	INX

PRG007_B888:

	; Cap X 0 to 7
	TXA
	AND #$07
	TAX

	; Set upper sprite pattern
	LDA Hammer_Patterns,X
	STA Sprite_RAM+$01,Y

	; Set bottom sprite pattern
	LDA Hammer_Patterns+4,X
	STA Sprite_RAM+$05,Y

	RTS		 ; Return

Boomerang_XVelDelta:	.byte $01, -$01
Boomerang_XVelLimit:	.byte $20, $E0
Boomerang_YVelAccel:	.byte $01, -$01
Boomerang_YVelLimit:	.byte $12, -$12

Boomerang_Attributes:	.byte SPR_HFLIP | SPR_VFLIP, SPR_HFLIP | SPR_VFLIP, $00, $00

Boomerang_Patterns:
	.byte $8B, $8F, $89, $8D, $8B, $8F


SObj_Boomerang:

	; Load Boomerang's graphics
	LDA #$4e
	STA PatTable_BankSel+4

	LDA <Player_HaltGame
	BEQ PRG007_B8B7	 ; If gameplay is not halted, jump to PRG007_B8B7

	JMP PRG007_B773	 ; Jump to PRG007_B773 (Draw Boomerang)

PRG007_B8B7:
	LDA SpecialObj_Data,X
	AND #%00001111
	BEQ PRG007_B8C1	 ; If lower 4 bits of SpecialObj_Data = 0, jump to PRG007_B8C1

	JMP PRG007_B6F2	 ; Jump to PRG007_B6F2

PRG007_B8C1:
	INC SpecialObj_Var1,X	 ; Var1 ++

	LDA SndCur_Level2
	AND #SND_BOOMERANG
	BNE PRG007_B8D3	 ; If boomerang sound is currently playing, jump to PRG007_B8D3

	; Player boomerang sound
	LDA Sound_QLevel2
	ORA #SND_BOOMERANG
	STA Sound_QLevel2

PRG007_B8D3:
	LDA SpecialObj_Var2,X
	BMI PRG007_B904

	LDA SpecialObj_Timer,X
	BNE PRG007_B904	 ; If timer not expired, jump to PRG007_B904

	LDA SpecialObj_Var2,X
	AND #$01
	TAY		 ; Y = 0 or 1 (Boomerang Direction)

	; Accelerate Boomerang
	LDA SpecialObj_XVel,X
	ADD Boomerang_XVelDelta,Y
	STA SpecialObj_XVel,X

	CMP Boomerang_XVelLimit,Y
	BNE PRG007_B904	 ; If boomerang has not hit limit, jump to PRG007_B904

	; Set boomerang timer
	LDA #$30
	STA SpecialObj_Timer,X

	INC SpecialObj_Var2,X	 ; SpecialObj_Var2++ (change direction)

	LDA SpecialObj_Var3,X
	BEQ PRG007_B904	 ; If SpecialObj_Var3 = 0, jump to PRG007_B904

	; Boomerang is on the return
	LDA #$ff
	STA SpecialObj_Var2,X

PRG007_B904:
	LDA <Counter_1
	LSR A
	BCS PRG007_B92A	 ; Every other tick, jump to PRG007_B92A

	LDA SpecialObj_Var3,X
	CMP #$01
	BLT PRG007_B915

	LDY SpecialObj_YVel,X
	BEQ PRG007_B92A	 ; If Boomerang Y Vel = 0, jump to PRG007_B92A

PRG007_B915:
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate Boomerang Y Velocity
	LDA SpecialObj_YVel,X
	ADD Boomerang_YVelAccel,Y
	STA SpecialObj_YVel,X

	CMP Boomerang_YVelLimit,Y
	BNE PRG007_B92A	 ; If Boomerang Y Velocity is at limit, jump to PRG007_B92A

	INC SpecialObj_Var3,X	 ; SpecialObj_Var3++

PRG007_B92A:
	JSR SObj_AddXVelFrac	; Apply X Velocity
	JSR SObj_AddYVelFrac	; Apply Y Velocity
	JSR PRG007_B773	 	; Draw Boomerang

	LDA SpecialObj_Var2,X
	BPL PRG007_B979	 ; If SpecialObj_Var2 <> $FF, jump to PRG007_B979

	TXA		 ; Keep things interesting
 	ADD <Counter_1	
	LSR A	
	BCS PRG007_B979	 ; Every other tick, jump to PRG007_B979 (RTS)

	LDA SpecialObj_Data,X
	LSR A
	LSR A
	LSR A
	LSR A
	TAY		 ; Y = object slot index of boomerang thrower

	LDA Objects_State,Y
	CMP #OBJSTATE_NORMAL
	BNE PRG007_B979	 ; If thrower's state <> Normal, jump to PRG007_B979 (RTS)

	LDA Level_ObjectID,Y
	CMP #OBJ_BOOMERANGBRO
	BNE PRG007_B979	; If thrower's slot is not a boomerang brother (Anymore), jump to PRG007_B979 (RTS)

	; This is for the Boomerang brother to "catch"

	LDA SpecialObj_YLo,X
	ADD #8
	SUB Objects_Y,Y
	SUB #8
	CMP #16
	BGE PRG007_B979	 ; If boomerang Y diff >= 16, jump to PRG007_B979 (RTS)

	LDA SpecialObj_XLo,X
	ADD #8
	SUB Objects_X,Y
	SBC #0
	CMP #16
	BGE PRG007_B979 ; If boomerang X diff >= 16, jump to PRGO007_B979 (RTS)

	JMP SpecialObj_Remove	 ; Boomerang Bro caught boomerang

PRG007_B979:
	RTS		 ; Return

SObj_UNKNOWN_XAccel:	.byte $01, -$01
SObj_UNKNOWN_XLimit:	.byte $20, $E0
SObj_UNKNOWN_YAccel:	.byte $04, -$01
SObj_UNKNOWN_YLimit:	.byte $0F, -$12
	
SObj_UNKNOWN:
	LDA <Player_HaltGame
	BEQ PRG007_B989	 ; If gameplay not halted, jump to PRG007_B989

	JMP PRG007_B773	 ; Otherwise, jump to PRG007_B773 (Hammer/Boomerang draw routines??)

PRG007_B989:
	LDA SpecialObj_Data,X
	AND #$0f
	BEQ PRG007_B993	 ; 1:16 ticks jump to PRG007_B993

	JMP PRG007_B6F2	 ; Jump to PRG007_B6F2

PRG007_B993:
	DEC SpecialObj_Var1,X	 ; Var1--

	LDY SpecialObj_Timer,X
	BEQ PRG007_B9A1	 ; If timer not expired, jump to PRG007_B9A1

	DEY		 ; Y--

	BNE PRG007_B9C4	 ; If timer still has at least 1 tick left, jump to PRG007_B9C4

	INC SpecialObj_Var3,X	 ; SpecialObj_Var3++

PRG007_B9A1:
	LDA <Counter_1
	AND #$00	; ??
	BNE PRG007_B9C4	 ; Jump technically NEVER to PRG007_B9C4

	LDA SpecialObj_Var2,X
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate X
	LDA SpecialObj_XVel,X
	ADD SObj_UNKNOWN_XAccel,Y
	STA SpecialObj_XVel,X

	CMP SObj_UNKNOWN_XLimit,Y
	BNE PRG007_B9C4	 ; If it hasn't hit its X velocity limit, jump to PRG007_B9C4

	; Timer = $50
	LDA #$50
	STA SpecialObj_Timer,X

	INC SpecialObj_Var2,X	 ; Var2++

PRG007_B9C4:
	LDA <Counter_1
	AND #$03
	BNE PRG007_B9ED	 ; 1:4 ticks proceed, otherwise jump to PRG007_B9ED

	LDA SpecialObj_Var3,X
	BEQ PRG007_B9ED	 ; If SpecialObj_Var3 = 0, jump to PRG007_B9ED

	CMP #$03
	BLT PRG007_B9D8	 ; If SpecialObj_Var3 < 3, jump to PRG007_B9D8

	LDY SpecialObj_YVel,X
	BEQ PRG007_B9ED	 ; If it is not moving vertically, jump to PRG007_B9ED

PRG007_B9D8:
	AND #$01
	TAY		 ; Y = 0 or 1

	; Accelerate Y
	LDA SpecialObj_YVel,X
	ADD SObj_UNKNOWN_YAccel,Y
	STA SpecialObj_YVel,X

	CMP SObj_UNKNOWN_YLimit,Y
	BNE PRG007_B9ED	 ; If it hasn't hit its Y velocity limit, jump to PRG007_B9ED

	INC SpecialObj_Var3,X	 ; SpecialObj_Var3++

PRG007_B9ED:
	JMP PRG007_B92A	 ; Jump to PRG007_B92A (uses more Boomerang behavior)

Fireball_Patterns:	.byte $65, $67, $65, $67
Fireball_Attributes:	.byte SPR_PAL1, SPR_PAL1, SPR_PAL1 | SPR_HFLIP | SPR_VFLIP, SPR_PAL1 | SPR_HFLIP | SPR_VFLIP

SObj_Fireball:
	LDA <Player_HaltGame
	BNE PRG007_BA33	 ; If gameplay halted, jump to PRG007_BA33

	; Gameplay not halted...

	INC SpecialObj_Var1,X	 ; SpecialObj_Var1++

	LDA SpecialObj_ID,X

	CMP #SOBJ_PIRANHAFIREBALL
	BEQ PRG007_BA2D	 ; If this is a piranha's fireball, jump to PRG007_BA2D

	CMP #SOBJ_FIRECHOMPFIRE
	BEQ PRG007_BA2D	 ; If this is a Fire Chomp's fireball, jump to PRG007_BA2D

	; Not a piranha's or Fire Chomp's fireball

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity

	LDA SpecialObj_YVel,X
	CMP #$30
	BPL PRG007_BA1A	 ; If fireball Y vel < $30, jump to PRG007_BA1A

	; Heavier gravity
	INC SpecialObj_YVel,X
	INC SpecialObj_YVel,X

PRG007_BA1A:
	LDA SpecialObj_ID,X
	CMP #SOBJ_FIREBROFIREBALL
	BNE PRG007_BA24	 ; If this is not Fire Bro's fireball, jump to PRG007_BA24

	JSR SObj_CheckHitSolid	 ; Bounce fireball off surfaces

PRG007_BA24:
	JMP PRG007_BA33	 ; Jump to PRG007_BA33

	JSR SObj_ApplyXYVelsWithGravity	 ; Apply X and Y velocities with gravity
	JMP PRG007_BA33	 ; Jump to PRG007_BA33

PRG007_BA2D:
	JSR SObj_AddXVelFrac	 ; Apply X velocity
	JSR SObj_AddYVelFrac	 ; Apply Y velocity

PRG007_BA33:
	JSR SObj_GetSprRAMOffChkVScreen
	BNE PRG007_BA92	 ; If fireball isn't vertically on-screen, jump to PRG007_BA92

	JSR SObj_SetSpriteXYRelative	 ; Special Object X/Y put to sprite, scroll-relative

	LDA SpecialObj_ID,X
	CMP #SOBJ_FIRECHOMPFIRE
	BNE PRG007_BA55	 ; If this is not a Fire Chomp's fireball, jump to PRG007_BA55

	; Fire Chomp's fireball only...

	LDA Level_NoStopCnt
	LSR A
	LSR A

	LDA #$89	 ; A = $89 (first fireball pattern)

	BCC PRG007_BA4D	 ; 4 ticks on, 4 ticks off; jump to PRG007_BA4D

	LDA #$8b	 ; A = $8B (second fireball pattern)

PRG007_BA4D:
	STA Sprite_RAM+$01,Y	 ; Set fireball pattern

	LDA #$01	; A = 1
	JMP PRG007_BA6E	 ; Jump to PRG007_BA6E

PRG007_BA55:
	LDA SpecialObj_XVel,X
	LSR A
	AND #SPR_HFLIP	 ; Flip based on X velocity
	PHA		 ; Save flip

	LDA SpecialObj_Var1,X
	LSR A
	LSR A
	AND #$03
	TAX		 ; X = 0 to 3

	; Set fireball pattern
	LDA Fireball_Patterns,X
	STA Sprite_RAM+$01,Y

	PLA		 ; Restore flip
	EOR Fireball_Attributes,X

PRG007_BA6E:

	; Set fireball attributes
	STA Sprite_RAM+$02,Y

	LDX <SlotIndexBackup	 ; X = special object slot index

	LDA <Player_Suit
	CMP #$06
	BNE PRG007_BA8F	 ; If Player is not wearing the Hammer Suit, jump to PRG007_BA8F

	LDA Player_IsDucking
	BEQ PRG007_BA8F	 ; If Player is NOT ducking (immunity to fireballs), jump to PRG007_BA8F

	LDA Player_StarInv
	PHA		 ; Save Player's Star Man invincibility status

	; Collide with it like Player were invincible!  (Visually the shell protects him)
	LDA #$10
	STA Player_StarInv
	JSR SObj_PlayerCollide

	; Restore actual Star Man invincibility
	PLA
	STA Player_StarInv

	RTS		 ; Return

PRG007_BA8F:
	JMP SObj_PlayerCollide	 ; Do Player-to-Fireball collision and don't come back!

PRG007_BA92:
	RTS		 ; Return

Poof_Patterns:	.byte $47, $45, $43, $41

SObj_Poof:
	LDA SpecialObj_Data,X
	BNE PRG007_BA9F	 ; If data > 0, jump to PRG007_BA9F

	JMP SpecialObj_Remove	 ; Otherwise, remove the puff

PRG007_BA9F:
	LDA <Player_HaltGame
	BNE PRG007_BAA6	 ; If gameplay halted, jump to PRG007_BAA6

	DEC SpecialObj_Data,X	 ; Data--

PRG007_BAA6:
	JSR SObj_GetSprRAMOffChkVScreen
	BNE PRG007_BAD6		; If puff is vertically off-screen, jump to PRG007_BAD6

	JSR SObj_Draw16x16	 ; Prep puff sprite

	; Set puff attributes on left sprite
	LDA Level_NoStopCnt
	LSR A
	LSR A
	LSR A
	ROR A
	AND #SPR_VFLIP
	STA <Temp_Var1
	LDA #SPR_PAL1
	ORA <Temp_Var1
	STA Sprite_RAM+$02,Y

	; Set puff attributes on right sprite
	EOR #(SPR_HFLIP | SPR_VFLIP)
	STA Sprite_RAM+$06,Y

	LDA SpecialObj_Data,X
	LSR A
	LSR A
	LSR A
	TAX

	; Set poof patterns
	LDA Poof_Patterns,X
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	LDX <SlotIndexBackup	; X = special object slot index

PRG007_BAD6:
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_GetSprRAMOffChkVScreen
;
; Gets an appropriate sprite RAM offset and also returns zero if
; the object is on the same vertical screen as the Player
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_SprRAMBase:
	.byte $08, $10, $00, $08, $10, $04, $0C, $14, $0C

SObj_GetSprRAMOffChkVScreen:
	LDY #$07	 ; Y = 7

	CPX #$09
	BEQ PRG007_BAED	 ; If special object slot = 9, jump to PRG007_BAED

	CPX #$03
	BLT PRG007_BAED	 ; If special object slot < 3, jump to PRG007_BAED

	LDY #$08	 ; Y = 8

PRG007_BAED:
	LDA SObj_SprRAMBase-1,X
	ADD Object_SprRAM-1,Y
	TAY		 ; Y = Sprite RAM offset

	CPX #$00
	BNE PRG007_BB1A	 ; If special object slot 0, jump to PRG007_BB1A

	JSR Object_GetRandNearUnusedSpr
	BNE PRG007_BB1A	 ; If sprite available, jump to PRG007_BB1A

	LDA SpecialObj_ID,X

	; If this special object is empty, or is a Nipper fireball/Piranha Fireball/Microgoomba, jump to PRG007_BB1A

	CMP #SOBJ_NIPPERFIREBALL
	BEQ PRG007_BB1A

	CMP #SOBJ_PIRANHAFIREBALL
	BEQ PRG007_BB1A

	CMP #SOBJ_MICROGOOMBA
	BEQ PRG007_BB1A

	CMP #$00
	BEQ PRG007_BB1A

	LDA RandomN,X
	AND #$03	; 0 to 3
	ASL A	
	ASL A	
	ASL A		; Multiply by 8
	TAY		; Y = 0, 8, 16, 24

PRG007_BB1A:
	LDA <Temp_Var14	; Return the relative Y Hi value

	RTS		 ; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_AddXVelFrac
;
; Adds the 4.4FP X velocity to X of special object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_AddXVelFrac:
	LDA SpecialObj_XVel,X		; Get X Velocity  
	ASL A
	ASL A
	ASL A
	ASL A		 		; Fractional part shifted up
	ADD SpecialObj_XVelFrac,X
	STA SpecialObj_XVelFrac,X	; Add to special object's X vel fractional accumulator

	PHP		 ; Save CPU status

	; Basically amounts to an arithmetic shift right 4 places
	LDA SpecialObj_XVel,X	; Get X Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 	; Whole part shifted down (integer)
	CMP #%00001000	; Check the sign bit
	BLT PRG007_BB39 ; If the value was not negatively signed, jump to PRG007_BB39
	ORA #%11110000	; Otherwise, apply a sign extension
PRG007_BB39:

	PLP		 ; Restore CPU status

	ADC SpecialObj_XLo,X
	STA SpecialObj_XLo,X ; Add with carry

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SObj_AddYVelFrac
;
; Adds the 4.4FP Y velocity to Y of special object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SObj_AddYVelFrac:
	LDA SpecialObj_YVel,X		; Get Y Velocity
	ASL A
	ASL A
	ASL A
	ASL A		 		; Fractional part shifted up
	ADD SpecialObj_YVelFrac,X
	STA SpecialObj_YVelFrac,X	; Add to special object's X vel fractional accumulator

	PHP		 ; Save CPU status

	; Basically amounts to an arithmetic shift right 4 places
	LDA SpecialObj_YVel,X	; Get Y Velocity
	LSR A
	LSR A
	LSR A
	LSR A		 	; Whole part shifted down (integer)
	CMP #%00001000	; Check the sign bit
	LDY #$00	 ; Y = $00 (16-bit sign extension)
	BLT PRG007_BB60	 ; If the value was not negatively signed, jump to PRG007_BB60
	ORA #%11110000	; Otherwise, apply a sign extension

	DEY		 ; Y = $FF (16-bit sign extension)

PRG007_BB60:
	PLP		 ; Restore CPU status

	ADC SpecialObj_YLo,X
	STA SpecialObj_YLo,X ; Add with carry

	TYA		 ; Sign extension

	; Apply sign extension
	ADC SpecialObj_YHi,X
	STA SpecialObj_YHi,X

	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CannonFire_UpdateAndDraw
;
; Updates and draws the Cannon Fires
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CannonFire_UpdateAndDraw:
	LDA <Player_HaltGame		 
	ORA EndCard_Flag
	BNE PRG007_BB80	 ; If gameplay halted or end level card grabbed, jump to PRG007_BB80 (RTS)

	LDX #$07	 ; X = 7
PRG007_BB78:
	STX <SlotIndexBackup	 ; Update index backup

	JSR CannonFire_DrawAndUpdate	; Draw and Update Cannon Fire

	DEX		 ; X--
	BPL PRG007_BB78	; While X >= 0, loop!

PRG007_BB80:
	RTS		 ; Return


CannonFire_DrawAndUpdate:
	LDA CannonFire_ID,X
	BEQ PRG007_BB80	 ; If this slot is unused/empty, jump to PRG007_BB80 (RTS)

	PHA		 ; Save ID

	; Update CannonFire_Timer
	LDA CannonFire_Timer,X
	BEQ PRG007_BB8F	 ; If CannonFire_Timer = 0, jump to CannonFire_Timer
	DEC CannonFire_Timer,X	 ; CannonFire_Timer--
PRG007_BB8F:

	; Update CannonFire_Timer2
	LDA CannonFire_Timer2,X
	BEQ PRG007_BB97
	DEC CannonFire_Timer2,X
PRG007_BB97:

	PLA		 ; Restore ID
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word PRG007_BB80	; 00: Unused (would never get here anyway)
	.word CFire_BulletBill	; 01: Bullet Bill cannon
	.word CFire_BulletBill	; 02: Missile Bill (homing Bullet Bill)
	.word CFire_RockyWrench	; 03: Creates Rocky Wrench
	.word CFire_4Way	; 04: 4-way cannon
	.word CFire_GoombaPipe	; 05: Goomba pipe (left output)
	.word CFire_GoombaPipe	; 06: Goomba pipe (right output)
	.word CFire_Cannonball 	; 07: Fires cannonballs horizontally left
	.word CFire_Cannonball	; 08: Fires BIG cannonballs horizontally left
	.word CFire_Cannonball	; 09: Fires cannonballs diagonally, upper left
	.word CFire_Cannonball	; 0A: Fires cannonballs diagonally, upper right
	.word CFire_Cannonball	; 0B: Fires cannonballs diagonally, lower left
	.word CFire_Cannonball	; 0C: Fires cannonballs diagonally, lower right
	.word CFire_Cannonball	; 0D:
	.word CFire_Cannonball	; 0E: 
	.word CFire_Cannonball 	; 0F: 
	.word CFire_Cannonball	; 10:
	.word CFire_Cannonball	; 11: Fires cannonballs horizontally right
	.word CFire_Cannonball	; 12: Fires BIG cannonballs horizontally right
	.word CFire_Cannonball	; 13: Launches fused Bob-ombs to the left
	.word CFire_Cannonball	; 14: Launches fused Bob-ombs to the right
	.word CFire_Laser	; 15: Laser fire

CFire_Laser:
	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BBEB	 ; If the Cannon Fire laser is horizontally off-screen, jump to PRG007_BBEB (RTS)

	LDA CannonFire_X,X
	SUB <Player_X
	CMP #$38
	BLT PRG007_BBEB	; If Player is too far left, jump to PRG007_BBEB (RTS)
	CMP #$4c
	BGE PRG007_BBEB	; If Player is too far right, jump to PRG007_BBEB (RTS)

	LDY #$07	 ; Y = 7
PRG007_BBE3:
	LDA SpecialObj_ID,Y
	BEQ PRG007_BBEC	 ; If this special object slot is not in use, jump to PRG007_BBEC

	DEY		 ; Y--
	BPL PRG007_BBE3	; While Y >= 0, loop!

PRG007_BBEB:
	RTS		 ; Return

PRG007_BBEC:
	LDA SndCur_Player
	ORA Sound_QPlayer
	AND #SND_PLAYERPIPE
	BNE PRG007_BBFB	 ; If the pipe/shrink sound is queued or currently playing, jump to PRG007_BBFB

	; Otherwise play the "bump" sound (which played rapidly makes the laser sound)
	LDA #SND_PLAYERBUMP
	STA Sound_QPlayer

PRG007_BBFB:

	; This is a laser!
	LDA #SOBJ_LASER
	STA SpecialObj_ID,Y

	; Set laser X
	LDA CannonFire_X,X
	SUB #$08
	STA SpecialObj_XLo,Y

	; Set laser Y
	LDA CannonFire_Y,X
	ADD #$08
	STA SpecialObj_YLo,Y
	LDA CannonFire_YHi,X
	STA SpecialObj_YHi,Y

	RTS		 ; Return

CFire_Cannonball:

	; Load cannonball graphics
	LDA #$36
	STA PatTable_BankSel+4

	LDA CannonFire_Timer,X
	BNE PRG007_BC5B	 ; If timer not expired, jump to PRG007_BC5B (RTS)

	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BC5B	 ; If Cannon Fire is off-screen left, jump to PRG007_BC5B (RTS)

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	CMP #240
	BGE PRG007_BC5B	 ; If Cannon Fire is off-screen right, jump to PRG007_BC5B (RTS)

	; Reload timer = $87
	LDA #$87
	STA CannonFire_Timer,X

	; Temp_Var1 = this particular Cannon Fire ID
	LDA CannonFire_ID,X
	STA <Temp_Var1

	CMP #CFIRE_HRBIGCANNON
	BEQ PRG007_BC4B	 ; If this is the right-shooting BIG Cannon, jump to PRG007_BC4B

	CMP #CFIRE_HLBIGCANNON
	BNE PRG007_BC4E	 ; If this is NOT the left-shooting BIG Cannon, jump to PRG007_BC4E

PRG007_BC4B:
	JMP PRG007_BC5C	 ; For all BIG Cannons, jump to PRG007_BC5C

PRG007_BC4E:
	CMP #CFIRE_LBOBOMBS
	BLT PRG007_BC55	 ; If this is not one of the Bob-omb cannons, jump to PRG007_BC55

	JMP PRG007_BCB4	 ; For all Bob-omb cannons, jump to PRG007_BCB4

PRG007_BC55: 
	ADD #(Cannons_CPXOff - CannonPoof_XOffs - CFIRE_HLCANNON)	; Offset to proper array index for this Cannon Fire
	JMP PRG007_BE59	 ; Jump to PRG007_BE59 (fire cannonball!)

PRG007_BC5B:
	RTS		 ; Return


PRG007_BC5C:

	; Left/right BIG Cannons

	JSR PrepareNewObjectOrAbort	; Get me an object slot or don't come back!

	; This is a BIG Cannon Ball!
	LDA #OBJ_BIGCANNONBALL
	STA Level_ObjectID,X

	; Big Cannon Ball is BIG
	INC Objects_IsGiant,X

	LDY <SlotIndexBackup	; Y = Cannon Fire slot index

	; Set BIG Cannon Ball Y
	LDA CannonFire_Y,Y
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	STA <Objects_YHi,X

	LDA <Temp_Var1
	CMP #CFIRE_HRCANNON

	LDA #$30	 ; A = $30
	LDY #$12	 ; Y = $12

	BGE PRG007_BC81	 ; Basically if this is the right-shooting BIG Cannon, jump to PRG007_BC81

	LDY #$09	 ; Y = $09
	LDA #-$30	 ; A = -$30

PRG007_BC81:
	STY <Temp_Var1	 ; Temp_Var1 = $12 (if right-shooting) or $09 (if left-shooting)

	STA <Objects_XVel,X	 ; X velocity = -$30 or $30, depending on direction

	EOR #$80	 ; Invert the sign bit

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	ASL A		 ; Inverted sign bit -> carry

	; Set BIG Cannon Ball X
	LDA CannonFire_X,Y
	BCS PRG007_BC92	 ; If right-shooting, jump to PRG007_BC92
	SUB #16		; -16 for left-shooting
PRG007_BC92:
	STA <Objects_X,X
	LDA CannonFire_XHi,Y
	SBC #$00
	STA <Objects_XHi,X

	JSR PRG007_BD09		; Set attribute and make noise and smoke!
	JSR CannonFire_NoiseAndSmoke	 ; make more smoke!!

	; +4 to this smoke though
	LDA CannonFire_Y,X
	SUB Level_VertScroll
	ADD #$04
	STA BrickBust_YUpr

	; +8 to the other smoke
	ADC #$08
	STA BrickBust_YUpr+1

	RTS		 ; Return

PRG007_BCB4:

	; Bob-omb cannons!

	JSR PrepareNewObjectOrAbort

	; It's a Bob-omb!!
	LDA #OBJ_BOBOMBEXPLODE
	STA Level_ObjectID,X

	; Bobomb's Timer3 = $80
	LDA #$80
	STA Objects_Timer3,X

	INC Objects_Var7,X	 ; Bob-omb's Var7++
	INC Objects_Var1,X	 ; Bob-omb's Var1++

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	; Set Bob-omb's Y
	LDA CannonFire_Y,Y
	SUB #$08
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; Set Bob-omb's Y velocity
	LDA #-$30
	STA <Objects_YVel,X

	LDA <Temp_Var1
	CMP #CFIRE_RBOBOMBS

	LDA #$10	 ; A = $10
	LDY #$0b	 ; Y = $0B
	BCS PRG007_BCE9	 ; If this is a right-shot Bob-omb, jump to PRG007_BCE9

	DEY		 ; Y = $0A
	LDA #-$10	 ; A = -$10

PRG007_BCE9:
	STY <Temp_Var1	 ; Temp_Var1 = $0A or $0B
	STA <Objects_XVel,X	 ; Set Bob-omb's X velocity (-$10 or $10)

	ASL A		 ; Shift sign bit into carry

	; Temp_Var2 = $00 (16-bit sign extension)
	LDA #$00
	STA <Temp_Var2

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	; Set Bob-omb's X
	LDA #$08	 ; A = $08
	BCC PRG007_BCFC	 ; If this is a right-shot Bob-omb, jump to PRG007_BCFC
	LDA #-$08	 ; A = -$08
	DEC <Temp_Var2	 ; Temp_Var2 = $FF (16-bit sign extension)
PRG007_BCFC:
	ADD CannonFire_X,Y
	STA <Objects_X,X
	LDA CannonFire_XHi,Y
	ADC <Temp_Var2	
	STA <Objects_XHi,X


PRG007_BD09:
	; Set Cannon Ball / Bob-omb attributes
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index
	JMP CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke


Goomba_InitFlipBits:	.byte SPR_HFLIP, $00

CFire_GoombaPipe:
	LDA CannonFire_Timer,X
	BNE PRG007_BD7A	 ; If timer not expired, jump to PRG007_BD7A (RTS)

	TXA
	TAY	; Cannon Fire index -> 'Y' (this isn't really used)

	; Set timer to $70
	LDA #$70
	STA CannonFire_Timer,Y	; (only used here, then it goes back to 'X' anyway)

	INC CannonFire_Var,X	 ; CannonFire_Var++

	LDA CannonFire_Var,X
	AND #$03
	BEQ PRG007_BD7A	 ; 1:4 ticks proceed, otherwise jump to PRG007_BD7A (RTS)

	JSR PrepareNewObjectOrAbort	 ; Prepare me a Goomba!

	; Set Goomba X
	LDA CannonFire_X,Y
	STA <Objects_X,X
	LDA CannonFire_XHi,Y
	STA <Objects_XHi,X

	JSR Level_ObjCalcXDiffs
	STY <Temp_Var2		 ; Store directional flag -> Temp_Var2

	LDY <SlotIndexBackup	 ; Y = Cannon Fire index

	LDA CannonFire_ID,Y

	LDY #$00	 ; Y = 0 (right output Goomba pipe)

	CMP #CFIRE_GOOMBAPIPE_L
	BNE PRG007_BD49	 ; If this is not a left output Goomba pipe, jump to CFIRE_GOOMBAPIPE

	INY		 ; Y = 1 (left output Goomba pipe)

PRG007_BD49:
	CPY <Temp_Var2
	BNE PRG007_BD7B	 ; If Player is on the wrong side of the Goomba pipe, jump to PRG007_BD7B

	; Set Goomba's initial flip bits
	LDA Goomba_InitFlipBits,Y
	STA Objects_FlipBits,X

	LDY <SlotIndexBackup	 ; Y = Cannon Fire slot index

	; Set Goomba's Y
	LDA CannonFire_Y,Y
	SUB #$03
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; It's a Goomba
	LDA #OBJ_GOOMBA
	STA Level_ObjectID,X

	; Set Goomba's color
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	; Set Goomba's Var1 = $28
	LDA #$28
	STA Objects_Var1,X

	LDA #$ff
	STA Objects_SprHVis,X

PRG007_BD78:
	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index

PRG007_BD7A:
	RTS		 ; Return

PRG007_BD7B:

	; Player's on the wrong side of the goomba pipe; kill goomba! :(
	LDA #OBJSTATE_DEADEMPTY
	STA Objects_State,X

	BEQ PRG007_BD78	 ; Jump (technically always) to PRG007_BD78

PRG007_BD82:
	.byte $00, $08, $10, $18, $20, $28, $30, $38

FourWay_CannonballXVel:	.byte $00, $0B, $10, $0B, $00, -$0B, -$10, -$0B

	.byte $F0, $F0, $F5, $0B, $F5, $0B, $F5, $0B, $F5, $0B, $10, $10

FourWay_CannonballYVel:	.byte -$10, -$0B, $00, $0B, $10, $0B, $00, -$0B

	.byte $00, $00, $F5, $F5, $0B, $0B, $F5, $F5, $0B, $0B, $00, $00

CannonPoof_XOffs:

FourWay_CPXOff:	.byte $08, $18, $1C, $18, $08, $F8, $F4, $F8

Cannons_CPXOff:
	.byte -$0C	; CFIRE_ULCANNON
	.byte -$0C	; CFIRE_URCANNON
	.byte -$08	; CFIRE_LLCANNON
	.byte  $08	; CFIRE_LRCANNON
	.byte -$08	; CFIRE_HLCANNON2
	.byte  $08	; CFIRE_ULCANNON2
	.byte  $00	; CFIRE_URCANNON2
	.byte  $00	; CFIRE_LLCANNON2
	.byte  $00	; CFIRE_HRCANNON
	.byte  $00	; Not used?
	.byte  $0C	; CFIRE_LBOBOMBS
	.byte  $0C	; CFIRE_RBOBOMBS


Bill_CPXOff:	.byte $0C, -$0C		; Bullet/Missile Bill


CannonPoof_YOffs:

FourWay_CPYOff:	.byte $F3, $F7, $07, $17, $1B, $17, $07, $F7

Cannons_CPYOff:
	.byte  $00	; CFIRE_ULCANNON
	.byte  $08	; CFIRE_URCANNON
	.byte -$08	; CFIRE_LLCANNON
	.byte -$08	; CFIRE_LRCANNON
	.byte  $08	; CFIRE_HLCANNON2
	.byte  $08	; CFIRE_ULCANNON2
	.byte  $00	; CFIRE_URCANNON2
	.byte  $00	; CFIRE_LLCANNON2
	.byte  $00	; CFIRE_HRCANNON
	.byte  $00	; Not used?
	.byte  $00	; CFIRE_LBOBOMBS
	.byte  $00	; CFIRE_RBOBOMBS

Bill_CPYOff:	.byte $00, $00		; Bullet/Missile Bill


CFire_4Way:

	; Load graphics for 4-Way cannon
	LDA #$36
	STA PatTable_BankSel+4

	LDA CannonFire_Timer2,X
	BNE PRG007_BE1C	 ; If timer2 has not expired, jump to PRG007_BE1C (RTS)

	; Reset timer2 = $3D
	LDA #$3d
	STA CannonFire_Timer2,X

	LDA CannonFire_Y,X
	CMP Level_VertScroll
	LDA CannonFire_YHi,X
	SBC Level_VertScrollH
	BNE PRG007_BE42	 ; If the 4-Way cannon is vertically off-screen, jump to PRG007_BE42 (RTS)

	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BE42	 ; If the 4-Way cannon is horizontally off-screen, jump to PRG007_BE42 (RTS)

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	ADD #32
	CMP #40
	BLT PRG007_BE42	 ; If the 4-Way cannon is too far left off-screen, jump to PRG007_BE42 (RTS)

	; Reset cannon timer to $20
	LDA #$20
	STA CannonFire_Timer,X

	INC CannonFire_Var,X	 ; CannonFire_Var++

PRG007_BE1C:
	LDA CannonFire_Timer,X
	BEQ PRG007_BE42	 ; If timer expired, jump to PRG007_BE42 (RTS)

	CMP #$1d
	BNE PRG007_BE43	 ; If timer <> $1D, jump to PRG007_BE43

	LDA #CHNGTILE_4WAYCANNON
	STA Level_ChgTileEvent

	; Set coordinates of change
	LDA CannonFire_Y,X
	STA Level_BlockChgYLo

	LDA CannonFire_YHi,X
	STA Level_BlockChgYHi

	LDA CannonFire_X,X
	STA Level_BlockChgXLo

	LDA CannonFire_XHi,X
	STA Level_BlockChgXHi

PRG007_BE42:
	RTS		 ; Return

PRG007_BE43:
	CMP #$01
	BNE PRG007_BEAA	 ; If timer <> 1, jump to PRG007_BEAA

	LDA CannonFire_Var,X
	AND #$07
	STA <Temp_Var1	; Temp_Var1 = 0 to 7

	JSR FireCannonBall	 ; Fire cannon ball
 
	LDA CannonFire_Var,X
	ADD #$04
	AND #$07	 ; +4 wrap around (fire the cannonball on the opposite side)

PRG007_BE59:
	STA <Temp_Var1
	JMP FireCannonBall	 ; Fire the cannonball!

FireCannonBall:
	LDY #$05	 ; Y = 5

PRG007_BE60:
	LDA SpecialObj_ID,Y
	BEQ PRG007_BE69	 ; If this special object slot is free, jump to PRG007_BE69

	DEY		 ; Y--
	BPL PRG007_BE60	 ; While Y >= 0, loop!

	RTS		 ; Return

PRG007_BE69:

	; Set this as a cannon ball!
	LDA #SOBJ_CANNONBALL
	STA SpecialObj_ID,Y

	; Set cannonball X
	LDA CannonFire_X,X
	CLC
	LDX <Temp_Var1		; X = 0 to 7
	ADC CannonPoof_XOffs,X
	STA SpecialObj_XLo,Y

	; Set cannonball Y velocity
	LDA FourWay_CannonballYVel,X
	STA SpecialObj_YVel,Y

	; Set cannonball X velocity
	LDA FourWay_CannonballXVel,X
	STA SpecialObj_XVel,Y

	; Temp_Var3 = 0 (16-bit sign extension)
	LDA #$00
	STA <Temp_Var3

	LDA CannonPoof_YOffs,X
	BPL PRG007_BE91	 ; If Y offset is not negative, jump to PRG007_BE91

	DEC <Temp_Var3	 ; Temp_Var3 = $FF (16-bit sign extension)

PRG007_BE91:
	CLC
	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index
	ADC CannonFire_Y,X
	STA SpecialObj_YLo,Y
	LDA CannonFire_YHi,X
	ADC <Temp_Var3		; 16-bit sign extension
	STA SpecialObj_YHi,Y	

	; Data = 0
	LDA #$00
	STA SpecialObj_Data,Y

	JMP CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke

PRG007_BEAA:
	RTS		 ; Return

	; Produces the smoke resulting from cannon fire; specify X/Y offset
	; from Cannon Fire's position by Temp_Var1 which indexes CannonPoof_X/YOffs
CannonFire_NoiseAndSmoke:
	; Cannon firing noise
	LDA Sound_QLevel1
	ORA #SND_LEVELBABOOM
	STA Sound_QLevel1

	JSR BrickBust_MoveOver	 ; Make room in first "brick bust" slot for poof

	; Brick bust, poof style
	LDA #$01
	STA BrickBust_En

	; Set poof X
	LDA CannonFire_X,X	; Get Cannon Fire X
	CLC
	LDX <Temp_Var1		; X = Temp_Var1 holds the index into CannonPoof_XOffs
	ADC CannonPoof_XOffs,X	; + CannonPoof_XOffs[Temp_Var1]
	SUB <Horz_Scroll	; Make relative to horizontal scroll
	STA BrickBust_X		; Set X

	LDA CannonPoof_YOffs,X	 ; A = CannonPoof_YOffs[Temp_Var1]

	LDX <SlotIndexBackup	 ; X = Cannon Fire slot index

	ADD CannonFire_Y,X	 ; + Cannon Fire Y
	SUB Level_VertScroll	 ; Make relative to vertical scroll
	STA BrickBust_YUpr	 ; Set Y

	; Set poof counter
	LDA #$1f
	STA BrickBust_HEn

	RTS		 ; Return


Rocky_InitAttr:	.byte SPR_HFLIP | SPR_BEHINDBG, SPR_BEHINDBG

CFire_RockyWrench:
	LDA CannonFire_Timer,X
	BNE PRG007_BF28	 ; If timer not expired, jump to PRG007_BF28 (RTS)

	; Reset cannon timer to $C0
	LDA #$c0
	STA CannonFire_Timer,X

	JSR PrepareNewObjectOrAbort	; Get me a slot for Rocky Wrench or don't come back!

	LDY <SlotIndexBackup	; Y = Cannon Fire slot index

	; This is a Rocky Wrench
	LDA #OBJ_ROCKYWRENCH
	STA Level_ObjectID,X

	; Start at Cannon Fire Y - 6
	LDA CannonFire_Y,Y
	SUB #$06
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; Set Rocky's X to Cannon Fire's X
	LDA CannonFire_XHi,Y
	STA <Objects_XHi,X
	LDA CannonFire_X,Y
	STA <Objects_X,X

	; Var5 = 0
	LDA #$00
	STA <Objects_Var5,X

	; Set Rocky's timer to $28
	LDA #$28
	STA Objects_Timer,X

	; Set Rocky's attributes
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	; Set Rocky's initial attributes towards Player
	JSR Level_ObjCalcXDiffs
	LDA Rocky_InitAttr,Y
	STA Objects_FlipBits,X

	LDX <SlotIndexBackup	; X = Cannon Fire slot index

PRG007_BF28:
	RTS		 ; Return

Bill_XVelTowardsPlayer:	.byte $18, -$18
Bill_FlipTowardsPlayer:	.byte SPR_HFLIP, $00
Bill_Var4TowardsPlayer:	.byte $01, $00
	
CFire_BulletBill:
	LDA CannonFire_Timer,X
	BNE PRG007_BF28	 ; If timer not expired, jump to PRG007_BF28 (RTS)

	LDA CannonFire_Y,X
	CMP Level_VertScroll
	LDA CannonFire_YHi,X
	SBC Level_VertScrollH
	BNE PRG007_BF28		; If Cannon Fire has fallen off screen vertically, jump to PRG007_BF28 (RTS)

	LDA CannonFire_X,X
	CMP <Horz_Scroll
	LDA CannonFire_XHi,X
	SBC <Horz_Scroll_Hi
	BNE PRG007_BF28		; If Cannon Fire has fallen off screen horizontally, jump to PRG007_BF28 (RTS)

	; Reset Cannon Fire timer to $80-$9F, random
	LDA RandomN,X
	AND #$1f
	ORA #$80
	STA CannonFire_Timer,X

	LDA CannonFire_X,X
	SUB <Horz_Scroll
	ADD #16
	CMP #32
	BLT PRG007_BF28		; If Cannon Fire X + 16 is less than 32 pixels from screen edge, jump to PRG007_BF28 (RTS)

	LDA <Player_X
	SBC CannonFire_X,X
	ADD #17
	CMP #34
	BLT PRG007_BF28		; If Player is standing on Bullet Bill cannon, jump to PRG007_BF28 (RTS)

	JSR PrepareNewObjectOrAbort

	LDY <SlotIndexBackup	 ; Y = Cannon Fire object slot

	LDA CannonFire_ID,Y
	LSR A		; Selects which Bill type

	LDA #OBJ_BULLETBILL

	BCS PRG007_BF80	 ; If carry set, jump to PRG007_BF80

	LDA #OBJ_BULLETBILLHOMING

PRG007_BF80:
	STA Level_ObjectID,X	 ; Store Bill's ID

	; Set Bill's palette
	LDA #SPR_PAL3
	STA Objects_SprAttr,X

	; Set Bill's Y
	LDA CannonFire_Y,Y
	SUB #$01
	STA <Objects_Y,X
	LDA CannonFire_YHi,Y
	SBC #$00
	STA <Objects_YHi,X

	; Set Bill's X
	LDA CannonFire_XHi,Y
	STA <Objects_XHi,X
	LDA CannonFire_X,Y
	STA <Objects_X,X
	STA Objects_Var13,X	; original X hold

	; Bill's timer = $0C
	LDA #$0c
	STA Objects_Timer,X

	; Bill's Var3 = $20
	LDA #$20
	STA Objects_Var3,X

	JSR Level_ObjCalcXDiffs

	; Bill fires towards Player
	LDA Bill_XVelTowardsPlayer,Y
	STA <Objects_XVel,X

	; Bill faces Player
	LDA Bill_FlipTowardsPlayer,Y
	STA Objects_FlipBits,X

	; Set Bill's direction flag
	LDA Bill_Var4TowardsPlayer,Y
	STA <Objects_Var4,X

	LDX <SlotIndexBackup	; X = Cannon Fire slot index

	TYA		; 0 or 1
	ADD #(Bill_CPXOff - CannonPoof_XOffs)
	STA <Temp_Var1	; -> Temp_Var1

	JSR CannonFire_NoiseAndSmoke	 ; Play cannon fire noise and make smoke

	RTS		 ; Return


	; Provides a newly prepared object or does not return to caller!
PrepareNewObjectOrAbort:
	LDX #$04	  ; X = 4
PRG007_BFCF:
	LDA Objects_State,X
	BEQ PRG007_BFDC	 ; If this object state = 0 (Dead/Empty), jump to PRG007_BFDC

	DEX		 ; X--
	BPL PRG007_BFCF	 ; While X >= 0, loop!

	; No object slots available; do not return to caller!!
	PLA
	PLA

	LDX <SlotIndexBackup	 ; Restore 'X' to its slot index value

	RTS		 ; Return

PRG007_BFDC:
	JSR Level_PrepareNewObject	 ; Prepare this new object

	; Set to normal state
	LDA #OBJSTATE_NORMAL
	STA Objects_State,X

	RTS		 ; Return

; Rest of ROM bank was empty

