; Super Mario Bros. 3 Full Disassembly by Southbird 2012
; For more info, see http://www.sonicepoch.com/sm3mix/
;
; PLEASE INCLUDE A CREDIT TO THE SOUTHBIRD DISASSEMBLY
; AND THE ABOVE LINK SOMEWHERE IN YOUR WORKS :)
;
; Original disassembler source generated by DCC6502 version v1.4
; (With labels, comments, and some syntax corrections for nesasm by Southbird)
; For more info about DCC6502, e-mail veilleux@ameth.org
;
; This source file last updated: 2012-03-06 18:57:13.927921102 -0600
; Distribution package date: Fri Apr  6 23:46:16 UTC 2012
;---------------------------------------------------------------------------
M2BSegData14:
	.byte $98, $56, $56, $90, $54, $56, $94, $7E, $98, $56, $5A, $5A, $90, $58, $5A, $94 ; $C000 - $C00F
	.byte $7E, $98, $5A, $00, $98, $5C, $5C, $90, $5A, $5C, $94, $7E, $98, $5C, $60, $60 ; $C010 - $C01F
	.byte $90, $5E, $60, $94, $7E, $98, $60, $94, $4E, $5C, $66, $5C, $4E, $5C, $66, $5C ; $C020 - $C02F
	.byte $52, $60, $6A, $60, $52, $60, $6A, $60

M2BSegData15:
	.byte $98, $5C, $5C, $90, $5A, $5C, $94, $7E ; $C030 - $C03F
	.byte $98, $5C, $60, $60, $90, $5E, $60, $94, $7E, $98, $60, $00, $98, $62, $62, $90 ; $C040 - $C04F
	.byte $60, $62, $94, $7E, $98, $62, $66, $66, $90, $64, $66, $94, $7E, $98, $66, $94 ; $C050 - $C05F
	.byte $54, $62, $6C, $62, $54, $62, $6C, $62, $58, $66, $70, $66, $58, $66, $70, $66 ; $C060 - $C06F
	.byte $98, $05, $00

M2BSegData1A:
	.byte $DC, $7E, $7E, $7E, $7E, $D4, $18, $30, $12, $2A, $14, $2C, $D8 ; $C070 - $C07F
	.byte $7E, $DC, $7E, $D4, $18, $30, $12, $2A, $14, $2C, $D8, $7E, $DC, $7E, $D4, $0A ; $C080 - $C08F
	.byte $22, $04, $1C, $06, $1E, $D8, $7E, $DC, $7E, $D4, $0A, $22, $04, $1C, $06, $1E ; $C090 - $C09F
	.byte $DC, $7E, $D2, $1E, $1C, $1A, $D8, $18, $1E, $1C, $10, $0E, $1A, $D2, $18, $24 ; $C0A0 - $C0AF
	.byte $22, $20, $2C, $2A, $D6, $28, $1E, $16, $14, $12, $10, $DC, $7E, $00, $8C, $7E ; $C0B0 - $C0BF
	.byte $7E, $7E, $7E, $84, $30, $48, $2A, $42, $2C, $44, $88, $7E, $8C, $7E, $84, $30 ; $C0C0 - $C0CF
	.byte $48, $2A, $42, $2C, $44, $88, $7E, $8C, $7E, $84, $22, $3A, $1C, $34, $1E, $36 ; $C0D0 - $C0DF
	.byte $88, $7E, $8C, $7E, $84, $22, $3A, $1C, $34, $1E, $36, $8C, $7E, $82, $36, $34 ; $C0E0 - $C0EF
	.byte $32, $88, $30, $36, $34, $28, $26, $32, $82, $30, $3C, $3A, $38, $44, $42, $86 ; $C0F0 - $C0FF
	.byte $40, $36, $2E, $2C, $2A, $28, $8C, $7E, $8A, $01, $02, $84, $01, $01, $88, $01 ; $C100 - $C10F
	.byte $8A, $02, $8A, $01, $89, $02, $88, $01, $01, $84, $01, $88, $02, $84, $02, $02 ; $C110 - $C11F
	.byte $00, $84, $02, $00

M2BSegData09:
	.byte $9C, $7E, $7E, $BC, $30, $48, $46, $7E, $30, $48, $46, $7E ; $C120 - $C12F
	.byte $00, $9C, $7E, $7E, $BC, $22, $3A, $38, $7E, $22, $3A, $38, $7E, $8C, $7E, $7E ; $C130 - $C13F
	.byte $BC, $30, $48, $46, $7E, $30, $48, $46, $7E, $8C, $7E, $7E, $00, $88, $0F, $86 ; $C140 - $C14F
	.byte $0F, $82, $0F, $82, $0F, $0F, $0F, $88, $0F, $88, $0F, $82, $0F, $0F, $0F, $84 ; $C150 - $C15F
	.byte $0F, $0F, $82, $0F, $0F, $0F, $00

M2BSegData0A:
	.byte $E8, $32, $32, $E4, $32, $32, $E2, $32, $38 ; $C160 - $C16F
	.byte $38, $E8, $32, $32, $E4, $32, $32, $E2, $32, $38, $38, $E8, $3E, $3E, $E4, $3E ; $C170 - $C17F
	.byte $3E, $E2, $3E, $44, $44, $E8, $3E, $3E, $E4, $3E, $3E, $E2, $3E, $44, $44, $00 ; $C180 - $C18F
	.byte $E8, $36, $36, $E4, $36, $36, $E2, $36, $3C, $3C, $E8, $36, $36, $E4, $36, $36 ; $C190 - $C19F
	.byte $E2, $36, $3C, $3C, $E8, $42, $42, $E4, $42, $42, $E2, $42, $48, $48, $E8, $42 ; $C1A0 - $C1AF
	.byte $42, $E4, $42, $42, $E2, $42, $48, $48, $E4, $58, $7E, $58, $7E, $58, $58, $E2 ; $C1B0 - $C1BF
	.byte $58, $5E, $5E, $E4, $58, $7E, $58, $7E, $58, $58, $E2, $58, $5E, $5E, $E4, $64 ; $C1C0 - $C1CF
	.byte $7E, $64, $7E, $64, $64, $E2, $64, $6A, $6A, $E4, $64, $7E, $64, $7E, $64, $64 ; $C1D0 - $C1DF
	.byte $E2, $64, $6A, $6A, $E8, $02, $02, $E4, $02, $02, $E2, $02, $02, $02, $00, $E8 ; $C1E0 - $C1EF
	.byte $0F, $0F, $E4, $0F, $0F, $E2, $0F, $0F, $0F, $E8, $0F, $0F, $E4, $0F, $0F, $E2 ; $C1F0 - $C1FF
	.byte $0F, $0F, $0F, $E8, $0E, $0E, $E4, $0E, $0E, $E2, $0E, $0E, $0E, $E8, $0E, $0E ; $C200 - $C20F
	.byte $E4, $0E, $0E, $E2, $0E, $0E, $0E, $00

M2BSegData07:
	.byte $B4, $18, $2E, $BB, $2C, $E0, $7E, $2A ; $C210 - $C21F
	.byte $28, $26, $E4, $24, $14, $EB, $7E, $00, $B4, $14, $2A, $BB, $28, $E0, $7E, $26 ; $C220 - $C22F
	.byte $24, $22, $E4, $20, $10, $EB, $7E, $E4, $3A, $50, $EB, $4E, $E0, $7E, $4C, $4A ; $C230 - $C23F
	.byte $48, $E4, $46, $36, $EB, $7E, $EC, $7E, $EA, $7E, $E4, $0E, $EC, $0F, $E4, $7E ; $C240 - $C24F
	.byte $00

M2BSegData08:
	.byte $BA, $7E, $BB, $26, $2E, $20, $2A, $EA, $7E, $00, $B8, $7E, $BB, $28, $18 ; $C250 - $C25F
	.byte $1A, $10, $B8, $7E, $EA, $7E, $BB, $34, $46, $2C, $3A, $BA, $7E, $EA, $7E, $BB ; $C260 - $C26F
	.byte $7E, $7E, $7E, $7E, $E4, $0E, $EC, $0F, $EA, $7E

M12ASegData1B:
	.byte $D2, $56, $54, $56, $DA, $50 ; $C270 - $C27F
	.byte $D8, $52, $54, $DA, $56, $D8, $60, $D6, $68, $D2, $68, $D8, $64, $68, $6A, $5E ; $C280 - $C28F
	.byte $DA, $64, $D8, $60, $00, $D8, $2E, $30, $7E, $34, $36, $38, $30, $42, $3E, $3A ; $C290 - $C29F
	.byte $38, $34, $3A, $3E, $26, $30

M12ASegData1C:
	.byte $D6, $68, $D2, $68, $DA, $68, $D9, $5E, $D4, $64 ; $C2A0 - $C2AF
	.byte $D8, $64, $D2, $7E, $60, $5E, $D8, $60, $D6, $6A, $D2, $6A, $DA, $6A, $D9, $60 ; $C2B0 - $C2BF
	.byte $D4, $64, $DA, $68, $D8, $64, $00, $D8, $2E, $38, $3C, $40, $46, $42, $40, $42 ; $C2C0 - $C2CF
	.byte $3E, $3A, $3E, $40, $3A, $3E, $26, $3A

M12ASegData1D:
	.byte $A4, $3E, $7E, $94, $56, $98, $52, $94 ; $C2D0 - $C2DF
	.byte $4C, $46, $42, $3E, $7E, $3E, $7E, $AA, $7E, $00, $A4, $2E, $7E, $94, $46, $98 ; $C2E0 - $C2EF
	.byte $42, $94, $3A, $34, $30, $2E, $7E, $2E, $7E, $AA, $7E, $A4, $3E, $7E, $56, $98 ; $C2F0 - $C2FF
	.byte $52, $94, $4C, $46, $42, $3E, $7E, $3E, $7E, $AA, $7E, $94, $02, $90, $02, $02 ; $C300 - $C30F
	.byte $94, $02, $02, $02, $02, $02, $02, $00, $A4, $06, $A0, $05, $05, $A4, $05, $05 ; $C310 - $C31F
	.byte $7E, $05, $05, $05, $06, $7E, $06, $8D, $7E, $7E, $08, $88, $08, $8D, $09, $09 ; $C320 - $C32F
	.byte $09, $94, $08

M12ASegData1E:
	.byte $98, $7E, $94, $50, $52, $50, $4C, $48, $46, $98, $4C, $94, $4C ; $C330 - $C33F
	.byte $9A, $42, $94, $7E, $98, $7E, $94, $46, $48, $46, $42, $3E, $3A, $98, $38, $94 ; $C340 - $C34F
	.byte $38, $9A, $3E, $94, $7E, $00, $98, $7E, $94, $48, $4C, $48, $46, $42, $3E, $98 ; $C350 - $C35F
	.byte $42, $94, $42, $9A, $3A, $94, $7E, $98, $7E, $94, $3E, $42, $3E, $3A, $38, $34 ; $C360 - $C36F
	.byte $98, $30, $94, $30, $9A, $38, $94, $7E, $99, $30, $98, $38, $94, $38, $98, $3E ; $C370 - $C37F
	.byte $99, $3A, $98, $42, $94, $42, $98, $48, $99, $3E, $98, $46, $94, $46, $98, $4C ; $C380 - $C38F
	.byte $99, $30, $98, $38, $94, $38, $98, $3E, $94, $02, $90, $02, $02, $94, $02, $02 ; $C390 - $C39F
	.byte $02, $02, $02, $02, $00, $A4, $01, $A0, $05, $05, $A4, $05, $01, $01, $06, $07 ; $C3A0 - $C3AF
	.byte $01, $00

M12ASegData1F:
	.byte $98, $7E, $94, $3A, $3E, $40, $48, $44, $40, $99, $3E, $9A, $38, $94 ; $C3B0 - $C3BF
	.byte $7E, $00, $98, $7E, $94, $30, $34, $52, $58, $56, $52, $99, $50, $9A, $48, $94 ; $C3C0 - $C3CF
	.byte $7E, $98, $3A, $94, $3A, $98, $40, $94, $40, $98, $48, $30, $94, $30, $98, $38 ; $C3D0 - $C3DF
	.byte $94, $38, $98, $3E, $94, $02, $90, $02, $02, $94, $02, $02, $02, $02, $02, $02 ; $C3E0 - $C3EF
	.byte $00, $A4, $01, $A0, $05, $05, $A4, $05, $01, $01, $06, $07, $01, $00

M12ASegData20:
	.byte $98, $7E ; $C3F0 - $C3FF
	.byte $94, $3A, $3E, $40, $48, $44, $40, $99, $3E, $9A, $48, $94, $7E, $98, $7E, $94 ; $C400 - $C40F
	.byte $42, $40, $42, $46, $48, $42, $9B, $4C, $C8, $3E, $00, $98, $7E, $94, $30, $34 ; $C410 - $C41F
	.byte $52, $58, $56, $52, $99, $50, $9A, $56, $94, $7E, $98, $7E, $94, $3A, $38, $3A ; $C420 - $C42F
	.byte $3E, $42, $3A, $9C, $46, $C8, $2E, $98, $3A, $94, $3A, $98, $40, $94, $40, $98 ; $C430 - $C43F
	.byte $48, $38, $94, $38, $98, $3E, $94, $3E, $98, $48, $36, $94, $36, $98, $3E, $94 ; $C440 - $C44F
	.byte $3E, $98, $48, $34, $94, $34, $98, $3E, $94, $3E, $98, $3E, $94, $02, $90, $02 ; $C450 - $C45F
	.byte $02, $94, $02, $02, $02, $02, $02, $02, $00, $A4, $01, $A0, $05, $05, $A4, $05 ; $C460 - $C46F
	.byte $01, $01, $06, $07, $01, $00

M12ASegData21:
	.byte $CA, $50, $C4, $7E, $4C, $50, $52, $CB, $56, $C8 ; $C470 - $C47F
	.byte $5A, $CA, $56, $C4, $7E, $52, $50, $52, $CB, $48, $C8, $56, $CA, $52, $C4, $7E ; $C480 - $C48F
	.byte $50, $4C, $50, $CA, $48, $C6, $46, $48, $50, $00, $C4, $30, $90, $56, $50, $94 ; $C490 - $C49F
	.byte $48, $3E, $C4, $7E, $46, $30, $34, $C4, $34, $90, $52, $4C, $94, $46, $3E, $C8 ; $C4A0 - $C4AF
	.byte $7E, $3A, $C4, $38, $90, $52, $4C, $94, $44, $3E, $C4, $7E, $34, $30, $34, $C4 ; $C4B0 - $C4BF
	.byte $42, $90, $52, $48, $94, $42, $3A, $C8, $7E, $34, $C4, $30, $90, $52, $48, $94 ; $C4C0 - $C4CF
	.byte $40, $3A, $C4, $7E, $30, $2E, $30, $C4, $3E, $90, $50, $48, $94, $3E, $38, $C6 ; $C4D0 - $C4DF
	.byte $26, $2A, $30, $C8, $48, $C4, $3E, $C8, $48, $C4, $3E, $C8, $48, $46, $C4, $3E ; $C4E0 - $C4EF
	.byte $C8, $46, $C4, $3E, $C8, $46, $44, $C4, $3E, $C8, $44, $C4, $3E, $C8, $44, $42 ; $C4F0 - $C4FF
	.byte $C4, $3A, $C8, $42, $C4, $3A, $C8, $42, $40, $C4, $3A, $C8, $40, $C4, $3A, $C8 ; $C500 - $C50F
	.byte $40, $3E, $C4, $38, $C8, $3E, $C4, $38, $C8, $3E, $C4, $02, $C0, $02, $02, $C4 ; $C510 - $C51F
	.byte $02, $02, $02, $02, $02, $02, $00, $A4, $01, $A0, $06, $06, $A4, $06, $07, $01 ; $C520 - $C52F
	.byte $06, $07, $06, $00

M12ASegData22:
	.byte $CA, $4C, $C4, $7E, $48, $46, $48, $CB, $4C, $C8, $3E, $00 ; $C530 - $C53F
	.byte $C4, $2A, $90, $54, $48, $94, $42, $3C, $C4, $7E, $2A, $28, $2A, $C4, $2E, $90 ; $C540 - $C54F
	.byte $52, $4C, $94, $46, $3E, $C8, $7E, $3E, $C8, $3C, $C4, $34, $C8, $3C, $C4, $34 ; $C550 - $C55F
	.byte $C8, $3C, $3E, $C4, $34, $C8, $3E, $C4, $34, $C8, $3E, $C4, $02, $C0, $02, $02 ; $C560 - $C56F
	.byte $C4, $02, $02, $02, $02, $02, $02, $00, $A4, $01, $A0, $06, $06, $A4, $06, $07 ; $C570 - $C57F
	.byte $01, $06, $07, $06, $00

M12ASegData23:
	.byte $CA, $4C, $C4, $7E, $48, $46, $48, $94, $56, $7E, $56 ; $C580 - $C58F
	.byte $7E, $AA, $7E, $00, $C4, $2A, $90, $54, $48, $94, $42, $3C, $C4, $7E, $2A, $28 ; $C590 - $C59F
	.byte $2A, $94, $2E, $7E, $2E, $7E, $AA, $7E, $C8, $3C, $C4, $34, $C8, $3C, $C4, $34 ; $C5A0 - $C5AF
	.byte $C8, $3C, $3E, $C4, $34, $C8, $3E, $C4, $34, $C8, $3E, $94, $3E, $7E, $3E, $7E ; $C5B0 - $C5BF
	.byte $AA, $7E, $C4, $02, $C0, $02, $02, $C4, $02, $02, $02, $02, $02, $02, $00, $A4 ; $C5C0 - $C5CF
	.byte $06, $A0, $06, $06, $A4, $06, $07, $01, $06, $07, $07, $06, $7E, $06, $8D, $7E ; $C5D0 - $C5DF
	.byte $7E, $08, $88, $08, $8D, $09, $09, $09, $94, $08


	;; BEGIN HUGE UNUSED SPACE

	.byte $FF, $FF, $FF, $FF, $FF, $FF ; $C5E0 - $C5EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C5F0 - $C5FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C600 - $C60F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C610 - $C61F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C620 - $C62F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C630 - $C63F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C640 - $C64F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C650 - $C65F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C660 - $C66F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C670 - $C67F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C680 - $C68F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C690 - $C69F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C6A0 - $C6AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C6B0 - $C6BF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C6C0 - $C6CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C6D0 - $C6DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C6E0 - $C6EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C6F0 - $C6FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C700 - $C70F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C710 - $C71F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C720 - $C72F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C730 - $C73F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C740 - $C74F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C750 - $C75F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C760 - $C76F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C770 - $C77F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C780 - $C78F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C790 - $C79F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C7A0 - $C7AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C7B0 - $C7BF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C7C0 - $C7CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C7D0 - $C7DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C7E0 - $C7EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C7F0 - $C7FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C800 - $C80F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C810 - $C81F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C820 - $C82F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C830 - $C83F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C840 - $C84F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C850 - $C85F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C860 - $C86F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C870 - $C87F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C880 - $C88F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C890 - $C89F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C8A0 - $C8AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C8B0 - $C8BF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C8C0 - $C8CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C8D0 - $C8DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C8E0 - $C8EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C8F0 - $C8FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C900 - $C90F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C910 - $C91F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C920 - $C92F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C930 - $C93F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C940 - $C94F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C950 - $C95F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C960 - $C96F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C970 - $C97F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C980 - $C98F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C990 - $C99F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C9A0 - $C9AF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C9B0 - $C9BF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C9C0 - $C9CF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C9D0 - $C9DF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C9E0 - $C9EF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $C9F0 - $C9FF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA00 - $CA0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA10 - $CA1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA20 - $CA2F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA30 - $CA3F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA40 - $CA4F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA50 - $CA5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA60 - $CA6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA70 - $CA7F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA80 - $CA8F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CA90 - $CA9F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CAA0 - $CAAF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CAB0 - $CABF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CAC0 - $CACF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CAD0 - $CADF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CAE0 - $CAEF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CAF0 - $CAFF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB00 - $CB0F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB10 - $CB1F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB20 - $CB2F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB30 - $CB3F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB40 - $CB4F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB50 - $CB5F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB60 - $CB6F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB70 - $CB7F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB80 - $CB8F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CB90 - $CB9F
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CBA0 - $CBAF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CBB0 - $CBBF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CBC0 - $CBCF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CBD0 - $CBDF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CBE0 - $CBEF
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $CBF0 - $CBFF

	;; END HUGE UNUSED SPACE


	; This defines a table of offsets that point to the start of
	; each Player_Frame's six patterns
	
	; Nintendo did a minor trick here to keep the offset down to one byte...
	; - They have 81 frames total, with 6 patterns each
	; - Dividing by 2 (to be fixed later) means the offset into the pattern lookup table is reduced to 3
	; - 3 * 81 = 243, which fits the 1 byte offset
	; But, for some reason, everything is off by 4?  The SPPF function below compensates for this, and 
	; PRG029_CF1E loads from 4 bytes shy of the proper address.  Maybe this was a mistake?  
SPPF .func ((\1 - SPPF_Table + 4) / 2)	; The offsets 
SPPF_Offsets:
	.byte SPPF(PF00), SPPF(PF01), SPPF(PF02), SPPF(PF03), SPPF(PF04), SPPF(PF05), SPPF(PF06), SPPF(PF07)
	.byte SPPF(PF08), SPPF(PF09), SPPF(PF0A), SPPF(PF0B), SPPF(PF0C), SPPF(PF0D), SPPF(PF0E), SPPF(PF0F)
	.byte SPPF(PF10), SPPF(PF11), SPPF(PF12), SPPF(PF13), SPPF(PF14), SPPF(PF15), SPPF(PF16), SPPF(PF17)
	.byte SPPF(PF18), SPPF(PF19), SPPF(PF1A), SPPF(PF1B), SPPF(PF1C), SPPF(PF1D), SPPF(PF1E), SPPF(PF1F)
	.byte SPPF(PF20), SPPF(PF21), SPPF(PF22), SPPF(PF23), SPPF(PF24), SPPF(PF25), SPPF(PF26), SPPF(PF27)
	.byte SPPF(PF28), SPPF(PF29), SPPF(PF2A), SPPF(PF2B), SPPF(PF2C), SPPF(PF2D), SPPF(PF2E), SPPF(PF2F)
	.byte SPPF(PF30), SPPF(PF31), SPPF(PF32), SPPF(PF33), SPPF(PF34), SPPF(PF35), SPPF(PF36), SPPF(PF37)
	.byte SPPF(PF38), SPPF(PF39), SPPF(PF3A), SPPF(PF3B), SPPF(PF3C), SPPF(PF3D), SPPF(PF3E), SPPF(PF3F)
	.byte SPPF(PF40), SPPF(PF41), SPPF(PF42), SPPF(PF43), SPPF(PF44), SPPF(PF45), SPPF(PF46), SPPF(PF47)
	.byte SPPF(PF48), SPPF(PF49), SPPF(PF4A), SPPF(PF4B), SPPF(PF4C), SPPF(PF4D), SPPF(PF4E), SPPF(PF4F)
	.byte SPPF(PF50)

	; The six Patterns per Player_Frame to start each of the six Player sprites with!
	; Note the order is the three patterns for the three sprites that make the upper 
	; half followed by the next three for the lower half.
	; $F1 is a magic value reserved as a "don't display this sprite" flag

SPPF_Table:
PF00:	.byte $01, $03, $F1, $05, $07, $09
PF01:	.byte $0B, $0D, $F1, $0F, $29, $2B
PF02:	.byte $2D, $2F, $F1, $19, $1B, $1D
PF03:	.byte $2D, $2F, $F1, $19, $1B, $09
PF04:	.byte $21, $21, $F1, $23, $23, $F1
PF05:	.byte $25, $25, $F1, $27, $27, $F1
PF06:	.byte $01, $03, $F1, $05, $07, $F1
PF07:	.byte $31, $33, $F1, $35, $37, $39
PF08:	.byte $01, $03, $F1, $05, $07, $39
PF09:	.byte $01, $03, $F1, $05, $07, $09
PF0A:	.byte $01, $03, $F1, $05, $07, $3B
PF0B:	.byte $F1, $F1, $F1, $3D, $3F, $F1
PF0C:	.byte $01, $03, $F1, $05, $07, $F1
PF0D:	.byte $0B, $0D, $F1, $0F, $29, $F1
PF0E:	.byte $2D, $2F, $F1, $19, $1B, $F1
PF0F:	.byte $31, $33, $F1, $35, $37, $F1
PF10:	.byte $09, $2F, $F1, $1D, $1F, $F1
PF11:	.byte $2D, $2F, $F1, $39, $3B, $F1
PF12:	.byte $31, $31, $F1, $33, $33, $F1
PF13:	.byte $35, $35, $F1, $37, $37, $F1
PF14:	.byte $39, $39, $F1, $3B, $3B, $F1
PF15:	.byte $01, $03, $F1, $05, $07, $09
PF16:	.byte $0B, $0D, $F1, $0F, $29, $2B
PF17:	.byte $2D, $2F, $F1, $19, $1B, $1D
PF18:	.byte $2D, $2F, $F1, $A9, $AB, $F1
PF19:	.byte $2D, $2F, $F1, $A9, $AD, $F1
PF1A	.byte $01, $03, $05, $07, $09, $0B
PF1B:	.byte $0D, $0F, $39, $3B, $3D, $3F
PF1C:	.byte $19, $1B, $1D, $1F, $21, $23
PF1D:	.byte $25, $27, $29, $2B, $2D, $2F
PF1E:	.byte $31, $33, $F1, $35, $37, $F1
PF1F:	.byte $25, $29, $2D, $33, $37, $0D
PF20:	.byte $25, $29, $2D, $33, $37, $0F
PF21:	.byte $19, $1D, $21, $1B, $1F, $23
PF22:	.byte $25, $29, $2D, $27, $2B, $2F
PF23:	.byte $25, $29, $2D, $33, $37, $3B
PF24:	.byte $01, $01, $F1, $03, $03, $F1
PF25:	.byte $05, $05, $F1, $07, $07, $F1
PF26:	.byte $09, $09, $F1, $0B, $0B, $F1
PF27:	.byte $31, $33, $F1, $35, $37, $F1
PF28:	.byte $31, $35, $F1, $39, $3D, $F1
PF29:	.byte $01, $03, $F1, $05, $07, $09

	; Second page begins here
PF2A:	.byte $01, $03, $F1, $0B, $0D, $0F
PF2B:	.byte $01, $03, $F1, $21, $23, $25
PF2C:	.byte $31, $33, $F1, $35, $37, $F1
PF2D:	.byte $27, $19, $F1, $1D, $1F, $F1
PF2E:	.byte $F1, $F1, $F1, $35, $37, $F1
PF2F:	.byte $F1, $F1, $F1, $31, $33, $F1
PF30:	.byte $29, $2B, $F1, $2D, $2F, $F1
PF31:	.byte $39, $3B, $F1, $3D, $3F, $F1
PF32:	.byte $F1, $F1, $F1, $2F, $2F, $F1
PF33:	.byte $F1, $F1, $F1, $2B, $2D, $F1
PF34:	.byte $29, $2B, $F1, $0D, $0F, $27
PF35:	.byte $29, $2B, $F1, $09, $0B, $25
PF36:	.byte $29, $2B, $F1, $01, $03, $3F
PF37:	.byte $29, $2B, $F1, $01, $03, $05
PF38:	.byte $29, $2B, $F1, $01, $03, $07
PF39:	.byte $29, $2B, $F1, $31, $33, $3D
PF3A:	.byte $29, $2B, $F1, $35, $37, $3D
PF3B:	.byte $29, $2B, $F1, $39, $3B, $3D
PF3C:	.byte $29, $2B, $F1, $0D, $1F, $25
PF3D:	.byte $29, $2B, $F1, $0D, $2D, $2F
PF3E:	.byte $F1, $F1, $F1, $05, $07, $F1
PF3F:	.byte $F1, $F1, $F1, $01, $03, $F1
PF40:	.byte $F1, $F1, $F1, $19, $1B, $F1
PF41:	.byte $F1, $F1, $F1, $21, $23, $F1
PF42:	.byte $F1, $F1, $F1, $1D, $1F, $F1
PF43:	.byte $05, $07, $F1, $A9, $AB, $F1
PF44:	.byte $05, $07, $F1, $A9, $AD, $F1
PF45:	.byte $29, $2B, $F1, $01, $03, $05
PF46:	.byte $F1, $F1, $F1, $25, $27, $F1
PF47:	.byte $F1, $F1, $F1, $29, $2B, $F1
PF48:	.byte $F1, $F1, $F1, $29, $2F, $F1
PF49:	.byte $F1, $F1, $F1, $25, $2D, $F1
PF4A:	.byte $F1, $F1, $F1, $09, $0B, $F1
PF4B:	.byte $F1, $F1, $F1, $0D, $0D, $F1
PF4C:	.byte $F1, $F1, $F1, $31, $33, $F1
PF4D:	.byte $F1, $F1, $F1, $35, $37, $F1
PF4E:	.byte $F1, $F1, $F1, $0F, $3F, $F1
PF4F:	.byte $19, $1B, $F1, $1D, $21, $F1
PF50:	.byte $19, $1B, $F1, $1D, $21, $23

	; Selects a VROM page offset per Player_Frame
Player_FramePageOff:
	.byte 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0	; 00 - 0F
	.byte 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1	; 10 - 1F
	.byte 1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2	; 20 - 2F
	.byte 2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3	; 30 - 3F
	.byte 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3	; 40 - 4F
	.byte 3

PRG029_CE88:
	.byte -8, 10, -8, 18,  8, 10,  8, 18,  1,  9,  0,  8,  2, 10, -2, 6

	; Specified root VROM page for a given power up
Player_PUpRootPage:
	;     Small, Big, Fire, Leaf, Frog, Tanooki, Hammer
	.byte $50,   $54, $54,  $00,  $50,  $40,     $44


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_Draw
;
; Not literally "draw", but configure the sprites for the Player
; to be drawn!  With the given data set of where the screen is
; scrolled, the Player's animation frame, invincibility status,
; etc. all handled by this major subroutine...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_Draw:
	LDX <Player_Frame
	LDA Player_FramePageOff,X
	STA <Temp_Var1		 ; Get VROM page offset for this animation frame -> Temp_Var1

	LDY <Player_Suit
	LDA Player_PUpRootPage,Y ; Get VROM root page for this power up
	ADD <Temp_Var1		 ; Add appropriate offset to the VROM base for the animation frame

	STA PatTable_BankSel+2	 ; Set VROM bank switch for sprites 1/4

	LDA <Player_X
	SUB <Horz_Scroll
	STA <Player_SpriteX	 ; Player_SpriteX = Player_X - Horz_Scroll

	LDA <Player_Y
	SUB Level_VertScroll
	STA <Player_SpriteY	; Player_SpriteY = Player_Y - Level_VertScroll

	LDA <Player_YHi	
	SBC Level_VertScrollH
	STA Player_AboveTop	 ; Player_Above top calculated if Player is off top of screen

	LDA Player_FlashInv
	BEQ PRG029_CED7	 	; If Player_FlashInv = 0, jump to PRG029_CED7

	DEC Player_FlashInv	; Player_FlashInv--
	AND #$02	 
	BEQ PRG029_CED7	 	; Every 2 ticks, draw Player
	JMP PRG029_D094	 	; Every other 2 ticks, don't!

PRG029_CED7:
	LDA Player_StarOff
	BNE PRG029_CEEA	 	; If Player_StarOff <> 0 (star invincibility wearing off), jump to PRG029_CEEA

	LDA Player_StarInv
	BEQ PRG029_CF0B	 	; If Player_StarInv = 0 (not star invincible), jump to PRG029_CF0B

	LDA <Counter_1
	AND #$01
	BEQ PRG029_CEEA		; Every other tick, jump to PRG029_CEEA

	DEC Player_StarInv	 ; Player_StarInv--

PRG029_CEEA:
	LDA <Counter_1
	AND #$0f	; A = 0-15 ticks

	LDY Player_StarOff
	BNE PRG029_CF07	 ; If Player_StarOff <> 0 (star invincibility wearing off), jump to PRG029_CF07

	LDY Player_StarInv
	CPY #32
	BNE PRG029_CF05	 ; If Player_StarInv <> 32, jump to PRG029_CF05

	; At precisely star invincibility tick 32...

	LDY Level_PSwitchCnt
	BNE PRG029_CF05	 	; If P-Switch is active, jump to PRG029_CF05

	; Otherwise, restore level BGM music now that invincibility is wearing off
	LDY Level_MusicQueueRestore
	STY Sound_QMusic2

PRG029_CF05:
	BCS PRG029_CF09	 ; If we're NOT doing the "wearing off" star invincibility, jump to PRG029_CF09

PRG029_CF07:
	; These shifts are used to produce the "slower" color cycle
	; when the star invincibility is wearing off...
	LSR A
	LSR A

PRG029_CF09:
	AND #$03	 ; Cap it 0-3 in any case (select one of the four sprite palettes, basically)

PRG029_CF0B:
	STA <Temp_Var1	 ; Store cycle tick into Temp_Var1 (0 if not invincible, sprite palette 0)

	LDA Level_PipeMove
	LDA Player_Behind
	ORA Player_SandSink
	BEQ PRG029_CF1E	 ; If Player is behind the scenes, jump to PRG029_CF1E

	; Set priority over background (normal most game sprite behavior)
	LDA #$20
	ORA <Temp_Var1
	STA <Temp_Var1

PRG029_CF1E:
	LDA #LOW(SPPF_Table-4)
	STA <Player_SprWorkL
	LDA #HIGH(SPPF_Table-4)
	STA <Player_SprWorkH

	; X = Player_Frame
	LDA SPPF_Offsets,X	; Get offset value to sprite's pattern set
	ASL A
	TAY			; Needs to be shifted up to be correct (stored shifted right 1)
	BCC PRG029_CF2F		; If carry is NOT set (a >= $80 value indicate "second page"), jump to PRG029_CF2F

	INC <Player_SprWorkH	 ; Go to second page

PRG029_CF2F:
	LDX Player_SprOff	 ; X = Root offset where Player sprite should begin

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$0D,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$11,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$15,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$01,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$05,X	 
	INY		 

	; Store pattern in this Player sprite and go to next byte
	LDA [Player_SprWorkL],Y	 
	STA Sprite_RAM+$09,X	 

	LDA <Player_FlipBits
	AND #$c0
	ORA <Temp_Var1		 ; Merge with possible other attributes (the star invincibility palette cycle)

	; Store attributes to all Player sprites
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$06,X
	STA Sprite_RAM+$0A,X
	STA Sprite_RAM+$0E,X
	STA Sprite_RAM+$12,X
	STA Sprite_RAM+$16,X

	LDA Sprite_RAM+$01,X
	CMP Sprite_RAM+$05,X
	BNE PRG029_CF88		; If the patterns to the first two sprites are not the same, jump to PRG029_CF88

	; If they ARE the same, this is a mirrored sprite (like Mario "looking towards screen" etc.)
	; So the "right half" sprites must mirror the "left half"

	LDA Sprite_RAM+$0E,X
	AND #~SPR_HFLIP	 	; Keep all attributes EXCEPT horizontal flip
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$0E,X
	ORA #SPR_HFLIP	 	; Force horizontal flip
	STA Sprite_RAM+$06,X
	STA Sprite_RAM+$12,X

PRG029_CF88:

	; First row sprites
	LDA <Player_SpriteY
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	; Second row sprites
	ADD #16
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

	; Left column
	LDA <Player_SpriteX
	STA Sprite_RAM+$03,X
	STA Sprite_RAM+$0F,X

	; Middle column
	ADD #8
	STA Sprite_RAM+$07,X
	STA Sprite_RAM+$13,X

	; Right column
	ADD #8
	STA Sprite_RAM+$0B,X
	STA Sprite_RAM+$17,X

	LDA <Player_FlipBits
	AND #SPR_HFLIP
	BEQ PRG029_D010	 ; If Player sprite is NOT horizontally flipped, jump to PRG029_D010

	; Reverse these patterns
	LDA Sprite_RAM+$01,X	 
	PHA		 
	LDA Sprite_RAM+$05,X	 
	STA Sprite_RAM+$01,X	 
	PLA		 
	STA Sprite_RAM+$05,X	 

	; Reverse these X values
	LDA Sprite_RAM+$0B,X	 
	ADD #-24
	STA Sprite_RAM+$0B,X	 
	STA Sprite_RAM+$17,X	

	; Reverse these patterns 
	LDA Sprite_RAM+$0D,X	 
	PHA		 
	LDA Sprite_RAM+$11,X	 
	STA Sprite_RAM+$0D,X	 
	PLA		 
	STA Sprite_RAM+$11,X	 


	LDA Player_Flip
	BEQ PRG029_D010	; If Player is not somersaulting, jump to PRG029_D010

	; Otherwise all of the sprites are pushed to the right by 8

	LDA Sprite_RAM+$03,X	 
	ADD #8
	STA Sprite_RAM+$03,X
	STA Sprite_RAM+$0F,X

	LDA Sprite_RAM+$07,X	 
	ADD #8
	STA Sprite_RAM+$07,X
	STA Sprite_RAM+$13,X
	 
	LDA Sprite_RAM+$0B,X	 
	ADD #8
	STA Sprite_RAM+$0B,X	 
	STA Sprite_RAM+$17,X	 


PRG029_D010:
	LDA Player_Kuribo
	BEQ PRG029_D050	 ; If Player is not in a Kuribo's shoe, jump to PRG029_D050

	; In short, if Player is small, use Temp_Var1 = 6, otherwise Temp_Var1 = 0 (sprite vertical offset in shoe)
	LDY #$00
	LDA <Player_Suit
	BNE PRG029_D01D
	LDY #$06
PRG029_D01D:
	STY <Temp_Var1

	LDA <Player_InAir
	BEQ PRG029_D036	 ; If Player is not mid-air, jump to PRG029_D036

	LDA <Player_YVel
	BPL PRG029_D029	 ; If Player is falling, jump to PRG029_D029

	EOR #$ff	 ; Otherwise negate it (sort of)

PRG029_D029:
	LSR A
	LSR A
	LSR A
	LSR A
	SUB #$03	; The "whole" part of the Y Velocity, minus 3

	EOR #$ff	 ; Negate that (sort of)
	BPL PRG029_D036	 ; If the result is positive, jump to PRG029_D036

	LDA #$00	 ; Otherwise if it slipped below zero, just use zero

PRG029_D036:
	ADD <Temp_Var1	 ; Add that to the initial offset
	ADD <Player_SpriteY	 ; And add in the Player's sprite Y position

	; Store that as the new Y position on the "first row" sprites
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	; The "second row" sprites (the shoe part in this case) use a different palette
	LDA Sprite_RAM+$02,X
	ORA #$02
	STA Sprite_RAM+$02,X
	STA Sprite_RAM+$06,X

PRG029_D050:
	LDA <Player_Frame
	CMP #PF_KICK_BIG 
	BNE PRG029_D076	 ; If Player_Frame <> PF_KICK_BIG (kicking shell, etc. when not small), jump to PRG029_D076

	; Otherwise the third "first row" sprite is pulled down to "second row"
	; This becomes the foot involved in the kick!
	LDA Sprite_RAM+$00,X
	STA Sprite_RAM+$14,X

	; If Player is not horizontally flipped, A = -8, otherwise A = 16
	LDA #-8
	LDY <Player_FlipBits
	BEQ PRG029_D064
	LDA #16
PRG029_D064:

	; The aforementioned foot sprite is offset into proper X position
	ADD Sprite_RAM+$0F,X
	STA Sprite_RAM+$17,X

	LDA #$1b
	STA Sprite_RAM+$15,X	; The foot sprite is forced to pattern $1B

	LDA Sprite_RAM+$0E,X
	STA Sprite_RAM+$16,X	; Attributes are copied (is this necessary?)

PRG029_D076:
	LDA <Player_FlipBits
	AND #$80	 
	BEQ PRG029_D094	 

	; If Player is vertically flipped, all sprite Y values must be reversed too!

	LDA Sprite_RAM+$00,X
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

	ADD #-16
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

PRG029_D094:
	LDA #$00
	STA Player_OffScreen	 ; Player_OffScreen = 0 (not off screen until we decide so!)

	LDY #$ff

	LDA Player_AboveTop
	BPL PRG029_D0AE	 	; If Player is not above top of screen, jump to PRG029_D0AE

	LDA <Player_SpriteY
	ADD #16
	LDA #$00
	ADC Player_AboveTop

	BNE PRG029_D0BC	 ; If Player is completely off the top of screen, jump to PRG029_D0BC
	BEQ PRG029_D0D3	 ; If Player is not at all off the top of screen, jump to PRG029_D0D3

PRG029_D0AE:
	BNE PRG029_D0BC	 ; Jump reserved for when Player is already known as off screen, so jump (technically always) to PRG029_D0BC

	LDA <Player_SpriteY
	CMP #$c0	 
	BGE PRG029_D0BC	 ; If Player_SpriteY >= $C0, he's below the status bar, so jump to PRG029_D0BC

	CMP #$b0
	BGE PRG029_D0C9	 ; If Player_SpriteY >= $B0, he's halway below the status bar, so jump to PRG029_D0C9
	BLT PRG029_D0D3	 ; Otherwise, Player is totally visible, jump to PRG029_D0D3

PRG029_D0BC:
	INC Player_OffScreen	; Player is off screen

	; Prevent "second row" sprites from being displayed
	TYA		 	; A = $FF
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X
	STA Sprite_RAM+$14,X

PRG029_D0C9:

	; Prevent "first row" sprites from being displayed
	TYA		 	; A = $FF
	STA Sprite_RAM+$00,X	
	STA Sprite_RAM+$04,X	
	STA Sprite_RAM+$08,X	

PRG029_D0D3:


	; $F1 is a magic value reserved as a "don't display this sprite" flag
	; So let's check if any sprite is using that value right now...
	LDY #$05	 ; Y = 5 (looping through all six Player sprites)

PRG029_D0D5:
	LDA Sprite_RAM+$01,X
	CMP #$f1	 
	BNE PRG029_D0E1	 ; If this sprite is NOT using pattern $F1, PRG029_D0E1

	; Pattern $F1 is the "don't use" pattern, so set this sprite's Y to $F8 (make invisible)
	LDA #$f8	 
	STA Sprite_RAM+$00,X

PRG029_D0E1:
	INX
	INX
	INX
	INX		 ; X -= 4 (previous sprite)
	DEY		 ; Y--
	BPL PRG029_D0D5	 ; While Y >= 0, loop!

	LDA Level_PipeMove
	BEQ PRG029_D13A	 ; If Level_PipeMove = 0, jump to PRG029_D13A (RTS)

	; When Player is going through pipe, a special "cover sprite" is used
	; at the pipe entrance which masks the Player...

	; Mask sprite X
	LDA <Pipe_PlayerX
	SUB <Horz_Scroll
	STA Sprite_RAM+$03
	STA Sprite_RAM+$07
	ADD #$08
	STA Sprite_RAM+$0B
	STA Sprite_RAM+$0F

	; Mask sprite Y
	LDA <Pipe_PlayerY
	SUB Level_VertScroll
	PHA
	CMP #$f0
	BLT PRG029_D10E
	LDA #$00	
PRG029_D10E:
	STA Sprite_RAM+$00
	STA Sprite_RAM+$08
	PLA
	ADD #16
	STA Sprite_RAM+$04
	STA Sprite_RAM+$0C


	; The pattern doesn't really matter so long as it is opaque
	; since the masking sprite is not intended to be visible
	; (not that certain glitches or ill behavior don't reveal
	; it once in a while)

	; Uses pattern $77 ("metal block" from used up [?], should be completely opaque)
	LDA #$77
	STA Sprite_RAM+$01
	STA Sprite_RAM+$05
	STA Sprite_RAM+$09
	STA Sprite_RAM+$0D

	; Must appear behind tiles
	LDA #SPR_BEHINDBG
	STA Sprite_RAM+$02
	STA Sprite_RAM+$06
	STA Sprite_RAM+$0A
	STA Sprite_RAM+$0E


PRG029_D13A:
	RTS		 ; Return

ToadHouse_Item2Inventory:
	.byte $0C, $08, $04, $05, $06, $04, $05, $06, $01, $02, $03, $04, $02, $03, $05

	; Toad House items:
	; 0 = Warp Whistle
	; 1 = P-Wing
	; 2 = Frog Suit
	; 3 = Tanooki
	; 4 = Hammer
	; 5 = Frog
	; 6 = Tanooki
	; 7 = Hammer
	; 8 = Mushroom
	; 9 = Fire Flower
	; 10 = Leaf

	; Item offsets per Toad House type
ToadHouse_ItemOff:
	;	0   1    2    3    4    5    6
	.byte $02, 03, $0A, $0A, $0A, $05, $08

	.byte $0B, $0E, $11

	; SB: This is a large set and could have the same effect
	; with just four items, so I wonder if there was a thought
	; of having additional items at some point?
ToadHouse_RandomItem:
	; Where 0 = Super Mushroom, 1 = Fire Flower, 2 = Super Leaf
	; OR 0 = Frog, 1 = Tanooki, 2 = Hammer
	; Super Mushroom / Frog has the best chance in this lottery by 1...
	.byte $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00, $01, $02, $00


	; X values of three treasure boxes, specifically the tile that must change when opened
ToadHouse_Box_X:	.byte $40, $70, $A0

	; Routine to open a chest if Player is standing in front of it
	; (Already checked for him pressing 'B'!)
ToadHouse_ChestPressB:
	LDA #TILE7_CHEST_LR
	SUB Level_Tile_Head
	CMP #$04
	BGE PRG029_D1B7	 ; If Player is NOT touching one of the treasure boxes, jump to PRG029_D1B7

	; Touching a treasure box... determine which one

	LDY #$00	 ; Y = 0 (first box)

	LDA <Player_X
	CMP #$60
	BLT PRG029_D17F	 ; If Player_X < $60, jump to PRG029_D17F

	INY		 ; Y = 1 (second box)

	CMP #$90
	BLT PRG029_D17F	 ; If Player_X < $90, jump to PRG029_D17F

	INY		 ; Y = 2 (third box)

PRG029_D17F:

	; Block change is always same height regardless of which box...
	LDA #$80
	STA Level_BlockChgYLo
	LDA #$01
	STA Level_BlockChgYHi

	LSR A		 ; A = 0, effectively
	STA Level_BlockChgXHi	 ; Always zero

	LDA ToadHouse_Box_X,Y	 ; Get proper X for the selected box
	STA Level_BlockChgXLo	 ; Store as low X of tile change

	LDA #CHNGTILE_TOADBOXOPEN
	STA Level_SkipStatusBarUpd	; Set Level_SkipStatusBarUpd (skip status bar for a frame, priority update!)
	STA Level_ChgTileEvent	 	; Toad House tile change event!

	; THouse_Treasure = 7 is standard random basic item (mushroom, flower, leaf)

	LDX THouse_Treasure
	DEX		 ; X = THouse_Treasure - 1
	CPX #$05	 
	BLS PRG029_D1B1	 ; If X < 5, jump to PRG029_D1B1

	; X = 5 if random super suit (frog, tanooki, hammer)
	; X = 6 if standard random basic item

	LDA RandomN
	AND #$0f
	TAY		 ; Y = Random number 0 - 15

	LDA ToadHouse_RandomItem,Y	; Pick a random item
	ADD ToadHouse_ItemOff,X	 	; Add appropriate offset
	TAX		 ; -> 'X'

PRG029_D1B1:
	LDA ToadHouse_Item2Inventory,X	 ; Load Toad House item code -> Player Inventory index
	TAX		 ; -> 'X'
	INX		 ; X++ (because 0 is "no box opened")

	RTS		 ; Return

PRG029_D1B7:
	LDX #$00	 ; X = 0
	RTS		 ; Return


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Player_DrawAndDoActions
;
; Have to give this one its props; this function does an entire
; mess of routines, from adjusting the Player during autoscroll,
; going to coin heaven, the airship intro, going through pipes,
; changing power ups... all the things that happen to the Player
; object, though none of the instigation code is here!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Player_DrawAndDoActions:
	LDA Player_HaltTick
	BEQ PRG029_D1CE	 	; If Player_HaltTick = 0 (not halted), jump to PRG029_D1CE

	; This code is only executed if the Player is halted

	DEC Player_HaltTick	; Player_HaltTick--

	JSR Player_Draw	 	; Draw Player's sprite!

	LDA Level_AScrlConfig
	BEQ PRG029_D1CD	 		; If Level_AScrlConfig = 0 (no auto scroll going on), jump to PRG029_D1CD

	JSR AutoScroll_CalcPlayerY	; Adjust Player_Y and Player_YHi for auto scroll

PRG029_D1CD:
	RTS		 ; Return


PRG029_D1CE:
	LDA <Player_IsDying
	BEQ PRG029_D1D5	 ; If Player is not dying, jump to PRG029_D1D5

	JMP PRG029_D6BC	 ; Jump to PRG029_D6BC (the Player's death routine)

PRG029_D1D5:
	LDA Level_CoinHeav
	BPL PRG029_D205	 ; If Level_CoinHeav >= 0, jump to PRG029_D205

	; Note that by above logic, Level_CoinHeav must be <= -1...
	; Technically, it is set to $80 (-128) at start!

	; Release holding anything and stop horizontal movement
	LDA #$00	 
	STA Player_IsHolding
	STA <Player_XVel

	; Produces an initial burst of upward Y velocity which slows down
	INC Level_CoinHeav	; Level_CoinHeav++
	LDA Level_CoinHeav
	STA <Player_YVel
	BNE PRG029_D1EE	 	; If Level_CoinHeav <> 0, jump to PRG029_D1EE

	INC Level_CoinHeav	; Level_CoinHeav++

PRG029_D1EE:
	LDA <Player_YHi
	BPL PRG029_D205	 ; If Player hasn't gone above top of screen yet, jump to PRG029_D205

	; Once Player crosses top of screen, he is then placed at halfway 
	; above the status bar (16 pixels above the death point!)
	LDA #$01
	STA <Player_YHi	; Player_YHi = 1 (really low)
	LDA #$b0	 
	STA <Player_Y	; Player_Y = $B0 (near the bottom)

	LDA #$d0
	STA Level_CoinHeav

	; Change to coin heaven (technically, this is the "general" level junction)
	LDA #$03	
	STA Level_JctCtl ; Level_JctCtl = 3

	RTS		 ; Return


PRG029_D205:
	LDA Player_SuitLost
	BEQ PRG029_D20E	 ; If Player_SuitLost = 0, jump to PRG029_D20E

	JSR Player_SuitLost_DoPoof	; Do the suit lost poof

	RTS		 ; Return


PRG029_D20E:
	LDA Player_StarOff
	BEQ PRG029_D224	 ; If Player_StarOff = 0 (invincibility is not wearing off), jump to PRG029_D224

	CMP #31
	BNE PRG029_D21D	 ; If Player_StarOff <> 31, jump to PRG029_D21D

	DEC Player_StarOff ; Player_StarOff--
	JMP PRG029_D224	   ; Jump to PRG029_D224

PRG029_D21D:
	JSR Player_Draw	   ; Draw Player
	DEC Player_StarOff ; Player_StarOff--

	RTS		 ; Return

PRG029_D224:
	LDA Player_Grow
	BEQ PRG029_D257	 ; If Player is not transforming into "Super", jump to PRG029_D257

	LSR A
	LSR A
	TAX		 ; X = Player_Grow >> 2

	LDY <Player_Suit ; Y = Player_Suit
	BNE PRG029_D238	 ; If Y <> 0 (small), jump to PRG029_D238

	STX <Temp_Var1
	LDA #$0b
	SUB <Temp_Var1
	TAX		 ; Otherwise, X = $0B - (Player_Grow >> 2)

PRG029_D238:
	AND #$01
	PHP		 ; Save result

	LDA Player_GrowFrames,X	 ; Get this grow frame
	STA <Player_Frame	 ; Set as current frame

	JSR Player_Draw		 ; Draw Player

	; Changes the Sprite 1/4 VROM bank as appropriate
	LDA PatTable_BankSel+2
	AND #$03
	ORA #$54
	PLP		 ; Restore result
	BEQ PRG029_D250
	SUB #$10	
PRG029_D250:
	STA PatTable_BankSel+2

	DEC Player_Grow	 ; Player_Grow--

	RTS		 ; Return

PRG029_D257:
	LDA Player_EndLevel
	BEQ PRG029_D279	 ; If we're not doing the end of level run, jump to PRG029_D279

	LDA Player_Kuribo
	BEQ PRG029_D26B	; If Player was not in a Kuribo's shoe, jump to PRG029_D26B

	; If Player was in Kuribo's shoe at the end goal, "poof" it away!

	LDA #$00
	STA Player_Kuribo

	LDA #$18
	STA Player_SuitLost	 ; Player_SuitLost = $18

PRG029_D26B:
	LDA <Player_InAir
	BNE PRG029_D279		; If Player is mid-air, jump to PRG029_D279

	DEC Player_EndLevel	; Player_EndLevel--

	LDA #$14
	STA <Player_XVel	; Player_XVel = $14
	JMP PRG029_D457	 	; Jump to PRG029_D457 

PRG029_D279:
	LDA Level_AirshipCtl
	BNE PRG029_D281	 ; If Level_AirshipCtl <> 0, jump to PRG029_D281

	JMP PRG029_D33E	 ; Otherwise, jump to PRG029_D33E

PRG029_D281:

	; Level_AirshipCtl <> 0...

	PHA		 ; Save Level_AirshipCtl

	LDA #$00
	STA <Scroll_LastDir	; Force screen to have "last moved right"

	INC <Horz_Scroll	; Screen scrolls to the right
	BNE PRG029_D28C	 	; If it hasn't rolled over, jump to PRG029_D28C
	INC <Horz_Scroll_Hi	; Otherwise, apply carry

PRG029_D28C:
	LDA <Horz_Scroll_Hi
	BNE PRG029_D296	 	; If Horz_Scroll_Hi <> 0, jump to PRG029_D296

	LDA <Horz_Scroll
	CMP #$60	
	BLT PRG029_D2AF	 ; If Horz_Scroll < $60, jump to PRG029_D2AF

PRG029_D296:
	INC Level_AirshipH	 ; Level_AirshipH++

	LDA Level_AirshipH
	ADD Counter_Wiggly	 ; Increase height of the airship in a bit of a wobbly way
	BCC PRG029_D2AF	 	; If it hasn't overflowed, jump to PRG029_D2AF

	INC <Vert_Scroll

	LDA <Objects_Y+4
	SUB #$01
	STA <Objects_Y+4	; Anchor's Y minus 1
	BCS PRG029_D2AF
	DEC <Objects_YHi+4	; If overflow occurred, propogate the carry
PRG029_D2AF: 

	PLA		 ; Restore Level_AirshipCtl
	JSR DynJump	 ; Dynamic jump based on Level_AirshipCtl... 
	
	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word AirshipCtl_DoNothing	; 0 - Do nothing (not used)
	.word AirshipCtl_RunAndJump	; 1 - Run and jump (when horizontal scroll hits $80)
	.word AirshipCtl_Catch		; 2 - Catch anchor
	.word AirshipCtl_HoldAnchor	; 3 - Hold onto anchor
	.word AirshipCtl_LandOnDeck	; 4 - Land Player on deck

AirshipCtl_DoNothing:
	RTS		 ; Return


AirshipCtl_RunAndJump:
	LDA #$ef
	STA Level_VertScroll	 ; Level_VertScroll = $EF

	LDA <Horz_Scroll
	CMP #$80
	BLT PRG029_D2D0	 ; If Horz_Scroll < $80, jump to PRG029_D2D0

	; Player makes the jump!
	LDA #-$60
	STA <Player_YVel	 ; Player_YVel = -$60
	INC Level_AirshipCtl	 ; Next Level_AirshipCtl!

PRG029_D2D0:
	LDA #$01
	STA <Player_FlipBits	 ; Player_FlipBits = 1

	LDA #$20
	STA <Player_XVel	 ; Player_XVel = $20

	JMP PRG029_D457	 ; $D2D8 


AirshipCtl_Catch:
	LDA <Player_X
	CMP #$36	
	BLT PRG029_D2FF	 ; If Player_X < $36, jump to PRG029_D2FF

	; Apply Player's velocities
	JSR Player_ApplyYVelocity
	JSR Player_ApplyXVelocity

	LDA <Player_YVel
	ADD #$04
	STA <Player_YVel ; Player_YVel += 4

	CMP #$0f
	BLS PRG029_D2F5	 ; If Player_YVel < $0F, jump to PRG029_D2F5

	INC Level_AirshipCtl	 ; Otherwise, next Level_AirshipCtl!

PRG029_D2F5:

	; Set mid-air jump frame as appropriate by suit and draw Player...
	LDY <Player_Suit
	LDA Airship_JumpFrameByPup,Y
	STA <Player_Frame
	JMP Player_Draw	

PRG029_D2FF:
	JMP PRG029_D457	 ; Jump to PRG029_D457


AirshipCtl_HoldAnchor:
	LDA #$02
	STA <Player_FlipBits	 ; Player_FlipBits = 2 (use "caught anchor" frame)

	LDA #-$14
	STA <Player_YVel ; Player_YVel = -$14
	JSR PRG029_D457	 ; Continue using the "run" code

	LDA <Vert_Scroll
	CMP #$70
	BLT PRG029_D31B	 ; If Vert_Scroll < $70, jump to PRG029_D31B (RTS)

	LDA #$03	 
	STA Level_JctCtl	 ; Level_JctCtl = 3 (general purpose junction)

	INC Level_AirshipCtl	 ; Next Level_AirshipCtl!

PRG029_D31B:
	RTS		 ; Return


AirshipCtl_LandOnDeck:
	LDA Level_AScrlConfig
	BEQ PRG029_D33D	 ; If autoscroll not enabled, jump to PRG029_D33D

	JSR Player_ApplyYVelocity	 ; Apply Player's Y velocity

	LDA <Player_YVel
	BMI PRG029_D330	 	; If Player's Y velocity is negative (still rising), jump to PRG029_D330

	LDA #$00
	STA Level_AirshipCtl	; Level_AirshipCtl = 0 (airship sequence complete)
	STA Level_TimerEn	; Level_TimerEn = 0 (level timer enabled!)

PRG029_D330:
	LDA <Player_YVel
	ADD #$04
	STA <Player_YVel ; Player_YVel += 4 (Player falling to airship)

	JSR Player_DoScrolling	; Update scrolling at Player's position

	JSR PRG029_D2F5	 ; Mid-air frame as appropriate

PRG029_D33D:
	RTS		 ; Return


PRG029_D33E:
	LDA Level_GetWandState
	CMP #$03
	BLS PRG029_D361	 ; If Level_GetWandState < 3 (wand grabbed), jump to PRG029_D361

	CMP #$07
	BLS PRG029_D354	 ; If Level_GetWandState < 7, jump to PRG029_D354

	; Player's slow decent...
	LDA <Player_Y
	ADD #$02
	STA <Player_Y	 ; Player_Y += 2

	BCC PRG029_D354	 ; If no carry, jump to PRG029_D354
	INC <Player_YHi	 ; Otherwise, apply carry

PRG029_D354:
	; Player holding wand!
	LDY <Player_Suit ; Y = Player_Suit
	LDA Airship_JumpFrameByPup,Y	 
	STA <Player_Frame	; Use proper "mid-air" frame
	JSR Player_Draw	 	; Draw Player
	JMP Wand_Offset_BySuit	 	; Jump to Wand_Offset_BySuit

PRG029_D361:

	; Level_PipeMove is set to $8x when we are EXITING from
	; a pipe OR moving through it (in-level transit style),
	; but NOT when a non-transit pipe is entered; just being
	; clear, the "BPL" is for jumping when Level_PipeMove is
	; NOT holding an $8x value (and it might be zero, but 
	; that check is coming up next...)
	LDA Level_PipeMove
	BPL PRG029_D369		; If not transiting or exiting, jump to PRG029_D369

	JMP Level_PipeTransitOrExit	 ; Otherwise jump to Level_PipeTransitOrExit

PRG029_D369:
	BNE Level_PipeEnter	 ; If Level_PipeMove is not zero (and not in the $8x range), jump to Level_PipeEnter

	JMP PRG029_D3EC	 ; Otherwise, jump to PRG029_D3EC

Level_PipeEnter:

	; For when you've just entered a pipe of any sort...

	LDA Event_Countdown
	BNE PRG029_D3A0	 ; If Event_Countdown <> 0, jump to PRG029_D3A0

	; Init...

	LDA Level_PipeMove
	AND #%00011100	 ; Examine just bits 2-4 (determines what the pipe will do)
	CMP #%00010100	 
	BNE PRG029_D384	 ; If this is NOT an in-level transit pipe, jump to PRG029_D384

	LDA #$05
	STA Level_PipeExitDir	 ; Otherwise, Level_PipeExitDir = 5 (in-level transit flag)
	JMP PRG029_D395	 	; Jump to PRG029_D395

PRG029_D384:

	; Non in-level transit pipe...

	LSR A
	LSR A		 ; Shift down twice so the pipe behavior value is index based
	STA Level_JctCtl ; Push it right into Level_JctCtl!
	CMP #$01	 ; Although Level_JctCtl = 1 is not valid, this is used as "return to map"...
	BNE PRG029_D395	 ; If Level_JctCtl <> 1, jump to PRG029_D395

	INC <Level_ExitToMap	 ; Level_ExitToMap = 1 (return to map)

	LDA #$00
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 0 (completed level, i.e. did not die)

	RTS		 ; Return


PRG029_D395:

	; Entered into an in-level transit pipe...

	; Level_PipeMove will hold the direction and bit 7, which flags the in-level transit pipe
	LDA Level_PipeMove
	AND #$03
	ORA #$80
	STA Level_PipeMove	 

	RTS		 ; Return

PRG029_D3A0:

	; While traveling in a pipe (but not an in-level transit style)

	LDA Level_PipeMove
	AND #%00000011	 ; Just keep the lower 2 bits (direction)
	CMP #$02
	BGS PRG029_D3CB	 ; If direction is down/up, jump to PRG029_D3CB

	; Left/right pipe

	LDA Event_Countdown
	CMP #16
	BLS PRG029_D3CA  ; If Event_Countdown < 16, jump to PRG029_D3CA (RTS)

	PHA		 ; Save Event_Countdown

	JSR PipeMove_LeftRight	 ; Move through pipe horizontally

	PLA		 ; Restore Event_Countdown

	CMP #36
	BGS PRG029_D3CA	 ; If Event_Countdown >= 36, jump to PRG029_D3CA

	; Remove Player's edge sprites as he vanishes into pipe
	LDX Player_SprOff
	LDA #$f8
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$0C,X
	STA Sprite_RAM+$10,X

PRG029_D3CA:
	RTS		 ; Return

PRG029_D3CB:

	; Up/down pipe

	JSR PipeMove_UpDown	 ; Move through pipe vertically

	LDA Event_Countdown
	CMP #16
	BGE PRG029_D3EB	 	; If Event_Countdown >= 16, jump to PRG029_D3EB (RTS)

	LDA Player_SprOff

	LDX <Player_YVel
	BPL PRG029_D3DF	 ; If Player_YVel >= 0 (going down), jump to PRG029_D3DF

	ADD #$0c	 ; Remove other half of Player


	; Gets rid of appropriate half of Player sprites as he disappears into pipe
PRG029_D3DF:
	TAX 	; X = Player_SprOff

	LDA #$f8
	STA Sprite_RAM+$00,X
	STA Sprite_RAM+$04,X
	STA Sprite_RAM+$08,X

PRG029_D3EB:
	RTS		 ; Return


PRG029_D3EC:

	; Nothing to do with pipes...

	JMP PRG008_A224	 ; Jump to PRG008_A224


	; When Player has grabbed wand, offset from Player X/Y by suit / power-up
Wand_XOff_BySuitL:	.byte -5, -5, -5, -5, -7, -5, -5
Wand_XOff_BySuitR:	.byte  6,  6,  6,  6,  8,  6,  6
Wand_YOff_BySuit:	.byte  1, -9, -9, -9,  3, -9, -9

Wand_Offset_BySuit:
	LDY Object_SprRAM+5	; Y = 5th index object Sprite RAM offset
	LDX <Player_Suit	; X = Player's suit

	LDA <Player_FlipBits
	PHP		 	; Save Player flip bits

	LDA Wand_XOff_BySuitR,X	; Wand offset, held right

	PLP		 	; Restore Player flip bits
	BNE PRG029_D415	 	; If Player is not flipped, jump to PRG029_D415

	LDA Wand_XOff_BySuitL,X	; Wand offset, held left

PRG029_D415:
	ADD <Player_SpriteX	; Add offset to Player sprite X
	STA Sprite_RAM+$03,Y	; -> Sprite X

	ADD #$08		; +8
	STA Sprite_RAM+$07,Y	; -> Sprite X

	; Temp_Var1 = Player_YHi
	LDA <Player_YHi
	STA <Temp_Var1

	LDA Wand_YOff_BySuit,X
	BPL PRG029_D42C	 	; If Y offset is positive, jump to PRG029_D42C

	DEC <Temp_Var1		; Otherwise, Temp_Var1--

PRG029_D42C:
	ADD <Player_SpriteY	; Add offset to Player Y
	BCC PRG029_D433	 	; If no carry, jump to PRG029_D433

	INC <Temp_Var1		; Otherwise, apply carry

PRG029_D433:
	LDX <Temp_Var1		; X = Temp_Var1
	CPX #$01
	BPL PRG029_D454	 	; If off-screen, jump to PRG029_D454

	; Store Wand Sprites Y
	STA Sprite_RAM+$00,Y
	STA Sprite_RAM+$04,Y

	; Store Wand Sprite Patterns
	LDA #$99
	STA Sprite_RAM+$01,Y
	STA Sprite_RAM+$05,Y

	; Palette cycling of wand
	LDA <Counter_1
	AND #$06
	LSR A
	STA Sprite_RAM+$02,Y

	; Mirrored half
	ORA #SPR_HFLIP
	STA Sprite_RAM+$06,Y

PRG029_D454:
	RTS		 ; Return

Level_EndFlipBits:
	.byte $00, $40

PRG029_D457:

	; The "run forward" bit at the end of a level...
	; OR the run & jump for the airship!

	LDA <Player_FlipBits
	AND #$02
	BEQ PRG029_D468	 ; If (Player_FlipBits & 2) = 0, jump to PRG029_D468

	JSR Player_ApplyYVelocity	 ; Apply Y velocity

	; Used by airship only (the "caught anchor" frames)
	LDY <Player_Suit
	LDA Player_ClimbFrame,Y ; Get "caught anchor" frame
	JMP PRG029_D49B	 	  ; Jump to PRG029_D49B

PRG029_D468:
	LDA <Player_FlipBits
	AND #$01
	TAY		; Y = Player_FlipBits & 1 
	LDA Level_EndFlipBits,Y	 ; Get proper flip bit
	ORA <Player_FlipBits	
	STA <Player_FlipBits	 ; Level_EndFlipBits |= Level_EndFlipBits[Y]

	JSR Player_ApplyXVelocity ; Apply X Velocity

	LDA <Counter_1
	AND #$06	
	LSR A		
	STA <Temp_Var1	 ; Temp_Var1 = (Counter_1 & 6) >> 1  (0-3)


PRG029_D47E:	; Jump point for horizontal pipe-walking

	LDY Player_Kuribo
	BEQ PRG029_D491	 ; If Player is NOT wearing Kuribo's shoe, jump to PRG029_D491

	; Wearing Kuribo's shoe (NOTE: This CAN'T happen because the 
	; shoe was forcefully removed before we got here; dead code?)

	AND #$01

	LDY <Player_Suit
	BEQ PRG029_D48B	 ; If Player_Suit = 0 (small), jump to PRG029_D48B

	LDY #$01	 ; Y = 1 (small / big same)

PRG029_D48B:
	ADD Player_KuriboFrame,Y
	BNE PRG029_D49B	 ; If result is not zero, jump to PRG029_D49B

PRG029_D491:
	LDA <Player_Suit
	ASL A
	ASL A		
	ORA <Temp_Var1
	TAY		; Y = (Player_Suit << 2) | Temp_Var1 (0 to 3)
	LDA Player_WalkFramesByPUp,Y	; Get appropriate frame

PRG029_D49B:
	STA <Player_Frame	; Whatever the result, store as Player frame!
	JSR Player_Draw	 	; Draw Player
	RTS		 ; Return


Pipe_Move_JumpTable:
	.word Player_Die_NotDying	; 0 - Not used
	.word Pipe_Move_Up		; 1 - Moving Up
	.word Pipe_Move_Down		; 2 - Down
	.word Pipe_Move_Right		; 3 - Right
	.word Pipe_Move_Left		; 4 - Left
	.word Pipe_Transit		; 5 - In-level transit

	; For horizontal pipe movement, X velocity right and left, respectively
PipeMove_XVel:	.byte 8, -8

	; For vertical pipe movement, Y velocity down and up, respectively
PipeMove_YVel:	.byte 8, -8

	; This sets the Scroll_LastDir variable based on travel direction (right and left, respectively)
PipeMove_LR_Dir:	.byte 0, 1

	; This adds to Horz_Scroll based on travel direction (right and left, respectively)
PipeMove_LR:	.byte 1, -1

	; High byte sign extension to values in table immediately above
PipeMove_LRH:	.byte $00, $FF

Level_PipeTransitOrExit:
	; Jump here when Level_PipeExitDir is one of the $8x varities
	; indicating that we're moving through the pipe (in-level
	; transit or simply exiting out one end of it)

	; Splash_DisTimer = 8 (halt Player splashing in water when in-pipe)
	LDA #$08
	STA Splash_DisTimer

	LDA Level_PipeExitDir
	ASL A		 
	TAY		

	; Dynamic jump based on Level_PipeExitDir index into Pipe_Move_JumpTable table 
	LDA Pipe_Move_JumpTable,Y
	STA <Temp_Var1	
	LDA Pipe_Move_JumpTable+1,Y
	STA <Temp_Var2		
	JMP [Temp_Var1]

Player_Die_NotDying:
	RTS		 ; Return

Pipe_Move_Up:
	; Level_PipeMove = $83 (indicates Player is moving up through pipe, no additional action to be taken)
	LDA #$83
	STA Level_PipeMove

	JSR PipeMove_UpDown	; Do pipe movement and draw Player

	LDA Event_Countdown
	BNE PRG029_D4DF	 	; If Event_Countdown <> 0, jump to PRG029_D4DF

	JMP Player_StopMovement	; Jump to Player_StopMovement

PRG029_D4DF:
	CMP #32
	LDA Player_SprOff
	BLT PRG029_D4E9	 ; If Event_Countdown < 32, jump to PRG029_D4E9 (RTS)

	JMP PRG029_D3DF ; Jump to PRG029_D3DF

PRG029_D4E9:
	RTS		 ; Return

Pipe_Move_Down:
	; Level_PipeMove = $82 (indicates Player is moving down through pipe, no additional action to be taken)
	LDA #$82
	STA Level_PipeMove
	STA <Player_InAir 	; Flag Player as being mid-air (going to fall out the bottom)

	LDA #$30
	STA <Player_YVel 	; Player_YVel = $30 

	JSR Player_ApplyYVelocity ; Apply Player's Y velocity
	JSR PipeMove_UpDown	 ; Move through pipe vertically

	LDA Event_Countdown
	BNE PRG029_D50E	 	; If Event_Countdown <> 0, jump to PRG029_D50E

	LDA #$00	 
	STA Player_IsDucking	; Clear ducking flag (since Player pressed down on a pipe, it's incorrectly set)
	STA Level_PipeMove	; Not moving through a pipe anymore
	STA <Player_XVel	; Not horizontally moving, period

	LDA #$38
	STA <Player_YVel	; Player_IsDucking = $38 (fall out the bottom)

PRG029_D50E:
	RTS		 ; Return

Pipe_Move_Right:
	; Level_PipeMove = $80 (indicates Player is moving right through pipe, no additional action to be taken)
	LDA #$80
	STA Level_PipeMove

	LDA #$40
	STA <Player_FlipBits ; Player_FlipBits = $40 (facing right)

	LDY #$00	 ; Y = 0 (moving right)

PRG029_D51A:
	LDA <Counter_1
	LSR A		
	BCC PRG029_D53B	 ; Basically, every other tick, jump to PRG029_D53B

	; And on the other ticks...

	LDA PipeMove_LR_Dir,Y
	STA <Scroll_LastDir

	LDA <Horz_Scroll

	LDX <Horz_Scroll_Hi
	BNE PRG029_D52E	 	; If Horz_Scroll_Hi = 0, jump to PRG029_D52E

	; Horz_Scroll_Hi <> 0...

	CMP #$80	 
	BLT PRG029_D53B	 ; If Horz_Scroll < $80, jump to PRG029_D53B

PRG029_D52E:
	ADD PipeMove_LR,Y
	STA <Horz_Scroll	; Horz_Scroll += PipeMove_LR[Y]

	; Add matching sign extension and any carry
	LDA PipeMove_LRH,Y
	ADC <Horz_Scroll_Hi
	STA <Horz_Scroll_Hi

PRG029_D53B:
	JSR PipeMove_LeftRight	 ; Move through pipe horizontally

	LDX Player_SprOff	 ; X = Player's root sprite position

	; Remove one of the masking sprites??
	LDA #$f8
	STA Sprite_RAM+$08,X

	LDA Event_Countdown
	BNE PRG029_D54E	 ; If Event_Countdown <> 0, jump to PRG029_D54E (RTS)

	JSR Player_StopMovement	 ; Stop movement exiting pipe!

PRG029_D54E:
	RTS		 ; Return

Pipe_Move_Left:
	; Level_PipeMove = $81 (indicates Player is moving left through pipe, no additional action to be taken)
	LDA #$81
	STA Level_PipeMove

	LDA #$00
	STA <Player_FlipBits ; Player_FlipBits = $00 (facing left)

	LDY #$01	 ; Y = 1 (moving left)

	JMP PRG029_D51A	; Jump to PRG029_D51A

	; Y Offset based on direction (down and up respectively)
PipeTransit_YOff:
	.byte 31, 0

Pipe_Transit:
	LDA Level_7Vertical
	BNE PRG029_D5DC	 ; If level is a vertical pipe maze type level, jump to PRG029_D5DC

	; Pipe transit for non-vertical levels
	;
	; This version is functionally limited in non-vertical levels 
	; such that only vertical runs of in-level transit pipes are
	; supported; none of the bends and such of a pipe maze level.
	;
	; But there is no Level_Tileset in the non-vertical realm that
	; has the graphics to support the bends and whatnot anyway, so
	; they clearly weren't planning on it...
	;
	; Further these pipes intend to bring you from the lowest scroll
	; point to the uppermost scroll point and visually act strangely
	; if you try to go somewhere short of that at either end.

	LDA #-2		 ; A = -2 (scroll upward)
	LDX #$01	 ; X = 1
	LDY <Player_YVel ; Y = Player_YVel
	BMI PRG029_D56F	 ; If Player_YVel < 0, jump to PRG029_D56F

	; If Player_Vel >= 0...
	LDA #$02	 ; A = 2 (scroll downward)
	DEX		 ; X = 0

PRG029_D56F:
	STA Pipe_TransYDelta	 ; Pipe_TransYDelta = -2 (going up) or 2 (going down)

	ADD <Vert_Scroll
	STA <Vert_Scroll 	; Vert_Scroll += A
	STA Level_VertScroll	; Level_VertScroll += A

	LDY <Player_YVel	; Y = Player_YVel
	BPL PRG029_D584	 	; If Player_YVel >= 0, jump to PRG029_D584

	BCS PRG029_D59B	 	; If carry occurred from addition to Vert_Scroll, jump to PRG029_D59B

	; Otherwise...

	; Inter-level vertical pipes stop moving upward when scroll reaches $00
	LDA #$00	 ; A = 0 
	BEQ PRG029_D58A	 ; Jump (technically always) to PRG029_D58A

PRG029_D584:
	CMP #$ef	 
	BLT PRG029_D59B	 ; If Vert_Scroll < $EF, jump to PRG029_D59B

	; Inter-level vertical pipes stop moving downward when scroll reaches $EF
	LDA #$ef	 ; Otherwise, A = $EF (bottom scroll)

PRG029_D58A:
	; Common termination point when exiting inter-level vertical pipe
	STA <Vert_Scroll ; Update Vert_Scroll

	LDA #$01
	STA Level_PipeExitDir	 ; Level_PipeExitDir = 1 (exiting up)

	LDY <Player_YVel
	BMI PRG029_D598	 	; If Player_YVel < 0, jump to PRG029_D598

	INC Level_PipeExitDir	 ; Otherwise, Level_PipeExitDir = 2 (exiting down)

PRG029_D598:
	JMP PRG008_A38E	 ; Jump to PRG008_A38E (Player exits pipe)

PRG029_D59B:
	; X = 0 (going down) or 1 (going up)

	LDA PipeTransit_YOff,X
	STA <Temp_Var10	 ; Temp_Var10 = PipeTransit_YOff[X] (appropriate Y offset)

	LDA #$08
	STA <Temp_Var11	 ; Temp_Var11 = 8

	JSR Player_GetTileAndSlope	; Get tile
	SUB #TILE1_PIPETB4_L	 	
	CMP #$02	 
	BLT PRG029_D5C3	 	; If tile is one of the transit pipe top/bottom tiles, jump to PRG029_D5C3 (RTS)

	LDA #16	 	; A = 16
 
	CPX #$00	 
	BEQ PRG029_D5B8	 ; If Player was going down, jump to PRG029_D5B8

	; Player was going up

	DEC <Player_YHi	 ; Player_YHi--
	LDA #-16	 ; A = 16

PRG029_D5B8:
	ADD <Player_Y	
	AND #$f0	
	STA <Player_Y	 ; Player_Y = (Player_Y + A) & $F0  (tile-aligned move)

	BCC PRG029_D5C3	 ; If no carry, jump to PRG029_D5C3

	INC <Player_YHi	 ; Otherwise, apply carry

PRG029_D5C3:
	RTS		 ; Return

	; Defines Y and X offset pairs, for two different rotation possibilities
	; when Player hits an elbow (does he go from up to right, or up to left? etc.)
	; Indexed per lower 2 bits of Level_PipeMove, shifted up by 2
PipeTransit_XYOffsets:
	;    YO1 XO1 YO2 XO2
	.byte 30, 18,  2, 18	; Moving right
	.byte 30,  2,  2,  2	; Moving left
	.byte 30, 14, 30,  2	; Moving up
	.byte  2, 14,  2,  2	; Moving down

	; This is actually access as a contiguous array, but might as well be clear
PipeTransit_YDelta:	.byte 2, -2	; Y Deltas while moving through pipes (down and up)
PipeTransit_XDelta:	.byte 2, -2	; X Deltas while moving through pipes (right and left)

	; Sets Level_PipeExitDir appropriately based on direction
Level_PipeExitDirTable:	.byte $03, $04, $02, $01

PRG029_D5DC:

	; Pipe transit in vertical levels

	LDA Level_PipeMove
	AND #$03	 ; Just the lower 2 bits of Level_PipeMove (the direction)
	PHA		 ; Save it

	TAY		 ; Y = the direction of Level_PipeMove

	LDX #$00	 		; Index Player's X

	CPY #$02
	BLS PRG029_D605	 ; If direction is right or left, jump to PRG029_D605

	; Direction is down or up

	LDX #(Player_Y - Player_X)	; Index Player's Y instead

	LDA PipeTransit_YDelta,Y	; Get delta
	BPL PRG029_D5FD	 		; If it's not negative, jump to PRG029_D5FD

	LDA <Player_SpriteY
	CMP #$68
	LDA #$00
	BLT PRG029_D608	 ; If Player_SpriteY < $68, jump to PRG029_D608

	DEC <Player_XHi,X ; Decrement approprate Player Hi
	JMP PRG029_D605	 ; Jump to PRG029_D605

PRG029_D5FD:
	LDA <Player_SpriteY
	CMP #$38	 
	LDA #$00	 
	BGE PRG029_D608	 ; If Player_SpriteY >= $38, jump to PRG029_D608

PRG029_D605:
	LDA PipeTransit_YDelta,Y 	; Get delta

PRG029_D608:
	ADD <Player_X,X		; Apply delta to Player X or Y (as appropriate)
	AND #$fe	 	; Align to nearest 2 pixels
	STA <Player_X,X	 	; Store it

	BCC PRG029_D613	 	; If no carry, jump to PRG029_D613

	INC <Player_XHi,X	; Otherwise, apply carry

PRG029_D613:
	AND #$0f	 ; Lower 4 bits of Player's X or Y
	TAX		 ; -> 'X'

	CPY #$02
	BLS PRG029_D651	 ; If direction is right or left, jump to PRG029_D651

	; Down or up

	LDA <Player_X
	AND #$f0
	ORA #$08
	STA <Player_X	 ; Player_X = (Player_X & $F0) | 8  (nearest column, centered)

	LDA #$01
	STA <Scroll_LastDir ; Scroll_LastDir = 1 (down)

	LDA PipeTransit_YDelta,Y	; Get delta
	BPL PRG029_D630	 		; If delta is not negative, jump to PRG029_D630

	; Negative delta means up, so...

	DEC <Scroll_LastDir	 ; Scroll_LastDir = 0 (up)
	DEC Level_VertScrollH	 ; Level_VertScrollH--

PRG029_D630:
	STA Pipe_TransYDelta	 ; Store into Pipe_TransYDelta
	ADD Level_VertScroll	
	STA Level_VertScroll	 ; Level_VertScroll += Pipe_TransYDelta
	BCC PRG029_D63F	 	; If no carry, jump to PRG029_D63F

	INC Level_VertScrollH	 ; Otherwise, apply carry

PRG029_D63F:
	LDY Level_VertScrollH	 ; Y = Level_VertScrollH

	JSR LevelJct_GetVScreenH ; Adjust coordinates for vertical

	; Update scrolls
	STA <Vert_Scroll
	STY <Vert_Scroll_Hi

	LDA <Player_Y
	SUB Level_VertScroll
	STA <Player_SpriteY	 ; Player_SpriteY = relative Y position

PRG029_D651:
	PLA		 ; Restore the lower 2 bits of Level_PipeMove (the direction)

	; 'X' was last left as lower 4 bits of Player's X or Y position
	; (i.e. distance across cell horizontally or vertically; a value
	; of zero indicates Player has just aligned with a new tile)
	CPX #$00
	BNE PRG029_D69B	 ; If Player has not reached a new tile, jump to PRG029_D69B

	; Player has reached a new tile...

	ASL A
	ASL A		 ; direction of pipe move, shifted left 2

	LDX #$01	 ; X = 1

	TAY		 ; Y = the direction of the pipe move, shifted left 2 (0, 4, 8, 12)

PRG029_D65B:
	LDA PipeTransit_XYOffsets,Y
	STA <Temp_Var10	 ; Temp_Var10 = Y offset

	LDA PipeTransit_XYOffsets+1,Y
	STA <Temp_Var11	 ; Temp_Var11 = X offset

	JSR Player_GetTileAndSlope	; Get tile
	STA <Temp_Var1		 ; Store into Temp_Var1

	SUB #TILE8_SCENPIPE_ENDVR
	CMP #$02	
	BGE PRG029_D674	 ; If tile is NOT a vertical scenery pipe's left or right end, jump to PRG029_D674

	JMP PRG029_D69C	 ; Otherwise, jump to PRG029_D69C

PRG029_D674:
	LDA <Temp_Var1	 
	CMP #TILE8_SCENPIPE_ENDH1B
	BNE PRG029_D67D	 ; If tile is NOT a horizontal scenery pipe's bottom tile, jump to PRG029_D67D

	JMP PRG029_D69C	 ; Otherwise, jump to PRG029_D69C

PRG029_D67D:
	LDA <Temp_Var1
	SUB #TILE8_PIPEELBOW_CUL
	CMP #$04	 
	BGE PRG029_D696	 ; If tile is NOT a pipe elbow corner tile, jump to PRG029_D696

	; Otherwise...
	STX <Temp_Var1	 	; Temp_Var1 = 1 OR 0 (depending which iteration, which will change which way it rotates)
	LDA Level_PipeMove
	AND #%10000010		; Keep only the up/down vs left/right bit and the "in-transit" bit
	EOR #%00000010		; Turn corner 
	ORA <Temp_Var1		; -> Temp_Var1

	STA Level_PipeMove	; Update Level_PipeMove
	LDX #$00	 	; X = 0

PRG029_D696:
	INY		 ; Y++
	INY		 ; Y++ (next Y/X offset pair)

	DEX		 ; X-- (if Player turned corner, this will result in a negative)
	BPL PRG029_D65B	 ; If X >= 0, loop!

PRG029_D69B:
	RTS		 ; Return


PRG029_D69C:

	; In-transit pipe, hit an end

	LDA Level_PipeMove
	AND #%00000011	 
	TAY		 	; Y = lower 2 bits of Level_PipeMove (the direction)
	BNE PRG029_D6AB	 	; If direction is not rightward, jump to PRG029_D6AB

	; Otherwise, add 16 to Player_X
	LDA <Player_X
	ADD #16
	STA <Player_X

PRG029_D6AB:

	; Set Level_PipeExitDir appropriately
	LDA Level_PipeExitDirTable,Y
	STA Level_PipeExitDir

	JMP PRG008_A38E	 ; Jump to PRG008_A38E

Player_Die_JumpTable:
	.word Player_Die_NotDying	; 0 - Player isn't dying!  Do nothing
	.word Player_Die_Dying		; 1 - Dying normal
	.word Player_Die_FellOff	; 2 - Dying by having fallen off screen
	.word Player_Die_TimeUp		; 3 - Dying due to time up

PRG029_D6BC:
	; Player is dying!

	LDA <Player_IsDying
	ASL A		 
	TAY		 ; Y = Player_IsDying << 1

	LDA Player_Die_JumpTable,Y
	STA <Temp_Var1
	LDA Player_Die_JumpTable+1,Y
	STA <Temp_Var2

	JMP [Temp_Var1]	 ; Jump to appropriate "Player is dying" routine...

Player_Die_Dying:
	LDA Player_AboveTop
	BNE PRG029_D6DA	 ; If Player is above top of screen, jump to PRG029_D6DA

	LDA <Player_SpriteY
	AND #$f0
	CMP #$b0
	BEQ PRG029_D6E5	 ; If Player_SpriteY >= $B0 && Player_SpriteY <= $BF (Player is halfway below status bar), jump to PRG029_D6E5

PRG029_D6DA:
	LDA Event_Countdown
	BNE PRG029_D6E2	 ; If Event_Countdown <> 0 (time until drop to map), jump to PRG029_D6E2
	JMP PRG029_D768	 ; Otherwise, jump to PRG029_D6E2

PRG029_D6E2:
	JMP PRG029_D771	 ; Jump to PRG029_D771 if Event_Countdown <> 0

PRG029_D6E5:
	LDA Event_Countdown
	BNE PRG029_D6EF	; If Event_Countdown > 0 (time until drop to map), jump to PRG029_D6EF

	; Reload Event_Countdown
	LDA #64
	STA Event_Countdown	; Event_Countdown = 64

PRG029_D6EF:
	CMP #$01
	BNE PRG029_D6F5	 ; If Event_Countdown <> 1, jump to PRG029_D6F5 (RTS)
	BEQ PRG029_D6FB	 ; If Event_Countdown = 1, jump to PRG029_D6FB

PRG029_D6F5:
	RTS		 ; Return


Player_Die_FellOff:
	LDA Event_Countdown
	BNE PRG029_D702	 ; If Event_Countdown <> 0, jump to PRG029_D702 (RTS)

PRG029_D6FB:
	INC <Level_ExitToMap	; Level_ExitToMap = 1

	LDA #$01
	STA Map_ReturnStatus	 ; Map_ReturnStatus = 1 (Player died, level is not clear)

PRG029_D702:
	RTS		 ; Return

	; Patterns for TIME-UP
TIMEUP_Sprites:
	.byte $21	; T
	.byte $23	; I
	.byte $25	; M
	.byte $27	; E
	.byte $29	; -
	.byte $1D	; U
	.byte $1F	; P

	; X positions for each letter in TIME-UP
TIMEUP_SpriteXs:
	.byte $60, $68, $70, $78, $80, $88, $90

Player_Die_TimeUp:
	LDA Player_AboveTop
	BNE PRG029_D71E	 ; If Player is off top of screen, jump to PRG029_D71E
	
	LDA <Player_SpriteY
	AND #$f0
	CMP #$b0
	BEQ PRG029_D729	 ; If Player_SpriteY >= $B0 && Player_SpriteY <= $BF (Player is halfway below status bar), jump to PRG029_D729

PRG029_D71E:
	LDA Event_Countdown
	BNE PRG029_D726	 ; If Event_Countdown <> 0, jump to PRG029_D726

	JMP PRG029_D768	 ; Jump to PRG029_D768

PRG029_D726:
	JMP PRG029_D771	 ; Jump to PRG029_D768 if Event_Countdown <> 0

PRG029_D729:
	DEC <Pipe_PlayerY	; Pipe_PlayerY--

	LDA <Pipe_PlayerX
	CMP #$60
	BLT PRG029_D73B	 ; If Pipe_PlayerX < $60, jump to PRG029_D73B

	ADD <Pipe_PlayerY
	STA <Pipe_PlayerX	; Pipe_PlayerX += Pipe_PlayerY

	LDA #112
	STA Event_Countdown	 ; Event_Countdown = 112

PRG029_D73B:
	LDA Event_Countdown
	BEQ PRG029_D6FB	 ; If Event_Countdown = 0, jump to PRG029_D6FB

	LDA #$32
	STA PatTable_BankSel+2	 ; Set sprites 1/4 VROM page for the TIME UP sprites

	LDY #$06	 ; Y = 6 (seven sprites for T I M E - U P)
	LDX Player_SprOff	 ; Starting from Player's sprite offset
PRG029_D74A:
	LDA <Pipe_PlayerX
	STA Sprite_RAM+$00,X

	LDA TIMEUP_Sprites,Y
	STA Sprite_RAM+$01,X

	LDA #$01
	STA Sprite_RAM+$02,X

	LDA TIMEUP_SpriteXs,Y
	STA Sprite_RAM+$03,X

	INX
	INX
	INX
	INX
	DEY		; Y--
	BPL PRG029_D74A	 ; While Y >= 0, loop

	RTS		 ; Return

PRG029_D768:
	; Player gravity while dying
	INC <Player_YVel
	INC <Player_YVel ; Player_YVel += 2

	LDX #$00	 ; X = 0 (?)

	JSR Player_ApplyYVelocity	 ; Applies Player's Y velocity

PRG029_D771:
	LDA #PF_DIE
	STA <Player_Frame ; Player_Frame = PF_DIE

	JSR Player_Draw	 ; Draw Player
	RTS		 ; Return


	; Move Player left/right within pipe
PipeMove_LeftRight:
	LDA Level_PipeMove 
	AND #$01	 ; Just determining left or right (see def for Level_PipeMove)
	TAY		 ; Y = 0 (right) or 1 (left) 

	LDA PipeMove_XVel,Y	 	; Get appropriate X velocity
	STA <Player_XVel	 	; Set it!

	JSR Player_ApplyXVelocity 	; Apply Player's X velocity

	; A little "step up" into the pipe
	DEC <Player_Y
	DEC <Player_Y	 ; Player_Y -= 2

	LDA <Counter_1
	AND #$0c	
	LSR A		
	LSR A		 
	STA <Temp_Var1	 ; Temp_Var1 = (Counter_1 & $C) >> 2 (0 to 3, walking animation)

	JSR PRG029_D47E	 ; Do walking animation and draw Player

	; Undo "step up"
	INC <Player_Y
	INC <Player_Y	 ; Player_Y += 2

	RTS		 ; Return


	; Move Player up/down within pipe
PipeMove_UpDown:
	LDA Level_PipeMove
	AND #$01	 ; Just determining up or down (see def for Level_PipeMove)
	TAY		 ; Y = 0 (down) or 1 (up)

	LDA PipeMove_YVel,Y	 	; Get appropriate Y velocity
	STA <Player_YVel	 	; Set it!

	JSR Player_ApplyYVelocity	; Apply Player's Y velocity

	JSR PipeMove_SetPlayerFrame	; Set appropriate frame for pipe traversal
	JMP Player_Draw	 		; Jump to draw Player!

Player_StopMovement:
	LDA #$00
	STA Level_PipeMove	; Not moving through a pipe
	STA <Player_XVel	; Player stopped horizontall
	STA <Player_YVel	; Player stopped vertically
	STA <Player_InAir	; Not mid-air
	RTS		 ; Return

SuitLost_Poof_Patterns:
	.byte $47, $45, $43, $41

Player_SuitLost_DoPoof:
	DEC Player_SuitLost	; Player_SuitLost-- 
	AND #$0c
	LSR A	
	LSR A	
	TAY		 ; Y = 0-3, changing every 4 ticks

	LDA SuitLost_Poof_Patterns,Y	; Get poof pattern
	STA <Temp_Var2		 ; Store into Temp_Var2

	LDY Player_SprOff	 ; Y = Player_SprOff (Player sprite beginning offset)

	LDA #%11000001	; Flipped horizontal and vertical, and palette 1
	STA <Temp_Var1	; -> Temp_Var1

PRG029_D7D3:
	; Sprite Y
	LDA <Player_SpriteY
	ADD #$08	 	; Start at 8 pixels below Player sprite Y pos
	STA Sprite_RAM+$00,Y	 ; Store into sprite Y

	; Poof pattern
	LDA <Temp_Var2
	STA Sprite_RAM+$01,Y

	; Attribute
	LDA <Temp_Var1
	STA Sprite_RAM+$02,Y

	; Sprite X
	LDA <Player_X
	SUB <Horz_Scroll
	STA Sprite_RAM+$03,Y

	LDA <Temp_Var1
	AND #$f0	
	BEQ PRG029_D7FC	 ; If we're the unflipped one, jump to PRG029_D7FC

	; Otherwise, put it to the right of the first one
	LDA Sprite_RAM+$03,Y
	ADD #$08	
	STA Sprite_RAM+$03,Y

PRG029_D7FC:
	INY
	INY
	INY
	INY		 ; Y += 4

	; Other sprite is not H/V flipped
	LDA <Temp_Var1
	SUB #%11000000
	STA <Temp_Var1

	BCS PRG029_D7D3	 ; Loop if not the second sprite

	RTS		 ; Return

	;; BEGIN HUGE UNUSED SPACE

	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D80A - $D819
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D81A - $D829
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D82A - $D839
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D83A - $D849
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D84A - $D859
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D85A - $D869
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D86A - $D879
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D87A - $D889
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D88A - $D899
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D89A - $D8A9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D8AA - $D8B9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D8BA - $D8C9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D8CA - $D8D9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D8DA - $D8E9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D8EA - $D8F9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D8FA - $D909
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D90A - $D919
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D91A - $D929
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D92A - $D939
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D93A - $D949
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D94A - $D959
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D95A - $D969
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D96A - $D979
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D97A - $D989
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D98A - $D999
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D99A - $D9A9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D9AA - $D9B9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D9BA - $D9C9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D9CA - $D9D9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D9DA - $D9E9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D9EA - $D9F9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $D9FA - $DA09
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA0A - $DA19
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA1A - $DA29
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA2A - $DA39
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA3A - $DA49
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA4A - $DA59
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA5A - $DA69
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA6A - $DA79
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA7A - $DA89
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA8A - $DA99
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DA9A - $DAA9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DAAA - $DAB9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DABA - $DAC9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DACA - $DAD9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DADA - $DAE9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DAEA - $DAF9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DAFA - $DB09
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB0A - $DB19
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB1A - $DB29
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB2A - $DB39
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB3A - $DB49
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB4A - $DB59
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB5A - $DB69
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB6A - $DB79
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB7A - $DB89
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB8A - $DB99
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DB9A - $DBA9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DBAA - $DBB9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DBBA - $DBC9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DBCA - $DBD9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DBDA - $DBE9
	.byte $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF ; $DBEA - $DBF9
	.byte $FF, $FF, $FF, $FF, $FF, $FF  ; $DBFA - $DBFF

	;; END HUGE UNUSED SPACE


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BlockChange_Do
;
; Performs a Block Change command, if one is needed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BlockChange_Do:
	LDA Level_7Vertical	 
	BEQ PRG029_DC36	 ; If level is not vertical, jump to PRG029_DC36

	; Vertical level only...

	; Fix Block Change Y coordinates for vertical world
	LDA Level_BlockChgYLo
	LDY Level_BlockChgYHi
	JSR LevelJct_GetVScreenH
	STA Level_BlockChgYLo
	STY Level_BlockChgYHi

	; Get tile here
	LDA Tile_Mem_AddrVL,Y
	STA <Map_Tile_AddrL
	LDA Tile_Mem_AddrVH,Y
	STA <Map_Tile_AddrH

	; Temp_Var6 = block change screen Y aligned to grid
	LDA Level_BlockChgYLo
	AND #$f0
	STA <Temp_Var6

	; Build row/column offset value -> Temp_Var5
	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	; Temp_Var7 = 0
	LDA #$00
	STA <Temp_Var7

	BEQ PRG029_DC7C	 ; Jump (technically always) to PRG029_DC7C

PRG029_DC36:

	; Non-vertical level only...

	LDA Level_BlockChgXHi
	ASL A		 ; Multiply by 2 (2 byte index per Tile_Mem_Addr)
	TAX		 ; -> 'X'

	; Set address in tile memory to Map_Tile_AddrL/H
	LDA Tile_Mem_Addr,X
	STA <Map_Tile_AddrL
	LDA Tile_Mem_Addr+1,X
	STA <Map_Tile_AddrH

	; Temp_Var7 = 0
	LDA #$00
	STA <Temp_Var7

	LDA Level_BlockChgYHi
	BEQ PRG029_DC50	 ; If block change is not on the lower part of the screen, jump to PRG029_DC50

	INC <Map_Tile_AddrH	; Otherwise, jump to lower screen address

PRG029_DC50:

	; Construct a row/column offset -> Temp_Var5
	LDA Level_BlockChgYLo
	AND #$f0
	STA <Temp_Var6
	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A
	LSR A
	ORA <Temp_Var6
	STA <Temp_Var5

	LDA Level_BlockChgYHi
	BNE PRG029_DC70	 ; If Level_BlockChgYHi <> 0 (block change is down low on the lower screen space), jump to PRG029_DC70

	; Block change is on upper screen space... 

	LDA Level_BlockChgYLo
	AND #$f0	 ; Align to grid
	CMP #$f0
	BNE PRG029_DC7C	 ; If not TOO low, jump to PRG029_DC7C

PRG029_DC70:

	; Block is on upper part of screen but at the 240 line
	; This logic calculates an alternate address because the code that actually
	; applies the tile change needs to have a 32 byte jump to the next line,
	; and use $F0 would overflow back to $10 and misalign the tile change!!

	; Temp_Var6 = 0-ish
	LDA Level_BlockChgYLo
	ADD #$10
	STA <Temp_Var6

	; Temp_Var7 = 1 (carry)
	LDA #$01
	STA <Temp_Var7

PRG029_DC7C:
	LDA Level_ChgTileEvent
	BNE PRG029_DC82	 ; If Level_ChgTileEvent <> 0, jump to PRG029_DC82

	; Otherwise, do nothing... seems like they should've checked for
	; this BEFORE bothering with all those calculations!  :)

	RTS		 ; Return

PRG029_DC82:
	JSR DynJump

	; THESE MUST FOLLOW DynJump FOR THE DYNAMIC JUMP TO WORK!!
	.word TileChng_DoNothing	; $00 - NOT USED (Level_ChgTileEvent = 0 not valid)
	.word TileChng_OneTile		; $01 - CHNGTILE_DELETECOIN
	.word TileChng_OneTile		; $02 - CHNGTILE_DELETETOBG
	.word TileChng_OneTile		; $03 - CHNGTILE_TOGNOTEBLOCK
	.word TileChng_OneTile		; $04 - CHNGTILE_TOBOUNCEWOOD
	.word TileChng_OneTile		; $05 - CHNGTILE_TONOTEBLOCK
	.word TileChng_OneTile		; $06 - CHNGTILE_COINHEAVEN
	.word TileChng_OneTile		; $07 - CHNGTILE_TOBRICK
	.word TileChng_OneTile		; $08 - CHNGTILE_TOMETALPLATE
	.word TileChng_OneTile		; $09 - CHNGTILE_PSWITCHSTOMP
	.word TileChng_OneTile		; $0A (Change to Fortress light cable??)
	.word TileChng_OneTile		; $0B - CHNGTILE_TOBRICKCOIN
	.word TileChng_OneTile		; $0C - CHNGTILE_DELETETOBGALT (not sure about this one)
	.word TileChng_OneTile		; $0D - not different from $02??
	.word TileChng_OneTile		; $0E (Spikes??)
	.word TileChng_OneTile		; $0F - CHNGTILE_DELETEDONUT
	.word TileChng_OneTile		; $10 - CHNGTILE_FROZENMUNCHER
	.word TileChng_OneTile		; $11 - CHNGTILE_FROZENCOIN
	.word TileChng_OneTile		; $12 - CHNGTILE_PSWITCHAPPEAR
	.word TileChng_DoorAppear	; $13 - CHNGTILE_DOORAPPEAR
	.word TileChng_ToadBoxOpen	; $14 - CHNGTILE_TOADBOXOPEN
	.word ChngTile_32x32		; $15 - CHNGTILE_4WAYCANNON
	.word ChngTile_32x32		; $16 - GiantBlock_BrickBust
	.word ChngTile_32x32		; $17 - GiantBlock_BlockHit
	.word ChngTile_32x32		; $18 - GiantBlock_BrickRestore


	; Tile to "change to"; just for updating the level grid
	; NOTES: 
	; TILE2_HANGGLOBE_CABLE -- only tile that made visual sense as a standalone ??
	; TILE9_PIPEWORKS_CRACK -- not sure about this one
	; TILE2_SPIKEUP -- only tile that made visual sense as a standalone ??
OneTile_ChangeToTile:
	.byte TILEA_COINREMOVED, TILE1_SKY, TILEA_GNOTE, TILEA_WOODBLOCKBOUNCE
	.byte TILEA_NOTE, TILEA_HNOTE, TILEA_BRICK, TILEA_BLOCKEMPTY
	.byte TILEA_PSWITCH_PRESSED, TILE2_HANGGLOBE_CABLE, TILEA_BRICKCOIN, TILE9_PIPEWORKS_CRACK
	.byte TILE1_SKY, TILE2_SPIKEUP, TILE2_DONUTLIFT, TILE4_MUNCHER, TILEA_COIN, TILEA_PSWITCH

	; Defines each of the four 8x8 patterns that make up the tile
	; Too bad Nintendo couldn't keep things like this in one spot :)
OneTile_ChangeToPatterns:
	.byte $05, $07, $06, $08	; $01 - CHNGTILE_DELETECOIN
	.byte $05, $07, $06, $08	; $02 - CHNGTILE_DELETETOBG
	.byte $B8, $BA, $B9, $BB	; $03 - CHNGTILE_TOGNOTEBLOCK
	.byte $C0, $C2, $C1, $C3	; $04 - CHNGTILE_TOBOUNCEWOOD
	.byte $B8, $BA, $B9, $BB	; $05 - CHNGTILE_TONOTEBLOCK
	.byte $B8, $BA, $B9, $BB	; $06 - CHNGTILE_COINHEAVEN
	.byte $B4, $B6, $B5, $B7	; $07 - CHNGTILE_TOBRICK
	.byte $D8, $DA, $D9, $DB	; $08 - CHNGTILE_TOMETALPLATE
	.byte $FF, $FF, $E6, $E7	; $09 - CHNGTILE_PSWITCHSTOMP
	.byte $60, $61, $6D, $6F	; $0A
	.byte $B4, $B6, $B5, $B7	; $0B - CHNGTILE_TOBRICKCOIN
	.byte $52, $50, $62, $60	; $0C - CHNGTILE_DELETETOBGALT
	.byte $05, $07, $06, $08	; $0D
	.byte $18, $1A, $19, $1B	; $0E
	.byte $5C, $5E, $5D, $5F	; $0F - CHNGTILE_DELETEDONUT
	.byte $92, $CA, $93, $CB	; $10 - CHNGTILE_FROZENMUNCHER
	.byte $DC, $DE, $DD, $DF	; $11 - CHNGTILE_FROZENCOIN
	.byte $E0, $E2, $E1, $E3	; $12 - CHNGTILE_PSWITCHAPPEAR


TileChng_OneTile:
	LDX Level_ChgTileEvent
	DEX		 ; X = Level_ChgTileEvent - 1 (because zero is no-action)

	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	; Change the tile to the proper target tile
	LDA OneTile_ChangeToTile,X
	STA [Map_Tile_AddrL],Y

	; X *= 4 (index into OneTile_ChangeToPatterns)
	TXA
	ASL A
	ASL A
	TAX

	LDY #$00	 ; Y = 0
PRG029_DD22:
	LDA OneTile_ChangeToPatterns,X	 ; Get pattern
	STA TileChng_Pats,Y	 ; Copy into TileChng_Pats

	INX		 ; X++ (next pattern)
	INY		 ; Y++ (count of patterns)
	CPY #$04
	BNE PRG029_DD22	 ; While Y < 4, loop!

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00001111	 ; Only keep lower 4 bits (bits 2 and 3 are still zero)
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7
	BEQ PRG029_DD41	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DD41

	ORA #$08	 ; Set $28 high address

PRG029_DD41:
	STA TileChng_VRAM_H	 ; Store the high byte of the tile change base address

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	STA <Temp_Var2	; -> Temp_Var2

	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A		; A = Level_BlockChgXLo / 8
	ORA <Temp_Var2	
	STA TileChng_VRAM_L	 ; Store the low byte of the tile change base address

	; Level_ChgTileEvent = 0 (we handled it)
	LDA #$00
	STA Level_ChgTileEvent

TileChng_DoNothing:
	RTS		 ; Return

TileChng_DoorBufCmds:
	; First two bytes for both are to-be-determined VRAM addres
	.byte $00, $00, VU_VERT | VU_REPEAT | 4, $FC	; Left 4 patterns of door
	.byte $00, $00, VU_VERT | VU_REPEAT | 4, $FC	; Right 4 patterns of door
	.byte $00	; Terminator
TileChng_DoorBufCmds_End

TileChng_DoorAppear:

	; Level_ChgTileEvent = 0 (we're handling it)
	LDA #$00
	STA Level_ChgTileEvent

	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	; Set upper tile of door
	LDA #TILEA_DOOR1
	STA [Map_Tile_AddrL],Y

	; +16 (next row of tiles)
	TYA
	ADD #16
	TAY

	BCC PRG029_DD77	 ; If no carry, jump to PRG029_DD77

	INC <Map_Tile_AddrH	; Apply carry

PRG029_DD77:

	; Set lower tile of door
	LDA #TILEA_DOOR1
	STA [Map_Tile_AddrL],Y

	LDY #$00	 ; Y = 0

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

PRG029_DD80:
	LDA TileChng_DoorBufCmds,Y	; Get next command byte
	STA Graphics_Buffer,X	 	; Store into graphics buffer

	INX		 ; X++ (one more byte in the graphics buffer)
	INY		 ; Y++ (next command byte)

	CPY #(TileChng_DoorBufCmds_End - TileChng_DoorBufCmds)
	BNE PRG029_DD80	; While more to commit, loop!

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00001111	 ; Only keep lower 4 bits (bits 2 and 3 are still zero)
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7
	BEQ PRG029_DDA2	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DDA2

	ORA #$08	 ; Set $28 high address

PRG029_DDA2:

	; Commit high addresses to graphics buffer
	STA Graphics_Buffer,X
	STA Graphics_Buffer+$04,X

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	STA <Temp_Var2	; -> Temp_Var2

	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A		; A = Level_BlockChgXLo / 8
	ORA <Temp_Var2	

	; Set low address for left column of patterns of door
	STA Graphics_Buffer+$01,X

	ADD #$01	 ; Next column of door

	; Set low address for right column of patterns of door
	STA Graphics_Buffer+$05,X

	; Add array size -1 to graphics buffer count
	LDA Graphics_BufCnt
	ADD #(TileChng_DoorBufCmds_End - TileChng_DoorBufCmds - 1)
	STA Graphics_BufCnt

	RTS		 ; Return

TileChng_ToadBoxBufCmds:
	; First two bytes for both are to-be-determined VRAM addres
	.byte $00, $00, $04, $50, $51, $52, $53	; Chest top patterns
	.byte $00, $00, $04, $54, $55, $56, $57	; Chest bottom patterns
	.byte $00	; Terminator
TileChng_ToadBoxBufCmds_End

TileChng_ToadBoxOpen:
	; Level_ChgTileEvent = 0 (we're handling it)
	LDA #$00
	STA Level_ChgTileEvent

	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	; Chest open tile upper left
	LDA #TILE7_CHEST_OPEN_UL
	STA [Map_Tile_AddrL],Y

	INY		 ; Y++

	; Chest open tile upper right
	LDA #TILE7_CHEST_OPEN_UR
	STA [Map_Tile_AddrL],Y


	LDY #$00	 ; Y = 0

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

PRG029_DDEC:
	LDA TileChng_ToadBoxBufCmds,Y	; Get next command byte
	STA Graphics_Buffer,X	 	; Store into graphics buffer

	INX		 ; X++ (one more byte in the graphics buffer)
	INY		 ; Y++ (next command byte)

	CPY #(TileChng_ToadBoxBufCmds_End - TileChng_ToadBoxBufCmds)
	BNE PRG029_DDEC	; While more to commit, loop!

	LDX Graphics_BufCnt	 ; X = Graphics_BufCnt

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00001111	 ; Only keep lower 4 bits (bits 2 and 3 are still zero)
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7
	BEQ PRG029_DE0E	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DE0E

	ORA #$08	 ; Set $28 high address

PRG029_DE0E:

	; Commit high addresses to graphics buffer
	STA Graphics_Buffer,X
	STA Graphics_Buffer+$07,X

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	STA <Temp_Var2	; -> Temp_Var2

	LDA Level_BlockChgXLo
	LSR A
	LSR A
	LSR A		; A = Level_BlockChgXLo / 8
	ORA <Temp_Var2	

	; Set low address for first row of open chest patterns
	STA Graphics_Buffer+$01,X

	ADD #32		; +32 to next row

	; Set low address for second row of open chest patterns
	STA Graphics_Buffer+$08,X

	; Add array size -1 to graphics buffer count
	LDA Graphics_BufCnt
	ADD #(TileChng_ToadBoxBufCmds_End - TileChng_ToadBoxBufCmds - 1)
	STA Graphics_BufCnt

	RTS		 ; Return

	; Change Big Buffer Command offset
CBIG_BCOff .func \1 - Chng4Way_90Degrees

	; Get initial offset to proper set of commands to be used
CBig_Offsets:
	.byte CBIG_BCOff(Chng4Way_90Degrees)	; 4-way cannon at 90 degrees
	.byte CBIG_BCOff(Chng4Way_45Degrees)	; 4-way cannon at 45 degrees

	.byte CBIG_BCOff(CBig_GiantBlock_BrickBust)	; GiantBlock_BrickBust
	.byte CBIG_BCOff(CBig_GiantBlock_BlockHit)	; GiantBlock_BlockHit
	.byte CBIG_BCOff(CBig_GiantBlock_BrickRestore)	; GiantBlock_BrickRestore

Chng4Way_90Degrees:
	.byte $00, $00, $04, $FF, $A6, $A7, $FF
	.byte $00, $00, $04, $8D, $B2, $BC, $8D
	.byte $00, $00, $04, $9D, $B3, $BD, $9D
	.byte $00, $00, $04, $FF, $AE, $AF, $FF
	.byte $00

Chng4Way_45Degrees:
	.byte $00, $00, $04, $09, $28, $36, $49
	.byte $00, $00, $04, $EC, $ED, $EE, $EF
	.byte $00, $00, $04, $E8, $E9, $EA, $EB
	.byte $00, $00, $04, $F8, $F9, $FA, $FB
	.byte $00

CBig_GiantBlock_BrickBust:
	.byte $00, $00, $04, $05, $07, $05, $07
	.byte $00, $00, $04, $06, $08, $06, $08
	.byte $00, $00, $04, $05, $07, $05, $07
	.byte $00, $00, $04, $06, $08, $06, $08
	.byte $00

CBig_GiantBlock_BlockHit:
	.byte $00, $00, $04, $04, $0D, $0D, $0E
	.byte $00, $00, $04, $24, $FE, $FE, $27
	.byte $00, $00, $04, $24, $FE, $FE, $27
	.byte $00, $00, $04, $34, $48, $48, $37
	.byte $00

CBig_GiantBlock_BrickRestore:
	.byte $00, $00, $04, $00, $01, $02, $03
	.byte $00, $00, $04, $10, $11, $12, $10
	.byte $00, $00, $04, $20, $21, $22, $23
	.byte $00, $00, $04, $30, $31, $32, $33
	.byte $00

CBIG_BCSize = Chng4Way_45Degrees - Chng4Way_90Degrees

PRG029_DECA:
	.byte $96, $92

CBig_ChngTiles:
	.byte TILE10_4WAYCANNON_90_UL, TILE10_4WAYCANNON_90_UR, TILE10_4WAYCANNON_90_LL, TILE10_4WAYCANNON_90_LR ; 4-way cannon 90 degrees
	.byte TILE10_4WAYCANNON_45_UL, TILE10_4WAYCANNON_45_UR, TILE10_4WAYCANNON_45_LL, TILE10_4WAYCANNON_45_LR ; 4-way cannon 45 degrees
	.byte TILE11_SKY, TILE11_SKY, TILE11_SKY, TILE11_SKY	; Giant World brick bust tile clear
	.byte TILE11_METAL_UL, TILE11_METAL_UR, TILE11_METAL_LL, TILE11_METAL_LR	; Giant World [?] block hit
	.byte TILE11_BRICK_UL, TILE11_BRICK_UR, TILE11_BRICK_LL, TILE11_BRICK_LR	; Giant World brick bump


ChngTile_32x32:
	LDX #$00	; X = 0

	LDA Level_ChgTileEvent
	CMP #CHNGTILE_4WAYCANNON
	BNE PRG029_DEF3	 ; If this is not the 4-way cannon change, jump to PRG029_DEF3

	; 4-way cannon change only...

	LDY <Temp_Var5	 ; Y = Temp_Var5 (row/column offset value)

	LDA [Map_Tile_AddrL],Y	 ; Get tile currently here
	CMP #TILE10_4WAYCANNON_45_UL
	BEQ PRG029_DEF9	 ; If cannon is at 45 degree position, jump to PRG029_DEF9
	BNE PRG029_DEF8	 ; Otherwise, jump to PRG029_DEF8

PRG029_DEF3:

	; Not the 4-way cannon...
	SUB #CHNGTILE_GIANTBRICKBUST	; Make relative
	TAX		 ; -> 'X'
	INX		 ; X++

PRG029_DEF8:
	INX		 ; X++ (X = 1 for 4-way cannon, 2+ for the others)

PRG029_DEF9:
	LDY CBig_Offsets,X	 ; Y = initial command offset

	STX <Temp_Var11		 ; Temp_Var11 = X (index into CBig_Offsets)

	LDX Graphics_BufCnt	 ; X = graphics buffer count

	; Temp_Var1 = total number of bytes we're going to copy (CBIG_BCSize)
	LDA #CBIG_BCSize
	STA <Temp_Var1

PRG029_DF05:
	LDA Chng4Way_90Degrees,Y	; Get next command byte
	STA Graphics_Buffer,X	 	; Store into graphics buffer

	INX		 ; X++ (one more byte in the graphics buffer)
	INY		 ; Y++ (next command byte)

	DEC <Temp_Var1	 ; Temp_Var1--
	BNE PRG029_DF05	 ; While Temp_Var1 > 0, loop!

	; Temp_Var11 (index into CBig_Offsets) multiplied by 4
	LDA <Temp_Var11
	ASL A
	ASL A
	STA <Temp_Var11

	; Temp_Var3 = 0
	LDA #$00
	STA <Temp_Var3

PRG029_DF1B:
	LDA <Temp_Var5	; A = Temp_Var5 (row/column offset value)
	AND #$f0	; Just keep the row part

	LDY <Temp_Var7	; Y = Temp_Var7
	BEQ PRG029_DF26	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DF26

	ADD #$10	 ; Next row

PRG029_DF26:
	STA <Temp_Var6	 ; -> Temp_Var6

	LDA <Temp_Var5	; A = Temp_Var5 (row/column offset value)
	AND #$0f	; Just keep the column part
	ASL A		; Multiply by 2
	STA <Temp_Var8	; -> Temp_Var8

	LDA <Temp_Var6	 ; Get tile Y (aligned to grid, so bits 0-3 are zero)
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0
	ASL A		 ; Bit 7 -> carry
	ADC #$00	 ; Set as bit 0 (result: Former bit 6-7 are now bit 0-1)
	PHA		 ; Save this value

	AND #%00000011	 ; Only keep lower 2 bits
	ORA #$20	 ; Set high part of video address

	LDY <Temp_Var7	; Y = Temp_Var7
	BEQ PRG029_DF42	 ; If Temp_Var7 not set (set if tile was on the fringe between upper and lower screen space), jump to PRG029_DF42

	ORA #$08	 ; Set $28 high address

PRG029_DF42:
	STA <Temp_Var9	 ; -> Temp_Var9

	LDX #$00	 ; X = 0

	LDA <Temp_Var3
	BEQ PRG029_DF4C	 ; If Temp_Var3 = 0 (loop first pass), jump to PRG029_DF4C

	LDX #$0e	 ; Otherwise, X = $0E

PRG029_DF4C:

	; X += current graphics buffer count
	TXA
	ADD Graphics_BufCnt
	TAX

	; Commit high addresses to graphics buffer
	LDA <Temp_Var9
	STA Graphics_Buffer,X
	STA Graphics_Buffer+$07,X

	PLA		; Restore value from before
	AND #%11110000	; Keep the upper 4 bits
	ORA <Temp_Var8	; The column value
	STA <Temp_Var4	; -> Temp_Var4

	; Set low address in graphics buffer
	STA Graphics_Buffer+$01,X

	ADD #32		; +32 is next row

	; Set low address in graphics buffer
	STA Graphics_Buffer+$08,X

	LDY <Temp_Var5	 ; Y = Temp_Var5
	LDX <Temp_Var11	 ; X = Temp_Var11

	LDA CBig_ChngTiles,X	 ; Get tile 
	STA [Map_Tile_AddrL],Y	 ; Set tile
	INY		 ; Next column
	LDA CBig_ChngTiles+1,X	 ; Get tile
	STA [Map_Tile_AddrL],Y	 ; Set tile

	; Temp_Var5 += 16 (next tile row)
	LDA <Temp_Var5
	ADD #16
	STA <Temp_Var5

	; Apply carry if needed
	LDA <Map_Tile_AddrH
	ADC #$00
	STA <Map_Tile_AddrH

	; Temp_Var11 += 2
	INC <Temp_Var11
	INC <Temp_Var11

	INC <Temp_Var3	; Temp_Var3++

	LDA <Temp_Var3
	CMP #$02
	BNE PRG029_DF1B	 ; While Temp_Var3 < 2, loop!

	; Add array size -1 to graphics buffer count
	LDA Graphics_BufCnt
	ADD #(CBIG_BCSize - 1)
	STA Graphics_BufCnt

	; Level_ChgTileEvent = 0 (redundant!)
	LDA #$00
	STA Level_ChgTileEvent

	INC Level_SkipStatusBarUpd	; Set Level_SkipStatusBarUpd (skip status bar for a frame, priority update!)

	RTS		 ; Return

	; Palette data for the "glowing coin" effect
PRG029_DFA4:
	.byte $3C, $0F, $36, $27	; 0
	.byte $3C, $0F, $36, $17	; 4
	.byte $3C, $0F, $36, $07	; 8
	.byte $3C, $0F, $36, $0F	; 12

; FIXME: Anybody want to claim this??
; Appears to be coin palette cycling routine
; $DFB4 
	LDA <Counter_1
	AND #$07
	BNE PRG029_DFEB	 ; 1:8 ticks continue, otherwise jump to PRG029_DFEB (RTS)

	LDA <Counter_1
	AND #$18
	LSR A
	TAX		 ; X = 0, 4, 8, 12

	; Copies current coin palette into buffer
	LDY Graphics_BufCnt

	LDA #$3f
	STA Graphics_Buffer,Y

	LDA #$04
	STA Graphics_Buffer+$01,Y
	STA Graphics_Buffer+$02,Y

PRG029_DFD0:
	LDA PRG029_DFA4,X
	STA Graphics_Buffer+$03,Y

	INY		 ; Y++
	INX		 ; X++

	TXA		 
	AND #$03	 ; X = 0 to 3
	BNE PRG029_DFD0	 ; While X <> 0, loop!

	; Terminator
	LDA #$00
	STA Graphics_Buffer+$03,Y

	; Graphics_BufCnt += 7
	LDA Graphics_BufCnt
	ADD #$07
	STA Graphics_BufCnt

PRG029_DFEB:
	RTS		 ; Return

; Rest of ROM bank was empty

